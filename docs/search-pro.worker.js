const V=Object.entries,et=Object.fromEntries,st="ENTRIES",L="KEYS",T="VALUES",_="";class D{set;_type;_path;constructor(t,s){const n=t._tree,o=Array.from(n.keys());this.set=t,this._type=s,this._path=o.length>0?[{node:n,keys:o}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:s}=E(this._path);if(E(s)===_)return{done:!1,value:this.result()};const n=t.get(E(s));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=E(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>E(t)).filter(t=>t!==_).join("")}value(){return E(this._path).node.get(_)}result(){switch(this._type){case T:return this.value();case L:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const E=e=>e[e.length-1],nt=(e,t,s)=>{const n=new Map;if(t===void 0)return n;const o=t.length+1,u=o+s,i=new Uint8Array(u*o).fill(s+1);for(let r=0;r<o;++r)i[r]=r;for(let r=1;r<u;++r)i[r*o]=r;return R(e,t,s,n,i,1,o,""),n},R=(e,t,s,n,o,u,i,r)=>{const d=u*i;t:for(const c of e.keys())if(c===_){const a=o[d-1];a<=s&&n.set(r,[e.get(c),a])}else{let a=u;for(let h=0;h<c.length;++h,++a){const g=c[h],m=i*a,p=m-i;let l=o[m];const f=Math.max(0,a-s-1),y=Math.min(i-1,a+s);for(let F=f;F<y;++F){const v=g!==t[F],z=o[p+F]+ +v,A=o[p+F+1]+1,w=o[m+F]+1,j=o[m+F+1]=Math.min(z,A,w);j<l&&(l=j)}if(l>s)continue t}R(e.get(c),t,s,n,o,a,i,r+c)}};class C{_tree;_prefix;_size=void 0;constructor(t=new Map,s=""){this._tree=t,this._prefix=s}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[s,n]=x(this._tree,t.slice(this._prefix.length));if(s===void 0){const[o,u]=O(n);for(const i of o.keys())if(i!==_&&i.startsWith(u)){const r=new Map;return r.set(i.slice(u.length),o.get(i)),new C(r,t)}}return new C(s,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,ot(this._tree,t)}entries(){return new D(this,st)}forEach(t){for(const[s,n]of this)t(s,n,this)}fuzzyGet(t,s){return nt(this._tree,t,s)}get(t){const s=k(this._tree,t);return s!==void 0?s.get(_):void 0}has(t){const s=k(this._tree,t);return s!==void 0&&s.has(_)}keys(){return new D(this,L)}set(t,s){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,I(this._tree,t).set(_,s),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=I(this._tree,t);return n.set(_,s(n.get(_))),this}fetch(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=I(this._tree,t);let o=n.get(_);return o===void 0&&n.set(_,o=s()),o}values(){return new D(this,T)}[Symbol.iterator](){return this.entries()}static from(t){const s=new C;for(const[n,o]of t)s.set(n,o);return s}static fromObject(t){return C.from(Object.entries(t))}}const x=(e,t,s=[])=>{if(t.length===0||e==null)return[e,s];for(const n of e.keys())if(n!==_&&t.startsWith(n))return s.push([e,n]),x(e.get(n),t.slice(n.length),s);return s.push([e,t]),x(void 0,"",s)},k=(e,t)=>{if(t.length===0||e==null)return e;for(const s of e.keys())if(s!==_&&t.startsWith(s))return k(e.get(s),t.slice(s.length))},I=(e,t)=>{const s=t.length;t:for(let n=0;e&&n<s;){for(const u of e.keys())if(u!==_&&t[n]===u[0]){const i=Math.min(s-n,u.length);let r=1;for(;r<i&&t[n+r]===u[r];)++r;const d=e.get(u);if(r===u.length)e=d;else{const c=new Map;c.set(u.slice(r),d),e.set(t.slice(n,n+r),c),e.delete(u),e=c}n+=r;continue t}const o=new Map;return e.set(t.slice(n),o),o}return e},ot=(e,t)=>{const[s,n]=x(e,t);if(s!==void 0){if(s.delete(_),s.size===0)W(n);else if(s.size===1){const[o,u]=s.entries().next().value;q(n,o,u)}}},W=e=>{if(e.length===0)return;const[t,s]=O(e);if(t.delete(s),t.size===0)W(e.slice(0,-1));else if(t.size===1){const[n,o]=t.entries().next().value;n!==_&&q(e.slice(0,-1),n,o)}},q=(e,t,s)=>{if(e.length===0)return;const[n,o]=O(e);n.set(o+t,s),n.delete(o)},O=e=>e[e.length-1],ut=(e,t)=>{const s=e._idToShortId.get(t);if(s!=null)return e._storedFields.get(s)},it=/[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u,M="or",$="and",rt="and_not",ct=(e,t)=>{e.includes(t)||e.push(t)},N=(e,t)=>{for(const s of t)e.includes(s)||e.push(s)},P=({score:e},{score:t})=>t-e,lt=()=>new Map,b=e=>{const t=new Map;for(const s of Object.keys(e))t.set(parseInt(s,10),e[s]);return t},G=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,ht={[M]:(e,t)=>{for(const s of t.keys()){const n=e.get(s);if(n==null)e.set(s,t.get(s));else{const{score:o,terms:u,match:i}=t.get(s);n.score=n.score+o,n.match=Object.assign(n.match,i),N(n.terms,u)}}return e},[$]:(e,t)=>{const s=new Map;for(const n of t.keys()){const o=e.get(n);if(o==null)continue;const{score:u,terms:i,match:r}=t.get(n);N(o.terms,i),s.set(n,{score:o.score+u,terms:o.terms,match:Object.assign(o.match,r)})}return s},[rt]:(e,t)=>{for(const s of t.keys())e.delete(s);return e}},dt=(e,t,s,n,o,u)=>{const{k:i,b:r,d}=u;return Math.log(1+(s-t+.5)/(t+.5))*(d+e*(i+1)/(e+i*(1-r+r*n/o)))},at=e=>(t,s,n)=>{const o=typeof e.fuzzy=="function"?e.fuzzy(t,s,n):e.fuzzy||!1,u=typeof e.prefix=="function"?e.prefix(t,s,n):e.prefix===!0;return{term:t,fuzzy:o,prefix:u}},H=(e,t,s,n)=>{for(const o of Object.keys(e._fieldIds))if(e._fieldIds[o]===s){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${n}" was not present in field "${o}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},ft=(e,t,s,n)=>{if(!e._index.has(n)){H(e,s,t,n);return}const o=e._index.fetch(n,lt),u=o.get(t);u==null||u.get(s)==null?H(e,s,t,n):u.get(s)<=1?u.size<=1?o.delete(t):u.delete(s):u.set(s,u.get(s)-1),e._index.get(n).size===0&&e._index.delete(n)},gt={k:1.2,b:.7,d:.5},mt={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(it),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{typeof console?.[e]=="function"&&console[e](t)},autoVacuum:!0},J={combineWith:M,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:gt},pt={combineWith:$,prefix:(e,t,s)=>t===s.length-1},Ft={batchSize:1e3,batchWait:10},U={minDirtFactor:.1,minDirtCount:20},_t={...Ft,...U},K=Symbol("*"),yt=(e,t)=>{const s=new Map,n={...e._options.searchOptions,...t};for(const[o,u]of e._documentIds){const i=n.boostDocument?n.boostDocument(u,"",e._storedFields.get(o)):1;s.set(o,{score:i,terms:[],match:{}})}return s},X=(e,t=M)=>{if(e.length===0)return new Map;const s=t.toLowerCase(),n=ht[s];if(!n)throw new Error(`Invalid combination operator: ${t}`);return e.reduce(n)||new Map},S=(e,t,s,n,o,u,i,r,d=new Map)=>{if(o==null)return d;for(const c of Object.keys(u)){const a=u[c],h=e._fieldIds[c],g=o.get(h);if(g==null)continue;let m=g.size;const p=e._avgFieldLength[h];for(const l of g.keys()){if(!e._documentIds.has(l)){ft(e,h,l,s),m-=1;continue}const f=i?i(e._documentIds.get(l),s,e._storedFields.get(l)):1;if(!f)continue;const y=g.get(l),F=e._fieldLength.get(l)[h],v=dt(y,m,e._documentCount,F,p,r),z=n*a*f*v,A=d.get(l);if(A){A.score+=z,ct(A.terms,t);const w=G(A.match,s);w?w.push(c):A.match[s]=[c]}else d.set(l,{score:z,terms:[t],match:{[s]:[c]}})}}return d},At=(e,t,s)=>{const n={...e._options.searchOptions,...s},o=(n.fields||e._options.fields).reduce((l,f)=>({...l,[f]:G(n.boost,f)||1}),{}),{boostDocument:u,weights:i,maxFuzzy:r,bm25:d}=n,{fuzzy:c,prefix:a}={...J.weights,...i},h=e._index.get(t.term),g=S(e,t.term,t.term,1,h,o,u,d);let m,p;if(t.prefix&&(m=e._index.atPrefix(t.term)),t.fuzzy){const l=t.fuzzy===!0?.2:t.fuzzy,f=l<1?Math.min(r,Math.round(t.term.length*l)):l;f&&(p=e._index.fuzzyGet(t.term,f))}if(m)for(const[l,f]of m){const y=l.length-t.term.length;if(!y)continue;p?.delete(l);const F=a*l.length/(l.length+.3*y);S(e,t.term,l,F,f,o,u,d,g)}if(p)for(const l of p.keys()){const[f,y]=p.get(l);if(!y)continue;const F=c*l.length/(l.length+y);S(e,t.term,l,F,f,o,u,d,g)}return g},Y=(e,t,s={})=>{if(t===K)return yt(e,s);if(typeof t!="string"){const a={...s,...t,queries:void 0},h=t.queries.map(g=>Y(e,g,a));return X(h,a.combineWith)}const{tokenize:n,processTerm:o,searchOptions:u}=e._options,i={tokenize:n,processTerm:o,...u,...s},{tokenize:r,processTerm:d}=i,c=r(t).flatMap(a=>d(a)).filter(a=>!!a).map(at(i)).map(a=>At(e,a,i));return X(c,i.combineWith)},Q=(e,t,s={})=>{const n=Y(e,t,s),o=[];for(const[u,{score:i,terms:r,match:d}]of n){const c=r.length||1,a={id:e._documentIds.get(u),score:i*c,terms:Object.keys(d),queryTerms:r,match:d};Object.assign(a,e._storedFields.get(u)),(s.filter==null||s.filter(a))&&o.push(a)}return t===K&&s.boostDocument==null&&e._options.searchOptions.boostDocument==null||o.sort(P),o},Ct=(e,t,s={})=>{s={...e._options.autoSuggestOptions,...s};const n=new Map;for(const{score:u,terms:i}of Q(e,t,s)){const r=i.join(" "),d=n.get(r);d!=null?(d.score+=u,d.count+=1):n.set(r,{score:u,terms:i,count:1})}const o=[];for(const[u,{score:i,terms:r,count:d}]of n)o.push({suggestion:u,terms:r,score:i/d});return o.sort(P),o};class Et{_options;_index;_documentCount;_documentIds;_idToShortId;_fieldIds;_fieldLength;_avgFieldLength;_nextId;_storedFields;_dirtCount;_currentVacuum;_enqueuedVacuum;_enqueuedVacuumConditions;constructor(t){if(t?.fields==null)throw new Error('SlimSearch: option "fields" must be provided');const s=t.autoVacuum==null||t.autoVacuum===!0?_t:t.autoVacuum;this._options={...mt,...t,autoVacuum:s,searchOptions:{...J,...t.searchOptions||{}},autoSuggestOptions:{...pt,...t.autoSuggestOptions||{}}},this._index=new C,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=U,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[s,n]of this._index){const o={};for(const[u,i]of n)o[u]=Object.fromEntries(i);t.push([s,o])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}addFields(t){for(let s=0;s<t.length;s++)this._fieldIds[t[s]]=s}}const zt=({index:e,documentCount:t,nextId:s,documentIds:n,fieldIds:o,fieldLength:u,averageFieldLength:i,storedFields:r,dirtCount:d,serializationVersion:c},a)=>{if(c!==1&&c!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const h=new Et(a);h._documentCount=t,h._nextId=s,h._documentIds=b(n),h._idToShortId=new Map,h._fieldIds=o,h._fieldLength=b(u),h._avgFieldLength=i,h._storedFields=b(r),h._dirtCount=d||0,h._index=new C;for(const[g,m]of h._documentIds)h._idToShortId.set(m,g);for(const[g,m]of e){const p=new Map;for(const l of Object.keys(m)){let f=m[l];c===1&&(f=f.ds),p.set(parseInt(l,10),b(f))}h._index.set(g,p)}return h},B=(e,t)=>{const s=e.toLowerCase(),n=t.toLowerCase(),o=[];let u=0,i=0;const r=(c,a=!1)=>{let h="";i===0?h=c.length>20?`… ${c.slice(-20)}`:c:a?h=c.length+i>100?`${c.slice(0,100-i)}… `:c:h=c.length>20?`${c.slice(0,20)} … ${c.slice(-20)}`:c,h&&o.push(h),i+=h.length,a||(o.push(["mark",t]),i+=t.length,i>=100&&o.push(" …"))};let d=s.indexOf(n,u);if(d===-1)return null;for(;d>=0;){const c=d+n.length;if(r(e.slice(u,d)),u=c,i>100)break;d=s.indexOf(n,u)}return i<100&&r(e.slice(u),!0),o},wt=(e,t)=>t.contents.reduce((s,[,n])=>s+n,0)-e.contents.reduce((s,[,n])=>s+n,0),xt=(e,t)=>Math.max(...t.contents.map(([,s])=>s))-Math.max(...e.contents.map(([,s])=>s)),Z=(e,t,s={})=>{const n={};return Q(t,e,{boost:{h:2,t:1,c:4},prefix:!0,...s}).forEach(o=>{const{id:u,terms:i,score:r}=o,d=u.includes("@"),c=u.includes("#"),[a,h]=u.split(/[#@]/),g=Number(a),m=i.sort((l,f)=>l.length-f.length).filter((l,f)=>i.slice(f+1).every(y=>!y.includes(l))),{contents:p}=n[g]??={title:"",contents:[]};if(d)p.push([{type:"customField",id:g,index:h,display:m.map(l=>o.c.map(f=>B(f,l))).flat().filter(l=>l!==null)},r]);else{const l=m.map(f=>B(o.h,f)).filter(f=>f!==null);if(l.length&&p.push([{type:c?"heading":"title",id:g,...c&&{anchor:h},display:l},r]),"t"in o)for(const f of o.t){const y=m.map(F=>B(f,F)).filter(F=>F!==null);y.length&&p.push([{type:"text",id:g,...c&&{anchor:h},display:y},r])}}}),V(n).sort(([,o],[,u])=>"max"==="total"?wt(o,u):xt(o,u)).map(([o,{title:u,contents:i}])=>{if(!u){const r=ut(t,o);r&&(u=r.h)}return{title:u,contents:i.map(([r])=>r)}})},tt=(e,t,s={})=>{const n=Ct(t,e,{fuzzy:.2,maxFuzzy:3,...s}).map(({suggestion:o})=>o);return e.includes(" ")?n:n.filter(o=>!o.includes(" "))},bt=et(V(JSON.parse("{\"/\":{\"documentCount\":141,\"nextId\":141,\"documentIds\":{\"0\":\"1\",\"1\":\"1@0\",\"2\":\"1@1\",\"3\":\"2\",\"4\":\"2#访问模式-access-modes\",\"5\":\"2#回收策略-reclaim-policy\",\"6\":\"2#pv-status\",\"7\":\"2#_1-available\",\"8\":\"2#_2-bound\",\"9\":\"2#_3-released\",\"10\":\"2#_4-failed\",\"11\":\"2#状态转换\",\"12\":\"2#状态图示\",\"13\":\"2#resourcequotas\",\"14\":\"2#作用\",\"15\":\"2#配置示例\",\"16\":\"2#主要字段\",\"17\":\"2#使用场景\",\"18\":\"2#limitranges\",\"19\":\"2#作用-1\",\"20\":\"2#配置示例-1\",\"21\":\"2#主要字段-1\",\"22\":\"2#使用场景-1\",\"23\":\"2#比较与总结\",\"24\":\"2#k8s技能图谱\",\"25\":\"2#静态pod\",\"26\":\"2#static-pod-的特点\",\"27\":\"2#创建-static-pod\",\"28\":\"2#使用场景-2\",\"29\":\"2#监控和管理\",\"30\":\"2#taint\",\"31\":\"2#taint-机制\",\"32\":\"2#无头服务-headless-services\",\"33\":\"2#headless-service-的特点\",\"34\":\"2#使用场景-3\",\"35\":\"2#headless-service-的定义示例\",\"36\":\"2#statefulset-与-headless-service-的结合\",\"37\":\"2#定义-headless-service\",\"38\":\"2#定义-statefulset\",\"39\":\"2#总结\",\"40\":\"2@0\",\"41\":\"2@1\",\"42\":\"3\",\"43\":\"3#概念概述\",\"44\":\"3#pipeline\",\"45\":\"3#python-sdk\",\"46\":\"3#dsl-compiler\",\"47\":\"3#pipeline-service\",\"48\":\"3#kubernetes-resources\",\"49\":\"3#orchestration-controllers\",\"50\":\"3#artifact-storage\",\"51\":\"3#persistence-agent-and-ml-metadata\",\"52\":\"3#pipeline-web-server\",\"53\":\"3#pipeline-1\",\"54\":\"3#component\",\"55\":\"3#组件代码\",\"56\":\"3#组件定义\",\"57\":\"3#容器化组件\",\"58\":\"3#graph\",\"59\":\"3#experiment\",\"60\":\"3#主要的-argo-工作流执行器类型包括\",\"61\":\"3#如何选择适合的执行器\",\"62\":\"3#controller-manager\",\"63\":\"3#官网地址\",\"64\":\"3#kubernetes-应用程序\",\"65\":\"3#它提供了\",\"66\":\"3#这可以被以下用户使用\",\"67\":\"3#目标\",\"68\":\"3#非目标\",\"69\":\"3#什么是-katib\",\"70\":\"3#为什么选择-katib\",\"71\":\"3#pipeline服务注册流程\",\"72\":\"3#api-v1beta1-注册的服务\",\"73\":\"3#api-v2beta1-注册的服务\",\"74\":\"3#其他\",\"75\":\"3#总结\",\"76\":\"3#pipeline创建流程\",\"77\":\"3#创建runs\",\"78\":\"3@0\",\"79\":\"3@1\",\"80\":\"4\",\"81\":\"4#operator-的基本概念\",\"82\":\"4#operator-的工作原理\",\"83\":\"4#operator-的应用场景\",\"84\":\"4#operator-的优势\",\"85\":\"4#使用-operator-的示例\",\"86\":\"4#开发-operator-的工具\",\"87\":\"4#总结\",\"88\":\"4@0\",\"89\":\"4@1\",\"90\":\"5\",\"91\":\"5#编程语言\",\"92\":\"5#技术栈\",\"93\":\"5#mlops\",\"94\":\"5#前端开发\",\"95\":\"5@0\",\"96\":\"5@1\",\"97\":\"6\",\"98\":\"6#地址\",\"99\":\"6#论文\",\"100\":\"6#介绍\",\"101\":\"6#重要亮点\",\"102\":\"6@0\",\"103\":\"6@1\",\"104\":\"7\",\"105\":\"7#_1-协议基础\",\"106\":\"7#_2-连接管理\",\"107\":\"7#_3-多路复用\",\"108\":\"7#_4-头部压缩\",\"109\":\"7#_5-服务器推送\",\"110\":\"7#_6-优先级和流控制\",\"111\":\"7#_7-加密和安全\",\"112\":\"7#_8-协议扩展性\",\"113\":\"7#_9-性能改进\",\"114\":\"7#总结\",\"115\":\"7#查看系统中已有的veth设备对或确认已创建的veth设备对-可以使用以下几种方法\",\"116\":\"7#使用-ip-命令\",\"117\":\"7#使用-ifconfig-命令\",\"118\":\"7#查看具体veth设备对的详细信息\",\"119\":\"7#示例\",\"120\":\"7#检查命名空间中的veth设备\",\"121\":\"7#vlan-与vxlan\",\"122\":\"7#vlan-virtual-local-area-network\",\"123\":\"7#vxlan-virtual-extensible-lan\",\"124\":\"7#对比\",\"125\":\"7#总结-1\",\"126\":\"7#vxlan与vtep\",\"127\":\"7#vxlan-virtual-extensible-lan-1\",\"128\":\"7#vtep-vxlan-tunnel-endpoint\",\"129\":\"7#vxlan-和-vtep-的工作流程\",\"130\":\"7#总结-2\",\"131\":\"7@0\",\"132\":\"7@1\",\"133\":\"8\",\"134\":\"8@0\",\"135\":\"8@1\",\"136\":\"9\",\"137\":\"10\",\"138\":\"11\",\"139\":\"12\",\"140\":\"13\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[1,152],\"1\":[null,null,1],\"2\":[null,null,1],\"3\":[1,2],\"4\":[4,16],\"5\":[4,13],\"6\":[3,20],\"7\":[2,16],\"8\":[2,13],\"9\":[2,16],\"10\":[2,11],\"11\":[1,27],\"12\":[1,23],\"13\":[1,9],\"14\":[1,10],\"15\":[1,40],\"16\":[1,13],\"17\":[1,10],\"18\":[1,12],\"19\":[1,14],\"20\":[1,45],\"21\":[1,13],\"22\":[1,10],\"23\":[1,23],\"24\":[1],\"25\":[1,27],\"26\":[3,43],\"27\":[3,40],\"28\":[1,31],\"29\":[1,34],\"30\":[1,10],\"31\":[2,147],\"32\":[4,17],\"33\":[3,35],\"34\":[1,17],\"35\":[3,37],\"36\":[5,7],\"37\":[3,22],\"38\":[2,44],\"39\":[1,21],\"40\":[null,null,1],\"41\":[null,null,1],\"42\":[2,35],\"43\":[1,11],\"44\":[1,3],\"45\":[3,5],\"46\":[1,3],\"47\":[1,2],\"48\":[1,4],\"49\":[1,7],\"50\":[1,17],\"51\":[1,6],\"52\":[1,7],\"53\":[1,33],\"54\":[1,18],\"55\":[1,24],\"56\":[1,22],\"57\":[1,13],\"58\":[1,29],\"59\":[1,106],\"60\":[4,41],\"61\":[2,220],\"62\":[2,64],\"63\":[1,6],\"64\":[2,21],\"65\":[2,14],\"66\":[2,13],\"67\":[1,24],\"68\":[1,6],\"69\":[3,64],\"70\":[3,45],\"71\":[1,5],\"72\":[3,42],\"73\":[3,19],\"74\":[1,6],\"75\":[1,28],\"76\":[1,2],\"77\":[1,5],\"78\":[null,null,1],\"79\":[null,null,1],\"80\":[2,17],\"81\":[2,29],\"82\":[2,23],\"83\":[2,19],\"84\":[2,16],\"85\":[3,18],\"86\":[3,20],\"87\":[1,17],\"88\":[null,null,1],\"89\":[null,null,1],\"90\":[1,6],\"91\":[1,19],\"92\":[1,18],\"93\":[1,5],\"94\":[1,22],\"95\":[null,null,1],\"96\":[null,null,1],\"97\":[1,4],\"98\":[1,5],\"99\":[1,5],\"100\":[1,8],\"101\":[1,47],\"102\":[null,null,1],\"103\":[null,null,1],\"104\":[1,12],\"105\":[2,10],\"106\":[2,19],\"107\":[2,15],\"108\":[2,14],\"109\":[2,13],\"110\":[2,13],\"111\":[2,14],\"112\":[2,11],\"113\":[2,11],\"114\":[1,36],\"115\":[3],\"116\":[2,13],\"117\":[2,7],\"118\":[1,5],\"119\":[1,37],\"120\":[1,70],\"121\":[2,12],\"122\":[6,28],\"123\":[5,25],\"124\":[1,32],\"125\":[1,6],\"126\":[1],\"127\":[5,23],\"128\":[5,29],\"129\":[4,15],\"130\":[1,10],\"131\":[null,null,1],\"132\":[null,null,1],\"133\":[1,98],\"134\":[null,null,1],\"135\":[null,null,1],\"136\":[1,3],\"137\":[1],\"138\":[1],\"139\":[1],\"140\":[1]},\"averageFieldLength\":[1.7298957836799733,26.964476069153676,0.7178770133482945],\"storedFields\":{\"0\":{\"h\":\"etcd\",\"t\":[\"etcd获取分布式锁\",\"cli, err := clientv3.New(clientv3.Config{Endpoints: endpoints}) if err != nil { log.Fatal(err) } defer cli.Close() // create two separate sessions for lock competition s1, err := concurrency.NewSession(cli, concurrency.WithTTL(10)) if err != nil { log.Fatal(err) } defer s1.Close() m1 := concurrency.NewMutex(s1, \\\"/my-lock/\\\") // acquire lock for s1 if err := m1.Lock(context.TODO()); err != nil { log.Fatal(err) } fmt.Println(\\\"acquired lock for s1\\\") if err := m1.Unlock(context.TODO()); err != nil { log.Fatal(err) } fmt.Println(\\\"released lock for s1\\\")\",\"1、首先通过 concurrency.NewSession 方法创建 Session，本质是创建了一个 TTL 为 10 的 Lease。\",\"2、其次得到 session 对象后，通过 concurrency.NewMutex 创建了一个 mutex 对象，包含 Lease、key prefix 等信息。\",\"3、然后通过 mutex 对象的 Lock 方法尝试获取锁。\",\"当 CreateRevision 为 0 时，它会创建一个 prefix 为 /my-lock 的 key（ /my-lock + LeaseID)，并获取到 /my-lock prefix 下面最早创建的一个 key（revision 最小），分布式锁最终是由写入此 key 的 client 获得，其他 client 则进入等待模式。\",\"4、最后使用结束，可通过 mutex 对象的 Unlock 方法释放锁。\",\"未获得锁的 client 是如何等待的呢?\",\"// wait for deletion revisions prior to myKey hdr, werr := waitDeletes(ctx, client, m.pfx, m.myRev-1) // release lock key if wait failed if werr != nil { m.Unlock(client.Ctx()) } else { m.hdr = hdr }\",\"通过 Watch 机制各自监听 prefix 相同，revision 比自己小的 key，因为只有 revision 比自己小的 key 释放锁，我才能有机会，获得锁，如下代码所示，其中 waitDelete 会使用我们上面的介绍的 Watch 去监听比自己小的 key\",\"为什么使用etcd分布式锁比redis分布式锁更好？\",\"相比 Redis 基于主备异步复制导致锁的安全性问题，etcd 是基于 Raft 共识算法实现的，一个写请求需要经过集群多数节点确认。因此一旦分布式锁申请返回给 client 成功后，它一定是持久化到了集群多数节点上，不会出现 Redis 主备异步复制可能导致丢数据的问题，具备更高的安全性。\",\"分布式锁的三个主要核心要素\",\"安全性、互斥性。在同一时间内，不允许多个 client 同时获得锁。\",\"活性。无论 client 出现 crash 还是遭遇网络分区，你都需要确保任意故障场景下，都不会出现死锁，常用的解决方案是超时和自动过期机制。\",\"高可用、高性能。加锁、释放锁的过程性能开销要尽量低，同时要保证高可用，避免单点故障。\"]},\"1\":{\"c\":[\"etcd\"]},\"2\":{\"c\":[\"分布式锁\"]},\"3\":{\"h\":\"k8s知识点\",\"t\":[\"k8s 笔记总结\"]},\"4\":{\"h\":\"访问模式（Access Modes）\",\"t\":[\"Kubernetes支持的访问模式如下。\",\"ReadWriteOnce（RWO）：读写权限，并且只能被单个Node挂 载。\",\"ReadOnlyMany（ROX）：只读权限，允许被多个Node挂载。\",\"ReadWriteMany（RWX）：读写权限，允许被多个Node挂载。\",\"某些PV可能支持多种访问模式，但PV在挂载时只能使用一种访问模式，多种访问模式不能同时生效。\"]},\"5\":{\"h\":\"回收策略（Reclaim Policy）\",\"t\":[\"Kubernetes支持的回收策略如下。\",\"Retain：保留数据，需要手工处理。\",\"Recycle：简单清除文件的操作。\",\"Delete：与PV相连的后端存储完成Volume的删除操作。\",\"目前只有NFS和HostPath两种类型的PV支持Recycle策略； AWSElasticBlockStore、GCEPersistentDisk、AzureDisk和Cinder类型的PV支持Delete策略。\"]},\"6\":{\"h\":\"PV (STATUS)\",\"t\":[\"在 Kubernetes 中，PersistentVolume (PV) 是一个集群级别的资源，用于表示集群中持久化存储的详细信息和状态。PV 的状态由其 STATUS 字段来表示，它反映了存储卷的当前状态。了解这些状态有助于掌握 PV 在生命周期中的位置，以及它是否能够被持久卷声明 (PersistentVolumeClaim, PVC) 使用。\",\"以下是 Kubernetes 中 PV 的几种可能的状态：\"]},\"7\":{\"h\":\"1.\",\"t\":[\"描述: 该状态表示 PV 可以被绑定到 PVC。PV 处于 Available 状态时，它未被任何 PVC 使用，可以供新的 PVC 绑定。\",\"特点: \",\"PV 还未与任何 PVC 绑定。\",\"准备好用于新的 PVC 绑定。\"]},\"8\":{\"h\":\"2.\",\"t\":[\"描述: 该状态表示 PV 已经被绑定到一个 PVC，且正被 PVC 使用。\",\"特点: \",\"PV 已经与一个 PVC 绑定。\",\"它不能再被其他 PVC 绑定，直到被释放。\"]},\"9\":{\"h\":\"3.\",\"t\":[\"描述: 该状态表示 PV 之前已经绑定的 PVC 已经被删除，但是 PV 本身还没有被集群中的任何新 PVC 再次使用。\",\"特点: \",\"PVC 已被删除。\",\"数据可能仍然存在于 PV 上，但它还未被新的 PVC 重新绑定。\"]},\"10\":{\"h\":\"4.\",\"t\":[\"描述: 该状态表示 PV 由于某种原因无法使用，通常是因为与 PV 相关的存储设备出现了错误或问题。\",\"特点: \",\"PV 在操作过程中遇到错误，无法正常使用。\",\"可能需要管理员干预以修复问题。\"]},\"11\":{\"h\":\"状态转换\",\"t\":[\"PV 的状态转换通常遵循以下过程：\",\"初始状态: PV 被创建后，处于 Available 状态。\",\"绑定: 一个 PVC 请求匹配 PV，PV 被绑定到 PVC 后，状态变为 Bound。\",\"释放: PVC 被删除后，PV 状态变为 Released。\",\"再利用或删除: \",\"如果允许再利用，管理员可以手动将 PV 状态重置为 Available，使其可以绑定到新的 PVC。\",\"如果 PV 被认为不再需要，可能会被删除。\"]},\"12\":{\"h\":\"状态图示\",\"t\":[\"以下是状态转换的示意图：\",\"Available | | PVC 绑定 V Bound | | PVC 删除 V Released | | 删除或再利用 V Failed (或) Available\",\"在 Kubernetes（K8s）集群中，ResourceQuotas 和 LimitRanges 是两种用于资源管理和控制的机制。它们帮助管理员确保资源的公平分配和高效利用。以下是对这两者的详细介绍：\"]},\"13\":{\"h\":\"ResourceQuotas\",\"t\":[\"ResourceQuotas 是一种在 Kubernetes 中用来限制命名空间（Namespace）内资源总量的机制。它们用于防止某个命名空间消耗过多的集群资源，从而影响其他命名空间的正常运行。\"]},\"14\":{\"h\":\"作用\",\"t\":[\"限制命名空间资源使用: ResourceQuotas 确保每个命名空间不会消耗超过指定的资源限额。\",\"控制资源分配: 它们帮助管理员公平分配集群资源，防止资源耗尽。\",\"提升资源管理能力: 通过设置资源限额，管理员可以更好地管理和监控资源使用情况。\"]},\"15\":{\"h\":\"配置示例\",\"t\":[\"以下是一个 ResourceQuota 的 YAML 配置示例，它限制了某个命名空间内的 CPU 和内存总量，以及对象数量（如 Pod 和 Service）：\",\"apiVersion: v1 kind: ResourceQuota metadata: name: example-quota namespace: example-namespace spec: hard: pods: \\\"10\\\" # 限制 Pod 的总数量 services: \\\"5\\\" # 限制 Service 的总数量 requests.cpu: \\\"4\\\" # 限制 CPU 请求总量 requests.memory: \\\"8Gi\\\" # 限制内存请求总量 limits.cpu: \\\"10\\\" # 限制 CPU 使用总量 limits.memory: \\\"16Gi\\\" # 限制内存使用总量\"]},\"16\":{\"h\":\"主要字段\",\"t\":[\"hard: 定义了资源的硬性限制，包括 CPU、内存、存储和对象数量等。\",\"scopes: 可选字段，指定了 ResourceQuota 适用的对象范围（如仅应用于某些特定的资源类型）。\"]},\"17\":{\"h\":\"使用场景\",\"t\":[\"开发环境: 限制资源以确保测试环境不会占用过多的生产资源。\",\"多租户环境: 在共享集群中，控制不同租户（命名空间）之间的资源使用。\",\"成本管理: 控制资源使用来管理和控制成本。\"]},\"18\":{\"h\":\"LimitRanges\",\"t\":[\"LimitRanges 是一种在 Kubernetes 中用于限制命名空间内单个 Pod 或容器资源使用的机制。与 ResourceQuotas 的整体限制不同，LimitRanges 主要控制单个 Pod 或容器的资源使用范围。\"]},\"19\":{\"h\":\"作用\",\"t\":[\"设置默认资源限制: 如果 Pod 或容器没有指定资源请求和限制，LimitRanges 可以提供默认值。\",\"防止资源过度消耗: 通过限制单个容器或 Pod 的资源使用，防止过多的资源消耗影响整个集群的性能。\",\"鼓励合理的资源分配: 鼓励开发人员在部署 Pod 时合理设置资源请求和限制。\"]},\"20\":{\"h\":\"配置示例\",\"t\":[\"以下是一个 LimitRange 的 YAML 配置示例，它为容器设置了 CPU 和内存的默认值和最大/最小值：\",\"apiVersion: v1 kind: LimitRange metadata: name: example-limits namespace: example-namespace spec: limits: - max: cpu: \\\"1\\\" # 容器的最大 CPU 使用量 memory: \\\"1Gi\\\" # 容器的最大内存使用量 min: cpu: \\\"100m\\\" # 容器的最小 CPU 使用量 memory: \\\"128Mi\\\" # 容器的最小内存使用量 default: cpu: \\\"500m\\\" # 容器的默认 CPU 请求量 memory: \\\"512Mi\\\" # 容器的默认内存请求量 defaultRequest: cpu: \\\"250m\\\" # 容器的默认 CPU 请求 memory: \\\"256Mi\\\" # 容器的默认内存请求 type: Container # 应用类型\"]},\"21\":{\"h\":\"主要字段\",\"t\":[\"max: 定义了单个容器可以请求的最大资源量。\",\"min: 定义了单个容器必须请求的最小资源量。\",\"default: 定义了容器没有指定资源请求和限制时的默认值。\",\"defaultRequest: 定义了容器没有指定资源请求时的默认请求值。\",\"type: 指定了限制适用于 Pod 还是容器。\"]},\"22\":{\"h\":\"使用场景\",\"t\":[\"应用程序标准化: 在命名空间内强制执行资源使用标准，确保所有容器符合预期的资源使用模式。\",\"资源优化: 防止资源过度配置或资源不足，从而优化集群性能和资源利用率。\",\"开发与测试环境: 在不同环境中设置不同的限制，确保资源的合理分配和使用。\"]},\"23\":{\"h\":\"比较与总结\",\"t\":[\"ResourceQuotas:\",\"范围: 适用于整个命名空间的资源总量。\",\"目的: 控制命名空间内的资源使用上限，确保集群资源的公平分配和高效利用。\",\"典型场景: 多租户环境、开发环境中的资源限制。\",\"LimitRanges:\",\"范围: 适用于单个 Pod 或容器的资源使用。\",\"目的: 设置资源使用的默认值和最大/最小限制，防止个体资源过度消耗。\",\"典型场景: 应用程序的资源标准化和资源优化。\",\"两者结合使用，可以在 Kubernetes 集群中提供强大的资源管理能力，确保资源的公平分配和高效使用。\"]},\"24\":{\"h\":\"k8s技能图谱\"},\"25\":{\"h\":\"静态pod\",\"t\":[\"Static Pod 是 Kubernetes 中的一种特殊类型的 Pod，它由 kubelet 直接管理，而不是通过 Kubernetes API Server 来创建和管理。Static Pod 通常用于集群管理工具（如 Kubernetes 本身）的部署和管理，尤其是在 Kubernetes 控制平面组件（如 etcd、kube-apiserver、kube-controller-manager 和 kube-scheduler）自身的管理中。\"]},\"26\":{\"h\":\"Static Pod 的特点\",\"t\":[\"由 kubelet 管理：\",\"Static Pod 由运行在节点上的 kubelet 直接管理，不需要 API Server 的参与。\",\"kubelet 会定期扫描特定的目录（通常是 /etc/kubernetes/manifests）中的 Pod 定义文件，并根据这些文件创建和管理 Pod。\",\"没有 ReplicaSet 或 Deployment：\",\"Static Pod 不是通过 Deployment、ReplicaSet 或其他控制器管理的，因此它们没有自动伸缩、滚动更新等高级特性。\",\"静态配置：\",\"Static Pod 的配置是静态文件，通常是 JSON 或 YAML 格式，存放在节点的文件系统中。\",\"这些配置文件不会因为 API Server 或 etcd 的故障而丢失，因此非常适合用于管理集群的核心组件。\",\"自动重启：\",\"如果 Static Pod 崩溃或被删除，kubelet 会根据配置文件自动重新创建它们，保证这些关键组件的高可用性。\"]},\"27\":{\"h\":\"创建 Static Pod\",\"t\":[\"要创建一个 Static Pod，你需要在节点的特定目录中（通常是 /etc/kubernetes/manifests）创建一个包含 Pod 定义的 YAML 文件。以下是一个示例：\",\"# 文件路径：/etc/kubernetes/manifests/static-pod-example.yaml apiVersion: v1 kind: Pod metadata: name: static-pod-example namespace: kube-system spec: containers: - name: nginx image: nginx:latest ports: - containerPort: 80\",\"将上述 YAML 文件保存到节点的 /etc/kubernetes/manifests 目录中后，kubelet 会自动检测到该文件并创建对应的 Pod。\"]},\"28\":{\"h\":\"使用场景\",\"t\":[\"Static Pod 通常用于以下场景：\",\"Kubernetes 控制平面组件：\",\"部署和管理 Kubernetes 控制平面组件（如 etcd、kube-apiserver、kube-controller-manager 和 kube-scheduler），这些组件必须在集群启动时运行，不能依赖于 Kubernetes 自身来管理。\",\"集群启动和恢复：\",\"在集群启动或恢复过程中，使用 Static Pod 确保关键组件能够独立于 Kubernetes API Server 和 etcd 正常启动。\",\"简化的节点管理：\",\"在一些简化的集群管理方案中，可能会使用 Static Pod 来运行节点级别的服务或代理，而不依赖于 Kubernetes 控制器。\"]},\"29\":{\"h\":\"监控和管理\",\"t\":[\"由于 Static Pod 由 kubelet 直接管理，因此它们的一些管理和监控操作与普通 Pod 略有不同：\",\"日志查看：你仍然可以使用 kubectl logs 命令查看 Static Pod 的日志。\",\"状态检查：可以使用 kubectl get pod -n kube-system 命令查看 Static Pod 的状态。\",\"更新 Pod：要更新 Static Pod，需要手动编辑对应的 YAML 文件，kubelet 会自动检测到文件的变化并重新创建 Pod。\",\"Static Pod 是 Kubernetes 提供的一种灵活机制，用于确保关键组件的高可用性和独立性，是集群稳定运行的关键保障之一。\"]},\"30\":{\"h\":\"Taint\",\"t\":[\"Taint 是 Kubernetes 中的一种机制，用于限制 Pod 在节点上运行的条件。Taint 可以应用于节点，并指定一个键值对，用于限制 Pod 在节点上运行的条件。\"]},\"31\":{\"h\":\"Taint 机制\",\"t\":[\"Taint 是应用在节点上的属性，表示这个节点对某些 Pod 来说是不合适的。每个 Taint 由三个部分组成：\",\"键（Key）：标识 Taint 的名称。\",\"值（Value）：标识 Taint 的具体值。\",\"效果（Effect）：标识 Taint 的作用方式。常见的效果有三种： \",\"NoSchedule：新的 Pod 不会被调度到这个节点上。\",\"PreferNoSchedule：尽量避免将新的 Pod 调度到这个节点上，但如果没有其他合适的节点，也可能会调度。\",\"NoExecute：已经运行在这个节点上的 Pod 会被驱逐，新 Pod 也不会被调度到这个节点上。\",\"节点设置taint\",\"kubectl taint no minikube level=high:NoSchedule\",\"移除 Taint\",\"kubectl taint no minikube level=high:NoSchedule-\",\"Pod设置toleration\",\"apiVersion: apps/v1 kind: Deployment metadata: name: nginx spec: replicas: 1 selector: matchLabels: app: nginx template: metadata: labels: app: nginx spec: containers: - name: nginx command: [\\\"python3\\\"] args: [\\\"-m\\\", \\\"http.server\\\", \\\"9999\\\"] image: \\\"registry.cnbita.com:5000/wangshi/python:3.10\\\" imagePullPolicy: IfNotPresent ports: - name: http containerPort: 80 protocol: TCP resources: requests: cpu: 100m memory: 128Mi limits: cpu: 500m memory: 256Mi tolerations: - key: \\\"level\\\" operator: \\\"Equal\\\" value: \\\"high\\\" effect: \\\"NoSchedule\\\"\",\"上述配置说明pod能够容忍节点设置taint的level=high:NoSchedule，如果pod不设置亲和性tolerations，则无法进行部署。如下所示：\",\"Tolerations: node.kubernetes.io/not-ready:NoExecute op=Exists for 300s node.kubernetes.io/unreachable:NoExecute op=Exists for 300s Events: Type Reason Age From Message ---- ------ ---- ---- ------- Warning FailedScheduling 3m57s default-scheduler 0/1 nodes are available: 1 node(s) had untolerated taint {level: high}. preemption: 0/1 nodes are available: 1 Preemption is not helpful for scheduling..\",\"在 Kubernetes 中，taint 是用于节点管理的机制，通过标记节点来影响 Pod 的调度。Taints 可以防止某些 Pod 调度到特定节点上，除非这些 Pod 具有相应的 toleration。这种机制有助于确保工作负载在集群中得到更好地分布和隔离。\"]},\"32\":{\"h\":\"无头服务（Headless Services）\",\"t\":[\"在 Kubernetes 中，Headless Service 是一种特殊类型的 Service，不会分配集群 IP（ClusterIP）。这种服务类型主要用于暴露 StatefulSet 的每个 Pod，并且允许直接访问每个 Pod。下面是对 Kubernetes Headless Service 的详细介绍：\"]},\"33\":{\"h\":\"Headless Service 的特点\",\"t\":[\"没有 Cluster IP：\",\"与普通的 Kubernetes Service 不同，Headless Service 不会为服务分配一个 Cluster IP。它通过将 ClusterIP 字段设置为 None 来实现这一点。\",\"直接访问 Pod：\",\"Headless Service 允许客户端直接访问服务后端的每个 Pod，而不是通过负载均衡器来访问。这对于需要直接与特定 Pod 进行通信的场景非常有用，例如 StatefulSet 中的数据库分片或有状态应用。\",\"DNS 解析：\",\"Headless Service 会为每个 Pod 创建一个 DNS 记录，这样客户端可以通过 DNS 名称直接访问特定的 Pod。对于 StatefulSet，每个 Pod 都有一个稳定的 DNS 名称。\"]},\"34\":{\"h\":\"使用场景\",\"t\":[\"Headless Service 主要用于以下几种场景：\",\"StatefulSet：\",\"StatefulSet 通常用于部署有状态应用，例如数据库集群或分布式文件系统。Headless Service 允许这些有状态应用中的各个 Pod 直接相互访问。\",\"自定义服务发现：\",\"在某些情况下，应用需要自定义的服务发现机制，而不是 Kubernetes 提供的负载均衡。Headless Service 允许应用自行管理和发现服务实例。\"]},\"35\":{\"h\":\"Headless Service 的定义示例\",\"t\":[\"以下是一个 Headless Service 的 YAML 定义示例：\",\"apiVersion: v1 kind: Service metadata: name: headless-service namespace: default spec: clusterIP: None selector: app: my-app ports: - name: http port: 80 targetPort: 8080\",\"这个示例定义了一个名为 headless-service 的服务，没有 ClusterIP。它选择了带有标签 app: my-app 的 Pod，并将流量从服务的 80 端口转发到 Pod 的 8080 端口。\"]},\"36\":{\"h\":\"StatefulSet 与 Headless Service 的结合\",\"t\":[\"以下是一个使用 Headless Service 的 StatefulSet 示例：\"]},\"37\":{\"h\":\"定义 Headless Service\",\"t\":[\"apiVersion: v1 kind: Service metadata: name: my-stateful-service namespace: default spec: clusterIP: None selector: app: my-stateful-app ports: - name: http port: 80 targetPort: 8080\"]},\"38\":{\"h\":\"定义 StatefulSet\",\"t\":[\"apiVersion: apps/v1 kind: StatefulSet metadata: name: my-stateful-app namespace: default spec: serviceName: \\\"my-stateful-service\\\" replicas: 3 selector: matchLabels: app: my-stateful-app template: metadata: labels: app: my-stateful-app spec: containers: - name: my-container image: my-image ports: - containerPort: 8080\",\"在这个例子中，my-stateful-service 是一个 Headless Service，它与 my-stateful-app StatefulSet 结合使用。每个 StatefulSet Pod 都有一个稳定的 DNS 名称，例如 my-stateful-app-0.my-stateful-service.default.svc.cluster.local。\"]},\"39\":{\"h\":\"总结\",\"t\":[\"Headless Service 是 Kubernetes 中的一种特殊服务类型，适用于需要直接访问每个 Pod 的场景。它通过不分配 Cluster IP 来实现这一点，并为每个 Pod 提供稳定的 DNS 记录。Headless Service 通常用于有状态应用和自定义服务发现场景，尤其是在 StatefulSet 中。\"]},\"40\":{\"c\":[\"k8s\"]},\"41\":{\"c\":[\"笔记\"]},\"42\":{\"h\":\"Kubeflow 简介\",\"t\":[\"k8s 云原生之Kubeflow 简介\",\"https://www.kubeflow.org/docs/started/introduction/\",\"Kubeflow 简介 Kubeflow 项目致力于让机器学习 (ML) 工作流在 Kubernetes 上的部署变得简单、可移植且可扩展。我们的目标不是重新创建其他服务，而是提供一种简单的方法，将最佳的 ML 开源系统部署到各种基础设施中。只要您运行 Kubernetes，就可以运行 Kubeflow。 下图展示了主要的 Kubeflow 组件，涵盖 Kubernetes 之上 ML 生命周期的每个步骤。 \",\"Kubeflow 是一个面向想要构建和试验 ML 管道的数据科学家的平台。Kubeflow 还适用于想要将 ML 系统部署到各种环境以进行开发、测试和生产级服务的 ML 工程师和运营团队。\"]},\"43\":{\"h\":\"概念概述\",\"t\":[\"Kubeflow 是_Kubernetes 的 ML 工具包_。 下图展示了 Kubeflow 作为在 Kubernetes 之上安排 ML 系统组件的平台： \"]},\"44\":{\"h\":\"Pipeline\",\"t\":[\"在高层次上，管道的执行过程如下：\"]},\"45\":{\"h\":\"Python SDK：\",\"t\":[\"使用Kubeflow Pipelines特定领域语言（DSL）创建组件或指定管道。\"]},\"46\":{\"h\":\"：\",\"t\":[\"DSL编译器将您的管道的Python代码转换为静态配置（YAML）。\"]},\"47\":{\"h\":\"：\",\"t\":[\"调用管道服务以从静态配置创建管道运行。\"]},\"48\":{\"h\":\"：\",\"t\":[\"管道服务调用Kubernetes API服务器以创建运行管道所需的必要Kubernetes资源（CRD）。\"]},\"49\":{\"h\":\"：\",\"t\":[\"一组编排控制器执行完成管道所需的容器。这些容器在虚拟机上的Kubernetes Pod中执行。一个示例控制器是Argo Workflow控制器，它编排基于任务的工作流。\"]},\"50\":{\"h\":\"：\",\"t\":[\"Pod存储两种类型的数据：\",\"Metadata：实验、作业、管道运行和单个标量指标。度量数据被聚合用于排序和过滤。Kubeflow Pipelines将元数据存储在MySQL数据库中。\",\"Artifacts：管道包、视图和大规模指标（时间序列）。使用大规模指标来调试管道运行或调查单个运行的性能。Kubeflow Pipelines将工件存储在像Minio服务器或Cloud Storage之类的工件存储中。\",\"MySQL数据库和Minio服务器都由Kubernetes持久卷子系统支持。\"]},\"51\":{\"h\":\"：\",\"t\":[\"管道持久性代理监视管道服务创建的Kubernetes资源，并将这些资源的状态持久化到ML元数据服务中。管道持久性代理记录已执行的容器集合及其输入和输出。输入/输出包括容器参数或数据工件URI。\"]},\"52\":{\"h\":\"：\",\"t\":[\"管道Web服务器从各种服务中收集数据以显示相关视图：当前运行的管道列表、管道执行历史记录、数据工件列表、有关单个管道运行的调试信息、有关单个管道运行的执行状态。\"]},\"53\":{\"h\":\"Pipeline\",\"t\":[\"在 Kubeflow Pipelines 中，管道是对机器学习（ML）工作流的描述，包括工作流中的所有组件及其相互关系，以图的形式呈现。管道配置包括运行管道所需的输入（参数）的定义，以及每个组件的输入和输出。 当你运行一个管道时，系统会启动一个或多个 Kubernetes Pod，这些 Pod 对应于工作流（管道）中的各个步骤（组件）。这些 Pod 会启动 Docker 容器，而容器则会启动你的程序。 开发完成管道后，你可以使用 Kubeflow Pipelines UI 或 Kubeflow Pipelines SDK 上传你的管道。\"]},\"54\":{\"h\":\"Component\",\"t\":[\"在 Kubeflow Pipelines 中，组件是一个独立的代码集，它执行机器学习（ML）工作流（管道）中的某一步骤，例如数据预处理、数据转换、模型训练等。组件类似于函数，具有名称、参数、返回值和主体。\"]},\"55\":{\"h\":\"组件代码\",\"t\":[\"每个组件的代码包括以下部分：\",\"客户端代码：与端点通信以提交作业的代码。例如，与 Google Dataproc API 通信以提交 Spark 作业的代码。\",\"运行时代码：执行实际作业的代码，通常在集群中运行。例如，将原始数据转换为预处理数据的 Spark 代码。\",\"关于客户端代码和运行时代码的命名约定——对于名为“mytask”的任务：\",\"mytask.py 程序包含客户端代码。\",\"mytask 目录包含所有运行时代码。\"]},\"56\":{\"h\":\"组件定义\",\"t\":[\"用 YAML 格式的组件规范描述 Kubeflow Pipelines 系统中的组件。组件定义包括以下部分：\",\"元数据：名称、描述等。\",\"接口：输入/输出规范（名称、类型、描述、默认值等）。\",\"实现：描述在给定组件输入参数值的情况下如何运行组件的规范。实现部分还描述了组件完成运行后如何获取输出值。\",\"有关组件的完整定义，请参见组件规范。\"]},\"57\":{\"h\":\"容器化组件\",\"t\":[\"你必须将组件打包为 Docker 镜像。组件代表容器内的特定程序或入口点。 管道中的每个组件独立执行。组件不会在同一进程中运行，也不能直接共享内存数据。你必须将传递给组件之间的数据序列化（转换为字符串或文件），以便数据可以在分布式网络上传输。然后，必须反序列化这些数据以供下游组件使用。\"]},\"58\":{\"h\":\"Graph\",\"t\":[\"在 Kubeflow Pipelines 中，图（Graph）是管道运行时在 Kubeflow Pipelines UI 中的图形表示。图显示了管道运行已执行或正在执行的步骤，箭头指示了管道组件之间的父/子关系。运行一开始，就可以查看这个图。图中的每个节点对应管道中的一个步骤，并进行相应的标注。 每个节点的右上角有一个图标，指示其状态：运行中（running）、成功（succeeded）、失败（failed）或跳过（skipped）。当节点的父节点包含条件语句时，节点可能会被跳过。\"]},\"59\":{\"h\":\"Experiment\",\"t\":[\"实验是一个工作空间，你可以在其中尝试管道的不同配置。你可以使用实验将你的运行组织成逻辑组。实验可以包含任意的运行，包括定期运行。\",\"一次运行（run）是对管道的单次执行。运行包含你尝试的所有实验的不可变日志，设计为自包含的，以便于重现。你可以通过查看 Kubeflow Pipelines UI 上的运行详情页面来跟踪运行的进度，在那里你可以看到运行时的图表、输出工件和每个步骤的日志。 定期运行（recurring run）或在 Kubeflow Pipelines 后端 API 中称为作业（job），是管道的可重复运行。定期运行的配置包括指定所有参数值的管道副本和运行触发器。你可以在任何实验中启动定期运行，它会定期启动运行配置的新副本。你可以从 Kubeflow Pipelines UI 启用/禁用定期运行。你还可以指定最大并发运行数，以限制并行启动的运行数量。如果管道预计运行时间较长且触发频繁运行，这会很有帮助。\",\"运行触发器是一个标志，用于告知系统何时生成新的定期运行配置。可用的运行触发器类型包括：\",\"周期性（Periodic）：基于时间间隔调度运行（例如：每2小时或每45分钟）。\",\"Cron：使用 cron 语法调度运行。\",\"步骤（step）是管道中某个组件的执行。步骤与其组件之间的关系是一种实例化关系，类似于运行与其管道之间的关系。在复杂的管道中，组件可以在循环中多次执行，或在解析管道代码中的 if/else 类似子句后有条件地执行。\",\"输出工件（output artifact）是由管道组件发出的输出，Kubeflow Pipelines UI 能理解并呈现为丰富的可视化内容。包括工件在内的管道组件非常有用，因为它们可以用于性能评估、快速决策或不同运行间的比较。工件还使得理解管道各个组件的工作方式成为可能。工件可以是简单的文本数据视图，也可以是丰富的交互式可视化。\",\"注意：Kubeflow Pipelines 已从使用 kubeflow/metadata 转向使用 google/ml-metadata 作为元数据依赖。 Kubeflow Pipelines 后端将管道运行的运行时信息存储在元数据存储中。运行时信息包括任务的状态、工件的可用性、与执行或工件关联的自定义属性等。了解更多信息，请参阅 ML Metadata 入门指南。 如果一个工件被多个不同运行中的执行使用，你可以查看跨管道运行的工件和执行之间的连接。这种连接可视化称为谱系图（Lineage Graph）。\",\"Argo 工作流执行器是一个符合特定接口的进程，使 Argo 能够执行某些操作，如监控 Pod 日志、收集工件、管理容器生命周期等。 Kubeflow Pipelines 使用 Argo Workflows 作为工作流引擎，因此 Kubeflow Pipelines 用户需要选择一个工作流执行器。\"]},\"60\":{\"h\":\"主要的 Argo 工作流执行器类型包括：\",\"t\":[\"K8sAPIExecutor：通过 Kubernetes API 直接与集群交互，执行和监控容器。这是默认的执行器，适用于大多数场景。\",\"PNSExecutor：通过共享的进程命名空间（Process Namespace Sharing），使主容器可以访问子容器的文件系统和进程。这对于需要在容器之间共享数据的工作流特别有用。\",\"EmissaryExecutor：基于 Emissary-Ingress，专为高效的文件操作和网络操作设计，适用于需要高效处理大量小文件的工作流。 自 2022 年 2 月 Kubeflow Pipelines 1.8 正式发布以来，Emissary 执行器一直是 Kubeflow Pipelines 的默认执行器。\",\"DockerExecutor：直接与 Docker 守护进程交互来管理容器。这种方法依赖于 Docker，在某些 Kubernetes 配置中可能不适用。\"]},\"61\":{\"h\":\"如何选择适合的执行器：\",\"t\":[\"选择合适的工作流执行器取决于工作流的具体需求和集群环境：\",\"默认选择 K8sAPIExecutor：如果你的工作流不需要特别的资源共享或文件处理，默认的 K8sAPIExecutor 通常是最合适的选择。\",\"选择 PNSExecutor：如果你的工作流步骤之间需要共享文件或进程命名空间，那么 PNSExecutor 是一个好的选择。\",\"选择 EmissaryExecutor：如果你的工作流需要高效处理大量文件操作，尤其是小文件，可以选择 EmissaryExecutor。\",\"选择 DockerExecutor：如果你更熟悉 Docker 并且你的集群配置支持 Docker，可以考虑 DockerExecutor，但要注意其兼容性问题。\",\"注意，Argo Workflows 支持其他工作流执行器，但 Kubeflow Pipelines 团队仅推荐在 Emissary 执行器和 Docker 执行器之间进行选择。在配置 Kubeflow Pipelines 时，用户可以根据具体需求和工作流特点选择合适的 Argo 工作流执行器，以优化管道的执行效率和资源管理。\",\"[root@yigou-stg-101-61 ~]# kubectl get po -n kubeflow NAME READY STATUS RESTARTS AGE controller-manager-78d9bcc678-bgwtr 1/1 Running 0 17h katib-controller-7d7dffdb8f-7c6vk 1/1 Running 0 17h katib-db-manager-77d684cf4-tqtgh 1/1 Running 0 17h katib-ui-849479cf5f-rgmgf 1/1 Running 0 17h metadata-grpc-deployment-66457c4745-q9ddn 1/1 Running 0 17h metadata-writer-9956596d8-92g5h 1/1 Running 0 17h ml-pipeline-7cc7c5b47-k8r6z 1/1 Running 1 (17h ago) 17h ml-pipeline-persistenceagent-6c686b5b54-9bzwq 1/1 Running 0 17h ml-pipeline-scheduledworkflow-d894ffcd8-65j6h 1/1 Running 0 17h ml-pipeline-ui-57dbbdfd77-5bbh9 1/1 Running 0 17h ml-pipeline-viewer-crd-86868f775c-thcd8 1/1 Running 0 17h ml-pipeline-visualizationserver-5499555669-fsgks 1/1 Running 0 17h workflow-controller-799c5f4b48-nv8km 1/1 Running 0 17h\",\"下面是每个 Pod 的功能简介：\",\"controller-manager-78d9bcc678-bgwtr：\",\"控制器管理器 Pod，负责管理 Kubernetes 集群中的控制器，如 ReplicaSet、Deployment 等。\",\"katib-controller-7d7dffdb8f-7c6vk：\",\"Katib 控制器 Pod，是 Katib（超参数调优工具）的控制器组件，负责管理和调度超参数搜索任务。\",\"katib-db-manager-77d684cf4-tqtgh：\",\"Katib 数据库管理器 Pod，负责管理 Katib 的数据库，存储超参数调优任务的状态和结果。\",\"katib-ui-849479cf5f-rgmgf：\",\"Katib 用户界面 Pod，提供 Katib 的 Web 用户界面，用于查看和监控超参数调优任务的状态和结果。\",\"metadata-grpc-deployment-66457c4745-q9ddn：\",\"元数据 gRPC 服务 Pod，提供 Kubernetes 元数据服务，允许用户在 Kubeflow Pipelines 中创建和管理元数据。\",\"metadata-writer-9956596d8-92g5h：\",\"元数据写入器 Pod，负责将元数据写入到存储后端，与元数据 gRPC 服务一起用于 Kubeflow Pipelines。\",\"ml-pipeline-7cc7c5b47-k8r6z：\",\"ML Pipeline Pod，是 Kubeflow Pipelines 的核心组件之一，提供了机器学习工作流的定义、运行和监控功能。\",\"registry.cnbita.com:5000/kubeflow-pipelines/api-server\",\"backend/src/apiserver\",\"backend\\\\Dockerfile\",\"ml-pipeline-persistenceagent-6c686b5b54-9bzwq：\",\"ML Pipeline 持久化代理 Pod，负责管理 Kubeflow Pipelines 的持久化存储，存储工作流定义和执行状态。\",\"ml-pipeline-scheduledworkflow-d894ffcd8-65j6h：\",\"ML Pipeline 定时工作流 Pod，负责调度和执行 Kubeflow Pipelines 中的定时任务。\",\"ml-pipeline-ui-57dbbdfd77-5bbh9：\",\"ML Pipeline 用户界面 Pod，提供 Kubeflow Pipelines 的 Web 用户界面，用于创建、运行和监控机器学习工作流。\",\"ml-pipeline-viewer-crd-86868f775c-thcd8：\",\"ML Pipeline 视图 CRD Pod，用于自定义 Kubeflow Pipelines 中的自定义资源定义（CRD）的展示。\",\"ml-pipeline-visualizationserver-5499555669-fsgks：\",\"ML Pipeline 可视化服务器 Pod，提供 Kubeflow Pipelines 的可视化服务，用于展示机器学习工作流的执行状态和结果。\",\"workflow-controller-799c5f4b48-nv8km：\",\"工作流控制器 Pod，是 Kubeflow Pipelines 的控制器组件之一，负责管理和执行工作流任务。\",\"这些 Pod 组成了 Kubeflow 中的各个核心组件，提供了从超参数调优到机器学习工作流管理的完整功能。这些 Pod 之间有一定的关联关系，它们共同组成了 Kubeflow 平台，用于支持机器学习工作流的定义、运行、监控和优化。以下是它们之间的一些主要关联关系：\",\"控制器管理器 (controller-manager)：\",\"负责管理 Kubernetes 集群中的各种控制器，确保其他 Pod 和服务正常运行。\",\"Katib 组件：\",\"katib-controller：管理和调度超参数调优任务。\",\"katib-db-manager：管理存储 Katib 数据的数据库。\",\"katib-ui：提供 Katib 的 Web 用户界面。\",\"Katib 的各个组件通过数据库和控制器进行通信和协调，共同实现超参数调优功能。\",\"元数据服务 (metadata-grpc-deployment 和 metadata-writer)：\",\"metadata-grpc-deployment：提供 gRPC 接口，用于管理元数据。\",\"metadata-writer：负责将元数据写入到持久化存储中。\",\"这些组件通过元数据存储和 gRPC 接口进行通信，支持 Kubeflow Pipelines 中的元数据管理。\",\"Kubeflow Pipelines 组件：\",\"ml-pipeline：核心组件，负责机器学习工作流的定义、运行和监控。\",\"ml-pipeline-persistenceagent：管理工作流的持久化存储。\",\"ml-pipeline-scheduledworkflow：调度和执行定时任务。\",\"ml-pipeline-ui：提供 Web 用户界面，允许用户交互和监控工作流。\",\"ml-pipeline-viewer-crd：展示自定义资源定义（CRD）。\",\"ml-pipeline-visualizationserver：提供工作流执行状态和结果的可视化。\",\"这些组件通过存储系统、API 和用户界面进行紧密集成，形成完整的机器学习工作流管理平台。\",\"工作流控制器 (workflow-controller)：\",\"负责管理和执行工作流任务，确保工作流按照定义的步骤顺利执行。\",\"与 Kubeflow Pipelines 组件紧密合作，管理和协调工作流的各个部分。\",\"总体而言，这些 Pod 通过 Kubernetes 集群中的服务和控制器进行通信和协调，共同提供了一个功能强大的机器学习工作流管理平台。\"]},\"62\":{\"h\":\"controller-manager\",\"t\":[\"apiVersion: apps/v1 kind: Deployment metadata: name: controller-manager labels: control-plane: controller-manager controller-tools.k8s.io: \\\"1.0\\\" spec: selector: matchLabels: control-plane: controller-manager controller-tools.k8s.io: \\\"1.0\\\" template: metadata: labels: control-plane: controller-manager controller-tools.k8s.io: \\\"1.0\\\" spec: containers: - command: - /kube-app-manager # Built from https://github.com/kubernetes-sigs/application master branch on the date specified in the image tag. image: gcr.io/ml-pipeline/application-crd-controller:20231101 imagePullPolicy: IfNotPresent name: manager env: - name: NAMESPACE valueFrom: fieldRef: fieldPath: metadata.namespace resources: limits: cpu: 100m memory: 30Mi requests: cpu: 100m memory: 20Mi serviceAccountName: application\"]},\"63\":{\"h\":\"官网地址\",\"t\":[\"https://github.com/kubernetes-sigs/application\"]},\"64\":{\"h\":\"Kubernetes 应用程序\",\"t\":[\"Kubernetes 是一个开源系统，用于自动化部署、扩展和管理容器化应用程序。 上述描述来自 Kubernetes 主页，主要集中在容器化应用程序上。然而，Kubernetes 的元数据、对象和可视化（例如在 Dashboard 中）都集中在容器基础设施上，而不是应用程序本身。 本项目中的应用程序 CRD（自定义资源定义）和控制器旨在改变这种状况，使其能够在众多支持工具之间实现互操作。\"]},\"65\":{\"h\":\"它提供了：\",\"t\":[\"描述应用程序元数据的能力（例如，运行一个像 WordPress 这样的应用程序）\",\"一个连接基础设施（例如 Deployments）的根对象。这对于将各种资源联系在一起甚至清理（即垃圾回收）很有用\",\"为支持应用程序提供信息，帮助它们查询和理解支持应用程序的对象\",\"应用程序级别的健康检查\"]},\"66\":{\"h\":\"这可以被以下用户使用：\",\"t\":[\"希望以应用程序为中心进行操作的应用程序运营商\",\"像 Helm 这样的工具，它们将其软件包发布集中在应用程序安装上，并且希望与其他工具（例如 Dashboard）实现互操作\",\"希望可视化应用程序（不仅仅是基础设施视图）的 Dashboards\"]},\"67\":{\"h\":\"目标\",\"t\":[\"提供一个用于在 Kubernetes 中创建、查看和管理应用程序的标准 API。\",\"提供通过 kubectl 与应用程序 API 交互的 CLI 实现。\",\"提供应用程序的安装状态和垃圾回收。\",\"提供一种标准方式，使应用程序能够向 UI 展示基本的健康检查。\",\"提供一种明确的机制，使应用程序能够声明对另一个应用程序的依赖关系。\",\"通过创建工具可以实现的标准，促进生态系统工具和 UI 之间的互操作性。\",\"促进 Kubernetes 应用程序使用通用的标签和注释。\"]},\"68\":{\"h\":\"非目标\",\"t\":[\"创建一个所有工具必须实现的标准。\",\"提供一种方式，使 UI 能够显示应用程序的指标。\"]},\"69\":{\"h\":\"什么是 Katib？\",\"t\":[\"Katib 是一个原生于 Kubernetes 的自动化机器学习（AutoML）项目。Katib 支持超参数调优、提前停止和神经架构搜索（NAS）。了解更多 AutoML 信息，请访问 fast.ai、Google Cloud、Microsoft Azure 或 Amazon SageMaker。 Katib 是一个与机器学习（ML）框架无关的项目。它可以调优用任何用户选择的语言编写的应用程序的超参数，并且本身支持许多 ML 框架，例如 TensorFlow、MXNet、PyTorch、XGBoost 等。 Katib 支持多种 AutoML 算法，例如贝叶斯优化（Bayesian optimization）、帕尔森估计树（Tree of Parzen Estimators）、随机搜索（Random Search）、协方差矩阵自适应进化策略（Covariance Matrix Adaptation Evolution Strategy）、Hyperband、高效神经架构搜索（Efficient Neural Architecture Search）、可微分架构搜索（Differentiable Architecture Search）等等。更多算法支持即将推出。 Katib 项目是开源的。开发者指南是希望为该项目做出贡献的开发者的良好起点。 \"]},\"70\":{\"h\":\"为什么选择 Katib？\",\"t\":[\"Katib 解决了 AI/ML 生命周期中的自动化机器学习（AutoML）步骤中的超参数优化或神经架构搜索问题，如下图所示： \",\"多节点和多GPU分布式训练：Katib 可以协调多节点和多GPU的分布式训练工作负载。\",\"与 Kubeflow Training Operator 集成：Katib 与 Kubeflow 的训练操作（如 PyTorchJob）集成，允许优化任何规模的大模型的超参数。\",\"此外，Katib 可以协调更高级的优化工作流，如 Argo Workflows 和 Tekton Pipelines。\",\"可扩展性和可移植性：Katib 是可扩展和可移植的。Katib 运行 Kubernetes 容器来执行超参数调优任务，这使得 Katib 可以与任何 ML 训练框架一起使用。\",\"用户甚至可以使用 Katib 来优化非ML任务，只要能够收集优化指标。\",\"丰富的优化算法支持：Katib 与许多优化框架（如 Hyperopt 和 Optuna）集成，这些框架实现了大多数最先进的优化算法。\",\"用户可以利用 Katib 控制平面来实现和基准测试他们自己的优化算法。\"]},\"71\":{\"h\":\"pipeline服务注册流程\",\"t\":[\" 其他服务注册在 startRpcServer 函数中，注册了以下服务：\"]},\"72\":{\"h\":\"API v1beta1 注册的服务\",\"t\":[\"ExperimentService: 实验服务\",\"apiv1beta1.RegisterExperimentServiceServer(s, sharedExperimentServer)\",\"PipelineService: 流水线服务\",\"apiv1beta1.RegisterPipelineServiceServer(s, sharedPipelineServer)\",\"JobService: 作业服务\",\"apiv1beta1.RegisterJobServiceServer(s, sharedJobServer)\",\"RunService: 运行服务\",\"apiv1beta1.RegisterRunServiceServer(s, sharedRunServer)\",\"TaskService: 任务服务\",\"apiv1beta1.RegisterTaskServiceServer(s, server.NewTaskServer(resourceManager))\",\"ReportService: 报告服务\",\"apiv1beta1.RegisterReportServiceServer(s, server.NewReportServer(resourceManager))\",\"VisualizationService: 可视化服务\",\"apiv1beta1.RegisterVisualizationServiceServer( s, server.NewVisualizationServer( resourceManager, common.GetStringConfig(cm.VisualizationServiceHost), common.GetStringConfig(cm.VisualizationServicePort), ))\",\"AuthService: 认证服务\",\"apiv1beta1.RegisterAuthServiceServer(s, server.NewAuthServer(resourceManager))\"]},\"73\":{\"h\":\"API v2beta1 注册的服务\",\"t\":[\"ExperimentService: 实验服务\",\"apiv2beta1.RegisterExperimentServiceServer(s, sharedExperimentServer)\",\"PipelineService: 流水线服务\",\"apiv2beta1.RegisterPipelineServiceServer(s, sharedPipelineServer)\",\"RecurringRunService: 定期运行服务\",\"apiv2beta1.RegisterRecurringRunServiceServer(s, sharedJobServer)\",\"RunService: 运行服务\",\"apiv2beta1.RegisterRunServiceServer(s, sharedRunServer)\"]},\"74\":{\"h\":\"其他\",\"t\":[\"ReflectionService: 反射服务\",\"reflection.Register(s)\"]},\"75\":{\"h\":\"总结\",\"t\":[\"在这个 startRpcServer 函数中，注册了以下 13 个服务：\",\"ExperimentService（v1beta1 和 v2beta1）\",\"PipelineService（v1beta1 和 v2beta1）\",\"JobService（v1beta1）\",\"RunService（v1beta1 和 v2beta1）\",\"TaskService（v1beta1）\",\"ReportService（v1beta1）\",\"VisualizationService（v1beta1）\",\"AuthService（v1beta1）\",\"RecurringRunService（v2beta1）\",\"ReflectionService\",\"这些服务涵盖了实验管理、流水线管理、作业管理、运行管理、任务管理、报告生成、数据可视化和认证功能，并且支持不同版本的API。 \"]},\"76\":{\"h\":\"pipeline创建流程\",\"t\":[\" 创建流水线只是把相关参数信息写入数据库。\"]},\"77\":{\"h\":\"创建Runs\",\"t\":[\" Runs创建过程是 请求apiserver->请求workflow,然后保存相关数据\"]},\"78\":{\"c\":[\"云原生\"]},\"79\":{\"c\":[\"Kubeflow\"]},\"80\":{\"h\":\"k8s operator\",\"t\":[\"什么是 Kubernetes Operator？\",\"Kubernetes Operator 是一种软件扩展，使用 Kubernetes 原生的 API 和工具来自动管理复杂应用的生命周期。Operator 可以将人类操作员（例如系统管理员）的操作自动化，管理 Kubernetes 应用程序的配置、部署、升级、备份和故障处理等任务。\"]},\"81\":{\"h\":\"Operator 的基本概念\",\"t\":[\"Custom Resource (自定义资源，CR): Kubernetes 的内置资源（如 Pod、Service）可能无法满足所有应用的需求。CR 提供了定义自定义对象的能力，使得用户可以在 Kubernetes 中引入新的资源类型。\",\"Custom Resource Definition (自定义资源定义，CRD): CRD 是 Kubernetes 用于定义 CR 结构的机制。通过 CRD，用户可以创建和管理新的自定义资源。\",\"Controller (控制器): 控制器是 Kubernetes 中一个不断循环检查资源实际状态并使其符合预期状态的逻辑组件。Operator 就是一个高级的控制器，专门用于管理自定义资源。\"]},\"82\":{\"h\":\"Operator 的工作原理\",\"t\":[\"定义 CRD: 开发者首先需要定义 CRD，这描述了自定义资源的结构和规范。CRD 定义了资源的 API 和行为方式。\",\"实现控制器: 控制器监控自定义资源的状态，并根据用户定义的逻辑执行相应的操作。控制器的核心任务是不断将资源的实际状态调整为期望状态。\",\"部署 Operator: Operator 本质上是一个 Kubernetes 应用，它包括了 CRD 和控制器的实现。部署 Operator 后，用户可以使用 kubectl 等工具创建和管理自定义资源。\"]},\"83\":{\"h\":\"Operator 的应用场景\",\"t\":[\"应用部署和管理: Operator 可以自动化复杂应用的部署和管理过程。例如，数据库集群的创建、分片、复制等任务都可以通过 Operator 自动执行。\",\"自动化升级: Operator 可以监控应用的新版本，并自动执行无中断的滚动升级。\",\"备份和恢复: Operator 可以定期备份应用的数据，并在出现故障时自动进行恢复。\",\"自愈能力: Operator 可以监控应用的健康状态，自动修复出现的问题，例如重新启动故障的组件。\"]},\"84\":{\"h\":\"Operator 的优势\",\"t\":[\"简化运维操作: Operator 自动化了许多日常的运维任务，减少了人为操作的复杂性和风险。\",\"标准化管理流程: 通过 Operator，可以将最佳实践和操作流程编码成标准化的流程，使得复杂应用的管理变得更一致和可靠。\",\"增强 Kubernetes 的能力: Operator 将 Kubernetes 的管理能力扩展到了自定义应用领域，使得 Kubernetes 可以管理更复杂的工作负载。\"]},\"85\":{\"h\":\"使用 Operator 的示例\",\"t\":[\"Prometheus Operator: 用于简化 Prometheus 集群的部署和管理，自动处理 Prometheus 配置、目标发现和告警管理。\",\"ElasticSearch Operator: 管理 ElasticSearch 集群的部署、升级和扩展，确保高可用性和数据一致性。\",\"MySQL Operator: 自动化 MySQL 数据库的创建、备份和恢复，简化数据库集群的管理。\"]},\"86\":{\"h\":\"开发 Operator 的工具\",\"t\":[\"Operator SDK: 一个流行的工具包，提供了从生成基础代码到测试和部署的全流程支持，简化了 Operator 的开发过程。\",\"Kubebuilder: 提供了面向 Go 语言的开发框架和工具，用于生成和管理 Kubernetes API 扩展。\",\"KUDO (Kubernetes Universal Declarative Operator): 提供了一种声明性的方式来定义和管理 Operator，使得创建复杂的应用管理变得更简单。\"]},\"87\":{\"h\":\"总结\",\"t\":[\"Kubernetes Operator 是一种强大的工具，可以自动化和简化复杂应用的管理。通过定义自定义资源和控制器，Operator 能够将人类操作员的经验和最佳实践转化为自动化的操作流程，大大增强了 Kubernetes 的管理能力。无论是管理数据库、消息队列，还是大数据处理集群，Operator 都可以帮助实现高效的运维管理。\",\"如果你对开发 Kubernetes Operator 有兴趣，可以先从简单的示例开始，逐步深入理解其背后的原理和应用场景。\"]},\"88\":{\"c\":[\"云原生\"]},\"89\":{\"c\":[\"operator\"]},\"90\":{\"h\":\"个人介绍\",\"t\":[\"个人简介\",\"大家好，我是一名全栈开发工程师，拥有广泛的编程语言知识和丰富的技术经验。以下是我的专业技能和经验介绍：\"]},\"91\":{\"h\":\"编程语言\",\"t\":[\"Java: 熟练使用Java进行企业级应用开发，精通Spring Boot框架，擅长构建高性能和可扩展的后端服务。\",\"C++: 具备扎实的C++基础，能够开发高效的系统级应用程序。\",\"C: 精通C语言，擅长底层编程和系统开发。\",\"Python: 精通Python，尤其在数据分析、机器学习以及自动化脚本编写方面有丰富经验。\",\"Go: 熟悉Go语言，能够利用其高并发和高性能特点开发后端服务。\"]},\"92\":{\"h\":\"技术栈\",\"t\":[\"Kubernetes (k8s): 熟悉容器编排，能够使用Kubernetes进行微服务管理和部署。\",\"Spring Boot: 深入理解Spring Boot框架，能够快速开发和部署企业级应用。\",\"MySQL: 精通关系型数据库设计和优化，具备高效处理大规模数据的能力。\",\"Redis: 熟悉Redis，能够利用其高性能特性进行缓存和存储操作。\",\"Nacos: 擅长使用Nacos进行服务发现和配置管理。\"]},\"93\":{\"h\":\"MLOps\",\"t\":[\"Kubeflow: 精通Kubeflow，能够构建、部署和管理机器学习模型流水线。\"]},\"94\":{\"h\":\"前端开发\",\"t\":[\"Vue: 熟练使用Vue.js进行前端开发，能够创建动态和响应式的用户界面。\",\"TypeScript (TS): 熟悉TypeScript，能够编写高质量的可维护代码。\",\"HTML: 精通HTML，能够设计和实现网页结构。\",\"Element-UI: 熟悉Element-UI库，能够快速开发美观且实用的前端界面。\",\"我致力于不断提升自己的技术水平和解决实际问题的能力，乐于接受新挑战，追求技术创新。如果你对我的技能和经验感兴趣，欢迎联系我！\"]},\"95\":{\"c\":[\"个人介绍\"]},\"96\":{\"c\":[\"个人\"]},\"97\":{\"h\":\"开源技术\",\"t\":[\"MInference：通过动态稀疏注意力加速长上下文 LLM 的预填充\"]},\"98\":{\"h\":\"地址\",\"t\":[\"https://github.com/microsoft/MInference\"]},\"99\":{\"h\":\"论文\",\"t\":[\"https://hqjiang.com/minference.html\"]},\"100\":{\"h\":\"介绍\",\"t\":[\"论文介绍了一种名为 MInference 的动态稀疏注意力方法，用于解决长上下文 LLM 推理中的问题，并通过多种实验和测试展示了其效果。\"]},\"101\":{\"h\":\"重要亮点\",\"t\":[\"MInference 的提出背景：长上下文 LLM 推理面临预填充阶段注意力延迟长、KV 缓存存储和传输成本高等挑战，之前方法难以低成本在单个 A100 GPU 实现百万级标记提示的可接受延迟，MInference 应运而生。\",\"MInference 的工作原理：利用动态稀疏注意的静态空间聚合模式，离线确定每个头的最佳动态稀疏模式，在推理中动态近似动态稀疏索引，使用优化的 GPU 内核执行高效计算，显著减少预填充阶段延迟。\",\"MInference 的主要贡献：加速长上下文 LLM 的预填充阶段多达 10 倍；将动态稀疏注意力分为三种模式并设计搜索算法；引入在线近似方法和优化内核，提出最佳推理代码库；通过四个基准测试评估，在成本效率和系统延迟方面表现出色。\",\"长上下文基准测试中的实验结果：在问答、编码、基于检索等一系列任务中测试 MInference，有效保留或扩展实际上下文窗口处理能力，在不同模型和方法对比中性能良好。\",\"内核中的延迟细分和稀疏模式：展示三种注意力模式和 FlashAttention 的微基准测试结果，Vertical-Slash 虽慢但仍有显著加速，还展示了 Vertical-Slash 头部 kernel 中的稀疏索引。\"]},\"102\":{\"c\":[\"开源技术\"]},\"103\":{\"c\":[\"推理引擎\"]},\"104\":{\"h\":\"计算机网络\",\"t\":[\"http2与http1区别?\",\"HTTP/2 是对 HTTP/1.x 协议的重大升级，旨在提高网络性能和效率。以下是 HTTP/2 相对于 HTTP/1 的一些关键区别和改进：\"]},\"105\":{\"h\":\"1. 协议基础\",\"t\":[\"HTTP/1.x: 基于纯文本的协议，使用新行符分隔的文本消息进行通信。\",\"HTTP/2: 基于二进制的协议，使用二进制帧传输数据，更高效地解析和传输数据。\"]},\"106\":{\"h\":\"2. 连接管理\",\"t\":[\"HTTP/1.x:\",\"每个请求/响应对通常需要一个单独的TCP连接（HTTP/1.0）。\",\"HTTP/1.1 引入了连接保持（Keep-Alive），允许在同一个TCP连接上复用多个请求，但在同一时刻只能处理一个请求（串行化处理）。\",\"HTTP/2:\",\"单个TCP连接上可以处理多个并发的请求/响应对。\",\"使用流的概念，每个请求/响应对在一个单独的流中，流之间可以独立并行处理。\"]},\"107\":{\"h\":\"3. 多路复用\",\"t\":[\"HTTP/1.x: 在一个连接上，只有一个请求/响应对可以被处理（头部阻塞问题），需要等待当前请求完成后，才能开始下一个请求。\",\"HTTP/2: 允许多个请求/响应对在同一连接上的多个流中并发传输，不同的流可以独立处理，不会相互阻塞。\"]},\"108\":{\"h\":\"4. 头部压缩\",\"t\":[\"HTTP/1.x: HTTP头部是以纯文本格式传输的，每个请求都需要发送完整的头部信息，导致冗余和带宽浪费。\",\"HTTP/2: 使用 HPACK 算法对头部进行压缩，减少了传输数据量。头部信息仅在第一次请求时完整传输，后续请求只需发送差异部分。\"]},\"109\":{\"h\":\"5. 服务器推送\",\"t\":[\"HTTP/1.x: 客户端必须明确请求每个资源，服务器只能响应客户端的请求。\",\"HTTP/2: 支持服务器推送功能，服务器可以在客户端请求之前主动发送资源，这有助于减少延迟和提升性能。例如，当客户端请求HTML页面时，服务器可以主动推送相关的CSS和JavaScript文件。\"]},\"110\":{\"h\":\"6. 优先级和流控制\",\"t\":[\"HTTP/1.x: 没有内建的优先级控制机制，所有请求被平等对待。\",\"HTTP/2: 支持流的优先级，客户端可以指定不同流的优先级，允许更重要的请求先行处理。同时，HTTP/2 提供流量控制机制，确保没有流会独占带宽。\"]},\"111\":{\"h\":\"7. 加密和安全\",\"t\":[\"HTTP/1.x: 加密是可选的（通过HTTP或HTTPS），但非加密的HTTP请求仍然普遍存在。\",\"HTTP/2: 大多数实现强制要求使用加密（通过HTTPS），尽管协议本身不强制这一点。现代浏览器和服务器在实际应用中通常要求 HTTP/2 使用 TLS。\"]},\"112\":{\"h\":\"8. 协议扩展性\",\"t\":[\"HTTP/1.x: 由于是文本协议，扩展和添加新功能变得复杂。\",\"HTTP/2: 作为二进制协议，HTTP/2 更容易扩展，添加新功能可以通过新帧类型和更复杂的协议操作来实现，而不影响现有的功能。\"]},\"113\":{\"h\":\"9. 性能改进\",\"t\":[\"HTTP/1.x: 多个小的请求可能会因为串行化处理导致较高的延迟和低效的带宽利用。\",\"HTTP/2: 通过多路复用、头部压缩和服务器推送等功能，HTTP/2 显著降低了延迟，改善了带宽利用，提升了整体性能。\"]},\"114\":{\"h\":\"总结\",\"t\":[\"特性\",\"HTTP/1.x\",\"HTTP/2\",\"协议类型\",\"基于纯文本\",\"基于二进制\",\"连接管理\",\"每个请求通常需要一个TCP连接\",\"单个连接处理多个并发请求\",\"多路复用\",\"不支持（有头部阻塞问题）\",\"支持\",\"头部压缩\",\"不支持\",\"使用HPACK算法进行压缩\",\"服务器推送\",\"不支持\",\"支持\",\"优先级和流控制\",\"不支持\",\"支持\",\"加密和安全\",\"可选（但非强制）\",\"大多数实现要求加密（HTTPS）\",\"协议扩展性\",\"扩展复杂\",\"更容易扩展\",\"性能\",\"受限于串行化处理和头部阻塞\",\"显著提升（多路复用、压缩、推送）\",\"HTTP/2 带来了显著的改进和优化，使得网络应用能够更高效地传输数据，提升了用户体验和网络性能。\"]},\"115\":{\"h\":\"查看系统中已有的veth设备对或确认已创建的veth设备对，可以使用以下几种方法：\"},\"116\":{\"h\":\"使用 命令\",\"t\":[\"ip 命令是查看和管理网络设备的主要工具：\",\"列出所有网络接口：\",\"ip link show\",\"该命令会列出系统中所有的网络接口，包括veth设备对。\",\"过滤veth设备：\",\"ip link show | grep veth\",\"通过grep过滤出veth设备。\"]},\"117\":{\"h\":\"使用 命令\",\"t\":[\"ifconfig命令也可以用于查看网络接口：\",\"ifconfig\",\"同样，可以使用grep过滤出veth设备：\",\"ifconfig | grep veth\"]},\"118\":{\"h\":\"查看具体veth设备对的详细信息\",\"t\":[\"可以使用以下命令查看某个veth设备对的详细信息：\",\"ip link show veth0\"]},\"119\":{\"h\":\"示例\",\"t\":[\"假设创建了一个veth设备对：\",\"ip link add veth0 type veth peer name veth1\",\"然后，可以使用以下命令查看：\",\"ip link show | grep veth\",\"输出可能类似于：\",\"10: veth0@veth1: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000 11: veth1@veth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000\",\"这表明veth0和veth1是一对互相连接的虚拟以太网设备。\"]},\"120\":{\"h\":\"检查命名空间中的veth设备\",\"t\":[\"如果将veth设备移动到不同的命名空间，可以使用以下命令查看特定命名空间中的网络接口：\",\"ip netns exec ns1 ip link show ip netns exec ns1 ip link show 1: lo: <LOOPBACK> mtu 65536 qdisc noop state DOWN mode DEFAULT group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 28: veth1@if29: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP mode DEFAULT group default qlen 1000 link/ether 52:7e:e0:b6:47:d2 brd ff:ff:ff:ff:ff:ff link-netnsid 0 ip netns exec ns1 ip a 1: lo: <LOOPBACK> mtu 65536 qdisc noop state DOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 28: veth1@if29: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP group default qlen 1000 link/ether 52:7e:e0:b6:47:d2 brd ff:ff:ff:ff:ff:ff link-netnsid 0 inet 192.168.1.2/24 scope global veth1 valid_lft forever preferred_lft forever inet6 fe80::507e:e0ff:feb6:47d2/64 scope link valid_lft forever preferred_lft forever\",\"假设veth1被移动到命名空间ns1，可以在ns1命名空间中看到它。\",\"通过这些命令，可以方便地查看和管理系统中的veth设备对。\"]},\"121\":{\"h\":\"VLAN 与VXLAN\",\"t\":[\"VLAN（Virtual Local Area Network）和VXLAN（Virtual Extensible LAN）是两种用于网络分段和虚拟化的技术，它们各自有不同的应用场景和特点。以下是对它们的解析：\"]},\"122\":{\"h\":\"VLAN（Virtual Local Area Network）\",\"t\":[\"VLAN是一种用于在同一物理网络上创建多个逻辑网络的技术。它的主要特点和用途如下：\",\"网络分段：通过VLAN，可以将一个物理网络分割成多个逻辑网络，使得不同VLAN之间的通信受到限制，从而提高网络的安全性和性能。\",\"标记帧：VLAN使用IEEE 802.1Q标准，在以太网帧中添加一个4字节的标签，标记帧属于哪个VLAN。\",\"VLAN ID：每个VLAN都有一个唯一的VLAN ID，范围是1到4094。网络设备根据这个ID来区分不同的VLAN。\",\"配置简单：VLAN的配置相对简单，只需要在交换机上配置相关的端口或接口即可。\",\"常见用途：\",\"提高网络安全性，通过分割网络减少广播域。\",\"提高网络性能，通过减少广播流量和冲突域。\",\"提供灵活的网络管理和用户分组。\"]},\"123\":{\"h\":\"VXLAN（Virtual Extensible LAN）\",\"t\":[\"VXLAN是一种用于在大规模数据中心和云环境中创建虚拟网络的技术。它的主要特点和用途如下：\",\"扩展性：VXLAN使用24位的VNI（VXLAN Network Identifier），理论上支持多达1600万个虚拟网络，大大超过了VLAN的4094个限制。\",\"基于隧道：VXLAN通过UDP隧道封装，将二层以太网帧封装在三层IP包中，从而可以跨越传统的二层边界在IP网络上传输。\",\"分布式架构：VXLAN适用于大规模的分布式数据中心环境，支持跨多个物理位置的虚拟机迁移和负载均衡。\",\"网络虚拟化：VXLAN可以在现有的IP网络基础上创建虚拟网络，使得虚拟机和容器之间的通信更加灵活和高效。\",\"常见用途：\",\"数据中心和云环境中的大规模虚拟化网络。\",\"跨多个数据中心的虚拟机迁移和高可用性。\",\"支持多租户环境，每个租户可以有独立的虚拟网络。\"]},\"124\":{\"h\":\"对比\",\"t\":[\"特点\",\"VLAN\",\"VXLAN\",\"标识符\",\"12位VLAN ID（最多4094个）\",\"24位VNI（最多1600万个）\",\"封装层\",\"二层以太网（IEEE 802.1Q）\",\"三层IP（UDP隧道封装）\",\"应用场景\",\"小规模网络、局域网\",\"大规模数据中心、云环境、跨数据中心\",\"配置复杂度\",\"简单\",\"较复杂，需要配置隧道端点（VTEP）\",\"扩展性\",\"有限，最多4094个VLAN\",\"高扩展性，支持多达1600万个虚拟网络\"]},\"125\":{\"h\":\"总结\",\"t\":[\"VLAN适用于较小规模的网络分段和隔离，而VXLAN适用于大规模数据中心和云环境中的网络虚拟化和扩展。它们各自有不同的优缺点和应用场景，根据具体需求选择合适的技术可以提高网络的性能、安全性和管理灵活性。\"]},\"126\":{\"h\":\"VXLAN与VTEP\"},\"127\":{\"h\":\"VXLAN（Virtual Extensible LAN）\",\"t\":[\"VXLAN是一种用于扩展二层网络的技术，特别适合在大型数据中心和云环境中使用。其主要特性包括：\",\"扩展性：VXLAN使用24位的VNI（VXLAN Network Identifier），支持多达1600万个虚拟网络，远远超过传统VLAN的4094个限制。\",\"隧道封装：VXLAN通过UDP隧道封装将二层以太网帧封装在三层IP包中，从而可以在三层IP网络上进行传输。这种方式允许二层流量跨越不同的三层网络，使得虚拟机可以在不同的物理位置之间自由迁移。\",\"多租户支持：VXLAN允许在同一个物理网络基础设施上运行多个独立的虚拟网络，每个虚拟网络可以有自己的VNI，从而支持多租户环境。\",\"弹性和高可用性：VXLAN可以在现有的IP网络上实现二层网络的扩展和弹性，支持负载均衡和高可用性。\"]},\"128\":{\"h\":\"VTEP（VXLAN Tunnel Endpoint）\",\"t\":[\"VTEP是VXLAN架构中的关键组件，负责VXLAN隧道的端点操作。其主要功能包括：\",\"隧道端点：VTEP是VXLAN隧道的起点和终点，负责VXLAN包的封装和解封装。每个VTEP有两个主要接口：一个是连接到传统二层网络的接口，另一个是连接到IP网络的接口。\",\"封装和解封装：当VTEP接收到来自二层网络的以太网帧时，它将帧封装在UDP包中，附加上VNI，然后通过IP网络发送到目标VTEP。目标VTEP解封装UDP包，并将以太网帧发送到其二层网络接口。\",\"VNI映射：VTEP负责将二层网络中的VLAN ID映射到VXLAN的VNI，从而在VXLAN隧道中维护虚拟网络的隔离和标识。\",\"MAC地址学习：VTEP通过监听网络流量和ARP（Address Resolution Protocol）请求，学习和维护虚拟网络中MAC地址到VTEP的映射关系。这类似于传统二层交换机的MAC地址表。\"]},\"129\":{\"h\":\"VXLAN 和 VTEP 的工作流程\",\"t\":[\"帧封装：当主机A发送一个以太网帧给主机B时，该帧首先被发送到本地的VTEP。\",\"VXLAN包封装：VTEP将该帧封装到一个UDP包中，并附加上对应的VNI。UDP包的源IP和目的IP是VTEP的IP地址。\",\"通过IP网络传输：封装好的VXLAN包通过三层IP网络传输到目的VTEP。\",\"帧解封装：目的VTEP接收到VXLAN包后，解封装出原始的以太网帧。\",\"帧传递：解封装的以太网帧被发送到目标主机B所在的二层网络。\"]},\"130\":{\"h\":\"总结\",\"t\":[\"VXLAN通过在现有的三层IP网络上创建虚拟二层网络，实现了大规模的数据中心和云环境中的网络虚拟化和扩展。VTEP作为VXLAN架构中的关键组件，负责隧道的端点操作，完成VXLAN包的封装和解封装。VXLAN和VTEP的结合，使得跨越不同物理位置的虚拟机能够像在同一个二层网络中一样进行通信，从而实现了高效、灵活和可扩展的网络架构。\"]},\"131\":{\"c\":[\"网络\"]},\"132\":{\"c\":[\"http\"]},\"133\":{\"h\":\"独立开发者一点思考\",\"t\":[\"杂谈之独立开发者一点思考\",\"https://indiehacker.one/\",\"全文总结 本文主要介绍了独立开发者的相关内容，包括什么是独立开发者、为什么要做独立开发者、有哪些牛逼的独立开发者、独立开发者面临的困境、独立开发的一些基本流程、想法、如何判断想法的是不是可以赚钱、三大核心问题、如何解决用户的问题、使用什么样的编程语言、采用什么样的产品形态、一个 MVP 产品最少需要做多少工作、一周开发一个新产品、三点金规铁律、发布、别人说你的产品是垃圾，伪需求怎么办、增长、心态、如何保持积极的心态、如何面对压力等。\",\"重要亮点\",\"什么是独立开发者：指的是一类独立的、自主运营并开发自己的在线业务以获得收入的人。\",\"为什么要做独立开发者：成为一名独立开发者可以提供很多传统工作所无法提供的优点，包括人身自由、财务自由、成长与学习、实现自己的想法等。\",\"有哪些牛逼的独立开发者：levelsio 和 Baye aka 威力狈是公认的独立开发者中的牛逼人物。\",\"独立开发者面临的困境：包括美工问题、营销问题、生活压力、保持动力等。\",\"独立开发的一些基本流程：包括想法、开发、发布等环节。\",\"想法：想法是一个产品的起始点，需要大致正确即可，在实践的过程中，想法可能会发生改变，产品方向也会发生改变。\",\"如何判断想法的是不是可以赚钱：做好一个 DEMO 页面，罗列你的想法和产品特点，中间加个具有号召性的按钮。然后把这个页面推广出去。最后做数据分析。根据分析结果，你很快就会知道你的想法是不是可以赚到钱。\",\"三大核心问题：包括产品有什么核心功能和特点、产品的目标客户是谁、目标客户会经常出现在那里。\",\"如何解决用户的问题：用户并不知道自己需要什么，直到我们拿出自己的产品，他们就会发现，这就是我想要的。\",\"使用什么样的编程语言：你会哪个就用哪个，熟悉哪个就用哪个。\",\"采用什么样的产品形态：需要考虑产品适合使用哪种产品形态、目标客户更愿意使用哪种产品、目前有能力提供哪种产品形态。\",\"一个 MVP 产品最少需要做多少工作：答案是 9 个页面和 9 个接口。\",\"一周开发一个新产品：对于一个中等水平的技术人员来说，一周的时间足够开发一个新产品。\",\"三点金规铁律：包括不要熬夜做产品、不做免费的产品、不做完美的产品。\",\"发布：当你的产品完成了最小 MVP 的时候，就可以发布了。\",\"别人说你的产品是垃圾，伪需求怎么办：需要重申审视是不是你的产品功能和特性不够，他是不是你的目标客户。\",\"如何保持积极的心态：积极是暂时的，不积极才是常态，关键是不要消极。\",\"如何面对压力：独立开发和创业一样有风险，需要有心理准备，最好有以下几方面准备：将独立开发当作\",\"全文总结 本文主要介绍了独立开发者的相关内容，包括什么是独立开发者、为什么要做独立开发者、有哪些牛逼的独立开发者、独立开发者面临的困境、独立开发的一些基本流程、想法、如何判断想法的是不是可以赚钱、三大核心问题、如何解决用户的问题、使用什么样的编程语言、采用什么样的产品形态、一个 MVP 产品最少需要做多少工作、一周开发一个新产品、三点金规铁律、发布、别人说你的产品是垃圾，伪需求怎么办、增长、心态、如何保持积极的心态、如何面对压力等。\",\"重要亮点\",\"什么是独立开发者：指的是一类独立的、自主运营并开发自己的在线业务以获得收入的人。\",\"为什么要做独立开发者：成为一名独立开发者可以提供很多传统工作所无法提供的优点，包括人身自由、财务自由、成长与学习、实现自己的想法等。\",\"有哪些牛逼的独立开发者：levelsio 和 Baye aka 威力狈是公认的独立开发者中的牛逼人物。\",\"独立开发者面临的困境：包括美工问题、营销问题、生活压力、保持动力等。\",\"独立开发的一些基本流程：包括想法、开发、发布等环节。\",\"想法：想法是一个产品的起始点，需要大致正确即可，在实践的过程中，想法可能会发生改变，产品方向也会发生改变。\",\"如何判断想法的是不是可以赚钱：做好一个 DEMO 页面，罗列你的想法和产品特点，中间加个具有号召性的按钮。然后把这个页面推广出去。最后做数据分析。根据分析结果，你很快就会知道你的想法是不是可以赚到钱。\",\"三大核心问题：包括产品有什么核心功能和特点、产品的目标客户是谁、目标客户会经常出现在那里。\",\"如何解决用户的问题：用户并不知道自己需要什么，直到我们拿出自己的产品，他们就会发现，这就是我想要的。\",\"使用什么样的编程语言：你会哪个就用哪个，熟悉哪个就用哪个。\",\"采用什么样的产品形态：需要考虑产品适合使用哪种产品形态、目标客户更愿意使用哪种产品、目前有能力提供哪种产品形态。\",\"一个 MVP 产品最少需要做多少工作：答案是 9 个页面和 9 个接口。\",\"一周开发一个新产品：对于一个中等水平的技术人员来说，一周的时间足够开发一个新产品。\",\"三点金规铁律：包括不要熬夜做产品、不做免费的产品、不做完美的产品。\",\"发布：当你的产品完成了最小 MVP 的时候，就可以发布了。\",\"别人说你的产品是垃圾，伪需求怎么办：需要重申审视是不是你的产品功能和特性不够，他是不是你的目标客户。\",\"如何保持积极的心态：积极是暂时的，不积极才是常态，关键是不要消极。\",\"如何面对压力：独立开发和创业一样有风险，需要有心理准备，最好有以下几方面准备：将独立开发当作\"]},\"134\":{\"c\":[\"杂谈\"]},\"135\":{\"c\":[\"独立开发者\"]},\"136\":{\"h\":\"\",\"t\":[\"404 Not Found\"]},\"137\":{\"h\":\"云原生\"},\"138\":{\"h\":\"介绍\"},\"139\":{\"h\":\"技术科普\"},\"140\":{\"h\":\"杂谈\"}},\"dirtCount\":0,\"index\":[[\"技术科普\",{\"0\":{\"139\":1}}],[\"技术栈\",{\"0\":{\"92\":1}}],[\"杂谈\",{\"0\":{\"140\":1},\"2\":{\"134\":1}}],[\"杂谈之独立开发者一点思考\",{\"1\":{\"133\":1}}],[\"关键是不要消极\",{\"1\":{\"133\":2}}],[\"关于客户端代码和运行时代码的命名约定\",{\"1\":{\"55\":1}}],[\"积极是暂时的\",{\"1\":{\"133\":2}}],[\"他是不是你的目标客户\",{\"1\":{\"133\":2}}],[\"他们就会发现\",{\"1\":{\"133\":2}}],[\"答案是\",{\"1\":{\"133\":2}}],[\"根据分析结果\",{\"1\":{\"133\":2}}],[\"根据具体需求选择合适的技术可以提高网络的性能\",{\"1\":{\"125\":1}}],[\"罗列你的想法和产品特点\",{\"1\":{\"133\":2}}],[\"页面\",{\"1\":{\"133\":2}}],[\"做好一个\",{\"1\":{\"133\":2}}],[\"产品的目标客户是谁\",{\"1\":{\"133\":2}}],[\"产品方向也会发生改变\",{\"1\":{\"133\":2}}],[\"产品最少需要做多少工作\",{\"1\":{\"133\":4}}],[\"生活压力\",{\"1\":{\"133\":2}}],[\"生命周期中的自动化机器学习\",{\"1\":{\"70\":1}}],[\"生命周期的每个步骤\",{\"1\":{\"42\":1}}],[\"营销问题\",{\"1\":{\"133\":2}}],[\"威力狈是公认的独立开发者中的牛逼人物\",{\"1\":{\"133\":2}}],[\"财务自由\",{\"1\":{\"133\":2}}],[\"心态\",{\"1\":{\"133\":2}}],[\"增长\",{\"1\":{\"133\":2}}],[\"增强\",{\"1\":{\"84\":1}}],[\"伪需求怎么办\",{\"1\":{\"133\":4}}],[\"别人说你的产品是垃圾\",{\"1\":{\"133\":4}}],[\"发布等环节\",{\"1\":{\"133\":2}}],[\"发布\",{\"1\":{\"133\":4}}],[\"采用什么样的产品形态\",{\"1\":{\"133\":4}}],[\"三点金规铁律\",{\"1\":{\"133\":4}}],[\"三大核心问题\",{\"1\":{\"133\":4}}],[\"三层ip\",{\"1\":{\"124\":1}}],[\"想法可能会发生改变\",{\"1\":{\"133\":2}}],[\"想法是一个产品的起始点\",{\"1\":{\"133\":2}}],[\"想法\",{\"1\":{\"133\":4}}],[\"独立开发和创业一样有风险\",{\"1\":{\"133\":2}}],[\"独立开发的一些基本流程\",{\"1\":{\"133\":4}}],[\"独立开发者\",{\"2\":{\"135\":1}}],[\"独立开发者面临的困境\",{\"1\":{\"133\":4}}],[\"独立开发者一点思考\",{\"0\":{\"133\":1}}],[\"全文总结\",{\"1\":{\"133\":2}}],[\"灵活和可扩展的网络架构\",{\"1\":{\"130\":1}}],[\"完成vxlan包的封装和解封装\",{\"1\":{\"130\":1}}],[\"帧传递\",{\"1\":{\"129\":1}}],[\"帧解封装\",{\"1\":{\"129\":1}}],[\"帧封装\",{\"1\":{\"129\":1}}],[\"学习和维护虚拟网络中mac地址到vtep的映射关系\",{\"1\":{\"128\":1}}],[\"附加上vni\",{\"1\":{\"128\":1}}],[\"封装好的vxlan包通过三层ip网络传输到目的vtep\",{\"1\":{\"129\":1}}],[\"封装和解封装\",{\"1\":{\"128\":1}}],[\"封装层\",{\"1\":{\"124\":1}}],[\"另一个是连接到ip网络的接口\",{\"1\":{\"128\":1}}],[\"隧道端点\",{\"1\":{\"128\":1}}],[\"隧道封装\",{\"1\":{\"127\":1}}],[\"弹性和高可用性\",{\"1\":{\"127\":1}}],[\"远远超过传统vlan的4094个限制\",{\"1\":{\"127\":1}}],[\"较复杂\",{\"1\":{\"124\":1}}],[\"跨数据中心\",{\"1\":{\"124\":1}}],[\"跨多个数据中心的虚拟机迁移和高可用性\",{\"1\":{\"123\":1}}],[\"云环境\",{\"1\":{\"124\":1}}],[\"云原生\",{\"0\":{\"137\":1},\"2\":{\"78\":1,\"88\":1}}],[\"云原生之kubeflow\",{\"1\":{\"42\":1}}],[\"局域网\",{\"1\":{\"124\":1}}],[\"小规模网络\",{\"1\":{\"124\":1}}],[\"二层以太网\",{\"1\":{\"124\":1}}],[\"理论上支持多达1600万个虚拟网络\",{\"1\":{\"123\":1}}],[\"网络\",{\"2\":{\"131\":1}}],[\"网络虚拟化\",{\"1\":{\"123\":1}}],[\"网络设备根据这个id来区分不同的vlan\",{\"1\":{\"122\":1}}],[\"网络分段\",{\"1\":{\"122\":1}}],[\"假设veth1被移动到命名空间ns1\",{\"1\":{\"120\":1}}],[\"假设创建了一个veth设备对\",{\"1\":{\"119\":1}}],[\"<loopback>\",{\"1\":{\"120\":2}}],[\"<broadcast\",{\"1\":{\"119\":2,\"120\":2}}],[\"检查命名空间中的veth设备\",{\"0\":{\"120\":1}}],[\"同样\",{\"1\":{\"117\":1}}],[\"同时\",{\"1\":{\"110\":1}}],[\"同时要保证高可用\",{\"1\":{\"0\":1}}],[\"同时获得锁\",{\"1\":{\"0\":1}}],[\"过滤veth设备\",{\"1\":{\"116\":1}}],[\"该帧首先被发送到本地的vtep\",{\"1\":{\"129\":1}}],[\"该命令会列出系统中所有的网络接口\",{\"1\":{\"116\":1}}],[\"该状态表示\",{\"1\":{\"7\":1,\"8\":1,\"9\":1,\"10\":1}}],[\"列出所有网络接口\",{\"1\":{\"116\":1}}],[\"查看具体veth设备对的详细信息\",{\"0\":{\"118\":1}}],[\"查看系统中已有的veth设备对或确认已创建的veth设备对\",{\"0\":{\"115\":1}}],[\"查看和管理应用程序的标准\",{\"1\":{\"67\":1}}],[\"带来了显著的改进和优化\",{\"1\":{\"114\":1}}],[\"推送\",{\"1\":{\"114\":1}}],[\"推理引擎\",{\"2\":{\"103\":1}}],[\"推理面临预填充阶段注意力延迟长\",{\"1\":{\"101\":1}}],[\"推理中的问题\",{\"1\":{\"100\":1}}],[\"压缩\",{\"1\":{\"114\":1}}],[\"受限于串行化处理和头部阻塞\",{\"1\":{\"114\":1}}],[\"性能\",{\"1\":{\"114\":1}}],[\"性能改进\",{\"0\":{\"113\":1}}],[\"单个连接处理多个并发请求\",{\"1\":{\"114\":1}}],[\"单个tcp连接上可以处理多个并发的请求\",{\"1\":{\"106\":1}}],[\"特别适合在大型数据中心和云环境中使用\",{\"1\":{\"127\":1}}],[\"特性\",{\"1\":{\"114\":1}}],[\"特点\",{\"1\":{\"7\":1,\"8\":1,\"9\":1,\"10\":1,\"124\":1}}],[\"改善了带宽利用\",{\"1\":{\"113\":1}}],[\"显著提升\",{\"1\":{\"114\":1}}],[\"显著降低了延迟\",{\"1\":{\"113\":1}}],[\"显著减少预填充阶段延迟\",{\"1\":{\"101\":1}}],[\"添加新功能可以通过新帧类型和更复杂的协议操作来实现\",{\"1\":{\"112\":1}}],[\"现代浏览器和服务器在实际应用中通常要求\",{\"1\":{\"111\":1}}],[\"尽管协议本身不强制这一点\",{\"1\":{\"111\":1}}],[\"尽量避免将新的\",{\"1\":{\"31\":1}}],[\"所有请求被平等对待\",{\"1\":{\"110\":1}}],[\"优先级和流控制\",{\"0\":{\"110\":1},\"1\":{\"114\":1}}],[\"客户端可以指定不同流的优先级\",{\"1\":{\"110\":1}}],[\"客户端必须明确请求每个资源\",{\"1\":{\"109\":1}}],[\"客户端代码\",{\"1\":{\"55\":1}}],[\"减少了传输数据量\",{\"1\":{\"108\":1}}],[\"减少了人为操作的复杂性和风险\",{\"1\":{\"84\":1}}],[\"导致冗余和带宽浪费\",{\"1\":{\"108\":1}}],[\"才能开始下一个请求\",{\"1\":{\"107\":1}}],[\"需要有心理准备\",{\"1\":{\"133\":2}}],[\"需要重申审视是不是你的产品功能和特性不够\",{\"1\":{\"133\":2}}],[\"需要考虑产品适合使用哪种产品形态\",{\"1\":{\"133\":2}}],[\"需要大致正确即可\",{\"1\":{\"133\":2}}],[\"需要配置隧道端点\",{\"1\":{\"124\":1}}],[\"需要等待当前请求完成后\",{\"1\":{\"107\":1}}],[\"需要手动编辑对应的\",{\"1\":{\"29\":1}}],[\"需要手工处理\",{\"1\":{\"5\":1}}],[\"流之间可以独立并行处理\",{\"1\":{\"106\":1}}],[\"流水线管理\",{\"1\":{\"75\":1}}],[\"流水线服务\",{\"1\":{\"72\":1,\"73\":1}}],[\"响应对在同一连接上的多个流中并发传输\",{\"1\":{\"107\":1}}],[\"响应对在一个单独的流中\",{\"1\":{\"106\":1}}],[\"响应对可以被处理\",{\"1\":{\"107\":1}}],[\"响应对\",{\"1\":{\"106\":1}}],[\"响应对通常需要一个单独的tcp连接\",{\"1\":{\"106\":1}}],[\"串行化处理\",{\"1\":{\"106\":1}}],[\"引入了连接保持\",{\"1\":{\"106\":1}}],[\"引入在线近似方法和优化内核\",{\"1\":{\"101\":1}}],[\"连接管理\",{\"0\":{\"106\":1},\"1\":{\"114\":1}}],[\"旨在提高网络性能和效率\",{\"1\":{\"104\":1}}],[\"协议类型\",{\"1\":{\"114\":1}}],[\"协议扩展性\",{\"0\":{\"112\":1},\"1\":{\"114\":1}}],[\"协议基础\",{\"0\":{\"105\":1}}],[\"协议的重大升级\",{\"1\":{\"104\":1}}],[\"协方差矩阵自适应进化策略\",{\"1\":{\"69\":1}}],[\"x\",{\"1\":{\"104\":1,\"105\":1,\"106\":1,\"107\":1,\"108\":1,\"109\":1,\"110\":1,\"111\":1,\"112\":1,\"113\":1,\"114\":1}}],[\"xgboost\",{\"1\":{\"69\":1}}],[\"计算机网络\",{\"0\":{\"104\":1}}],[\"头部信息仅在第一次请求时完整传输\",{\"1\":{\"108\":1}}],[\"头部压缩和服务器推送等功能\",{\"1\":{\"113\":1}}],[\"头部压缩\",{\"0\":{\"108\":1},\"1\":{\"114\":1}}],[\"头部阻塞问题\",{\"1\":{\"107\":1}}],[\"头部\",{\"1\":{\"101\":1}}],[\"虽慢但仍有显著加速\",{\"1\":{\"101\":1}}],[\"编码\",{\"1\":{\"101\":1}}],[\"编程语言\",{\"0\":{\"91\":1}}],[\"倍\",{\"1\":{\"101\":1}}],[\"加密是可选的\",{\"1\":{\"111\":1}}],[\"加密和安全\",{\"0\":{\"111\":1},\"1\":{\"114\":1}}],[\"加速长上下文\",{\"1\":{\"101\":1}}],[\"加锁\",{\"1\":{\"0\":1}}],[\"离线确定每个头的最佳动态稀疏模式\",{\"1\":{\"101\":1}}],[\"利用动态稀疏注意的静态空间聚合模式\",{\"1\":{\"101\":1}}],[\"应运而生\",{\"1\":{\"101\":1}}],[\"应用场景\",{\"1\":{\"124\":1}}],[\"应用部署和管理\",{\"1\":{\"83\":1}}],[\"应用\",{\"1\":{\"82\":1}}],[\"应用需要自定义的服务发现机制\",{\"1\":{\"34\":1}}],[\"应用程序的配置\",{\"1\":{\"80\":1}}],[\"应用程序的资源标准化和资源优化\",{\"1\":{\"23\":1}}],[\"应用程序使用通用的标签和注释\",{\"1\":{\"67\":1}}],[\"应用程序级别的健康检查\",{\"1\":{\"65\":1}}],[\"应用程序\",{\"0\":{\"64\":1}}],[\"应用程序标准化\",{\"1\":{\"22\":1}}],[\"应用类型\",{\"1\":{\"20\":1}}],[\"缓存存储和传输成本高等挑战\",{\"1\":{\"101\":1}}],[\"长上下文基准测试中的实验结果\",{\"1\":{\"101\":1}}],[\"长上下文\",{\"1\":{\"101\":1}}],[\"重要亮点\",{\"0\":{\"101\":1},\"1\":{\"133\":2}}],[\"重新绑定\",{\"1\":{\"9\":1}}],[\"介绍\",{\"0\":{\"100\":1,\"138\":1}}],[\"论文介绍了一种名为\",{\"1\":{\"100\":1}}],[\"论文\",{\"0\":{\"99\":1}}],[\"地址\",{\"0\":{\"98\":1}}],[\"欢迎联系我\",{\"1\":{\"94\":1}}],[\"追求技术创新\",{\"1\":{\"94\":1}}],[\"乐于接受新挑战\",{\"1\":{\"94\":1}}],[\"前端开发\",{\"0\":{\"94\":1}}],[\"深入理解spring\",{\"1\":{\"92\":1}}],[\"熟练使用vue\",{\"1\":{\"94\":1}}],[\"熟练使用java进行企业级应用开发\",{\"1\":{\"91\":1}}],[\"熟悉哪个就用哪个\",{\"1\":{\"133\":2}}],[\"熟悉element\",{\"1\":{\"94\":1}}],[\"熟悉typescript\",{\"1\":{\"94\":1}}],[\"熟悉redis\",{\"1\":{\"92\":1}}],[\"熟悉容器编排\",{\"1\":{\"92\":1}}],[\"熟悉go语言\",{\"1\":{\"91\":1}}],[\"机器学习以及自动化脚本编写方面有丰富经验\",{\"1\":{\"91\":1}}],[\"机制\",{\"0\":{\"31\":1}}],[\"机制各自监听\",{\"1\":{\"0\":1}}],[\"尤其在数据分析\",{\"1\":{\"91\":1}}],[\"尤其是小文件\",{\"1\":{\"61\":1}}],[\"尤其是在\",{\"1\":{\"25\":1,\"39\":1}}],[\"擅长使用nacos进行服务发现和配置管理\",{\"1\":{\"92\":1}}],[\"擅长底层编程和系统开发\",{\"1\":{\"91\":1}}],[\"擅长构建高性能和可扩展的后端服务\",{\"1\":{\"91\":1}}],[\"精通html\",{\"1\":{\"94\":1}}],[\"精通kubeflow\",{\"1\":{\"93\":1}}],[\"精通关系型数据库设计和优化\",{\"1\":{\"92\":1}}],[\"精通python\",{\"1\":{\"91\":1}}],[\"精通c语言\",{\"1\":{\"91\":1}}],[\"精通spring\",{\"1\":{\"91\":1}}],[\"拥有广泛的编程语言知识和丰富的技术经验\",{\"1\":{\"90\":1}}],[\"大规模数据中心\",{\"1\":{\"124\":1}}],[\"大大超过了vlan的4094个限制\",{\"1\":{\"123\":1}}],[\"大大增强了\",{\"1\":{\"87\":1}}],[\"大多数实现要求加密\",{\"1\":{\"114\":1}}],[\"大多数实现强制要求使用加密\",{\"1\":{\"111\":1}}],[\"大家好\",{\"1\":{\"90\":1}}],[\"个接口\",{\"1\":{\"133\":2}}],[\"个页面和\",{\"1\":{\"133\":2}}],[\"个人\",{\"2\":{\"96\":1}}],[\"个人简介\",{\"1\":{\"90\":1}}],[\"个人介绍\",{\"0\":{\"90\":1},\"2\":{\"95\":1}}],[\"个服务\",{\"1\":{\"75\":1}}],[\"逐步深入理解其背后的原理和应用场景\",{\"1\":{\"87\":1}}],[\"有哪些牛逼的独立开发者\",{\"1\":{\"133\":4}}],[\"有限\",{\"1\":{\"124\":1}}],[\"有头部阻塞问题\",{\"1\":{\"114\":1}}],[\"有效保留或扩展实际上下文窗口处理能力\",{\"1\":{\"101\":1}}],[\"有兴趣\",{\"1\":{\"87\":1}}],[\"有关组件的完整定义\",{\"1\":{\"56\":1}}],[\"有关单个管道运行的执行状态\",{\"1\":{\"52\":1}}],[\"有关单个管道运行的调试信息\",{\"1\":{\"52\":1}}],[\"消息队列\",{\"1\":{\"87\":1}}],[\"扩展性\",{\"1\":{\"123\":1,\"124\":1,\"127\":1}}],[\"扩展复杂\",{\"1\":{\"114\":1}}],[\"扩展和添加新功能变得复杂\",{\"1\":{\"112\":1}}],[\"扩展和管理容器化应用程序\",{\"1\":{\"64\":1}}],[\"扩展\",{\"1\":{\"86\":1}}],[\"语言的开发框架和工具\",{\"1\":{\"86\":1}}],[\"语法调度运行\",{\"1\":{\"59\":1}}],[\"标记帧属于哪个vlan\",{\"1\":{\"122\":1}}],[\"标记帧\",{\"1\":{\"122\":1}}],[\"标准化管理流程\",{\"1\":{\"84\":1}}],[\"标识符\",{\"1\":{\"124\":1}}],[\"标识\",{\"1\":{\"31\":3}}],[\"备份和恢复\",{\"1\":{\"83\":1,\"85\":1}}],[\"备份和故障处理等任务\",{\"1\":{\"80\":1}}],[\"复制等任务都可以通过\",{\"1\":{\"83\":1}}],[\"分布式架构\",{\"1\":{\"123\":1}}],[\"分布式锁\",{\"2\":{\"2\":1}}],[\"分布式锁的三个主要核心要素\",{\"1\":{\"0\":1}}],[\"分布式锁最终是由写入此\",{\"1\":{\"0\":1}}],[\"分片\",{\"1\":{\"83\":1}}],[\"专门用于管理自定义资源\",{\"1\":{\"81\":1}}],[\"专为高效的文件操作和网络操作设计\",{\"1\":{\"60\":1}}],[\"就是一个高级的控制器\",{\"1\":{\"81\":1}}],[\"就可以发布了\",{\"1\":{\"133\":2}}],[\"就可以查看这个图\",{\"1\":{\"58\":1}}],[\"就可以运行\",{\"1\":{\"42\":1}}],[\"结构的机制\",{\"1\":{\"81\":1}}],[\"结合使用\",{\"1\":{\"38\":1}}],[\"升级和扩展\",{\"1\":{\"85\":1}}],[\"升级\",{\"1\":{\"80\":1}}],[\"部署\",{\"1\":{\"80\":1,\"82\":2}}],[\"部署和管理机器学习模型流水线\",{\"1\":{\"93\":1}}],[\"部署和管理\",{\"1\":{\"28\":1}}],[\"原生的\",{\"1\":{\"80\":1}}],[\">请求workflow\",{\"1\":{\"77\":1}}],[\"报告生成\",{\"1\":{\"75\":1}}],[\"报告服务\",{\"1\":{\"72\":1}}],[\"任务管理\",{\"1\":{\"75\":1}}],[\"任务服务\",{\"1\":{\"72\":1}}],[\"反射服务\",{\"1\":{\"74\":1}}],[\"认证服务\",{\"1\":{\"72\":1}}],[\"注册了以下\",{\"1\":{\"75\":1}}],[\"注册了以下服务\",{\"1\":{\"71\":1}}],[\"注册的服务\",{\"0\":{\"72\":1,\"73\":1}}],[\"注意\",{\"1\":{\"59\":1,\"61\":1}}],[\"函数中\",{\"1\":{\"71\":1,\"75\":1}}],[\"丰富的优化算法支持\",{\"1\":{\"70\":1}}],[\"训练框架一起使用\",{\"1\":{\"70\":1}}],[\"此外\",{\"1\":{\"70\":1}}],[\"集成\",{\"1\":{\"70\":3}}],[\"集群的部署\",{\"1\":{\"85\":1}}],[\"集群的部署和管理\",{\"1\":{\"85\":1}}],[\"集群启动和恢复\",{\"1\":{\"28\":1}}],[\"集群中的服务和控制器进行通信和协调\",{\"1\":{\"61\":1}}],[\"集群中的各种控制器\",{\"1\":{\"61\":1}}],[\"集群中的控制器\",{\"1\":{\"61\":1}}],[\"集群中提供强大的资源管理能力\",{\"1\":{\"23\":1}}],[\"集群中\",{\"1\":{\"12\":1}}],[\"解封装的以太网帧被发送到目标主机b所在的二层网络\",{\"1\":{\"129\":1}}],[\"解封装出原始的以太网帧\",{\"1\":{\"129\":1}}],[\"解决了\",{\"1\":{\"70\":1}}],[\"解析\",{\"1\":{\"33\":1}}],[\"更容易扩展\",{\"1\":{\"112\":1,\"114\":1}}],[\"更高效地解析和传输数据\",{\"1\":{\"105\":1}}],[\"更多算法支持即将推出\",{\"1\":{\"69\":1}}],[\"更新\",{\"1\":{\"29\":1}}],[\"随机搜索\",{\"1\":{\"69\":1}}],[\"帕尔森估计树\",{\"1\":{\"69\":1}}],[\"算法对头部进行压缩\",{\"1\":{\"108\":1}}],[\"算法\",{\"1\":{\"69\":1}}],[\"框架\",{\"1\":{\"69\":1}}],[\"框架无关的项目\",{\"1\":{\"69\":1}}],[\"信息\",{\"1\":{\"69\":1}}],[\"项目是开源的\",{\"1\":{\"69\":1}}],[\"项目\",{\"1\":{\"69\":1}}],[\"项目致力于让机器学习\",{\"1\":{\"42\":1}}],[\"什么是独立开发者\",{\"1\":{\"133\":2}}],[\"什么是\",{\"0\":{\"69\":1},\"1\":{\"80\":1}}],[\"非目标\",{\"0\":{\"68\":1}}],[\"促进\",{\"1\":{\"67\":1}}],[\"促进生态系统工具和\",{\"1\":{\"67\":1}}],[\"展示三种注意力模式和\",{\"1\":{\"101\":1}}],[\"展示基本的健康检查\",{\"1\":{\"67\":1}}],[\"展示自定义资源定义\",{\"1\":{\"61\":1}}],[\"交互的\",{\"1\":{\"67\":1}}],[\"希望可视化应用程序\",{\"1\":{\"66\":1}}],[\"希望以应用程序为中心进行操作的应用程序运营商\",{\"1\":{\"66\":1}}],[\"像\",{\"1\":{\"66\":1}}],[\"帮助它们查询和理解支持应用程序的对象\",{\"1\":{\"65\":1}}],[\"很有用\",{\"1\":{\"65\":1}}],[\"即垃圾回收\",{\"1\":{\"65\":1}}],[\"然而\",{\"1\":{\"64\":1}}],[\"然后把这个页面推广出去\",{\"1\":{\"133\":2}}],[\"然后保存相关数据\",{\"1\":{\"77\":1}}],[\"然后\",{\"1\":{\"57\":1,\"119\":1}}],[\"然后通过ip网络发送到目标vtep\",{\"1\":{\"128\":1}}],[\"然后通过\",{\"1\":{\"0\":1}}],[\"官网地址\",{\"0\":{\"63\":1}}],[\"总体而言\",{\"1\":{\"61\":1}}],[\"总结\",{\"0\":{\"39\":1,\"75\":1,\"87\":1,\"114\":1,\"125\":1,\"130\":1}}],[\"形成完整的机器学习工作流管理平台\",{\"1\":{\"61\":1}}],[\"核心组件\",{\"1\":{\"61\":1}}],[\"支持负载均衡和高可用性\",{\"1\":{\"127\":1}}],[\"支持多达1600万个虚拟网络\",{\"1\":{\"124\":1,\"127\":1}}],[\"支持多租户环境\",{\"1\":{\"123\":1}}],[\"支持多种\",{\"1\":{\"69\":1}}],[\"支持跨多个物理位置的虚拟机迁移和负载均衡\",{\"1\":{\"123\":1}}],[\"支持流的优先级\",{\"1\":{\"110\":1}}],[\"支持服务器推送功能\",{\"1\":{\"109\":1}}],[\"支持超参数调优\",{\"1\":{\"69\":1}}],[\"支持\",{\"1\":{\"61\":1,\"114\":3}}],[\"支持其他工作流执行器\",{\"1\":{\"61\":1}}],[\"共同提供了一个功能强大的机器学习工作流管理平台\",{\"1\":{\"61\":1}}],[\"共同实现超参数调优功能\",{\"1\":{\"61\":1}}],[\"共识算法实现的\",{\"1\":{\"0\":1}}],[\"监控和优化\",{\"1\":{\"61\":1}}],[\"监控和管理\",{\"0\":{\"29\":1}}],[\"平台\",{\"1\":{\"61\":1}}],[\"组成了\",{\"1\":{\"61\":1}}],[\"组件紧密合作\",{\"1\":{\"61\":1}}],[\"组件可以在循环中多次执行\",{\"1\":{\"59\":1}}],[\"组件不会在同一进程中运行\",{\"1\":{\"57\":1}}],[\"组件代表容器内的特定程序或入口点\",{\"1\":{\"57\":1}}],[\"组件代码\",{\"0\":{\"55\":1}}],[\"组件定义包括以下部分\",{\"1\":{\"56\":1}}],[\"组件定义\",{\"0\":{\"56\":1}}],[\"组件类似于函数\",{\"1\":{\"54\":1}}],[\"组件是一个独立的代码集\",{\"1\":{\"54\":1}}],[\"组件\",{\"1\":{\"42\":1,\"53\":1,\"61\":2}}],[\"视图\",{\"1\":{\"61\":1}}],[\"视图和大规模指标\",{\"1\":{\"50\":1}}],[\"持久化代理\",{\"1\":{\"61\":1}}],[\"负责隧道的端点操作\",{\"1\":{\"130\":1}}],[\"负责vxlan包的封装和解封装\",{\"1\":{\"128\":1}}],[\"负责vxlan隧道的端点操作\",{\"1\":{\"128\":1}}],[\"负责机器学习工作流的定义\",{\"1\":{\"61\":1}}],[\"负责将元数据写入到持久化存储中\",{\"1\":{\"61\":1}}],[\"负责将元数据写入到存储后端\",{\"1\":{\"61\":1}}],[\"负责调度和执行\",{\"1\":{\"61\":1}}],[\"负责管理和执行工作流任务\",{\"1\":{\"61\":2}}],[\"负责管理和调度超参数搜索任务\",{\"1\":{\"61\":1}}],[\"负责管理\",{\"1\":{\"61\":4}}],[\"服务器可以主动推送相关的css和javascript文件\",{\"1\":{\"109\":1}}],[\"服务器可以在客户端请求之前主动发送资源\",{\"1\":{\"109\":1}}],[\"服务器只能响应客户端的请求\",{\"1\":{\"109\":1}}],[\"服务器推送\",{\"0\":{\"109\":1},\"1\":{\"114\":1}}],[\"服务一起用于\",{\"1\":{\"61\":1}}],[\"服务\",{\"1\":{\"61\":1}}],[\"超参数调优工具\",{\"1\":{\"61\":1}}],[\"等工具创建和管理自定义资源\",{\"1\":{\"82\":1}}],[\"等等\",{\"1\":{\"69\":1}}],[\"等\",{\"1\":{\"61\":1,\"69\":1}}],[\"等信息\",{\"1\":{\"0\":1}}],[\"9\",{\"0\":{\"113\":1},\"1\":{\"133\":4}}],[\"9bzwq\",{\"1\":{\"61\":2}}],[\"92g5h\",{\"1\":{\"61\":2}}],[\"9956596d8\",{\"1\":{\"61\":2}}],[\"9999\",{\"1\":{\"31\":1}}],[\"qlen\",{\"1\":{\"119\":2,\"120\":4}}],[\"qdisc\",{\"1\":{\"119\":2,\"120\":4}}],[\"q9ddn\",{\"1\":{\"61\":2}}],[\"quota\",{\"1\":{\"15\":1}}],[\"64\",{\"1\":{\"120\":1}}],[\"65536\",{\"1\":{\"120\":2}}],[\"65j6h\",{\"1\":{\"61\":2}}],[\"6\",{\"0\":{\"110\":1}}],[\"6c686b5b54\",{\"1\":{\"61\":2}}],[\"66457c4745\",{\"1\":{\"61\":2}}],[\"61\",{\"1\":{\"61\":1}}],[\"7e\",{\"1\":{\"120\":2}}],[\"7\",{\"0\":{\"111\":1}}],[\"799c5f4b48\",{\"1\":{\"61\":2}}],[\"7cc7c5b47\",{\"1\":{\"61\":2}}],[\"7c6vk\",{\"1\":{\"61\":2}}],[\"77d684cf4\",{\"1\":{\"61\":2}}],[\"7d7dffdb8f\",{\"1\":{\"61\":2}}],[\"78d9bcc678\",{\"1\":{\"61\":2}}],[\"b6\",{\"1\":{\"120\":2}}],[\"brd\",{\"1\":{\"120\":4}}],[\"branch\",{\"1\":{\"62\":1}}],[\"boot\",{\"1\":{\"92\":1}}],[\"boot框架\",{\"1\":{\"91\":1,\"92\":1}}],[\"bound\",{\"1\":{\"11\":1,\"12\":1}}],[\"baye\",{\"1\":{\"133\":2}}],[\"bayesian\",{\"1\":{\"69\":1}}],[\"backend\",{\"1\":{\"61\":2}}],[\"built\",{\"1\":{\"62\":1}}],[\"bgwtr\",{\"1\":{\"61\":2}}],[\"~\",{\"1\":{\"61\":1}}],[\"yigou\",{\"1\":{\"61\":1}}],[\"yaml\",{\"1\":{\"15\":1,\"20\":1,\"26\":1,\"27\":3,\"29\":1,\"35\":1,\"46\":1,\"56\":1}}],[\"团队仅推荐在\",{\"1\":{\"61\":1}}],[\"那么\",{\"1\":{\"61\":1}}],[\"选择\",{\"1\":{\"61\":3}}],[\"选择合适的工作流执行器取决于工作流的具体需求和集群环境\",{\"1\":{\"61\":1}}],[\"默认的\",{\"1\":{\"61\":1}}],[\"默认选择\",{\"1\":{\"61\":1}}],[\"默认值等\",{\"1\":{\"56\":1}}],[\"配置复杂度\",{\"1\":{\"124\":1}}],[\"配置简单\",{\"1\":{\"122\":1}}],[\"配置\",{\"1\":{\"85\":1}}],[\"配置中可能不适用\",{\"1\":{\"60\":1}}],[\"配置示例\",{\"0\":{\"15\":1,\"20\":1},\"1\":{\"15\":1,\"20\":1}}],[\"守护进程交互来管理容器\",{\"1\":{\"60\":1}}],[\"正式发布以来\",{\"1\":{\"60\":1}}],[\"正常启动\",{\"1\":{\"28\":1}}],[\"月\",{\"1\":{\"60\":1}}],[\"年\",{\"1\":{\"60\":1}}],[\"执行器之间进行选择\",{\"1\":{\"61\":1}}],[\"执行器和\",{\"1\":{\"61\":1}}],[\"执行器一直是\",{\"1\":{\"60\":1}}],[\"执行和监控容器\",{\"1\":{\"60\":1}}],[\"执行实际作业的代码\",{\"1\":{\"55\":1}}],[\"收集工件\",{\"1\":{\"59\":1}}],[\"日志\",{\"1\":{\"59\":1}}],[\"日志查看\",{\"1\":{\"29\":1}}],[\"能够快速开发美观且实用的前端界面\",{\"1\":{\"94\":1}}],[\"能够快速开发和部署企业级应用\",{\"1\":{\"92\":1}}],[\"能够设计和实现网页结构\",{\"1\":{\"94\":1}}],[\"能够编写高质量的可维护代码\",{\"1\":{\"94\":1}}],[\"能够创建动态和响应式的用户界面\",{\"1\":{\"94\":1}}],[\"能够构建\",{\"1\":{\"93\":1}}],[\"能够利用其高性能特性进行缓存和存储操作\",{\"1\":{\"92\":1}}],[\"能够利用其高并发和高性能特点开发后端服务\",{\"1\":{\"91\":1}}],[\"能够使用kubernetes进行微服务管理和部署\",{\"1\":{\"92\":1}}],[\"能够开发高效的系统级应用程序\",{\"1\":{\"91\":1}}],[\"能够将人类操作员的经验和最佳实践转化为自动化的操作流程\",{\"1\":{\"87\":1}}],[\"能够显示应用程序的指标\",{\"1\":{\"68\":1}}],[\"能够执行某些操作\",{\"1\":{\"59\":1}}],[\"能理解并呈现为丰富的可视化内容\",{\"1\":{\"59\":1}}],[\"入门指南\",{\"1\":{\"59\":1}}],[\"了解更多\",{\"1\":{\"69\":1}}],[\"了解更多信息\",{\"1\":{\"59\":1}}],[\"了解这些状态有助于掌握\",{\"1\":{\"6\":1}}],[\"转向使用\",{\"1\":{\"59\":1}}],[\"转换为字符串或文件\",{\"1\":{\"57\":1}}],[\"快速决策或不同运行间的比较\",{\"1\":{\"59\":1}}],[\"类似子句后有条件地执行\",{\"1\":{\"59\":1}}],[\"类似于运行与其管道之间的关系\",{\"1\":{\"59\":1}}],[\"类型\",{\"1\":{\"56\":1}}],[\"步骤中的超参数优化或神经架构搜索问题\",{\"1\":{\"70\":1}}],[\"步骤与其组件之间的关系是一种实例化关系\",{\"1\":{\"59\":1}}],[\"步骤\",{\"1\":{\"59\":1}}],[\"每2小时或每45分钟\",{\"1\":{\"59\":1}}],[\"每个vtep有两个主要接口\",{\"1\":{\"128\":1}}],[\"每个vlan都有一个唯一的vlan\",{\"1\":{\"122\":1}}],[\"每个虚拟网络可以有自己的vni\",{\"1\":{\"127\":1}}],[\"每个租户可以有独立的虚拟网络\",{\"1\":{\"123\":1}}],[\"每个请求通常需要一个tcp连接\",{\"1\":{\"114\":1}}],[\"每个请求都需要发送完整的头部信息\",{\"1\":{\"108\":1}}],[\"每个请求\",{\"1\":{\"106\":2}}],[\"每个节点的右上角有一个图标\",{\"1\":{\"58\":1}}],[\"每个组件的代码包括以下部分\",{\"1\":{\"55\":1}}],[\"每个\",{\"1\":{\"31\":1,\"33\":1,\"38\":1}}],[\"基于隧道\",{\"1\":{\"123\":1}}],[\"基于二进制\",{\"1\":{\"114\":1}}],[\"基于二进制的协议\",{\"1\":{\"105\":1}}],[\"基于纯文本\",{\"1\":{\"114\":1}}],[\"基于纯文本的协议\",{\"1\":{\"105\":1}}],[\"基于检索等一系列任务中测试\",{\"1\":{\"101\":1}}],[\"基于\",{\"1\":{\"60\":1}}],[\"基于时间间隔调度运行\",{\"1\":{\"59\":1}}],[\"基于主备异步复制导致锁的安全性问题\",{\"1\":{\"0\":1}}],[\"周期性\",{\"1\":{\"59\":1}}],[\"禁用定期运行\",{\"1\":{\"59\":1}}],[\"启用\",{\"1\":{\"59\":1}}],[\"js进行前端开发\",{\"1\":{\"94\":1}}],[\"json\",{\"1\":{\"26\":1}}],[\"java\",{\"1\":{\"91\":1}}],[\"jobservice\",{\"1\":{\"72\":1,\"75\":1}}],[\"job\",{\"1\":{\"59\":1}}],[\"定时工作流\",{\"1\":{\"61\":1}}],[\"定期运行服务\",{\"1\":{\"73\":1}}],[\"定期运行的配置包括指定所有参数值的管道副本和运行触发器\",{\"1\":{\"59\":1}}],[\"定期运行\",{\"1\":{\"59\":1}}],[\"定义\",{\"0\":{\"37\":1,\"38\":1},\"1\":{\"82\":1}}],[\"定义示例\",{\"1\":{\"35\":1}}],[\"定义的\",{\"1\":{\"27\":1}}],[\"定义文件\",{\"1\":{\"26\":1}}],[\"定义了资源的\",{\"1\":{\"82\":1}}],[\"定义了资源的硬性限制\",{\"1\":{\"16\":1}}],[\"定义了容器没有指定资源请求时的默认请求值\",{\"1\":{\"21\":1}}],[\"定义了容器没有指定资源请求和限制时的默认值\",{\"1\":{\"21\":1}}],[\"定义了单个容器必须请求的最小资源量\",{\"1\":{\"21\":1}}],[\"定义了单个容器可以请求的最大资源量\",{\"1\":{\"21\":1}}],[\"设计为自包含的\",{\"1\":{\"59\":1}}],[\"设置资源使用的默认值和最大\",{\"1\":{\"23\":1}}],[\"设置默认资源限制\",{\"1\":{\"19\":1}}],[\"节点可能会被跳过\",{\"1\":{\"58\":1}}],[\"节点设置taint\",{\"1\":{\"31\":1}}],[\"失败\",{\"1\":{\"58\":1}}],[\"指的是一类独立的\",{\"1\":{\"133\":2}}],[\"指示其状态\",{\"1\":{\"58\":1}}],[\"指定了限制适用于\",{\"1\":{\"21\":1}}],[\"指定了\",{\"1\":{\"16\":1}}],[\"运行管理\",{\"1\":{\"75\":1}}],[\"运行服务\",{\"1\":{\"72\":1,\"73\":1}}],[\"运行一个像\",{\"1\":{\"65\":1}}],[\"运行一开始\",{\"1\":{\"58\":1}}],[\"运行\",{\"1\":{\"61\":1,\"70\":1}}],[\"运行和监控\",{\"1\":{\"61\":1}}],[\"运行和监控机器学习工作流\",{\"1\":{\"61\":1}}],[\"运行和监控功能\",{\"1\":{\"61\":1}}],[\"运行时信息包括任务的状态\",{\"1\":{\"59\":1}}],[\"运行时代码\",{\"1\":{\"55\":1}}],[\"运行触发器是一个标志\",{\"1\":{\"59\":1}}],[\"运行包含你尝试的所有实验的不可变日志\",{\"1\":{\"59\":1}}],[\"运行中\",{\"1\":{\"58\":1}}],[\"子关系\",{\"1\":{\"58\":1}}],[\"箭头指示了管道组件之间的父\",{\"1\":{\"58\":1}}],[\"图中的每个节点对应管道中的一个步骤\",{\"1\":{\"58\":1}}],[\"图显示了管道运行已执行或正在执行的步骤\",{\"1\":{\"58\":1}}],[\"图\",{\"1\":{\"58\":1}}],[\"必须反序列化这些数据以供下游组件使用\",{\"1\":{\"57\":1}}],[\"镜像\",{\"1\":{\"57\":1}}],[\"请访问\",{\"1\":{\"69\":1}}],[\"请参阅\",{\"1\":{\"59\":1}}],[\"请参见组件规范\",{\"1\":{\"56\":1}}],[\"请求apiserver\",{\"1\":{\"77\":1}}],[\"请求\",{\"1\":{\"20\":1,\"128\":1}}],[\"请求量\",{\"1\":{\"20\":1}}],[\"请求总量\",{\"1\":{\"15\":1}}],[\"请求匹配\",{\"1\":{\"11\":1}}],[\"实现自己的想法等\",{\"1\":{\"133\":2}}],[\"实现了大规模的数据中心和云环境中的网络虚拟化和扩展\",{\"1\":{\"130\":1}}],[\"实现百万级标记提示的可接受延迟\",{\"1\":{\"101\":1}}],[\"实现控制器\",{\"1\":{\"82\":1}}],[\"实现互操作\",{\"1\":{\"66\":1}}],[\"实现部分还描述了组件完成运行后如何获取输出值\",{\"1\":{\"56\":1}}],[\"实现\",{\"1\":{\"56\":1,\"67\":1}}],[\"实验服务\",{\"1\":{\"72\":1,\"73\":1}}],[\"实验可以包含任意的运行\",{\"1\":{\"59\":1}}],[\"实验是一个工作空间\",{\"1\":{\"59\":1}}],[\"实验\",{\"1\":{\"50\":1}}],[\"接口进行通信\",{\"1\":{\"61\":1}}],[\"接口\",{\"1\":{\"56\":1,\"61\":1}}],[\"元数据写入器\",{\"1\":{\"61\":1}}],[\"元数据服务\",{\"1\":{\"61\":2}}],[\"元数据\",{\"1\":{\"56\":1,\"61\":1}}],[\"用户并不知道自己需要什么\",{\"1\":{\"133\":2}}],[\"用户可以使用\",{\"1\":{\"82\":1}}],[\"用户可以创建和管理新的自定义资源\",{\"1\":{\"81\":1}}],[\"用户可以利用\",{\"1\":{\"70\":1}}],[\"用户可以根据具体需求和工作流特点选择合适的\",{\"1\":{\"61\":1}}],[\"用户甚至可以使用\",{\"1\":{\"70\":1}}],[\"用户界面\",{\"1\":{\"61\":6}}],[\"用户需要选择一个工作流执行器\",{\"1\":{\"59\":1}}],[\"用\",{\"1\":{\"56\":1}}],[\"用于解决长上下文\",{\"1\":{\"100\":1}}],[\"用于生成和管理\",{\"1\":{\"86\":1}}],[\"用于简化\",{\"1\":{\"85\":1}}],[\"用于定义\",{\"1\":{\"81\":1}}],[\"用于自动化部署\",{\"1\":{\"64\":1}}],[\"用于自定义\",{\"1\":{\"61\":1}}],[\"用于管理元数据\",{\"1\":{\"61\":1}}],[\"用于支持机器学习工作流的定义\",{\"1\":{\"61\":1}}],[\"用于展示机器学习工作流的执行状态和结果\",{\"1\":{\"61\":1}}],[\"用于创建\",{\"1\":{\"61\":1}}],[\"用于查看和监控超参数调优任务的状态和结果\",{\"1\":{\"61\":1}}],[\"用于告知系统何时生成新的定期运行配置\",{\"1\":{\"59\":1}}],[\"用于限制\",{\"1\":{\"30\":2}}],[\"用于确保关键组件的高可用性和独立性\",{\"1\":{\"29\":1}}],[\"用于表示集群中持久化存储的详细信息和状态\",{\"1\":{\"6\":1}}],[\"程序包含客户端代码\",{\"1\":{\"55\":1}}],[\"代码\",{\"1\":{\"55\":1}}],[\"返回值和主体\",{\"1\":{\"54\":1}}],[\"模型训练等\",{\"1\":{\"54\":1}}],[\"udp包的源ip和目的ip是vtep的ip地址\",{\"1\":{\"129\":1}}],[\"udp隧道封装\",{\"1\":{\"124\":1}}],[\"up>\",{\"1\":{\"119\":2,\"120\":2}}],[\"up\",{\"1\":{\"119\":2,\"120\":4}}],[\"ui库\",{\"1\":{\"94\":1}}],[\"ui\",{\"1\":{\"53\":1,\"58\":1,\"59\":3,\"61\":6,\"67\":2,\"68\":1,\"94\":1}}],[\"unknown\",{\"1\":{\"119\":2}}],[\"universal\",{\"1\":{\"86\":1}}],[\"untolerated\",{\"1\":{\"31\":1}}],[\"unreachable\",{\"1\":{\"31\":1}}],[\"unlock\",{\"1\":{\"0\":3}}],[\"容器来执行超参数调优任务\",{\"1\":{\"70\":1}}],[\"容器化组件\",{\"0\":{\"57\":1}}],[\"容器\",{\"1\":{\"53\":1}}],[\"容器的默认内存请求\",{\"1\":{\"20\":1}}],[\"容器的默认内存请求量\",{\"1\":{\"20\":1}}],[\"容器的默认\",{\"1\":{\"20\":2}}],[\"容器的最小内存使用量\",{\"1\":{\"20\":1}}],[\"容器的最小\",{\"1\":{\"20\":1}}],[\"容器的最大内存使用量\",{\"1\":{\"20\":1}}],[\"容器的最大\",{\"1\":{\"20\":1}}],[\"参数\",{\"1\":{\"53\":1,\"54\":1}}],[\"数据中心和云环境中的大规模虚拟化网络\",{\"1\":{\"123\":1}}],[\"数据库的创建\",{\"1\":{\"85\":1}}],[\"数据库集群的创建\",{\"1\":{\"83\":1}}],[\"数据库管理器\",{\"1\":{\"61\":1}}],[\"数据可视化和认证功能\",{\"1\":{\"75\":1}}],[\"数据可能仍然存在于\",{\"1\":{\"9\":1}}],[\"数据的数据库\",{\"1\":{\"61\":1}}],[\"数据转换\",{\"1\":{\"54\":1}}],[\"数据工件列表\",{\"1\":{\"52\":1}}],[\"输出可能类似于\",{\"1\":{\"119\":1}}],[\"输出工件\",{\"1\":{\"59\":1}}],[\"输出工件和每个步骤的日志\",{\"1\":{\"59\":1}}],[\"输出规范\",{\"1\":{\"56\":1}}],[\"输出包括容器参数或数据工件uri\",{\"1\":{\"51\":1}}],[\"输入\",{\"1\":{\"51\":1,\"56\":1}}],[\"度量数据被聚合用于排序和过滤\",{\"1\":{\"50\":1}}],[\"一周的时间足够开发一个新产品\",{\"1\":{\"133\":2}}],[\"一周开发一个新产品\",{\"1\":{\"133\":4}}],[\"一次运行\",{\"1\":{\"59\":1}}],[\"一组编排控制器执行完成管道所需的容器\",{\"1\":{\"49\":1}}],[\"一个是连接到传统二层网络的接口\",{\"1\":{\"128\":1}}],[\"一个流行的工具包\",{\"1\":{\"86\":1}}],[\"一个连接基础设施\",{\"1\":{\"65\":1}}],[\"一个示例控制器是argo\",{\"1\":{\"49\":1}}],[\"一个\",{\"1\":{\"11\":1,\"133\":4}}],[\"一个写请求需要经过集群多数节点确认\",{\"1\":{\"0\":1}}],[\"调度和执行定时任务\",{\"1\":{\"61\":1}}],[\"调度到特定节点上\",{\"1\":{\"31\":1}}],[\"调度到这个节点上\",{\"1\":{\"31\":1}}],[\"调用管道服务以从静态配置创建管道运行\",{\"1\":{\"47\":1}}],[\"系统中的组件\",{\"1\":{\"56\":1}}],[\"系统会启动一个或多个\",{\"1\":{\"53\":1}}],[\"系统组件的平台\",{\"1\":{\"43\":1}}],[\"系统部署到各种环境以进行开发\",{\"1\":{\"42\":1}}],[\"作为二进制协议\",{\"1\":{\"112\":1}}],[\"作为工作流引擎\",{\"1\":{\"59\":1}}],[\"作为元数据依赖\",{\"1\":{\"59\":1}}],[\"作为在\",{\"1\":{\"43\":1}}],[\"作业管理\",{\"1\":{\"75\":1}}],[\"作业服务\",{\"1\":{\"72\":1}}],[\"作业的代码\",{\"1\":{\"55\":1}}],[\"作业\",{\"1\":{\"50\":1}}],[\"作用\",{\"0\":{\"14\":1,\"19\":1}}],[\"概念概述\",{\"0\":{\"43\":1}}],[\"工件的可用性\",{\"1\":{\"59\":1}}],[\"工件可以是简单的文本数据视图\",{\"1\":{\"59\":1}}],[\"工件还使得理解管道各个组件的工作方式成为可能\",{\"1\":{\"59\":1}}],[\"工作流控制器\",{\"1\":{\"61\":2}}],[\"工作流执行器\",{\"1\":{\"61\":1}}],[\"工作流执行器类型包括\",{\"0\":{\"60\":1}}],[\"工作流执行器是一个符合特定接口的进程\",{\"1\":{\"59\":1}}],[\"工作流\",{\"1\":{\"54\":1}}],[\"工作流的描述\",{\"1\":{\"53\":1}}],[\"工作流在\",{\"1\":{\"42\":1}}],[\"工具包\",{\"1\":{\"43\":1}}],[\"工程师和运营团队\",{\"1\":{\"42\":1}}],[\"测试和生产级服务的\",{\"1\":{\"42\":1}}],[\"管道中的每个组件独立执行\",{\"1\":{\"57\":1}}],[\"管道\",{\"1\":{\"53\":1,\"54\":1}}],[\"管道配置包括运行管道所需的输入\",{\"1\":{\"53\":1}}],[\"管道是对机器学习\",{\"1\":{\"53\":1}}],[\"管道执行历史记录\",{\"1\":{\"52\":1}}],[\"管道web服务器从各种服务中收集数据以显示相关视图\",{\"1\":{\"52\":1}}],[\"管道持久性代理记录已执行的容器集合及其输入和输出\",{\"1\":{\"51\":1}}],[\"管道持久性代理监视管道服务创建的kubernetes资源\",{\"1\":{\"51\":1}}],[\"管道包\",{\"1\":{\"50\":1}}],[\"管道运行和单个标量指标\",{\"1\":{\"50\":1}}],[\"管道服务调用kubernetes\",{\"1\":{\"48\":1}}],[\"管道的执行过程如下\",{\"1\":{\"44\":1}}],[\"管道的数据科学家的平台\",{\"1\":{\"42\":1}}],[\"管理和协调工作流的各个部分\",{\"1\":{\"61\":1}}],[\"管理和调度超参数调优任务\",{\"1\":{\"61\":1}}],[\"管理工作流的持久化存储\",{\"1\":{\"61\":1}}],[\"管理存储\",{\"1\":{\"61\":1}}],[\"管理容器生命周期等\",{\"1\":{\"59\":1}}],[\"管理\",{\"1\":{\"26\":1,\"80\":1,\"85\":1}}],[\"管理员可以更好地管理和监控资源使用情况\",{\"1\":{\"14\":1}}],[\"管理员可以手动将\",{\"1\":{\"11\":1}}],[\"涵盖\",{\"1\":{\"42\":1}}],[\"下图展示了\",{\"1\":{\"43\":1}}],[\"下图展示了主要的\",{\"1\":{\"42\":1}}],[\"下面是每个\",{\"1\":{\"61\":1}}],[\"下面是对\",{\"1\":{\"32\":1}}],[\"下面最早创建的一个\",{\"1\":{\"0\":1}}],[\"只需要在交换机上配置相关的端口或接口即可\",{\"1\":{\"122\":1}}],[\"只有一个请求\",{\"1\":{\"107\":1}}],[\"只要能够收集优化指标\",{\"1\":{\"70\":1}}],[\"只要您运行\",{\"1\":{\"42\":1}}],[\"只读权限\",{\"1\":{\"4\":1}}],[\"开源技术\",{\"0\":{\"97\":1},\"2\":{\"102\":1}}],[\"开源系统部署到各种基础设施中\",{\"1\":{\"42\":1}}],[\"开发\",{\"0\":{\"86\":1},\"1\":{\"133\":2}}],[\"开发者首先需要定义\",{\"1\":{\"82\":1}}],[\"开发者指南是希望为该项目做出贡献的开发者的良好起点\",{\"1\":{\"69\":1}}],[\"开发完成管道后\",{\"1\":{\"53\":1}}],[\"开发与测试环境\",{\"1\":{\"22\":1}}],[\"开发环境中的资源限制\",{\"1\":{\"23\":1}}],[\"开发环境\",{\"1\":{\"17\":1}}],[\"将独立开发当作\",{\"1\":{\"133\":2}}],[\"将二层以太网帧封装在三层ip包中\",{\"1\":{\"123\":1}}],[\"将动态稀疏注意力分为三种模式并设计搜索算法\",{\"1\":{\"101\":1}}],[\"将\",{\"1\":{\"84\":1}}],[\"将原始数据转换为预处理数据的\",{\"1\":{\"55\":1}}],[\"将最佳的\",{\"1\":{\"42\":1}}],[\"将上述\",{\"1\":{\"27\":1}}],[\"而vxlan适用于大规模数据中心和云环境中的网络虚拟化和扩展\",{\"1\":{\"125\":1}}],[\"而容器则会启动你的程序\",{\"1\":{\"53\":1}}],[\"而是提供一种简单的方法\",{\"1\":{\"42\":1}}],[\"而不影响现有的功能\",{\"1\":{\"112\":1}}],[\"而不是应用程序本身\",{\"1\":{\"64\":1}}],[\"而不是\",{\"1\":{\"34\":1}}],[\"而不是通过负载均衡器来访问\",{\"1\":{\"33\":1}}],[\"而不是通过\",{\"1\":{\"25\":1}}],[\"而不依赖于\",{\"1\":{\"28\":1}}],[\"我致力于不断提升自己的技术水平和解决实际问题的能力\",{\"1\":{\"94\":1}}],[\"我是一名全栈开发工程师\",{\"1\":{\"90\":1}}],[\"我们的目标不是重新创建其他服务\",{\"1\":{\"42\":1}}],[\"我才能有机会\",{\"1\":{\"0\":1}}],[\"of\",{\"1\":{\"69\":1}}],[\"one\",{\"1\":{\"133\":1}}],[\"on\",{\"1\":{\"62\":1}}],[\"output\",{\"1\":{\"59\":1}}],[\"org\",{\"1\":{\"42\":1}}],[\"optuna\",{\"1\":{\"70\":1}}],[\"optimization\",{\"1\":{\"69\":1}}],[\"op=exists\",{\"1\":{\"31\":2}}],[\"operator\",{\"0\":{\"80\":1,\"81\":1,\"82\":1,\"83\":1,\"84\":1,\"85\":1,\"86\":1},\"1\":{\"31\":1,\"70\":1,\"80\":3,\"81\":1,\"82\":3,\"83\":5,\"84\":3,\"85\":3,\"86\":4,\"87\":4},\"2\":{\"89\":1}}],[\"笔记\",{\"2\":{\"41\":1}}],[\"笔记总结\",{\"1\":{\"3\":1}}],[\"示例\",{\"0\":{\"119\":1},\"1\":{\"36\":1}}],[\"端口\",{\"1\":{\"35\":1}}],[\"端口转发到\",{\"1\":{\"35\":1}}],[\"名称\",{\"1\":{\"33\":1,\"38\":1,\"56\":2}}],[\"名称直接访问特定的\",{\"1\":{\"33\":1}}],[\"都可以帮助实现高效的运维管理\",{\"1\":{\"87\":1}}],[\"都集中在容器基础设施上\",{\"1\":{\"64\":1}}],[\"都有一个稳定的\",{\"1\":{\"33\":1,\"38\":1}}],[\"都不会出现死锁\",{\"1\":{\"0\":1}}],[\"对比\",{\"0\":{\"124\":1}}],[\"对应于工作流\",{\"1\":{\"53\":1}}],[\"对于一个中等水平的技术人员来说\",{\"1\":{\"133\":2}}],[\"对于名为\",{\"1\":{\"55\":1}}],[\"对于\",{\"1\":{\"33\":1}}],[\"对象和可视化\",{\"1\":{\"64\":1}}],[\"对象的\",{\"1\":{\"0\":2}}],[\"对象\",{\"1\":{\"0\":1}}],[\"对象后\",{\"1\":{\"0\":1}}],[\"记录\",{\"1\":{\"33\":1,\"39\":1}}],[\"d2\",{\"1\":{\"120\":2}}],[\"down\",{\"1\":{\"120\":2}}],[\"dockerfile\",{\"1\":{\"61\":1}}],[\"dockerexecutor\",{\"1\":{\"60\":1,\"61\":2}}],[\"docker\",{\"1\":{\"53\":1,\"57\":1,\"60\":2,\"61\":3}}],[\"docs\",{\"1\":{\"42\":1}}],[\"differentiable\",{\"1\":{\"69\":1}}],[\"dashboards\",{\"1\":{\"66\":1}}],[\"dashboard\",{\"1\":{\"64\":1,\"66\":1}}],[\"date\",{\"1\":{\"62\":1}}],[\"dataproc\",{\"1\":{\"55\":1}}],[\"d894ffcd8\",{\"1\":{\"61\":2}}],[\"db\",{\"1\":{\"61\":3}}],[\"dsl编译器将您的管道的python代码转换为静态配置\",{\"1\":{\"46\":1}}],[\"dsl\",{\"1\":{\"45\":1}}],[\"dns\",{\"1\":{\"33\":4,\"38\":1,\"39\":1}}],[\"demo\",{\"1\":{\"133\":2}}],[\"declarative\",{\"1\":{\"86\":1}}],[\"deployments\",{\"1\":{\"65\":1}}],[\"deployment\",{\"1\":{\"26\":2,\"31\":1,\"61\":5,\"62\":1}}],[\"definition\",{\"1\":{\"81\":1}}],[\"defaultrequest\",{\"1\":{\"20\":1,\"21\":1}}],[\"default\",{\"1\":{\"20\":1,\"21\":1,\"31\":1,\"35\":1,\"37\":1,\"38\":2,\"119\":4,\"120\":6}}],[\"defer\",{\"1\":{\"0\":2}}],[\"delete\",{\"1\":{\"5\":1}}],[\"deletion\",{\"1\":{\"0\":1}}],[\"例如重新启动故障的组件\",{\"1\":{\"83\":1}}],[\"例如系统管理员\",{\"1\":{\"80\":1}}],[\"例如贝叶斯优化\",{\"1\":{\"69\":1}}],[\"例如在\",{\"1\":{\"64\":1}}],[\"例如数据预处理\",{\"1\":{\"54\":1}}],[\"例如数据库集群或分布式文件系统\",{\"1\":{\"34\":1}}],[\"例如\",{\"1\":{\"33\":1,\"38\":1,\"55\":2,\"59\":1,\"65\":2,\"66\":1,\"69\":1,\"83\":1,\"109\":1}}],[\"进行通信的场景非常有用\",{\"1\":{\"33\":1}}],[\"允许更重要的请求先行处理\",{\"1\":{\"110\":1}}],[\"允许多个请求\",{\"1\":{\"107\":1}}],[\"允许在同一个tcp连接上复用多个请求\",{\"1\":{\"106\":1}}],[\"允许优化任何规模的大模型的超参数\",{\"1\":{\"70\":1}}],[\"允许用户交互和监控工作流\",{\"1\":{\"61\":1}}],[\"允许用户在\",{\"1\":{\"61\":1}}],[\"允许应用自行管理和发现服务实例\",{\"1\":{\"34\":1}}],[\"允许这些有状态应用中的各个\",{\"1\":{\"34\":1}}],[\"允许客户端直接访问服务后端的每个\",{\"1\":{\"33\":1}}],[\"允许被多个node挂载\",{\"1\":{\"4\":2}}],[\"字段设置为\",{\"1\":{\"33\":1}}],[\"字段来表示\",{\"1\":{\"6\":1}}],[\"这就是我想要的\",{\"1\":{\"133\":2}}],[\"这类似于传统二层交换机的mac地址表\",{\"1\":{\"128\":1}}],[\"这表明veth0和veth1是一对互相连接的虚拟以太网设备\",{\"1\":{\"119\":1}}],[\"这有助于减少延迟和提升性能\",{\"1\":{\"109\":1}}],[\"这描述了自定义资源的结构和规范\",{\"1\":{\"82\":1}}],[\"这使得\",{\"1\":{\"70\":1}}],[\"这可以被以下用户使用\",{\"0\":{\"66\":1}}],[\"这对于将各种资源联系在一起甚至清理\",{\"1\":{\"65\":1}}],[\"这对于需要在容器之间共享数据的工作流特别有用\",{\"1\":{\"60\":1}}],[\"这对于需要直接与特定\",{\"1\":{\"33\":1}}],[\"这样的工具\",{\"1\":{\"66\":1}}],[\"这样的应用程序\",{\"1\":{\"65\":1}}],[\"这样客户端可以通过\",{\"1\":{\"33\":1}}],[\"这是默认的执行器\",{\"1\":{\"60\":1}}],[\"这会很有帮助\",{\"1\":{\"59\":1}}],[\"这个示例定义了一个名为\",{\"1\":{\"35\":1}}],[\"这种方式允许二层流量跨越不同的三层网络\",{\"1\":{\"127\":1}}],[\"这种方法依赖于\",{\"1\":{\"60\":1}}],[\"这种连接可视化称为谱系图\",{\"1\":{\"59\":1}}],[\"这种服务类型主要用于暴露\",{\"1\":{\"32\":1}}],[\"这种机制有助于确保工作负载在集群中得到更好地分布和隔离\",{\"1\":{\"31\":1}}],[\"这些服务涵盖了实验管理\",{\"1\":{\"75\":1}}],[\"这些框架实现了大多数最先进的优化算法\",{\"1\":{\"70\":1}}],[\"这些组件通过存储系统\",{\"1\":{\"61\":1}}],[\"这些组件通过元数据存储和\",{\"1\":{\"61\":1}}],[\"这些组件必须在集群启动时运行\",{\"1\":{\"28\":1}}],[\"这些\",{\"1\":{\"53\":2,\"61\":3}}],[\"这些容器在虚拟机上的kubernetes\",{\"1\":{\"49\":1}}],[\"这些配置文件不会因为\",{\"1\":{\"26\":1}}],[\"具备高效处理大规模数据的能力\",{\"1\":{\"92\":1}}],[\"具备扎实的c++基础\",{\"1\":{\"91\":1}}],[\"具备更高的安全性\",{\"1\":{\"0\":1}}],[\"具有名称\",{\"1\":{\"54\":1}}],[\"具有相应的\",{\"1\":{\"31\":1}}],[\"除非这些\",{\"1\":{\"31\":1}}],[\"则无法进行部署\",{\"1\":{\"31\":1}}],[\"则进入等待模式\",{\"1\":{\"0\":1}}],[\"移除\",{\"1\":{\"31\":1}}],[\"也可以是丰富的交互式可视化\",{\"1\":{\"59\":1}}],[\"也可能会调度\",{\"1\":{\"31\":1}}],[\"也不能直接共享内存数据\",{\"1\":{\"57\":1}}],[\"也不会被调度到这个节点上\",{\"1\":{\"31\":1}}],[\"新\",{\"1\":{\"31\":1}}],[\"新的\",{\"1\":{\"31\":1}}],[\"常见用途\",{\"1\":{\"122\":1,\"123\":1}}],[\"常见的效果有三种\",{\"1\":{\"31\":1}}],[\"常用的解决方案是超时和自动过期机制\",{\"1\":{\"0\":1}}],[\"效果\",{\"1\":{\"31\":1}}],[\"值\",{\"1\":{\"31\":1}}],[\"键\",{\"1\":{\"31\":1}}],[\"表示这个节点对某些\",{\"1\":{\"31\":1}}],[\"提高网络性能\",{\"1\":{\"122\":1}}],[\"提高网络安全性\",{\"1\":{\"122\":1}}],[\"提升了用户体验和网络性能\",{\"1\":{\"114\":1}}],[\"提升了整体性能\",{\"1\":{\"113\":1}}],[\"提升资源管理能力\",{\"1\":{\"14\":1}}],[\"提出最佳推理代码库\",{\"1\":{\"101\":1}}],[\"提前停止和神经架构搜索\",{\"1\":{\"69\":1}}],[\"提供灵活的网络管理和用户分组\",{\"1\":{\"122\":1}}],[\"提供流量控制机制\",{\"1\":{\"110\":1}}],[\"提供一种方式\",{\"1\":{\"68\":1}}],[\"提供一种明确的机制\",{\"1\":{\"67\":1}}],[\"提供一种标准方式\",{\"1\":{\"67\":1}}],[\"提供一个用于在\",{\"1\":{\"67\":1}}],[\"提供应用程序的安装状态和垃圾回收\",{\"1\":{\"67\":1}}],[\"提供通过\",{\"1\":{\"67\":1}}],[\"提供工作流执行状态和结果的可视化\",{\"1\":{\"61\":1}}],[\"提供了一种声明性的方式来定义和管理\",{\"1\":{\"86\":1}}],[\"提供了面向\",{\"1\":{\"86\":1}}],[\"提供了从生成基础代码到测试和部署的全流程支持\",{\"1\":{\"86\":1}}],[\"提供了从超参数调优到机器学习工作流管理的完整功能\",{\"1\":{\"61\":1}}],[\"提供了定义自定义对象的能力\",{\"1\":{\"81\":1}}],[\"提供了机器学习工作流的定义\",{\"1\":{\"61\":1}}],[\"提供\",{\"1\":{\"61\":7}}],[\"提供稳定的\",{\"1\":{\"39\":1}}],[\"提供的负载均衡\",{\"1\":{\"34\":1}}],[\"提供的一种灵活机制\",{\"1\":{\"29\":1}}],[\"要更新\",{\"1\":{\"29\":1}}],[\"要创建一个\",{\"1\":{\"27\":1}}],[\"global\",{\"1\":{\"120\":1}}],[\"gpu\",{\"1\":{\"101\":2}}],[\"go\",{\"1\":{\"86\":1,\"91\":1}}],[\"google\",{\"1\":{\"55\":1,\"59\":1,\"69\":1}}],[\"gcr\",{\"1\":{\"62\":1}}],[\"gcepersistentdisk\",{\"1\":{\"5\":1}}],[\"github\",{\"1\":{\"62\":1,\"63\":1,\"98\":1}}],[\"group\",{\"1\":{\"119\":2,\"120\":4}}],[\"grep\",{\"1\":{\"116\":1,\"117\":1,\"119\":1}}],[\"grpc\",{\"1\":{\"61\":8}}],[\"graph\",{\"0\":{\"58\":1},\"1\":{\"58\":1,\"59\":1}}],[\"getstringconfig\",{\"1\":{\"72\":2}}],[\"get\",{\"1\":{\"29\":1,\"61\":1}}],[\"命令是查看和管理网络设备的主要工具\",{\"1\":{\"116\":1}}],[\"命令\",{\"0\":{\"116\":1,\"117\":1}}],[\"命令查看\",{\"1\":{\"29\":2}}],[\"命名空间\",{\"1\":{\"17\":1}}],[\"略有不同\",{\"1\":{\"29\":1}}],[\"来优化非ml任务\",{\"1\":{\"70\":1}}],[\"来实现这一点\",{\"1\":{\"33\":1,\"39\":1}}],[\"来说是不合适的\",{\"1\":{\"31\":1}}],[\"来运行节点级别的服务或代理\",{\"1\":{\"28\":1}}],[\"来创建和管理\",{\"1\":{\"25\":1}}],[\"简单\",{\"1\":{\"124\":1}}],[\"简单清除文件的操作\",{\"1\":{\"5\":1}}],[\"简化了\",{\"1\":{\"86\":1}}],[\"简化数据库集群的管理\",{\"1\":{\"85\":1}}],[\"简化运维操作\",{\"1\":{\"84\":1}}],[\"简化的节点管理\",{\"1\":{\"28\":1}}],[\"简介\",{\"0\":{\"42\":1},\"1\":{\"42\":2}}],[\"86868f775c\",{\"1\":{\"61\":2}}],[\"849479cf5f\",{\"1\":{\"61\":2}}],[\"8\",{\"0\":{\"112\":1},\"1\":{\"60\":1}}],[\"802\",{\"1\":{\"122\":1,\"124\":1}}],[\"8080\",{\"1\":{\"35\":2,\"37\":1,\"38\":1}}],[\"80\",{\"1\":{\"27\":1,\"31\":1,\"35\":2,\"37\":1}}],[\"8gi\",{\"1\":{\"15\":1}}],[\"ieee\",{\"1\":{\"124\":1}}],[\"id映射到vxlan的vni\",{\"1\":{\"128\":1}}],[\"identifier\",{\"1\":{\"123\":1,\"127\":1}}],[\"id\",{\"1\":{\"122\":2,\"124\":1}}],[\"indiehacker\",{\"1\":{\"133\":1}}],[\"inet6\",{\"1\":{\"120\":1}}],[\"inet\",{\"1\":{\"120\":1}}],[\"in\",{\"1\":{\"62\":1}}],[\"ingress\",{\"1\":{\"60\":1}}],[\"introduction\",{\"1\":{\"42\":1}}],[\"ip\",{\"1\":{\"32\":1,\"33\":2,\"39\":1,\"116\":3,\"118\":1,\"119\":2,\"120\":6}}],[\"is\",{\"1\":{\"31\":1}}],[\"io\",{\"1\":{\"31\":2,\"62\":4}}],[\"imagepullpolicy\",{\"1\":{\"31\":1,\"62\":1}}],[\"image\",{\"1\":{\"27\":1,\"31\":1,\"38\":2,\"62\":2}}],[\"if29\",{\"1\":{\"120\":2}}],[\"ifconfig\",{\"1\":{\"117\":2}}],[\"ifconfig命令也可以用于查看网络接口\",{\"1\":{\"117\":1}}],[\"ifnotpresent\",{\"1\":{\"31\":1,\"62\":1}}],[\"if\",{\"1\":{\"0\":6,\"59\":1}}],[\"文件保存到节点的\",{\"1\":{\"27\":1}}],[\"文件路径\",{\"1\":{\"27\":1}}],[\"文件\",{\"1\":{\"27\":1,\"29\":1}}],[\"你会哪个就用哪个\",{\"1\":{\"133\":2}}],[\"你很快就会知道你的想法是不是可以赚到钱\",{\"1\":{\"133\":2}}],[\"你还可以指定最大并发运行数\",{\"1\":{\"59\":1}}],[\"你可以查看跨管道运行的工件和执行之间的连接\",{\"1\":{\"59\":1}}],[\"你可以从\",{\"1\":{\"59\":1}}],[\"你可以在任何实验中启动定期运行\",{\"1\":{\"59\":1}}],[\"你可以在其中尝试管道的不同配置\",{\"1\":{\"59\":1}}],[\"你可以通过查看\",{\"1\":{\"59\":1}}],[\"你可以使用实验将你的运行组织成逻辑组\",{\"1\":{\"59\":1}}],[\"你可以使用\",{\"1\":{\"53\":1}}],[\"你必须将传递给组件之间的数据序列化\",{\"1\":{\"57\":1}}],[\"你必须将组件打包为\",{\"1\":{\"57\":1}}],[\"你仍然可以使用\",{\"1\":{\"29\":1}}],[\"你需要在节点的特定目录中\",{\"1\":{\"27\":1}}],[\"你都需要确保任意故障场景下\",{\"1\":{\"0\":1}}],[\"创建runs\",{\"0\":{\"77\":1}}],[\"创建流水线只是把相关参数信息写入数据库\",{\"1\":{\"76\":1}}],[\"创建组件或指定管道\",{\"1\":{\"45\":1}}],[\"创建一个所有工具必须实现的标准\",{\"1\":{\"68\":1}}],[\"创建一个\",{\"1\":{\"33\":1}}],[\"创建一个包含\",{\"1\":{\"27\":1}}],[\"创建\",{\"0\":{\"27\":1}}],[\"创建了一个\",{\"1\":{\"0\":1}}],[\"保持动力等\",{\"1\":{\"133\":2}}],[\"保证这些关键组件的高可用性\",{\"1\":{\"26\":1}}],[\"保留数据\",{\"1\":{\"5\":1}}],[\"崩溃或被删除\",{\"1\":{\"26\":1}}],[\"自主运营并开发自己的在线业务以获得收入的人\",{\"1\":{\"133\":2}}],[\"自愈能力\",{\"1\":{\"83\":1}}],[\"自动处理\",{\"1\":{\"85\":1}}],[\"自动化\",{\"1\":{\"85\":1}}],[\"自动化了许多日常的运维任务\",{\"1\":{\"84\":1}}],[\"自动化升级\",{\"1\":{\"83\":1}}],[\"自动修复出现的问题\",{\"1\":{\"83\":1}}],[\"自动执行\",{\"1\":{\"83\":1}}],[\"自动重启\",{\"1\":{\"26\":1}}],[\"自定义资源\",{\"1\":{\"81\":1}}],[\"自定义资源定义\",{\"1\":{\"64\":1,\"81\":1}}],[\"自定义服务发现\",{\"1\":{\"34\":1}}],[\"自\",{\"1\":{\"60\":1}}],[\"自身来管理\",{\"1\":{\"28\":1}}],[\"自身的管理中\",{\"1\":{\"25\":1}}],[\"存储工作流定义和执行状态\",{\"1\":{\"61\":1}}],[\"存储超参数调优任务的状态和结果\",{\"1\":{\"61\":1}}],[\"存储和对象数量等\",{\"1\":{\"16\":1}}],[\"存放在节点的文件系统中\",{\"1\":{\"26\":1}}],[\"格式的组件规范描述\",{\"1\":{\"56\":1}}],[\"格式\",{\"1\":{\"26\":1}}],[\"静态配置\",{\"1\":{\"26\":1}}],[\"静态pod\",{\"0\":{\"25\":1}}],[\"滚动更新等高级特性\",{\"1\":{\"26\":1}}],[\"没有内建的优先级控制机制\",{\"1\":{\"110\":1}}],[\"没有\",{\"1\":{\"26\":1,\"33\":1,\"35\":1}}],[\"会启动\",{\"1\":{\"53\":1}}],[\"会为每个\",{\"1\":{\"33\":1}}],[\"会被驱逐\",{\"1\":{\"31\":1}}],[\"会自动检测到文件的变化并重新创建\",{\"1\":{\"29\":1}}],[\"会自动检测到该文件并创建对应的\",{\"1\":{\"27\":1}}],[\"会根据配置文件自动重新创建它们\",{\"1\":{\"26\":1}}],[\"会定期扫描特定的目录\",{\"1\":{\"26\":1}}],[\"会使用我们上面的介绍的\",{\"1\":{\"0\":1}}],[\"由三个部分组成\",{\"1\":{\"31\":1}}],[\"由于是文本协议\",{\"1\":{\"112\":1}}],[\"由于\",{\"1\":{\"29\":1}}],[\"由于某种原因无法使用\",{\"1\":{\"10\":1}}],[\"由运行在节点上的\",{\"1\":{\"26\":1}}],[\"由\",{\"1\":{\"26\":1,\"29\":1}}],[\"直到我们拿出自己的产品\",{\"1\":{\"133\":2}}],[\"直到被释放\",{\"1\":{\"8\":1}}],[\"直接与\",{\"1\":{\"60\":1}}],[\"直接与集群交互\",{\"1\":{\"60\":1}}],[\"直接相互访问\",{\"1\":{\"34\":1}}],[\"直接访问\",{\"1\":{\"33\":1}}],[\"直接管理\",{\"1\":{\"25\":1,\"26\":1,\"29\":1}}],[\"两者结合使用\",{\"1\":{\"23\":1}}],[\"典型场景\",{\"1\":{\"23\":2}}],[\"目前有能力提供哪种产品形态\",{\"1\":{\"133\":2}}],[\"目前只有nfs和hostpath两种类型的pv支持recycle策略\",{\"1\":{\"5\":1}}],[\"目标客户更愿意使用哪种产品\",{\"1\":{\"133\":2}}],[\"目标客户会经常出现在那里\",{\"1\":{\"133\":2}}],[\"目标vtep解封装udp包\",{\"1\":{\"128\":1}}],[\"目标发现和告警管理\",{\"1\":{\"85\":1}}],[\"目标\",{\"0\":{\"67\":1}}],[\"目录包含所有运行时代码\",{\"1\":{\"55\":1}}],[\"目录中后\",{\"1\":{\"27\":1}}],[\"目的vtep接收到vxlan包后\",{\"1\":{\"129\":1}}],[\"目的\",{\"1\":{\"23\":2}}],[\"适用于需要高效处理大量小文件的工作流\",{\"1\":{\"60\":1}}],[\"适用于需要直接访问每个\",{\"1\":{\"39\":1}}],[\"适用于大多数场景\",{\"1\":{\"60\":1}}],[\"适用于单个\",{\"1\":{\"23\":1}}],[\"适用于整个命名空间的资源总量\",{\"1\":{\"23\":1}}],[\"适用的对象范围\",{\"1\":{\"16\":1}}],[\"范围是1到4094\",{\"1\":{\"122\":1}}],[\"范围\",{\"1\":{\"23\":2}}],[\"比较与总结\",{\"0\":{\"23\":1}}],[\"比自己小的\",{\"1\":{\"0\":2}}],[\"从而实现了高效\",{\"1\":{\"130\":1}}],[\"从而在vxlan隧道中维护虚拟网络的隔离和标识\",{\"1\":{\"128\":1}}],[\"从而支持多租户环境\",{\"1\":{\"127\":1}}],[\"从而可以在三层ip网络上进行传输\",{\"1\":{\"127\":1}}],[\"从而可以跨越传统的二层边界在ip网络上传输\",{\"1\":{\"123\":1}}],[\"从而提高网络的安全性和性能\",{\"1\":{\"122\":1}}],[\"从而优化集群性能和资源利用率\",{\"1\":{\"22\":1}}],[\"从而影响其他命名空间的正常运行\",{\"1\":{\"13\":1}}],[\"资源优化\",{\"1\":{\"22\":1}}],[\"确保没有流会独占带宽\",{\"1\":{\"110\":1}}],[\"确保高可用性和数据一致性\",{\"1\":{\"85\":1}}],[\"确保工作流按照定义的步骤顺利执行\",{\"1\":{\"61\":1}}],[\"确保其他\",{\"1\":{\"61\":1}}],[\"确保关键组件能够独立于\",{\"1\":{\"28\":1}}],[\"确保资源的公平分配和高效使用\",{\"1\":{\"23\":1}}],[\"确保资源的合理分配和使用\",{\"1\":{\"22\":1}}],[\"确保集群资源的公平分配和高效利用\",{\"1\":{\"23\":1}}],[\"确保所有容器符合预期的资源使用模式\",{\"1\":{\"22\":1}}],[\"确保每个命名空间不会消耗超过指定的资源限额\",{\"1\":{\"14\":1}}],[\"鼓励开发人员在部署\",{\"1\":{\"19\":1}}],[\"鼓励合理的资源分配\",{\"1\":{\"19\":1}}],[\"防止个体资源过度消耗\",{\"1\":{\"23\":1}}],[\"防止过多的资源消耗影响整个集群的性能\",{\"1\":{\"19\":1}}],[\"防止资源过度配置或资源不足\",{\"1\":{\"22\":1}}],[\"防止资源过度消耗\",{\"1\":{\"19\":1}}],[\"防止资源耗尽\",{\"1\":{\"14\":1}}],[\"与vxlan\",{\"0\":{\"121\":1}}],[\"与许多优化框架\",{\"1\":{\"70\":1}}],[\"与应用程序\",{\"1\":{\"67\":1}}],[\"与元数据\",{\"1\":{\"61\":1}}],[\"与执行或工件关联的自定义属性等\",{\"1\":{\"59\":1}}],[\"与端点通信以提交作业的代码\",{\"1\":{\"55\":1}}],[\"与普通的\",{\"1\":{\"33\":1}}],[\"与\",{\"0\":{\"36\":1},\"1\":{\"18\":1,\"55\":1,\"61\":1,\"70\":2}}],[\"与pv相连的后端存储完成volume的删除操作\",{\"1\":{\"5\":1}}],[\"成长与学习\",{\"1\":{\"133\":2}}],[\"成为一名独立开发者可以提供很多传统工作所无法提供的优点\",{\"1\":{\"133\":2}}],[\"成功\",{\"1\":{\"58\":1}}],[\"成功后\",{\"1\":{\"0\":1}}],[\"成本管理\",{\"1\":{\"17\":1}}],[\"之前方法难以低成本在单个\",{\"1\":{\"101\":1}}],[\"之前已经绑定的\",{\"1\":{\"9\":1}}],[\"之间的互操作性\",{\"1\":{\"67\":1}}],[\"之间的资源使用\",{\"1\":{\"17\":1}}],[\"之间有一定的关联关系\",{\"1\":{\"61\":1}}],[\"之上安排\",{\"1\":{\"43\":1}}],[\"之上\",{\"1\":{\"42\":1}}],[\"控制平面来实现和基准测试他们自己的优化算法\",{\"1\":{\"70\":1}}],[\"控制平面组件\",{\"1\":{\"25\":1,\"28\":2}}],[\"控制器的核心任务是不断将资源的实际状态调整为期望状态\",{\"1\":{\"82\":1}}],[\"控制器监控自定义资源的状态\",{\"1\":{\"82\":1}}],[\"控制器是\",{\"1\":{\"81\":1}}],[\"控制器管理器\",{\"1\":{\"61\":2}}],[\"控制器\",{\"1\":{\"28\":1,\"61\":1,\"81\":1}}],[\"控制命名空间内的资源使用上限\",{\"1\":{\"23\":1}}],[\"控制资源使用来管理和控制成本\",{\"1\":{\"17\":1}}],[\"控制资源分配\",{\"1\":{\"14\":1}}],[\"控制不同租户\",{\"1\":{\"17\":1}}],[\"多租户支持\",{\"1\":{\"127\":1}}],[\"多租户环境\",{\"1\":{\"17\":1,\"23\":1}}],[\"多个小的请求可能会因为串行化处理导致较高的延迟和低效的带宽利用\",{\"1\":{\"113\":1}}],[\"多路复用\",{\"0\":{\"107\":1},\"1\":{\"114\":2}}],[\"多节点和多gpu分布式训练\",{\"1\":{\"70\":1}}],[\"多种访问模式不能同时生效\",{\"1\":{\"4\":1}}],[\"内核中的延迟细分和稀疏模式\",{\"1\":{\"101\":1}}],[\"内核执行高效计算\",{\"1\":{\"101\":1}}],[\"内存\",{\"1\":{\"16\":1}}],[\"内资源总量的机制\",{\"1\":{\"13\":1}}],[\"包括不要熬夜做产品\",{\"1\":{\"133\":2}}],[\"包括产品有什么核心功能和特点\",{\"1\":{\"133\":2}}],[\"包括想法\",{\"1\":{\"133\":2}}],[\"包括美工问题\",{\"1\":{\"133\":2}}],[\"包括人身自由\",{\"1\":{\"133\":2}}],[\"包括什么是独立开发者\",{\"1\":{\"133\":2}}],[\"包括veth设备对\",{\"1\":{\"116\":1}}],[\"包括工件在内的管道组件非常有用\",{\"1\":{\"59\":1}}],[\"包括工作流中的所有组件及其相互关系\",{\"1\":{\"53\":1}}],[\"包括定期运行\",{\"1\":{\"59\":1}}],[\"包括\",{\"1\":{\"16\":1}}],[\"包含\",{\"1\":{\"0\":1}}],[\"主页\",{\"1\":{\"64\":1}}],[\"主要集中在容器化应用程序上\",{\"1\":{\"64\":1}}],[\"主要的\",{\"0\":{\"60\":1}}],[\"主要用于以下几种场景\",{\"1\":{\"34\":1}}],[\"主要控制单个\",{\"1\":{\"18\":1}}],[\"主要字段\",{\"0\":{\"16\":1,\"21\":1}}],[\"主备异步复制可能导致丢数据的问题\",{\"1\":{\"0\":1}}],[\"507e\",{\"1\":{\"120\":1}}],[\"5000\",{\"1\":{\"31\":1,\"61\":1}}],[\"500m\",{\"1\":{\"20\":1,\"31\":1}}],[\"52\",{\"1\":{\"120\":2}}],[\"5499555669\",{\"1\":{\"61\":2}}],[\"5bbh9\",{\"1\":{\"61\":2}}],[\"57dbbdfd77\",{\"1\":{\"61\":2}}],[\"512mi\",{\"1\":{\"20\":1}}],[\"5\",{\"0\":{\"109\":1},\"1\":{\"15\":1}}],[\"限制资源以确保测试环境不会占用过多的生产资源\",{\"1\":{\"17\":1}}],[\"限制内存使用总量\",{\"1\":{\"15\":1}}],[\"限制内存请求总量\",{\"1\":{\"15\":1}}],[\"限制\",{\"1\":{\"15\":4}}],[\"限制命名空间资源使用\",{\"1\":{\"14\":1}}],[\"hpack\",{\"1\":{\"108\":1}}],[\"hqjiang\",{\"1\":{\"99\":1}}],[\"html\",{\"1\":{\"94\":1,\"99\":1}}],[\"http头部是以纯文本格式传输的\",{\"1\":{\"108\":1}}],[\"http2与http1区别\",{\"1\":{\"104\":1}}],[\"https\",{\"1\":{\"42\":1,\"62\":1,\"63\":1,\"98\":1,\"99\":1,\"114\":1,\"133\":1}}],[\"http\",{\"1\":{\"31\":2,\"35\":1,\"37\":1,\"104\":4,\"105\":2,\"106\":4,\"107\":2,\"108\":2,\"109\":2,\"110\":3,\"111\":3,\"112\":3,\"113\":3,\"114\":3},\"2\":{\"132\":1}}],[\"hyperopt\",{\"1\":{\"70\":1}}],[\"hyperband\",{\"1\":{\"69\":1}}],[\"helm\",{\"1\":{\"66\":1}}],[\"helpful\",{\"1\":{\"31\":1}}],[\"headless\",{\"0\":{\"32\":1,\"33\":1,\"35\":1,\"36\":1,\"37\":1},\"1\":{\"32\":2,\"33\":3,\"34\":3,\"35\":3,\"36\":1,\"38\":1,\"39\":2}}],[\"had\",{\"1\":{\"31\":1}}],[\"hard\",{\"1\":{\"15\":1,\"16\":1}}],[\"high\",{\"1\":{\"31\":2}}],[\"hdr\",{\"1\":{\"0\":3}}],[\"和vxlan\",{\"1\":{\"121\":1}}],[\"和控制器的实现\",{\"1\":{\"82\":1}}],[\"和控制器旨在改变这种状况\",{\"1\":{\"64\":1}}],[\"和行为方式\",{\"1\":{\"82\":1}}],[\"和工具来自动管理复杂应用的生命周期\",{\"1\":{\"80\":1}}],[\"和用户界面进行紧密集成\",{\"1\":{\"61\":1}}],[\"和服务正常运行\",{\"1\":{\"61\":1}}],[\"和内存的默认值和最大\",{\"1\":{\"20\":1}}],[\"和内存总量\",{\"1\":{\"15\":1}}],[\"和\",{\"0\":{\"129\":1},\"1\":{\"12\":1,\"15\":1,\"25\":1,\"28\":2,\"61\":1,\"70\":2,\"75\":3,\"133\":2}}],[\"或在解析管道代码中的\",{\"1\":{\"59\":1}}],[\"或在\",{\"1\":{\"59\":1}}],[\"或跳过\",{\"1\":{\"58\":1}}],[\"或其他控制器管理的\",{\"1\":{\"26\":1}}],[\"或容器的资源使用\",{\"1\":{\"23\":1}}],[\"或容器的资源使用范围\",{\"1\":{\"18\":1}}],[\"或容器没有指定资源请求和限制\",{\"1\":{\"19\":1}}],[\"或容器资源使用的机制\",{\"1\":{\"18\":1}}],[\"或\",{\"1\":{\"12\":1,\"26\":3,\"53\":1,\"69\":1}}],[\"删除或再利用\",{\"1\":{\"12\":1}}],[\"删除\",{\"1\":{\"12\":1}}],[\"vni映射\",{\"1\":{\"128\":1}}],[\"vtep作为vxlan架构中的关键组件\",{\"1\":{\"130\":1}}],[\"vtep将该帧封装到一个udp包中\",{\"1\":{\"129\":1}}],[\"vtep通过监听网络流量和arp\",{\"1\":{\"128\":1}}],[\"vtep负责将二层网络中的vlan\",{\"1\":{\"128\":1}}],[\"vtep是vxlan隧道的起点和终点\",{\"1\":{\"128\":1}}],[\"vtep是vxlan架构中的关键组件\",{\"1\":{\"128\":1}}],[\"vtep\",{\"0\":{\"128\":1,\"129\":1},\"1\":{\"124\":1}}],[\"vxlan和vtep的结合\",{\"1\":{\"130\":1}}],[\"vxlan通过在现有的三层ip网络上创建虚拟二层网络\",{\"1\":{\"130\":1}}],[\"vxlan通过udp隧道封装将二层以太网帧封装在三层ip包中\",{\"1\":{\"127\":1}}],[\"vxlan通过udp隧道封装\",{\"1\":{\"123\":1}}],[\"vxlan包封装\",{\"1\":{\"129\":1}}],[\"vxlan可以在现有的ip网络上实现二层网络的扩展和弹性\",{\"1\":{\"127\":1}}],[\"vxlan可以在现有的ip网络基础上创建虚拟网络\",{\"1\":{\"123\":1}}],[\"vxlan允许在同一个物理网络基础设施上运行多个独立的虚拟网络\",{\"1\":{\"127\":1}}],[\"vxlan是一种用于扩展二层网络的技术\",{\"1\":{\"127\":1}}],[\"vxlan是一种用于在大规模数据中心和云环境中创建虚拟网络的技术\",{\"1\":{\"123\":1}}],[\"vxlan与vtep\",{\"0\":{\"126\":1}}],[\"vxlan适用于大规模的分布式数据中心环境\",{\"1\":{\"123\":1}}],[\"vxlan使用24位的vni\",{\"1\":{\"123\":1,\"127\":1}}],[\"vxlan\",{\"0\":{\"123\":1,\"127\":1,\"128\":1,\"129\":1},\"1\":{\"123\":1,\"124\":1,\"127\":1}}],[\"vlan适用于较小规模的网络分段和隔离\",{\"1\":{\"125\":1}}],[\"vlan的配置相对简单\",{\"1\":{\"122\":1}}],[\"vlan使用ieee\",{\"1\":{\"122\":1}}],[\"vlan是一种用于在同一物理网络上创建多个逻辑网络的技术\",{\"1\":{\"122\":1}}],[\"vlan\",{\"0\":{\"121\":1,\"122\":1},\"1\":{\"121\":1,\"122\":1,\"124\":1}}],[\"valid\",{\"1\":{\"120\":2}}],[\"valuefrom\",{\"1\":{\"62\":1}}],[\"value\",{\"1\":{\"31\":2}}],[\"veth1\",{\"1\":{\"119\":3,\"120\":3}}],[\"veth0\",{\"1\":{\"118\":1,\"119\":3}}],[\"veth\",{\"1\":{\"116\":1,\"117\":1,\"119\":2}}],[\"vertical\",{\"1\":{\"101\":2}}],[\"vue\",{\"1\":{\"94\":1}}],[\"v2beta1\",{\"0\":{\"73\":1},\"1\":{\"75\":4}}],[\"virtual\",{\"0\":{\"122\":1,\"123\":1,\"127\":1},\"1\":{\"121\":2}}],[\"visualizationserviceport\",{\"1\":{\"72\":1}}],[\"visualizationservicehost\",{\"1\":{\"72\":1}}],[\"visualizationservice\",{\"1\":{\"72\":1,\"75\":1}}],[\"visualizationserver\",{\"1\":{\"61\":3}}],[\"viewer\",{\"1\":{\"61\":3}}],[\"v1beta1\",{\"0\":{\"72\":1},\"1\":{\"75\":8}}],[\"v1\",{\"1\":{\"15\":1,\"20\":1,\"27\":1,\"31\":1,\"35\":1,\"37\":1,\"38\":1,\"62\":1}}],[\"v\",{\"1\":{\"12\":3}}],[\"|\",{\"1\":{\"12\":6,\"116\":1,\"117\":1,\"119\":1}}],[\"使得跨越不同物理位置的虚拟机能够像在同一个二层网络中一样进行通信\",{\"1\":{\"130\":1}}],[\"使得虚拟机可以在不同的物理位置之间自由迁移\",{\"1\":{\"127\":1}}],[\"使得虚拟机和容器之间的通信更加灵活和高效\",{\"1\":{\"123\":1}}],[\"使得不同vlan之间的通信受到限制\",{\"1\":{\"122\":1}}],[\"使得网络应用能够更高效地传输数据\",{\"1\":{\"114\":1}}],[\"使得创建复杂的应用管理变得更简单\",{\"1\":{\"86\":1}}],[\"使得\",{\"1\":{\"84\":1}}],[\"使得复杂应用的管理变得更一致和可靠\",{\"1\":{\"84\":1}}],[\"使得用户可以在\",{\"1\":{\"81\":1}}],[\"使应用程序能够声明对另一个应用程序的依赖关系\",{\"1\":{\"67\":1}}],[\"使应用程序能够向\",{\"1\":{\"67\":1}}],[\"使其能够在众多支持工具之间实现互操作\",{\"1\":{\"64\":1}}],[\"使其可以绑定到新的\",{\"1\":{\"11\":1}}],[\"使主容器可以访问子容器的文件系统和进程\",{\"1\":{\"60\":1}}],[\"使\",{\"1\":{\"59\":1,\"68\":1}}],[\"使用什么样的编程语言\",{\"1\":{\"133\":4}}],[\"使用hpack算法进行压缩\",{\"1\":{\"114\":1}}],[\"使用流的概念\",{\"1\":{\"106\":1}}],[\"使用二进制帧传输数据\",{\"1\":{\"105\":1}}],[\"使用新行符分隔的文本消息进行通信\",{\"1\":{\"105\":1}}],[\"使用优化的\",{\"1\":{\"101\":1}}],[\"使用大规模指标来调试管道运行或调查单个运行的性能\",{\"1\":{\"50\":1}}],[\"使用kubeflow\",{\"1\":{\"45\":1}}],[\"使用量\",{\"1\":{\"20\":2}}],[\"使用场景\",{\"0\":{\"17\":1,\"22\":1,\"28\":1,\"34\":1}}],[\"使用总量\",{\"1\":{\"15\":1}}],[\"使用\",{\"0\":{\"85\":1,\"116\":1,\"117\":1},\"1\":{\"6\":1,\"7\":1,\"8\":1,\"28\":1,\"59\":2,\"80\":1,\"108\":1,\"111\":1}}],[\"如何面对压力\",{\"1\":{\"133\":2}}],[\"如何面对压力等\",{\"1\":{\"133\":2}}],[\"如何保持积极的心态\",{\"1\":{\"133\":4}}],[\"如何解决用户的问题\",{\"1\":{\"133\":4}}],[\"如何判断想法的是不是可以赚钱\",{\"1\":{\"133\":4}}],[\"如何选择适合的执行器\",{\"0\":{\"61\":1}}],[\"如监控\",{\"1\":{\"59\":1}}],[\"如下图所示\",{\"1\":{\"70\":1}}],[\"如下所示\",{\"1\":{\"31\":1}}],[\"如下代码所示\",{\"1\":{\"0\":1}}],[\"如仅应用于某些特定的资源类型\",{\"1\":{\"16\":1}}],[\"如\",{\"1\":{\"15\":1,\"25\":2,\"28\":1,\"61\":1,\"70\":3,\"81\":1}}],[\"如果将veth设备移动到不同的命名空间\",{\"1\":{\"120\":1}}],[\"如果你对我的技能和经验感兴趣\",{\"1\":{\"94\":1}}],[\"如果你对开发\",{\"1\":{\"87\":1}}],[\"如果你更熟悉\",{\"1\":{\"61\":1}}],[\"如果你的工作流需要高效处理大量文件操作\",{\"1\":{\"61\":1}}],[\"如果你的工作流步骤之间需要共享文件或进程命名空间\",{\"1\":{\"61\":1}}],[\"如果你的工作流不需要特别的资源共享或文件处理\",{\"1\":{\"61\":1}}],[\"如果一个工件被多个不同运行中的执行使用\",{\"1\":{\"59\":1}}],[\"如果管道预计运行时间较长且触发频繁运行\",{\"1\":{\"59\":1}}],[\"如果pod不设置亲和性tolerations\",{\"1\":{\"31\":1}}],[\"如果\",{\"1\":{\"11\":1,\"19\":1,\"26\":1}}],[\"如果允许再利用\",{\"1\":{\"11\":1}}],[\"再利用或删除\",{\"1\":{\"11\":1}}],[\"再次使用\",{\"1\":{\"9\":1}}],[\"释放\",{\"1\":{\"11\":1}}],[\"释放锁的过程性能开销要尽量低\",{\"1\":{\"0\":1}}],[\"释放锁\",{\"1\":{\"0\":1}}],[\"后续请求只需发送差异部分\",{\"1\":{\"108\":1}}],[\"后端将管道运行的运行时信息存储在元数据存储中\",{\"1\":{\"59\":1}}],[\"后端\",{\"1\":{\"59\":1}}],[\"后\",{\"1\":{\"11\":1,\"82\":1}}],[\"被认为不再需要\",{\"1\":{\"11\":1}}],[\"被删除后\",{\"1\":{\"11\":1}}],[\"被绑定到\",{\"1\":{\"11\":1}}],[\"被创建后\",{\"1\":{\"11\":1}}],[\"初始状态\",{\"1\":{\"11\":1}}],[\"状态检查\",{\"1\":{\"29\":1}}],[\"状态图示\",{\"0\":{\"12\":1}}],[\"状态重置为\",{\"1\":{\"11\":1}}],[\"状态变为\",{\"1\":{\"11\":2}}],[\"状态\",{\"1\":{\"11\":1}}],[\"状态转换\",{\"0\":{\"11\":1}}],[\"状态时\",{\"1\":{\"7\":1}}],[\"无头服务\",{\"0\":{\"32\":1}}],[\"无法正常使用\",{\"1\":{\"10\":1}}],[\"无论是管理数据库\",{\"1\":{\"87\":1}}],[\"无论\",{\"1\":{\"0\":1}}],[\"通信以提交\",{\"1\":{\"55\":1}}],[\"通常在集群中运行\",{\"1\":{\"55\":1}}],[\"通常用于有状态应用和自定义服务发现场景\",{\"1\":{\"39\":1}}],[\"通常用于部署有状态应用\",{\"1\":{\"34\":1}}],[\"通常用于以下场景\",{\"1\":{\"28\":1}}],[\"通常用于集群管理工具\",{\"1\":{\"25\":1}}],[\"通常是最合适的选择\",{\"1\":{\"61\":1}}],[\"通常是\",{\"1\":{\"26\":2,\"27\":1}}],[\"通常是因为与\",{\"1\":{\"10\":1}}],[\"通过ip网络传输\",{\"1\":{\"129\":1}}],[\"通过减少广播流量和冲突域\",{\"1\":{\"122\":1}}],[\"通过分割网络减少广播域\",{\"1\":{\"122\":1}}],[\"通过vlan\",{\"1\":{\"122\":1}}],[\"通过这些命令\",{\"1\":{\"120\":1}}],[\"通过grep过滤出veth设备\",{\"1\":{\"116\":1}}],[\"通过多路复用\",{\"1\":{\"113\":1}}],[\"通过https\",{\"1\":{\"111\":1}}],[\"通过http或https\",{\"1\":{\"111\":1}}],[\"通过四个基准测试评估\",{\"1\":{\"101\":1}}],[\"通过动态稀疏注意力加速长上下文\",{\"1\":{\"97\":1}}],[\"通过定义自定义资源和控制器\",{\"1\":{\"87\":1}}],[\"通过创建工具可以实现的标准\",{\"1\":{\"67\":1}}],[\"通过共享的进程命名空间\",{\"1\":{\"60\":1}}],[\"通过标记节点来影响\",{\"1\":{\"31\":1}}],[\"通过限制单个容器或\",{\"1\":{\"19\":1}}],[\"通过设置资源限额\",{\"1\":{\"14\":1}}],[\"通过\",{\"1\":{\"0\":2,\"60\":1,\"61\":1,\"81\":1,\"84\":1}}],[\"上述描述来自\",{\"1\":{\"64\":1}}],[\"上述配置说明pod能够容忍节点设置taint的level=high\",{\"1\":{\"31\":1}}],[\"上的运行详情页面来跟踪运行的进度\",{\"1\":{\"59\":1}}],[\"上的部署变得简单\",{\"1\":{\"42\":1}}],[\"上传你的管道\",{\"1\":{\"53\":1}}],[\"上\",{\"1\":{\"9\":1}}],[\"已从使用\",{\"1\":{\"59\":1}}],[\"已被删除\",{\"1\":{\"9\":1}}],[\"已经运行在这个节点上的\",{\"1\":{\"31\":1}}],[\"已经被删除\",{\"1\":{\"9\":1}}],[\"已经被绑定到一个\",{\"1\":{\"8\":1}}],[\"已经与一个\",{\"1\":{\"8\":1}}],[\"本文主要介绍了独立开发者的相关内容\",{\"1\":{\"133\":2}}],[\"本质上是一个\",{\"1\":{\"82\":1}}],[\"本质是创建了一个\",{\"1\":{\"0\":1}}],[\"本项目中的应用程序\",{\"1\":{\"64\":1}}],[\"本身\",{\"1\":{\"25\":1}}],[\"本身还没有被集群中的任何新\",{\"1\":{\"9\":1}}],[\"但非强制\",{\"1\":{\"114\":1}}],[\"但非加密的http请求仍然普遍存在\",{\"1\":{\"111\":1}}],[\"但在同一时刻只能处理一个请求\",{\"1\":{\"106\":1}}],[\"但\",{\"1\":{\"61\":1}}],[\"但要注意其兼容性问题\",{\"1\":{\"61\":1}}],[\"但如果没有其他合适的节点\",{\"1\":{\"31\":1}}],[\"但它还未被新的\",{\"1\":{\"9\":1}}],[\"但是\",{\"1\":{\"9\":1}}],[\"但pv在挂载时只能使用一种访问模式\",{\"1\":{\"4\":1}}],[\"且正被\",{\"1\":{\"8\":1}}],[\"准备好用于新的\",{\"1\":{\"7\":1}}],[\"还展示了\",{\"1\":{\"101\":1}}],[\"还适用于想要将\",{\"1\":{\"42\":1}}],[\"还是大数据处理集群\",{\"1\":{\"87\":1}}],[\"还是容器\",{\"1\":{\"21\":1}}],[\"还是遭遇网络分区\",{\"1\":{\"0\":1}}],[\"还未与任何\",{\"1\":{\"7\":1}}],[\"绑定\",{\"1\":{\"7\":3,\"8\":2,\"11\":1,\"12\":1}}],[\"处于\",{\"1\":{\"7\":1,\"11\":1}}],[\"可选\",{\"1\":{\"114\":1}}],[\"可选字段\",{\"1\":{\"16\":1}}],[\"可视化服务\",{\"1\":{\"72\":1}}],[\"可视化服务器\",{\"1\":{\"61\":1}}],[\"可扩展性和可移植性\",{\"1\":{\"70\":1}}],[\"可微分架构搜索\",{\"1\":{\"69\":1}}],[\"可用的运行触发器类型包括\",{\"1\":{\"59\":1}}],[\"可移植且可扩展\",{\"1\":{\"42\":1}}],[\"可能无法满足所有应用的需求\",{\"1\":{\"81\":1}}],[\"可能会使用\",{\"1\":{\"28\":1}}],[\"可能会被删除\",{\"1\":{\"11\":1}}],[\"可能需要管理员干预以修复问题\",{\"1\":{\"10\":1}}],[\"可以方便地查看和管理系统中的veth设备对\",{\"1\":{\"120\":1}}],[\"可以先从简单的示例开始\",{\"1\":{\"87\":1}}],[\"可以自动化和简化复杂应用的管理\",{\"1\":{\"87\":1}}],[\"可以自动化复杂应用的部署和管理过程\",{\"1\":{\"83\":1}}],[\"可以管理更复杂的工作负载\",{\"1\":{\"84\":1}}],[\"可以将一个物理网络分割成多个逻辑网络\",{\"1\":{\"122\":1}}],[\"可以将最佳实践和操作流程编码成标准化的流程\",{\"1\":{\"84\":1}}],[\"可以将人类操作员\",{\"1\":{\"80\":1}}],[\"可以监控应用的健康状态\",{\"1\":{\"83\":1}}],[\"可以监控应用的新版本\",{\"1\":{\"83\":1}}],[\"可以定期备份应用的数据\",{\"1\":{\"83\":1}}],[\"可以与任何\",{\"1\":{\"70\":1}}],[\"可以协调更高级的优化工作流\",{\"1\":{\"70\":1}}],[\"可以协调多节点和多gpu的分布式训练工作负载\",{\"1\":{\"70\":1}}],[\"可以考虑\",{\"1\":{\"61\":1}}],[\"可以选择\",{\"1\":{\"61\":1}}],[\"可以防止某些\",{\"1\":{\"31\":1}}],[\"可以应用于节点\",{\"1\":{\"30\":1}}],[\"可以使用以下命令查看特定命名空间中的网络接口\",{\"1\":{\"120\":1}}],[\"可以使用以下命令查看\",{\"1\":{\"119\":1}}],[\"可以使用以下命令查看某个veth设备对的详细信息\",{\"1\":{\"118\":1}}],[\"可以使用以下几种方法\",{\"0\":{\"115\":1}}],[\"可以使用grep过滤出veth设备\",{\"1\":{\"117\":1}}],[\"可以使用\",{\"1\":{\"29\":1}}],[\"可以在ns1命名空间中看到它\",{\"1\":{\"120\":1}}],[\"可以在\",{\"1\":{\"23\":1}}],[\"可以提供默认值\",{\"1\":{\"19\":1}}],[\"可以供新的\",{\"1\":{\"7\":1}}],[\"可以被绑定到\",{\"1\":{\"7\":1}}],[\"可通过\",{\"1\":{\"0\":1}}],[\"描述应用程序元数据的能力\",{\"1\":{\"65\":1}}],[\"描述在给定组件输入参数值的情况下如何运行组件的规范\",{\"1\":{\"56\":1}}],[\"描述等\",{\"1\":{\"56\":1}}],[\"描述\",{\"1\":{\"7\":1,\"8\":1,\"9\":1,\"10\":1,\"56\":1}}],[\"以优化管道的执行效率和资源管理\",{\"1\":{\"61\":1}}],[\"以限制并行启动的运行数量\",{\"1\":{\"59\":1}}],[\"以便于重现\",{\"1\":{\"59\":1}}],[\"以便数据可以在分布式网络上传输\",{\"1\":{\"57\":1}}],[\"以图的形式呈现\",{\"1\":{\"53\":1}}],[\"以及每个组件的输入和输出\",{\"1\":{\"53\":1}}],[\"以及对象数量\",{\"1\":{\"15\":1}}],[\"以及它是否能够被持久卷声明\",{\"1\":{\"6\":1}}],[\"以下是对它们的解析\",{\"1\":{\"121\":1}}],[\"以下是对这两者的详细介绍\",{\"1\":{\"12\":1}}],[\"以下是我的专业技能和经验介绍\",{\"1\":{\"90\":1}}],[\"以下是它们之间的一些主要关联关系\",{\"1\":{\"61\":1}}],[\"以下是一个使用\",{\"1\":{\"36\":1}}],[\"以下是一个示例\",{\"1\":{\"27\":1}}],[\"以下是一个\",{\"1\":{\"15\":1,\"20\":1,\"35\":1}}],[\"以下是状态转换的示意图\",{\"1\":{\"12\":1}}],[\"以下是\",{\"1\":{\"6\":1,\"104\":1}}],[\"中间加个具有号召性的按钮\",{\"1\":{\"133\":2}}],[\"中一个不断循环检查资源实际状态并使其符合预期状态的逻辑组件\",{\"1\":{\"81\":1}}],[\"中引入新的资源类型\",{\"1\":{\"81\":1}}],[\"中创建\",{\"1\":{\"67\":1}}],[\"中创建和管理元数据\",{\"1\":{\"61\":1}}],[\"中称为作业\",{\"1\":{\"59\":1}}],[\"中的稀疏索引\",{\"1\":{\"101\":1}}],[\"中的元数据管理\",{\"1\":{\"61\":1}}],[\"中的各个核心组件\",{\"1\":{\"61\":1}}],[\"中的各个步骤\",{\"1\":{\"53\":1}}],[\"中的自定义资源定义\",{\"1\":{\"61\":1}}],[\"中的定时任务\",{\"1\":{\"61\":1}}],[\"中的图形表示\",{\"1\":{\"58\":1}}],[\"中的某一步骤\",{\"1\":{\"54\":1}}],[\"中的数据库分片或有状态应用\",{\"1\":{\"33\":1}}],[\"中的一种特殊服务类型\",{\"1\":{\"39\":1}}],[\"中的一种特殊类型的\",{\"1\":{\"25\":1}}],[\"中的一种机制\",{\"1\":{\"30\":1}}],[\"中的\",{\"1\":{\"26\":1}}],[\"中用于限制命名空间内单个\",{\"1\":{\"18\":1}}],[\"中用来限制命名空间\",{\"1\":{\"13\":1}}],[\"中\",{\"1\":{\"6\":2,\"31\":1,\"32\":1,\"39\":1,\"53\":1,\"54\":1,\"58\":1,\"64\":1}}],[\"在实践的过程中\",{\"1\":{\"133\":2}}],[\"在以太网帧中添加一个4字节的标签\",{\"1\":{\"122\":1}}],[\"在一个连接上\",{\"1\":{\"107\":1}}],[\"在一些简化的集群管理方案中\",{\"1\":{\"28\":1}}],[\"在不同模型和方法对比中性能良好\",{\"1\":{\"101\":1}}],[\"在不同环境中设置不同的限制\",{\"1\":{\"22\":1}}],[\"在问答\",{\"1\":{\"101\":1}}],[\"在成本效率和系统延迟方面表现出色\",{\"1\":{\"101\":1}}],[\"在推理中动态近似动态稀疏索引\",{\"1\":{\"101\":1}}],[\"在这个\",{\"1\":{\"75\":1}}],[\"在这个例子中\",{\"1\":{\"38\":1}}],[\"在配置\",{\"1\":{\"61\":1}}],[\"在某些\",{\"1\":{\"60\":1}}],[\"在某些情况下\",{\"1\":{\"34\":1}}],[\"在复杂的管道中\",{\"1\":{\"59\":1}}],[\"在那里你可以看到运行时的图表\",{\"1\":{\"59\":1}}],[\"在高层次上\",{\"1\":{\"44\":1}}],[\"在节点上运行的条件\",{\"1\":{\"30\":2}}],[\"在集群启动或恢复过程中\",{\"1\":{\"28\":1}}],[\"在命名空间内强制执行资源使用标准\",{\"1\":{\"22\":1}}],[\"在共享集群中\",{\"1\":{\"17\":1}}],[\"在操作过程中遇到错误\",{\"1\":{\"10\":1}}],[\"在生命周期中的位置\",{\"1\":{\"6\":1}}],[\"在\",{\"1\":{\"6\":1,\"12\":1,\"31\":1,\"32\":1,\"53\":1,\"54\":1,\"58\":1}}],[\"在同一时间内\",{\"1\":{\"0\":1}}],[\"aka\",{\"1\":{\"133\":2}}],[\"a\",{\"1\":{\"120\":1}}],[\"address\",{\"1\":{\"128\":1}}],[\"add\",{\"1\":{\"119\":1}}],[\"adaptation\",{\"1\":{\"69\":1}}],[\"alive\",{\"1\":{\"106\":1}}],[\"a100\",{\"1\":{\"101\":1}}],[\"authservice\",{\"1\":{\"72\":1,\"75\":1}}],[\"automl\",{\"1\":{\"69\":3,\"70\":1}}],[\"amazon\",{\"1\":{\"69\":1}}],[\"azure\",{\"1\":{\"69\":1}}],[\"azuredisk和cinder类型的pv支持delete策略\",{\"1\":{\"5\":1}}],[\"ai\",{\"1\":{\"69\":1,\"70\":1}}],[\"ago\",{\"1\":{\"61\":1}}],[\"age\",{\"1\":{\"31\":1,\"61\":1}}],[\"architecture\",{\"1\":{\"69\":2}}],[\"argo\",{\"0\":{\"60\":1},\"1\":{\"59\":3,\"61\":2,\"70\":1}}],[\"args\",{\"1\":{\"31\":1}}],[\"artifact\",{\"1\":{\"59\":1}}],[\"artifacts\",{\"1\":{\"50\":1}}],[\"area\",{\"0\":{\"122\":1},\"1\":{\"121\":1}}],[\"are\",{\"1\":{\"31\":2}}],[\"application\",{\"1\":{\"62\":3,\"63\":1}}],[\"app\",{\"1\":{\"31\":2,\"35\":4,\"37\":2,\"38\":7,\"62\":1}}],[\"apps\",{\"1\":{\"31\":1,\"38\":1,\"62\":1}}],[\"apiv2beta1\",{\"1\":{\"73\":4}}],[\"apiv1beta1\",{\"1\":{\"72\":8}}],[\"apiversion\",{\"1\":{\"15\":1,\"20\":1,\"27\":1,\"31\":1,\"35\":1,\"37\":1,\"38\":1,\"62\":1}}],[\"api服务器以创建运行管道所需的必要kubernetes资源\",{\"1\":{\"48\":1}}],[\"apiserver\",{\"1\":{\"25\":1,\"28\":1,\"61\":1}}],[\"api\",{\"0\":{\"72\":1,\"73\":1},\"1\":{\"25\":1,\"26\":2,\"28\":1,\"55\":1,\"59\":1,\"60\":1,\"61\":2,\"67\":2,\"80\":1,\"82\":1,\"86\":1}}],[\"available\",{\"1\":{\"7\":1,\"11\":2,\"12\":2,\"31\":2}}],[\"awselasticblockstore\",{\"1\":{\"5\":1}}],[\"access\",{\"0\":{\"4\":1}}],[\"acquired\",{\"1\":{\"0\":1}}],[\"acquire\",{\"1\":{\"0\":1}}],[\"回收策略\",{\"0\":{\"5\":1}}],[\"某些pv可能支持多种访问模式\",{\"1\":{\"4\":1}}],[\"载\",{\"1\":{\"4\":1}}],[\"并附加上对应的vni\",{\"1\":{\"129\":1}}],[\"并通过多种实验和测试展示了其效果\",{\"1\":{\"100\":1}}],[\"并在出现故障时自动进行恢复\",{\"1\":{\"83\":1}}],[\"并自动执行无中断的滚动升级\",{\"1\":{\"83\":1}}],[\"并根据用户定义的逻辑执行相应的操作\",{\"1\":{\"82\":1}}],[\"并根据这些文件创建和管理\",{\"1\":{\"26\":1}}],[\"并进行相应的标注\",{\"1\":{\"58\":1}}],[\"并将以太网帧发送到其二层网络接口\",{\"1\":{\"128\":1}}],[\"并将这些资源的状态持久化到ml元数据服务中\",{\"1\":{\"51\":1}}],[\"并将流量从服务的\",{\"1\":{\"35\":1}}],[\"并为每个\",{\"1\":{\"39\":1}}],[\"并且支持不同版本的api\",{\"1\":{\"75\":1}}],[\"并且本身支持许多\",{\"1\":{\"69\":1}}],[\"并且希望与其他工具\",{\"1\":{\"66\":1}}],[\"并且你的集群配置支持\",{\"1\":{\"61\":1}}],[\"并且允许直接访问每个\",{\"1\":{\"32\":1}}],[\"并且只能被单个node挂\",{\"1\":{\"4\":1}}],[\"并指定一个键值对\",{\"1\":{\"30\":1}}],[\"并获取到\",{\"1\":{\"0\":1}}],[\"读写权限\",{\"1\":{\"4\":2}}],[\"访问模式\",{\"0\":{\"4\":1}}],[\"keep\",{\"1\":{\"106\":1}}],[\"kernel\",{\"1\":{\"101\":1}}],[\"key\",{\"1\":{\"0\":8,\"31\":2}}],[\"kv\",{\"1\":{\"101\":1}}],[\"kudo\",{\"1\":{\"86\":1}}],[\"kubebuilder\",{\"1\":{\"86\":1}}],[\"kubeflow\",{\"0\":{\"42\":1},\"1\":{\"42\":7,\"43\":2,\"50\":2,\"53\":3,\"54\":1,\"56\":1,\"58\":2,\"59\":9,\"60\":2,\"61\":18,\"70\":2,\"93\":1},\"2\":{\"79\":1}}],[\"kubectl\",{\"1\":{\"29\":2,\"31\":2,\"61\":1,\"67\":1,\"82\":1}}],[\"kube\",{\"1\":{\"25\":3,\"27\":1,\"28\":3,\"29\":1,\"62\":1}}],[\"kubelet\",{\"1\":{\"25\":1,\"26\":4,\"27\":1,\"29\":2}}],[\"kubernetes\",{\"0\":{\"64\":1},\"1\":{\"6\":2,\"12\":1,\"13\":1,\"18\":1,\"23\":1,\"25\":4,\"26\":1,\"27\":3,\"28\":5,\"29\":1,\"30\":1,\"31\":3,\"32\":2,\"33\":1,\"34\":1,\"39\":1,\"42\":3,\"43\":2,\"53\":1,\"60\":2,\"61\":4,\"62\":1,\"63\":1,\"64\":3,\"67\":2,\"69\":1,\"70\":1,\"80\":4,\"81\":4,\"82\":1,\"84\":3,\"86\":2,\"87\":3,\"92\":1}}],[\"kubernetes支持的回收策略如下\",{\"1\":{\"5\":1}}],[\"kubernetes支持的访问模式如下\",{\"1\":{\"4\":1}}],[\"k8r6z\",{\"1\":{\"61\":2}}],[\"k8sapiexecutor\",{\"1\":{\"60\":1,\"61\":2}}],[\"k8s技能图谱\",{\"0\":{\"24\":1}}],[\"k8s\",{\"0\":{\"80\":1},\"1\":{\"3\":1,\"12\":1,\"42\":1,\"62\":3,\"92\":1},\"2\":{\"40\":1}}],[\"k8s知识点\",{\"0\":{\"3\":1}}],[\"katib\",{\"0\":{\"69\":1,\"70\":1},\"1\":{\"61\":19,\"69\":5,\"70\":10}}],[\"kind\",{\"1\":{\"15\":1,\"20\":1,\"27\":1,\"31\":1,\"35\":1,\"37\":1,\"38\":1,\"62\":1}}],[\"避免单点故障\",{\"1\":{\"0\":1}}],[\"高扩展性\",{\"1\":{\"124\":1}}],[\"高效神经架构搜索\",{\"1\":{\"69\":1}}],[\"高性能\",{\"1\":{\"0\":1}}],[\"高可用\",{\"1\":{\"0\":1}}],[\"出现\",{\"1\":{\"0\":1}}],[\"活性\",{\"1\":{\"0\":1}}],[\"不积极才是常态\",{\"1\":{\"133\":2}}],[\"不做完美的产品\",{\"1\":{\"133\":2}}],[\"不做免费的产品\",{\"1\":{\"133\":2}}],[\"不支持\",{\"1\":{\"114\":4}}],[\"不仅仅是基础设施视图\",{\"1\":{\"66\":1}}],[\"不同的流可以独立处理\",{\"1\":{\"107\":1}}],[\"不同\",{\"1\":{\"33\":1}}],[\"不会相互阻塞\",{\"1\":{\"107\":1}}],[\"不会为服务分配一个\",{\"1\":{\"33\":1}}],[\"不会分配集群\",{\"1\":{\"32\":1}}],[\"不会被调度到这个节点上\",{\"1\":{\"31\":1}}],[\"不会出现\",{\"1\":{\"0\":1}}],[\"不能依赖于\",{\"1\":{\"28\":1}}],[\"不是通过\",{\"1\":{\"26\":1}}],[\"不需要\",{\"1\":{\"26\":1}}],[\"不允许多个\",{\"1\":{\"0\":1}}],[\"互斥性\",{\"1\":{\"0\":1}}],[\"安全性和管理灵活性\",{\"1\":{\"125\":1}}],[\"安全性\",{\"1\":{\"0\":1}}],[\"它将帧封装在udp包中\",{\"1\":{\"128\":1}}],[\"它的主要特点和用途如下\",{\"1\":{\"122\":1,\"123\":1}}],[\"它包括了\",{\"1\":{\"82\":1}}],[\"它可以调优用任何用户选择的语言编写的应用程序的超参数\",{\"1\":{\"69\":1}}],[\"它提供了\",{\"0\":{\"65\":1}}],[\"它会定期启动运行配置的新副本\",{\"1\":{\"59\":1}}],[\"它会创建一个\",{\"1\":{\"0\":1}}],[\"它执行机器学习\",{\"1\":{\"54\":1}}],[\"它编排基于任务的工作流\",{\"1\":{\"49\":1}}],[\"它通过不分配\",{\"1\":{\"39\":1}}],[\"它通过将\",{\"1\":{\"33\":1}}],[\"它与\",{\"1\":{\"38\":1}}],[\"它选择了带有标签\",{\"1\":{\"35\":1}}],[\"它由\",{\"1\":{\"25\":1}}],[\"它为容器设置了\",{\"1\":{\"20\":1}}],[\"它限制了某个命名空间内的\",{\"1\":{\"15\":1}}],[\"它们各自有不同的优缺点和应用场景\",{\"1\":{\"125\":1}}],[\"它们各自有不同的应用场景和特点\",{\"1\":{\"121\":1}}],[\"它们将其软件包发布集中在应用程序安装上\",{\"1\":{\"66\":1}}],[\"它们共同组成了\",{\"1\":{\"61\":1}}],[\"它们帮助管理员公平分配集群资源\",{\"1\":{\"14\":1}}],[\"它们帮助管理员确保资源的公平分配和高效利用\",{\"1\":{\"12\":1}}],[\"它们用于防止某个命名空间消耗过多的集群资源\",{\"1\":{\"13\":1}}],[\"它不能再被其他\",{\"1\":{\"8\":1}}],[\"它未被任何\",{\"1\":{\"7\":1}}],[\"它反映了存储卷的当前状态\",{\"1\":{\"6\":1}}],[\"它一定是持久化到了集群多数节点上\",{\"1\":{\"0\":1}}],[\"因为它们可以用于性能评估\",{\"1\":{\"59\":1}}],[\"因为只有\",{\"1\":{\"0\":1}}],[\"因此\",{\"1\":{\"59\":1}}],[\"因此它们的一些管理和监控操作与普通\",{\"1\":{\"29\":1}}],[\"因此它们没有自动伸缩\",{\"1\":{\"26\":1}}],[\"因此非常适合用于管理集群的核心组件\",{\"1\":{\"26\":1}}],[\"因此一旦分布式锁申请返回给\",{\"1\":{\"0\":1}}],[\"random\",{\"1\":{\"69\":1}}],[\"raft\",{\"1\":{\"0\":1}}],[\"rgmgf\",{\"1\":{\"61\":2}}],[\"root\",{\"1\":{\"61\":1}}],[\"rox\",{\"1\":{\"4\":1}}],[\"runs创建过程是\",{\"1\":{\"77\":1}}],[\"runservice\",{\"1\":{\"72\":1,\"73\":1,\"75\":1}}],[\"run\",{\"1\":{\"59\":2}}],[\"running\",{\"1\":{\"58\":1,\"61\":13}}],[\"rwx\",{\"1\":{\"4\":1}}],[\"rwo\",{\"1\":{\"4\":1}}],[\"reflection\",{\"1\":{\"74\":1}}],[\"reflectionservice\",{\"1\":{\"74\":1,\"75\":1}}],[\"reportservice\",{\"1\":{\"72\":1,\"75\":1}}],[\"replicas\",{\"1\":{\"31\":1,\"38\":1}}],[\"replicaset\",{\"1\":{\"26\":2,\"61\":1}}],[\"register\",{\"1\":{\"74\":1}}],[\"registerauthserviceserver\",{\"1\":{\"72\":1}}],[\"registervisualizationserviceserver\",{\"1\":{\"72\":1}}],[\"registerrecurringrunserviceserver\",{\"1\":{\"73\":1}}],[\"registerreportserviceserver\",{\"1\":{\"72\":1}}],[\"registerrunserviceserver\",{\"1\":{\"72\":1,\"73\":1}}],[\"registertaskserviceserver\",{\"1\":{\"72\":1}}],[\"registerjobserviceserver\",{\"1\":{\"72\":1}}],[\"registerpipelineserviceserver\",{\"1\":{\"72\":1,\"73\":1}}],[\"registerexperimentserviceserver\",{\"1\":{\"72\":1,\"73\":1}}],[\"registry\",{\"1\":{\"31\":1,\"61\":1}}],[\"resolution\",{\"1\":{\"128\":1}}],[\"resource\",{\"1\":{\"81\":2}}],[\"resourcemanager\",{\"1\":{\"72\":4}}],[\"resources\",{\"1\":{\"31\":1,\"62\":1}}],[\"resourcequota\",{\"1\":{\"15\":2,\"16\":1}}],[\"resourcequotas\",{\"0\":{\"13\":1},\"1\":{\"12\":1,\"13\":1,\"14\":1,\"18\":1,\"23\":1}}],[\"restarts\",{\"1\":{\"61\":1}}],[\"reason\",{\"1\":{\"31\":1}}],[\"ready\",{\"1\":{\"31\":1,\"61\":1}}],[\"readwritemany\",{\"1\":{\"4\":1}}],[\"readwriteonce\",{\"1\":{\"4\":1}}],[\"readonlymany\",{\"1\":{\"4\":1}}],[\"requests\",{\"1\":{\"15\":2,\"31\":1,\"62\":1}}],[\"recurringrunservice\",{\"1\":{\"73\":1,\"75\":1}}],[\"recurring\",{\"1\":{\"59\":1}}],[\"recycle\",{\"1\":{\"5\":1}}],[\"reclaim\",{\"0\":{\"5\":1}}],[\"retain\",{\"1\":{\"5\":1}}],[\"redis\",{\"1\":{\"0\":2,\"92\":1}}],[\"release\",{\"1\":{\"0\":1}}],[\"released\",{\"1\":{\"0\":1,\"11\":1,\"12\":1}}],[\"revisions\",{\"1\":{\"0\":1}}],[\"revision\",{\"1\":{\"0\":3}}],[\"是两种用于网络分段和虚拟化的技术\",{\"1\":{\"121\":1}}],[\"是两种用于资源管理和控制的机制\",{\"1\":{\"12\":1}}],[\"是对\",{\"1\":{\"104\":1}}],[\"是对管道的单次执行\",{\"1\":{\"59\":1}}],[\"是可扩展和可移植的\",{\"1\":{\"70\":1}}],[\"是由管道组件发出的输出\",{\"1\":{\"59\":1}}],[\"是管道中某个组件的执行\",{\"1\":{\"59\":1}}],[\"是管道的可重复运行\",{\"1\":{\"59\":1}}],[\"是管道运行时在\",{\"1\":{\"58\":1}}],[\"是用于节点管理的机制\",{\"1\":{\"31\":1}}],[\"是应用在节点上的属性\",{\"1\":{\"31\":1}}],[\"是集群稳定运行的关键保障之一\",{\"1\":{\"29\":1}}],[\"是\",{\"1\":{\"25\":1,\"29\":1,\"30\":1,\"39\":1,\"43\":1,\"61\":3,\"81\":1}}],[\"是一个与机器学习\",{\"1\":{\"69\":1}}],[\"是一个原生于\",{\"1\":{\"69\":1}}],[\"是一个开源系统\",{\"1\":{\"64\":1}}],[\"是一个好的选择\",{\"1\":{\"61\":1}}],[\"是一个面向想要构建和试验\",{\"1\":{\"42\":1}}],[\"是一个\",{\"1\":{\"38\":1}}],[\"是一个集群级别的资源\",{\"1\":{\"6\":1}}],[\"是一种强大的工具\",{\"1\":{\"87\":1}}],[\"是一种软件扩展\",{\"1\":{\"80\":1}}],[\"是一种特殊类型的\",{\"1\":{\"32\":1}}],[\"是一种在\",{\"1\":{\"13\":1,\"18\":1}}],[\"是基于\",{\"1\":{\"0\":1}}],[\"是如何等待的呢\",{\"1\":{\"0\":1}}],[\"相对于\",{\"1\":{\"104\":1}}],[\"相关的存储设备出现了错误或问题\",{\"1\":{\"10\":1}}],[\"相比\",{\"1\":{\"0\":1}}],[\"相同\",{\"1\":{\"0\":1}}],[\"去监听比自己小的\",{\"1\":{\"0\":1}}],[\"peer\",{\"1\":{\"119\":1}}],[\"persistenceagent\",{\"1\":{\"61\":3}}],[\"persistentvolumeclaim\",{\"1\":{\"6\":1}}],[\"persistentvolume\",{\"1\":{\"6\":1}}],[\"periodic\",{\"1\":{\"59\":1}}],[\"parzen\",{\"1\":{\"69\":1}}],[\"plane\",{\"1\":{\"62\":3}}],[\"pnsexecutor\",{\"1\":{\"60\":1,\"61\":2}}],[\"pytorchjob\",{\"1\":{\"70\":1}}],[\"pytorch\",{\"1\":{\"69\":1}}],[\"python\",{\"0\":{\"45\":1},\"1\":{\"31\":1,\"91\":1}}],[\"python3\",{\"1\":{\"31\":1}}],[\"py\",{\"1\":{\"55\":1}}],[\"pipeline创建流程\",{\"0\":{\"76\":1}}],[\"pipeline服务注册流程\",{\"0\":{\"71\":1}}],[\"pipelineservice\",{\"1\":{\"72\":1,\"73\":1,\"75\":1}}],[\"pipelines\",{\"1\":{\"53\":3,\"54\":1,\"56\":1,\"58\":2,\"59\":8,\"60\":2,\"61\":15,\"70\":1}}],[\"pipelines将工件存储在像minio服务器或cloud\",{\"1\":{\"50\":1}}],[\"pipelines将元数据存储在mysql数据库中\",{\"1\":{\"50\":1}}],[\"pipelines特定领域语言\",{\"1\":{\"45\":1}}],[\"pipeline\",{\"0\":{\"44\":1,\"53\":1},\"1\":{\"61\":24,\"62\":1}}],[\"po\",{\"1\":{\"61\":1}}],[\"port\",{\"1\":{\"35\":1,\"37\":1}}],[\"ports\",{\"1\":{\"27\":1,\"31\":1,\"35\":1,\"37\":1,\"38\":1}}],[\"pod存储两种类型的数据\",{\"1\":{\"50\":1}}],[\"pod中执行\",{\"1\":{\"49\":1}}],[\"pod设置toleration\",{\"1\":{\"31\":1}}],[\"pods\",{\"1\":{\"15\":1}}],[\"pod\",{\"0\":{\"26\":1,\"27\":1},\"1\":{\"15\":2,\"18\":2,\"19\":3,\"21\":1,\"23\":1,\"25\":3,\"26\":6,\"27\":6,\"28\":3,\"29\":9,\"30\":2,\"31\":8,\"32\":2,\"33\":6,\"34\":1,\"35\":2,\"38\":1,\"39\":2,\"53\":3,\"59\":1,\"61\":18,\"81\":1}}],[\"policy\",{\"0\":{\"5\":1}}],[\"pvc\",{\"1\":{\"6\":1,\"7\":5,\"8\":4,\"9\":4,\"11\":4,\"12\":2}}],[\"pv\",{\"0\":{\"6\":1},\"1\":{\"6\":4,\"7\":3,\"8\":2,\"9\":3,\"10\":3,\"11\":7}}],[\"pfx\",{\"1\":{\"0\":1}}],[\"prometheus\",{\"1\":{\"85\":3}}],[\"process\",{\"1\":{\"60\":1}}],[\"protocol\",{\"1\":{\"31\":1,\"128\":1}}],[\"preemption\",{\"1\":{\"31\":2}}],[\"preferred\",{\"1\":{\"120\":2}}],[\"prefernoschedule\",{\"1\":{\"31\":1}}],[\"prefix\",{\"1\":{\"0\":4}}],[\"prior\",{\"1\":{\"0\":1}}],[\"println\",{\"1\":{\"0\":2}}],[\"wordpress\",{\"1\":{\"65\":1}}],[\"workflow\",{\"1\":{\"61\":3}}],[\"workflows\",{\"1\":{\"59\":1,\"61\":1,\"70\":1}}],[\"workflow控制器\",{\"1\":{\"49\":1}}],[\"web\",{\"1\":{\"61\":4}}],[\"werr\",{\"1\":{\"0\":2}}],[\"writer\",{\"1\":{\"61\":4}}],[\"www\",{\"1\":{\"42\":1}}],[\"warning\",{\"1\":{\"31\":1}}],[\"wangshi\",{\"1\":{\"31\":1}}],[\"watch\",{\"1\":{\"0\":2}}],[\"waitdelete\",{\"1\":{\"0\":1}}],[\"waitdeletes\",{\"1\":{\"0\":1}}],[\"wait\",{\"1\":{\"0\":2}}],[\"withttl\",{\"1\":{\"0\":1}}],[\"未获得锁的\",{\"1\":{\"0\":1}}],[\"最好有以下几方面准备\",{\"1\":{\"133\":2}}],[\"最后做数据分析\",{\"1\":{\"133\":2}}],[\"最后使用结束\",{\"1\":{\"0\":1}}],[\"最多1600万个\",{\"1\":{\"124\":1}}],[\"最多4094个vlan\",{\"1\":{\"124\":1}}],[\"最多4094个\",{\"1\":{\"124\":1}}],[\"最小限制\",{\"1\":{\"23\":1}}],[\"最小值\",{\"1\":{\"20\":1}}],[\"最小\",{\"1\":{\"0\":1}}],[\"404\",{\"1\":{\"136\":1}}],[\"47d2\",{\"1\":{\"120\":1}}],[\"47\",{\"1\":{\"120\":2}}],[\"4\",{\"0\":{\"10\":1,\"108\":1},\"1\":{\"0\":1,\"15\":1}}],[\"其主要功能包括\",{\"1\":{\"128\":1}}],[\"其主要特性包括\",{\"1\":{\"127\":1}}],[\"其中\",{\"1\":{\"0\":1}}],[\"其他服务注册在\",{\"1\":{\"71\":1}}],[\"其他\",{\"0\":{\"74\":1},\"1\":{\"0\":1}}],[\"其次得到\",{\"1\":{\"0\":1}}],[\"获得锁\",{\"1\":{\"0\":1}}],[\"获得\",{\"1\":{\"0\":1}}],[\"+\",{\"1\":{\"0\":1}}],[\"时间序列\",{\"1\":{\"50\":1}}],[\"时合理设置资源请求和限制\",{\"1\":{\"19\":1}}],[\"时\",{\"1\":{\"0\":1,\"61\":1}}],[\"00\",{\"1\":{\"120\":24}}],[\"0\",{\"1\":{\"0\":1,\"31\":2,\"38\":1,\"61\":12,\"62\":3,\"106\":1,\"120\":2}}],[\"当你的产品完成了最小\",{\"1\":{\"133\":2}}],[\"当你运行一个管道时\",{\"1\":{\"53\":1}}],[\"当主机a发送一个以太网帧给主机b时\",{\"1\":{\"129\":1}}],[\"当vtep接收到来自二层网络的以太网帧时\",{\"1\":{\"128\":1}}],[\"当客户端请求html页面时\",{\"1\":{\"109\":1}}],[\"当节点的父节点包含条件语句时\",{\"1\":{\"58\":1}}],[\"当前运行的管道列表\",{\"1\":{\"52\":1}}],[\"当\",{\"1\":{\"0\":1}}],[\"方法释放锁\",{\"1\":{\"0\":1}}],[\"方法尝试获取锁\",{\"1\":{\"0\":1}}],[\"方法创建\",{\"1\":{\"0\":1}}],[\"30mi\",{\"1\":{\"62\":1}}],[\"300s\",{\"1\":{\"31\":2}}],[\"3m57s\",{\"1\":{\"31\":1}}],[\"3\",{\"0\":{\"9\":1,\"107\":1},\"1\":{\"0\":1,\"31\":1,\"38\":1}}],[\"24位vni\",{\"1\":{\"124\":1}}],[\"24\",{\"1\":{\"120\":1}}],[\"28\",{\"1\":{\"120\":2}}],[\"20mi\",{\"1\":{\"62\":1}}],[\"20231101\",{\"1\":{\"62\":1}}],[\"2022\",{\"1\":{\"60\":1}}],[\"256mi\",{\"1\":{\"20\":1,\"31\":1}}],[\"250m\",{\"1\":{\"20\":1}}],[\"2\",{\"0\":{\"8\":1,\"106\":1},\"1\":{\"0\":1,\"60\":1,\"104\":2,\"105\":1,\"106\":1,\"107\":1,\"108\":1,\"109\":1,\"110\":2,\"111\":2,\"112\":2,\"113\":2,\"114\":2,\"120\":1}}],[\"lft\",{\"1\":{\"120\":4}}],[\"llm\",{\"1\":{\"97\":1,\"100\":1,\"101\":2}}],[\"link\",{\"1\":{\"116\":2,\"118\":1,\"119\":2,\"120\":9}}],[\"lineage\",{\"1\":{\"59\":1}}],[\"limitrange\",{\"1\":{\"20\":2}}],[\"limitranges\",{\"0\":{\"18\":1},\"1\":{\"12\":1,\"18\":2,\"19\":1,\"23\":1}}],[\"limits\",{\"1\":{\"15\":2,\"20\":2,\"31\":1,\"62\":1}}],[\"lan\",{\"0\":{\"123\":1,\"127\":1},\"1\":{\"121\":1}}],[\"labels\",{\"1\":{\"31\":1,\"38\":1,\"62\":2}}],[\"latest\",{\"1\":{\"27\":1}}],[\"levelsio\",{\"1\":{\"133\":2}}],[\"level\",{\"1\":{\"31\":2}}],[\"level=high\",{\"1\":{\"31\":2}}],[\"leaseid\",{\"1\":{\"0\":1}}],[\"lease\",{\"1\":{\"0\":2}}],[\"loopback\",{\"1\":{\"120\":2}}],[\"lo\",{\"1\":{\"120\":2}}],[\"lower\",{\"1\":{\"119\":2,\"120\":2}}],[\"local\",{\"0\":{\"122\":1},\"1\":{\"38\":1,\"121\":1}}],[\"lock\",{\"1\":{\"0\":11}}],[\"logs\",{\"1\":{\"29\":1}}],[\"log\",{\"1\":{\"0\":4}}],[\"的时候\",{\"1\":{\"133\":2}}],[\"的一些关键区别和改进\",{\"1\":{\"104\":1}}],[\"的微基准测试结果\",{\"1\":{\"101\":1}}],[\"的主要贡献\",{\"1\":{\"101\":1}}],[\"的提出背景\",{\"1\":{\"101\":1}}],[\"的动态稀疏注意力方法\",{\"1\":{\"100\":1}}],[\"的预填充阶段多达\",{\"1\":{\"101\":1}}],[\"的预填充\",{\"1\":{\"97\":1}}],[\"的管理能力\",{\"1\":{\"87\":1}}],[\"的管理能力扩展到了自定义应用领域\",{\"1\":{\"84\":1}}],[\"的开发过程\",{\"1\":{\"86\":1}}],[\"的工作流程\",{\"0\":{\"129\":1}}],[\"的工作原理\",{\"0\":{\"82\":1},\"1\":{\"101\":1}}],[\"的工具\",{\"0\":{\"86\":1}}],[\"的示例\",{\"0\":{\"85\":1}}],[\"的能力\",{\"1\":{\"84\":1}}],[\"的优势\",{\"0\":{\"84\":1}}],[\"的应用场景\",{\"0\":{\"83\":1}}],[\"的内置资源\",{\"1\":{\"81\":1}}],[\"的基本概念\",{\"0\":{\"81\":1}}],[\"的操作自动化\",{\"1\":{\"80\":1}}],[\"的训练操作\",{\"1\":{\"70\":1}}],[\"的自动化机器学习\",{\"1\":{\"69\":1}}],[\"的根对象\",{\"1\":{\"65\":1}}],[\"的元数据\",{\"1\":{\"64\":1}}],[\"的各个组件通过数据库和控制器进行通信和协调\",{\"1\":{\"61\":1}}],[\"的可视化服务\",{\"1\":{\"61\":1}}],[\"的展示\",{\"1\":{\"61\":1}}],[\"的持久化存储\",{\"1\":{\"61\":1}}],[\"的核心组件之一\",{\"1\":{\"61\":1}}],[\"的数据库\",{\"1\":{\"61\":1}}],[\"的控制器组件之一\",{\"1\":{\"61\":1}}],[\"的控制器组件\",{\"1\":{\"61\":1}}],[\"的功能简介\",{\"1\":{\"61\":1}}],[\"的默认执行器\",{\"1\":{\"60\":1}}],[\"的任务\",{\"1\":{\"55\":1}}],[\"的定义\",{\"1\":{\"53\":1}}],[\"的定义示例\",{\"0\":{\"35\":1}}],[\"的场景\",{\"1\":{\"39\":1}}],[\"的结合\",{\"0\":{\"36\":1}}],[\"的服务\",{\"1\":{\"35\":1}}],[\"的详细介绍\",{\"1\":{\"32\":1}}],[\"的每个\",{\"1\":{\"32\":1}}],[\"的调度\",{\"1\":{\"31\":1}}],[\"的作用方式\",{\"1\":{\"31\":1}}],[\"的具体值\",{\"1\":{\"31\":1}}],[\"的名称\",{\"1\":{\"31\":1}}],[\"的日志\",{\"1\":{\"29\":1}}],[\"的故障而丢失\",{\"1\":{\"26\":1}}],[\"的配置是静态文件\",{\"1\":{\"26\":1}}],[\"的参与\",{\"1\":{\"26\":1}}],[\"的特点\",{\"0\":{\"26\":1,\"33\":1}}],[\"的部署和管理\",{\"1\":{\"25\":1}}],[\"的资源使用\",{\"1\":{\"19\":1}}],[\"的整体限制不同\",{\"1\":{\"18\":1}}],[\"的总数量\",{\"1\":{\"15\":2}}],[\"的状态\",{\"1\":{\"29\":1}}],[\"的状态转换通常遵循以下过程\",{\"1\":{\"11\":1}}],[\"的状态由其\",{\"1\":{\"6\":1}}],[\"的几种可能的状态\",{\"1\":{\"6\":1}}],[\"的\",{\"1\":{\"0\":3,\"15\":1,\"20\":1,\"35\":3,\"36\":1,\"43\":1,\"61\":3,\"66\":1}}],[\"为什么要做独立开发者\",{\"1\":{\"133\":4}}],[\"为什么选择\",{\"0\":{\"70\":1}}],[\"为什么使用etcd分布式锁比redis分布式锁更好\",{\"1\":{\"0\":1}}],[\"为支持应用程序提供信息\",{\"1\":{\"65\":1}}],[\"为\",{\"1\":{\"0\":3}}],[\"首先通过\",{\"1\":{\"0\":1}}],[\"1q\",{\"1\":{\"124\":1}}],[\"1q标准\",{\"1\":{\"122\":1}}],[\"12位vlan\",{\"1\":{\"124\":1}}],[\"128mi\",{\"1\":{\"20\":1,\"31\":1}}],[\"168\",{\"1\":{\"120\":1}}],[\"16gi\",{\"1\":{\"15\":1}}],[\"192\",{\"1\":{\"120\":1}}],[\"11\",{\"1\":{\"119\":1}}],[\"1500\",{\"1\":{\"119\":2,\"120\":2}}],[\"13\",{\"1\":{\"75\":1}}],[\"17h\",{\"1\":{\"61\":14}}],[\"1gi\",{\"1\":{\"20\":1}}],[\"1\",{\"0\":{\"7\":1,\"105\":1},\"1\":{\"0\":2,\"20\":1,\"31\":5,\"60\":1,\"61\":27,\"62\":3,\"104\":2,\"105\":1,\"106\":4,\"107\":1,\"108\":1,\"109\":1,\"110\":1,\"111\":1,\"112\":1,\"113\":1,\"114\":1,\"120\":3}}],[\"1000\",{\"1\":{\"119\":2,\"120\":4}}],[\"100m\",{\"1\":{\"20\":1,\"31\":1,\"62\":2}}],[\"101\",{\"1\":{\"61\":1}}],[\"10\",{\"1\":{\"0\":2,\"15\":2,\"31\":1,\"101\":1,\"119\":1}}],[\"tunnel\",{\"0\":{\"128\":1}}],[\"tls\",{\"1\":{\"111\":1}}],[\"ts\",{\"1\":{\"94\":1}}],[\"training\",{\"1\":{\"70\":1}}],[\"tree\",{\"1\":{\"69\":1}}],[\"tekton\",{\"1\":{\"70\":1}}],[\"tensorflow\",{\"1\":{\"69\":1}}],[\"template\",{\"1\":{\"31\":1,\"38\":1,\"62\":1}}],[\"the\",{\"1\":{\"62\":2}}],[\"thcd8\",{\"1\":{\"61\":2}}],[\"tqtgh\",{\"1\":{\"61\":2}}],[\"taskservice\",{\"1\":{\"72\":1,\"75\":1}}],[\"tag\",{\"1\":{\"62\":1}}],[\"targetport\",{\"1\":{\"35\":1,\"37\":1}}],[\"taints\",{\"1\":{\"31\":1}}],[\"taint\",{\"0\":{\"30\":1,\"31\":1},\"1\":{\"30\":2,\"31\":10}}],[\"tcp\",{\"1\":{\"31\":1}}],[\"typescript\",{\"1\":{\"94\":1}}],[\"type\",{\"1\":{\"20\":1,\"21\":1,\"31\":1,\"119\":1}}],[\"tools\",{\"1\":{\"62\":3}}],[\"toleration\",{\"1\":{\"31\":1}}],[\"tolerations\",{\"1\":{\"31\":2}}],[\"to\",{\"1\":{\"0\":1}}],[\"todo\",{\"1\":{\"0\":2}}],[\"ttl\",{\"1\":{\"0\":1}}],[\"two\",{\"1\":{\"0\":1}}],[\"mvp\",{\"1\":{\"133\":6}}],[\"mode\",{\"1\":{\"119\":2,\"120\":2}}],[\"modes\",{\"0\":{\"4\":1}}],[\"mtu\",{\"1\":{\"119\":2,\"120\":4}}],[\"multicast\",{\"1\":{\"119\":2,\"120\":2}}],[\"mutex\",{\"1\":{\"0\":3}}],[\"mxnet\",{\"1\":{\"69\":1}}],[\"microsoft\",{\"1\":{\"69\":1,\"98\":1}}],[\"minference\",{\"1\":{\"97\":1,\"98\":1,\"99\":1,\"100\":1,\"101\":5}}],[\"minikube\",{\"1\":{\"31\":2}}],[\"min\",{\"1\":{\"20\":1,\"21\":1}}],[\"mlops\",{\"0\":{\"93\":1}}],[\"ml\",{\"1\":{\"42\":6,\"43\":2,\"53\":1,\"54\":1,\"59\":2,\"61\":24,\"62\":1,\"69\":2,\"70\":2}}],[\"mac地址学习\",{\"1\":{\"128\":1}}],[\"matrix\",{\"1\":{\"69\":1}}],[\"matchlabels\",{\"1\":{\"31\":1,\"38\":1,\"62\":1}}],[\"master\",{\"1\":{\"62\":1}}],[\"manifests\",{\"1\":{\"26\":1,\"27\":3}}],[\"manager\",{\"0\":{\"62\":1},\"1\":{\"25\":1,\"28\":1,\"61\":6,\"62\":6}}],[\"max\",{\"1\":{\"20\":1,\"21\":1}}],[\"message\",{\"1\":{\"31\":1}}],[\"memory\",{\"1\":{\"15\":2,\"20\":4,\"31\":2,\"62\":2}}],[\"metadata\",{\"1\":{\"15\":1,\"20\":1,\"27\":1,\"31\":2,\"35\":1,\"37\":1,\"38\":2,\"50\":1,\"59\":3,\"61\":8,\"62\":3}}],[\"m\",{\"1\":{\"0\":4,\"31\":1}}],[\"mysql\",{\"1\":{\"85\":2,\"92\":1}}],[\"mysql数据库和minio服务器都由kubernetes持久卷子系统支持\",{\"1\":{\"50\":1}}],[\"mytask\",{\"1\":{\"55\":3}}],[\"myrev\",{\"1\":{\"0\":1}}],[\"mykey\",{\"1\":{\"0\":1}}],[\"my\",{\"1\":{\"0\":4,\"35\":2,\"37\":2,\"38\":10}}],[\"m1\",{\"1\":{\"0\":3}}],[\"show\",{\"1\":{\"116\":2,\"118\":1,\"119\":1,\"120\":2}}],[\"sharedrunserver\",{\"1\":{\"72\":1,\"73\":1}}],[\"sharedjobserver\",{\"1\":{\"72\":1,\"73\":1}}],[\"sharedpipelineserver\",{\"1\":{\"72\":1,\"73\":1}}],[\"sharedexperimentserver\",{\"1\":{\"72\":1,\"73\":1}}],[\"sharing\",{\"1\":{\"60\":1}}],[\"slash\",{\"1\":{\"101\":2}}],[\"sagemaker\",{\"1\":{\"69\":1}}],[\"sigs\",{\"1\":{\"62\":1,\"63\":1}}],[\"src\",{\"1\":{\"61\":1}}],[\"skipped\",{\"1\":{\"58\":1}}],[\"succeeded\",{\"1\":{\"58\":1}}],[\"spring\",{\"1\":{\"92\":1}}],[\"spark\",{\"1\":{\"55\":2}}],[\"specified\",{\"1\":{\"62\":1}}],[\"spec\",{\"1\":{\"15\":1,\"20\":1,\"27\":1,\"31\":2,\"35\":1,\"37\":1,\"38\":2,\"62\":2}}],[\"strategy\",{\"1\":{\"69\":1}}],[\"stg\",{\"1\":{\"61\":1}}],[\"step\",{\"1\":{\"59\":1}}],[\"storage之类的工件存储中\",{\"1\":{\"50\":1}}],[\"startrpcserver\",{\"1\":{\"71\":1,\"75\":1}}],[\"started\",{\"1\":{\"42\":1}}],[\"state\",{\"1\":{\"119\":2,\"120\":4}}],[\"stateful\",{\"1\":{\"37\":2,\"38\":8}}],[\"statefulset\",{\"0\":{\"36\":1,\"38\":1},\"1\":{\"32\":1,\"33\":2,\"34\":2,\"36\":1,\"38\":3,\"39\":1}}],[\"static\",{\"0\":{\"26\":1,\"27\":1},\"1\":{\"25\":2,\"26\":4,\"27\":3,\"28\":3,\"29\":5}}],[\"status\",{\"0\":{\"6\":1},\"1\":{\"6\":1,\"61\":1}}],[\"sdk\",{\"0\":{\"45\":1},\"1\":{\"53\":1,\"86\":1}}],[\"svc\",{\"1\":{\"38\":1}}],[\"s\",{\"1\":{\"31\":1,\"72\":8,\"73\":4,\"74\":1}}],[\"system\",{\"1\":{\"27\":1,\"29\":1}}],[\"scope\",{\"1\":{\"120\":2}}],[\"scopes\",{\"1\":{\"16\":1}}],[\"scheduledworkflow\",{\"1\":{\"61\":3}}],[\"scheduler\",{\"1\":{\"25\":1,\"28\":1,\"31\":1}}],[\"scheduling\",{\"1\":{\"31\":1}}],[\"s1\",{\"1\":{\"0\":6}}],[\"search\",{\"1\":{\"69\":3}}],[\"selector\",{\"1\":{\"31\":1,\"35\":1,\"37\":1,\"38\":1,\"62\":1}}],[\"server\",{\"1\":{\"25\":1,\"26\":2,\"28\":1,\"31\":1,\"61\":1,\"72\":4}}],[\"serviceaccountname\",{\"1\":{\"62\":1}}],[\"servicename\",{\"1\":{\"38\":1}}],[\"services\",{\"0\":{\"32\":1},\"1\":{\"15\":1}}],[\"service\",{\"0\":{\"33\":1,\"35\":1,\"36\":1,\"37\":1},\"1\":{\"15\":2,\"32\":3,\"33\":4,\"34\":3,\"35\":4,\"36\":1,\"37\":2,\"38\":4,\"39\":2,\"81\":1}}],[\"session\",{\"1\":{\"0\":2}}],[\"sessions\",{\"1\":{\"0\":1}}],[\"separate\",{\"1\":{\"0\":1}}],[\"found\",{\"1\":{\"136\":1}}],[\"forever\",{\"1\":{\"120\":4}}],[\"for\",{\"1\":{\"0\":5,\"31\":3}}],[\"feb6\",{\"1\":{\"120\":1}}],[\"fe80\",{\"1\":{\"120\":1}}],[\"ff\",{\"1\":{\"120\":12}}],[\"flashattention\",{\"1\":{\"101\":1}}],[\"fieldpath\",{\"1\":{\"62\":1}}],[\"fieldref\",{\"1\":{\"62\":1}}],[\"fsgks\",{\"1\":{\"61\":2}}],[\"from\",{\"1\":{\"31\":1,\"62\":1}}],[\"fast\",{\"1\":{\"69\":1}}],[\"failedscheduling\",{\"1\":{\"31\":1}}],[\"failed\",{\"1\":{\"0\":1,\"12\":1,\"58\":1}}],[\"fatal\",{\"1\":{\"0\":4}}],[\"fmt\",{\"1\":{\"0\":2}}],[\"ns1\",{\"1\":{\"120\":3}}],[\"network\",{\"0\":{\"122\":1},\"1\":{\"121\":1,\"123\":1,\"127\":1}}],[\"netnsid\",{\"1\":{\"120\":2}}],[\"netns\",{\"1\":{\"120\":3}}],[\"neural\",{\"1\":{\"69\":1}}],[\"newauthserver\",{\"1\":{\"72\":1}}],[\"newvisualizationserver\",{\"1\":{\"72\":1}}],[\"newreportserver\",{\"1\":{\"72\":1}}],[\"newtaskserver\",{\"1\":{\"72\":1}}],[\"newmutex\",{\"1\":{\"0\":2}}],[\"newsession\",{\"1\":{\"0\":2}}],[\"new\",{\"1\":{\"0\":1}}],[\"nacos\",{\"1\":{\"92\":1}}],[\"nas\",{\"1\":{\"69\":1}}],[\"name\",{\"1\":{\"15\":1,\"20\":1,\"27\":2,\"31\":3,\"35\":2,\"37\":2,\"38\":2,\"61\":1,\"62\":3,\"119\":1}}],[\"namespace\",{\"1\":{\"13\":1,\"15\":2,\"20\":2,\"27\":1,\"35\":1,\"37\":1,\"38\":1,\"60\":1,\"62\":2}}],[\"nv8km\",{\"1\":{\"61\":2}}],[\"noop\",{\"1\":{\"120\":2}}],[\"noqueue\",{\"1\":{\"119\":2,\"120\":2}}],[\"none\",{\"1\":{\"33\":1,\"35\":1,\"37\":1}}],[\"not\",{\"1\":{\"31\":2,\"136\":1}}],[\"nodes\",{\"1\":{\"31\":2}}],[\"node\",{\"1\":{\"31\":3}}],[\"no\",{\"1\":{\"31\":2}}],[\"noexecute\",{\"1\":{\"31\":3}}],[\"noschedule\",{\"1\":{\"31\":5}}],[\"n\",{\"1\":{\"29\":1,\"61\":1}}],[\"nginx\",{\"1\":{\"27\":2,\"31\":4}}],[\"nil\",{\"1\":{\"0\":5}}],[\"c\",{\"1\":{\"91\":1}}],[\"c++\",{\"1\":{\"91\":1}}],[\"custom\",{\"1\":{\"81\":2}}],[\"cm\",{\"1\":{\"72\":2}}],[\"cnbita\",{\"1\":{\"31\":1,\"61\":1}}],[\"cpu\",{\"1\":{\"15\":5,\"16\":1,\"20\":9,\"31\":2,\"62\":2}}],[\"cr\",{\"1\":{\"81\":3}}],[\"cron\",{\"1\":{\"59\":2}}],[\"crd\",{\"1\":{\"48\":1,\"61\":6,\"62\":1,\"64\":1,\"81\":3,\"82\":4}}],[\"crash\",{\"1\":{\"0\":1}}],[\"createrevision\",{\"1\":{\"0\":1}}],[\"create\",{\"1\":{\"0\":1}}],[\"ctx\",{\"1\":{\"0\":2}}],[\"covariance\",{\"1\":{\"69\":1}}],[\"common\",{\"1\":{\"72\":2}}],[\"command\",{\"1\":{\"31\":1,\"62\":1}}],[\"component\",{\"0\":{\"54\":1}}],[\"competition\",{\"1\":{\"0\":1}}],[\"com\",{\"1\":{\"31\":1,\"61\":1,\"62\":1,\"63\":1,\"98\":1,\"99\":1}}],[\"control\",{\"1\":{\"62\":3}}],[\"controller\",{\"0\":{\"62\":1},\"1\":{\"25\":1,\"28\":1,\"61\":9,\"62\":8,\"81\":1}}],[\"containerport\",{\"1\":{\"27\":1,\"31\":1,\"38\":1}}],[\"containers\",{\"1\":{\"27\":1,\"31\":1,\"38\":1,\"62\":1}}],[\"container\",{\"1\":{\"20\":1,\"38\":1}}],[\"context\",{\"1\":{\"0\":2}}],[\"concurrency\",{\"1\":{\"0\":5}}],[\"config\",{\"1\":{\"0\":1}}],[\"cloud\",{\"1\":{\"69\":1}}],[\"close\",{\"1\":{\"0\":2}}],[\"cluster\",{\"1\":{\"33\":2,\"38\":1,\"39\":1}}],[\"clusterip\",{\"1\":{\"32\":1,\"33\":1,\"35\":2,\"37\":1}}],[\"client\",{\"1\":{\"0\":8}}],[\"clientv3\",{\"1\":{\"0\":2}}],[\"cli\",{\"1\":{\"0\":3,\"67\":1}}],[\"=\",{\"1\":{\"0\":12}}],[\"e0ff\",{\"1\":{\"120\":1}}],[\"e0\",{\"1\":{\"120\":2}}],[\"ether\",{\"1\":{\"120\":2}}],[\"etc\",{\"1\":{\"26\":1,\"27\":3}}],[\"etcd获取分布式锁\",{\"1\":{\"0\":1}}],[\"etcd\",{\"0\":{\"0\":1},\"1\":{\"0\":1,\"25\":1,\"26\":1,\"28\":2},\"2\":{\"1\":1}}],[\"element\",{\"1\":{\"94\":1}}],[\"elasticsearch\",{\"1\":{\"85\":2}}],[\"else\",{\"1\":{\"0\":1,\"59\":1}}],[\"efficient\",{\"1\":{\"69\":1}}],[\"effect\",{\"1\":{\"31\":2}}],[\"evolution\",{\"1\":{\"69\":1}}],[\"events\",{\"1\":{\"31\":1}}],[\"estimators\",{\"1\":{\"69\":1}}],[\"endpoint\",{\"0\":{\"128\":1}}],[\"endpoints\",{\"1\":{\"0\":2}}],[\"env\",{\"1\":{\"62\":1}}],[\"emissary\",{\"1\":{\"60\":2,\"61\":1}}],[\"emissaryexecutor\",{\"1\":{\"60\":1,\"61\":2}}],[\"extensible\",{\"0\":{\"123\":1,\"127\":1},\"1\":{\"121\":1}}],[\"exec\",{\"1\":{\"120\":3}}],[\"experimentservice\",{\"1\":{\"72\":1,\"73\":1,\"75\":1}}],[\"experiment\",{\"0\":{\"59\":1}}],[\"example\",{\"1\":{\"15\":2,\"20\":2,\"27\":2}}],[\"equal\",{\"1\":{\"31\":1}}],[\"err\",{\"1\":{\"0\":12}}]],\"serializationVersion\":2}}")).map(([e,t])=>[e,zt(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:s,options:n,id:o}})=>{const u=bt[s];e==="suggest"?self.postMessage([e,o,tt(t,u,n)]):e==="search"?self.postMessage([e,o,Z(t,u,n)]):self.postMessage({suggestions:[e,o,tt(t,u,n)],results:[e,o,Z(t,u,n)]})};
//# sourceMappingURL=index.js.map
