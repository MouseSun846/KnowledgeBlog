import{_ as n,c as s,o as e,a as i}from"./app-K9spj8_g.js";const a={},l=i(`<div class="hint-container tip"><p class="hint-container-title">etcd获取分布式锁</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>cli, err := clientv3.New(clientv3.Config{Endpoints: endpoints})</span></span>
<span class="line"><span>if err != nil {</span></span>
<span class="line"><span>   log.Fatal(err)</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>defer cli.Close()</span></span>
<span class="line"><span>// create two separate sessions for lock competition</span></span>
<span class="line"><span>s1, err := concurrency.NewSession(cli, concurrency.WithTTL(10))</span></span>
<span class="line"><span>if err != nil {</span></span>
<span class="line"><span>   log.Fatal(err)</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>defer s1.Close()</span></span>
<span class="line"><span>m1 := concurrency.NewMutex(s1, &quot;/my-lock/&quot;)</span></span>
<span class="line"><span>// acquire lock for s1</span></span>
<span class="line"><span>if err := m1.Lock(context.TODO()); err != nil {</span></span>
<span class="line"><span>   log.Fatal(err)</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>fmt.Println(&quot;acquired lock for s1&quot;)</span></span>
<span class="line"><span>if err := m1.Unlock(context.TODO()); err != nil {</span></span>
<span class="line"><span>   log.Fatal(err)</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>fmt.Println(&quot;released lock for s1&quot;)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>1、首先通过 concurrency.NewSession 方法创建 Session，本质是创建了一个 TTL 为 10 的 Lease。</p><p>2、其次得到 session 对象后，通过 concurrency.NewMutex 创建了一个 mutex 对象，包含 Lease、key prefix 等信息。</p><p>3、然后通过 mutex 对象的 Lock 方法尝试获取锁。</p><p>当 CreateRevision 为 0 时，它会创建一个 prefix 为 /my-lock 的 key（ /my-lock + LeaseID)，并获取到 /my-lock prefix 下面最早创建的一个 key（revision 最小），分布式锁最终是由写入此 key 的 client 获得，其他 client 则进入等待模式。</p><p>4、最后使用结束，可通过 mutex 对象的 Unlock 方法释放锁。</p></div><div class="hint-container tip"><p class="hint-container-title">未获得锁的 client 是如何等待的呢?</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>// wait for deletion revisions prior to myKey</span></span>
<span class="line"><span>hdr, werr := waitDeletes(ctx, client, m.pfx, m.myRev-1)</span></span>
<span class="line"><span>// release lock key if wait failed</span></span>
<span class="line"><span>if werr != nil {</span></span>
<span class="line"><span>   m.Unlock(client.Ctx())</span></span>
<span class="line"><span>} else {</span></span>
<span class="line"><span>   m.hdr = hdr</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过 Watch 机制各自监听 prefix 相同，revision 比自己小的 key，因为只有 revision 比自己小的 key 释放锁，我才能有机会，获得锁，如下代码所示，其中 waitDelete 会使用我们上面的介绍的 Watch 去监听比自己小的 key</p></div><div class="hint-container tip"><p class="hint-container-title">为什么使用etcd分布式锁比redis分布式锁更好？</p><p>相比 Redis 基于主备异步复制导致锁的安全性问题，etcd 是基于 Raft 共识算法实现的，一个写请求需要经过集群多数节点确认。因此一旦分布式锁申请返回给 client 成功后，它一定是持久化到了集群多数节点上，不会出现 Redis 主备异步复制可能导致丢数据的问题，具备更高的安全性。</p></div><div class="hint-container tip"><p class="hint-container-title">分布式锁的三个主要核心要素</p><p>安全性、互斥性。在同一时间内，不允许多个 client 同时获得锁。</p><p>活性。无论 client 出现 crash 还是遭遇网络分区，你都需要确保任意故障场景下，都不会出现死锁，常用的解决方案是超时和自动过期机制。</p><p>高可用、高性能。加锁、释放锁的过程性能开销要尽量低，同时要保证高可用，避免单点故障。</p></div>`,4),p=[l];function t(c,r){return e(),s("div",null,p)}const o=n(a,[["render",t],["__file","etcd.html.vue"]]),m=JSON.parse('{"path":"/%E4%BA%91%E5%8E%9F%E7%94%9F/etcd.html","title":"etcd","lang":"zh-CN","frontmatter":{"date":"2024-07-08T00:00:00.000Z","title":"etcd","category":["etcd"],"tag":["分布式锁"],"description":"etcd获取分布式锁 1、首先通过 concurrency.NewSession 方法创建 Session，本质是创建了一个 TTL 为 10 的 Lease。 2、其次得到 session 对象后，通过 concurrency.NewMutex 创建了一个 mutex 对象，包含 Lease、key prefix 等信息。 3、然后通过 mutex ...","head":[["meta",{"property":"og:url","content":"https://mousesun846.github.io/KnowledgeBlog/KnowledgeBlog/%E4%BA%91%E5%8E%9F%E7%94%9F/etcd.html"}],["meta",{"property":"og:site_name","content":"知识笔记"}],["meta",{"property":"og:title","content":"etcd"}],["meta",{"property":"og:description","content":"etcd获取分布式锁 1、首先通过 concurrency.NewSession 方法创建 Session，本质是创建了一个 TTL 为 10 的 Lease。 2、其次得到 session 对象后，通过 concurrency.NewMutex 创建了一个 mutex 对象，包含 Lease、key prefix 等信息。 3、然后通过 mutex ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-07-08T06:44:35.000Z"}],["meta",{"property":"article:author","content":"MouseSun"}],["meta",{"property":"article:tag","content":"分布式锁"}],["meta",{"property":"article:published_time","content":"2024-07-08T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-07-08T06:44:35.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"etcd\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-07-08T00:00:00.000Z\\",\\"dateModified\\":\\"2024-07-08T06:44:35.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"MouseSun\\",\\"url\\":\\"https://github.com/MouseSun846\\",\\"email\\":\\"\\"}]}"]]},"headers":[],"git":{"createdTime":1720421075000,"updatedTime":1720421075000,"contributors":[{"name":"mousesun","email":"3026098675@qq.com","commits":1}]},"readingTime":{"minutes":2.06,"words":619},"filePathRelative":"云原生/etcd.md","localizedDate":"2024年7月8日","excerpt":"<div class=\\"hint-container tip\\">\\n<p class=\\"hint-container-title\\">etcd获取分布式锁</p>\\n<div class=\\"language- line-numbers-mode\\" data-highlighter=\\"shiki\\" data-ext=\\"\\" data-title=\\"\\" style=\\"--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34\\"><pre class=\\"shiki shiki-themes github-light one-dark-pro vp-code\\"><code><span class=\\"line\\"><span>cli, err := clientv3.New(clientv3.Config{Endpoints: endpoints})</span></span>\\n<span class=\\"line\\"><span>if err != nil {</span></span>\\n<span class=\\"line\\"><span>   log.Fatal(err)</span></span>\\n<span class=\\"line\\"><span>}</span></span>\\n<span class=\\"line\\"><span>defer cli.Close()</span></span>\\n<span class=\\"line\\"><span>// create two separate sessions for lock competition</span></span>\\n<span class=\\"line\\"><span>s1, err := concurrency.NewSession(cli, concurrency.WithTTL(10))</span></span>\\n<span class=\\"line\\"><span>if err != nil {</span></span>\\n<span class=\\"line\\"><span>   log.Fatal(err)</span></span>\\n<span class=\\"line\\"><span>}</span></span>\\n<span class=\\"line\\"><span>defer s1.Close()</span></span>\\n<span class=\\"line\\"><span>m1 := concurrency.NewMutex(s1, \\"/my-lock/\\")</span></span>\\n<span class=\\"line\\"><span>// acquire lock for s1</span></span>\\n<span class=\\"line\\"><span>if err := m1.Lock(context.TODO()); err != nil {</span></span>\\n<span class=\\"line\\"><span>   log.Fatal(err)</span></span>\\n<span class=\\"line\\"><span>}</span></span>\\n<span class=\\"line\\"><span>fmt.Println(\\"acquired lock for s1\\")</span></span>\\n<span class=\\"line\\"><span>if err := m1.Unlock(context.TODO()); err != nil {</span></span>\\n<span class=\\"line\\"><span>   log.Fatal(err)</span></span>\\n<span class=\\"line\\"><span>}</span></span>\\n<span class=\\"line\\"><span>fmt.Println(\\"released lock for s1\\")</span></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div><p>1、首先通过 concurrency.NewSession 方法创建 Session，本质是创建了一个 TTL 为 10 的 Lease。</p>\\n<p>2、其次得到 session 对象后，通过 concurrency.NewMutex 创建了一个 mutex 对象，包含 Lease、key prefix 等信息。</p>\\n<p>3、然后通过 mutex 对象的 Lock 方法尝试获取锁。</p>\\n<p>当 CreateRevision 为 0 时，它会创建一个 prefix 为 /my-lock 的 key（ /my-lock + LeaseID)，并获取到 /my-lock prefix 下面最早创建的一个 key（revision 最小），分布式锁最终是由写入此 key 的 client 获得，其他 client 则进入等待模式。</p>\\n<p>4、最后使用结束，可通过 mutex 对象的 Unlock 方法释放锁。</p>\\n</div>","autoDesc":true}');export{o as comp,m as data};
