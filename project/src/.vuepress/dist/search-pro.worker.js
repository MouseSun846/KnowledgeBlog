const V=Object.entries,et=Object.fromEntries,st="ENTRIES",L="KEYS",T="VALUES",_="";class D{set;_type;_path;constructor(t,s){const n=t._tree,o=Array.from(n.keys());this.set=t,this._type=s,this._path=o.length>0?[{node:n,keys:o}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:s}=E(this._path);if(E(s)===_)return{done:!1,value:this.result()};const n=t.get(E(s));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=E(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>E(t)).filter(t=>t!==_).join("")}value(){return E(this._path).node.get(_)}result(){switch(this._type){case T:return this.value();case L:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const E=e=>e[e.length-1],nt=(e,t,s)=>{const n=new Map;if(t===void 0)return n;const o=t.length+1,u=o+s,i=new Uint8Array(u*o).fill(s+1);for(let r=0;r<o;++r)i[r]=r;for(let r=1;r<u;++r)i[r*o]=r;return R(e,t,s,n,i,1,o,""),n},R=(e,t,s,n,o,u,i,r)=>{const d=u*i;t:for(const c of e.keys())if(c===_){const a=o[d-1];a<=s&&n.set(r,[e.get(c),a])}else{let a=u;for(let h=0;h<c.length;++h,++a){const g=c[h],m=i*a,p=m-i;let l=o[m];const f=Math.max(0,a-s-1),y=Math.min(i-1,a+s);for(let F=f;F<y;++F){const v=g!==t[F],z=o[p+F]+ +v,A=o[p+F+1]+1,w=o[m+F]+1,j=o[m+F+1]=Math.min(z,A,w);j<l&&(l=j)}if(l>s)continue t}R(e.get(c),t,s,n,o,a,i,r+c)}};class C{_tree;_prefix;_size=void 0;constructor(t=new Map,s=""){this._tree=t,this._prefix=s}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[s,n]=x(this._tree,t.slice(this._prefix.length));if(s===void 0){const[o,u]=O(n);for(const i of o.keys())if(i!==_&&i.startsWith(u)){const r=new Map;return r.set(i.slice(u.length),o.get(i)),new C(r,t)}}return new C(s,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,ot(this._tree,t)}entries(){return new D(this,st)}forEach(t){for(const[s,n]of this)t(s,n,this)}fuzzyGet(t,s){return nt(this._tree,t,s)}get(t){const s=k(this._tree,t);return s!==void 0?s.get(_):void 0}has(t){const s=k(this._tree,t);return s!==void 0&&s.has(_)}keys(){return new D(this,L)}set(t,s){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,I(this._tree,t).set(_,s),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=I(this._tree,t);return n.set(_,s(n.get(_))),this}fetch(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=I(this._tree,t);let o=n.get(_);return o===void 0&&n.set(_,o=s()),o}values(){return new D(this,T)}[Symbol.iterator](){return this.entries()}static from(t){const s=new C;for(const[n,o]of t)s.set(n,o);return s}static fromObject(t){return C.from(Object.entries(t))}}const x=(e,t,s=[])=>{if(t.length===0||e==null)return[e,s];for(const n of e.keys())if(n!==_&&t.startsWith(n))return s.push([e,n]),x(e.get(n),t.slice(n.length),s);return s.push([e,t]),x(void 0,"",s)},k=(e,t)=>{if(t.length===0||e==null)return e;for(const s of e.keys())if(s!==_&&t.startsWith(s))return k(e.get(s),t.slice(s.length))},I=(e,t)=>{const s=t.length;t:for(let n=0;e&&n<s;){for(const u of e.keys())if(u!==_&&t[n]===u[0]){const i=Math.min(s-n,u.length);let r=1;for(;r<i&&t[n+r]===u[r];)++r;const d=e.get(u);if(r===u.length)e=d;else{const c=new Map;c.set(u.slice(r),d),e.set(t.slice(n,n+r),c),e.delete(u),e=c}n+=r;continue t}const o=new Map;return e.set(t.slice(n),o),o}return e},ot=(e,t)=>{const[s,n]=x(e,t);if(s!==void 0){if(s.delete(_),s.size===0)W(n);else if(s.size===1){const[o,u]=s.entries().next().value;q(n,o,u)}}},W=e=>{if(e.length===0)return;const[t,s]=O(e);if(t.delete(s),t.size===0)W(e.slice(0,-1));else if(t.size===1){const[n,o]=t.entries().next().value;n!==_&&q(e.slice(0,-1),n,o)}},q=(e,t,s)=>{if(e.length===0)return;const[n,o]=O(e);n.set(o+t,s),n.delete(o)},O=e=>e[e.length-1],ut=(e,t)=>{const s=e._idToShortId.get(t);if(s!=null)return e._storedFields.get(s)},it=/[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u,M="or",$="and",rt="and_not",ct=(e,t)=>{e.includes(t)||e.push(t)},N=(e,t)=>{for(const s of t)e.includes(s)||e.push(s)},P=({score:e},{score:t})=>t-e,lt=()=>new Map,b=e=>{const t=new Map;for(const s of Object.keys(e))t.set(parseInt(s,10),e[s]);return t},G=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,ht={[M]:(e,t)=>{for(const s of t.keys()){const n=e.get(s);if(n==null)e.set(s,t.get(s));else{const{score:o,terms:u,match:i}=t.get(s);n.score=n.score+o,n.match=Object.assign(n.match,i),N(n.terms,u)}}return e},[$]:(e,t)=>{const s=new Map;for(const n of t.keys()){const o=e.get(n);if(o==null)continue;const{score:u,terms:i,match:r}=t.get(n);N(o.terms,i),s.set(n,{score:o.score+u,terms:o.terms,match:Object.assign(o.match,r)})}return s},[rt]:(e,t)=>{for(const s of t.keys())e.delete(s);return e}},dt=(e,t,s,n,o,u)=>{const{k:i,b:r,d}=u;return Math.log(1+(s-t+.5)/(t+.5))*(d+e*(i+1)/(e+i*(1-r+r*n/o)))},at=e=>(t,s,n)=>{const o=typeof e.fuzzy=="function"?e.fuzzy(t,s,n):e.fuzzy||!1,u=typeof e.prefix=="function"?e.prefix(t,s,n):e.prefix===!0;return{term:t,fuzzy:o,prefix:u}},H=(e,t,s,n)=>{for(const o of Object.keys(e._fieldIds))if(e._fieldIds[o]===s){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${n}" was not present in field "${o}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},ft=(e,t,s,n)=>{if(!e._index.has(n)){H(e,s,t,n);return}const o=e._index.fetch(n,lt),u=o.get(t);u==null||u.get(s)==null?H(e,s,t,n):u.get(s)<=1?u.size<=1?o.delete(t):u.delete(s):u.set(s,u.get(s)-1),e._index.get(n).size===0&&e._index.delete(n)},gt={k:1.2,b:.7,d:.5},mt={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(it),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{typeof console?.[e]=="function"&&console[e](t)},autoVacuum:!0},J={combineWith:M,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:gt},pt={combineWith:$,prefix:(e,t,s)=>t===s.length-1},Ft={batchSize:1e3,batchWait:10},U={minDirtFactor:.1,minDirtCount:20},_t={...Ft,...U},K=Symbol("*"),yt=(e,t)=>{const s=new Map,n={...e._options.searchOptions,...t};for(const[o,u]of e._documentIds){const i=n.boostDocument?n.boostDocument(u,"",e._storedFields.get(o)):1;s.set(o,{score:i,terms:[],match:{}})}return s},X=(e,t=M)=>{if(e.length===0)return new Map;const s=t.toLowerCase(),n=ht[s];if(!n)throw new Error(`Invalid combination operator: ${t}`);return e.reduce(n)||new Map},S=(e,t,s,n,o,u,i,r,d=new Map)=>{if(o==null)return d;for(const c of Object.keys(u)){const a=u[c],h=e._fieldIds[c],g=o.get(h);if(g==null)continue;let m=g.size;const p=e._avgFieldLength[h];for(const l of g.keys()){if(!e._documentIds.has(l)){ft(e,h,l,s),m-=1;continue}const f=i?i(e._documentIds.get(l),s,e._storedFields.get(l)):1;if(!f)continue;const y=g.get(l),F=e._fieldLength.get(l)[h],v=dt(y,m,e._documentCount,F,p,r),z=n*a*f*v,A=d.get(l);if(A){A.score+=z,ct(A.terms,t);const w=G(A.match,s);w?w.push(c):A.match[s]=[c]}else d.set(l,{score:z,terms:[t],match:{[s]:[c]}})}}return d},At=(e,t,s)=>{const n={...e._options.searchOptions,...s},o=(n.fields||e._options.fields).reduce((l,f)=>({...l,[f]:G(n.boost,f)||1}),{}),{boostDocument:u,weights:i,maxFuzzy:r,bm25:d}=n,{fuzzy:c,prefix:a}={...J.weights,...i},h=e._index.get(t.term),g=S(e,t.term,t.term,1,h,o,u,d);let m,p;if(t.prefix&&(m=e._index.atPrefix(t.term)),t.fuzzy){const l=t.fuzzy===!0?.2:t.fuzzy,f=l<1?Math.min(r,Math.round(t.term.length*l)):l;f&&(p=e._index.fuzzyGet(t.term,f))}if(m)for(const[l,f]of m){const y=l.length-t.term.length;if(!y)continue;p?.delete(l);const F=a*l.length/(l.length+.3*y);S(e,t.term,l,F,f,o,u,d,g)}if(p)for(const l of p.keys()){const[f,y]=p.get(l);if(!y)continue;const F=c*l.length/(l.length+y);S(e,t.term,l,F,f,o,u,d,g)}return g},Y=(e,t,s={})=>{if(t===K)return yt(e,s);if(typeof t!="string"){const a={...s,...t,queries:void 0},h=t.queries.map(g=>Y(e,g,a));return X(h,a.combineWith)}const{tokenize:n,processTerm:o,searchOptions:u}=e._options,i={tokenize:n,processTerm:o,...u,...s},{tokenize:r,processTerm:d}=i,c=r(t).flatMap(a=>d(a)).filter(a=>!!a).map(at(i)).map(a=>At(e,a,i));return X(c,i.combineWith)},Q=(e,t,s={})=>{const n=Y(e,t,s),o=[];for(const[u,{score:i,terms:r,match:d}]of n){const c=r.length||1,a={id:e._documentIds.get(u),score:i*c,terms:Object.keys(d),queryTerms:r,match:d};Object.assign(a,e._storedFields.get(u)),(s.filter==null||s.filter(a))&&o.push(a)}return t===K&&s.boostDocument==null&&e._options.searchOptions.boostDocument==null||o.sort(P),o},Ct=(e,t,s={})=>{s={...e._options.autoSuggestOptions,...s};const n=new Map;for(const{score:u,terms:i}of Q(e,t,s)){const r=i.join(" "),d=n.get(r);d!=null?(d.score+=u,d.count+=1):n.set(r,{score:u,terms:i,count:1})}const o=[];for(const[u,{score:i,terms:r,count:d}]of n)o.push({suggestion:u,terms:r,score:i/d});return o.sort(P),o};class Et{_options;_index;_documentCount;_documentIds;_idToShortId;_fieldIds;_fieldLength;_avgFieldLength;_nextId;_storedFields;_dirtCount;_currentVacuum;_enqueuedVacuum;_enqueuedVacuumConditions;constructor(t){if(t?.fields==null)throw new Error('SlimSearch: option "fields" must be provided');const s=t.autoVacuum==null||t.autoVacuum===!0?_t:t.autoVacuum;this._options={...mt,...t,autoVacuum:s,searchOptions:{...J,...t.searchOptions||{}},autoSuggestOptions:{...pt,...t.autoSuggestOptions||{}}},this._index=new C,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=U,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[s,n]of this._index){const o={};for(const[u,i]of n)o[u]=Object.fromEntries(i);t.push([s,o])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}addFields(t){for(let s=0;s<t.length;s++)this._fieldIds[t[s]]=s}}const zt=({index:e,documentCount:t,nextId:s,documentIds:n,fieldIds:o,fieldLength:u,averageFieldLength:i,storedFields:r,dirtCount:d,serializationVersion:c},a)=>{if(c!==1&&c!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const h=new Et(a);h._documentCount=t,h._nextId=s,h._documentIds=b(n),h._idToShortId=new Map,h._fieldIds=o,h._fieldLength=b(u),h._avgFieldLength=i,h._storedFields=b(r),h._dirtCount=d||0,h._index=new C;for(const[g,m]of h._documentIds)h._idToShortId.set(m,g);for(const[g,m]of e){const p=new Map;for(const l of Object.keys(m)){let f=m[l];c===1&&(f=f.ds),p.set(parseInt(l,10),b(f))}h._index.set(g,p)}return h},B=(e,t)=>{const s=e.toLowerCase(),n=t.toLowerCase(),o=[];let u=0,i=0;const r=(c,a=!1)=>{let h="";i===0?h=c.length>20?`… ${c.slice(-20)}`:c:a?h=c.length+i>100?`${c.slice(0,100-i)}… `:c:h=c.length>20?`${c.slice(0,20)} … ${c.slice(-20)}`:c,h&&o.push(h),i+=h.length,a||(o.push(["mark",t]),i+=t.length,i>=100&&o.push(" …"))};let d=s.indexOf(n,u);if(d===-1)return null;for(;d>=0;){const c=d+n.length;if(r(e.slice(u,d)),u=c,i>100)break;d=s.indexOf(n,u)}return i<100&&r(e.slice(u),!0),o},wt=(e,t)=>t.contents.reduce((s,[,n])=>s+n,0)-e.contents.reduce((s,[,n])=>s+n,0),xt=(e,t)=>Math.max(...t.contents.map(([,s])=>s))-Math.max(...e.contents.map(([,s])=>s)),Z=(e,t,s={})=>{const n={};return Q(t,e,{boost:{h:2,t:1,c:4},prefix:!0,...s}).forEach(o=>{const{id:u,terms:i,score:r}=o,d=u.includes("@"),c=u.includes("#"),[a,h]=u.split(/[#@]/),g=Number(a),m=i.sort((l,f)=>l.length-f.length).filter((l,f)=>i.slice(f+1).every(y=>!y.includes(l))),{contents:p}=n[g]??={title:"",contents:[]};if(d)p.push([{type:"customField",id:g,index:h,display:m.map(l=>o.c.map(f=>B(f,l))).flat().filter(l=>l!==null)},r]);else{const l=m.map(f=>B(o.h,f)).filter(f=>f!==null);if(l.length&&p.push([{type:c?"heading":"title",id:g,...c&&{anchor:h},display:l},r]),"t"in o)for(const f of o.t){const y=m.map(F=>B(f,F)).filter(F=>F!==null);y.length&&p.push([{type:"text",id:g,...c&&{anchor:h},display:y},r])}}}),V(n).sort(([,o],[,u])=>"max"==="total"?wt(o,u):xt(o,u)).map(([o,{title:u,contents:i}])=>{if(!u){const r=ut(t,o);r&&(u=r.h)}return{title:u,contents:i.map(([r])=>r)}})},tt=(e,t,s={})=>{const n=Ct(t,e,{fuzzy:.2,maxFuzzy:3,...s}).map(({suggestion:o})=>o);return e.includes(" ")?n:n.filter(o=>!o.includes(" "))},bt=et(V(JSON.parse("{\"/\":{\"documentCount\":314,\"nextId\":314,\"documentIds\":{\"0\":\"1\",\"1\":\"1@0\",\"2\":\"1@1\",\"3\":\"2\",\"4\":\"2#访问模式-access-modes\",\"5\":\"2#回收策略-reclaim-policy\",\"6\":\"2#pv-status\",\"7\":\"2#_1-available\",\"8\":\"2#_2-bound\",\"9\":\"2#_3-released\",\"10\":\"2#_4-failed\",\"11\":\"2#状态转换\",\"12\":\"2#状态图示\",\"13\":\"2#resourcequotas\",\"14\":\"2#作用\",\"15\":\"2#配置示例\",\"16\":\"2#主要字段\",\"17\":\"2#使用场景\",\"18\":\"2#limitranges\",\"19\":\"2#作用-1\",\"20\":\"2#配置示例-1\",\"21\":\"2#主要字段-1\",\"22\":\"2#使用场景-1\",\"23\":\"2#比较与总结\",\"24\":\"2#k8s技能图谱\",\"25\":\"2#静态pod\",\"26\":\"2#static-pod-的特点\",\"27\":\"2#创建-static-pod\",\"28\":\"2#使用场景-2\",\"29\":\"2#监控和管理\",\"30\":\"2#taint\",\"31\":\"2#taint-机制\",\"32\":\"2#无头服务-headless-services\",\"33\":\"2#headless-service-的特点\",\"34\":\"2#使用场景-3\",\"35\":\"2#headless-service-的定义示例\",\"36\":\"2#statefulset-与-headless-service-的结合\",\"37\":\"2#定义-headless-service\",\"38\":\"2#定义-statefulset\",\"39\":\"2#总结\",\"40\":\"2#kubelet的hairpin-mode\",\"41\":\"2#hairpin-mode-的工作原理\",\"42\":\"2#配置-hairpin-mode\",\"43\":\"2#配置示例-2\",\"44\":\"2#使用场景-4\",\"45\":\"2#总结-1\",\"46\":\"2#资源短缺\",\"47\":\"2#如何能够让-kubernetes-的调度器尽可能地将-pod-分布在不同机器上-避免-堆叠-呢\",\"48\":\"2#_1-pod-反亲和性-pod-anti-affinity\",\"49\":\"2#示例\",\"50\":\"2#_2-节点亲和性-node-affinity\",\"51\":\"2#示例-1\",\"52\":\"2#_3-分布式调度策略-spread-constraints\",\"53\":\"2#示例-2\",\"54\":\"2#_4-自定义调度器策略-custom-scheduler-policies\",\"55\":\"2#示例-3\",\"56\":\"2#kubelet如何实现-exec、logs-等接口\",\"57\":\"2#集群安装\",\"58\":\"2@0\",\"59\":\"2@1\",\"60\":\"3\",\"61\":\"3#_1-nginx容器启动\",\"62\":\"3#_2-安装kong\",\"63\":\"3#_3-创建服务-hello-service\",\"64\":\"3#_4-查询服务-hello-service\",\"65\":\"3#_5-删除服务-hello-service\",\"66\":\"3#_6-创建路由-hello-route\",\"67\":\"3#_7-查询路由-hello-route\",\"68\":\"3#_8-删除路由-hello-route\",\"69\":\"3#_9-访问服务\",\"70\":\"3#总结\",\"71\":\"3@0\",\"72\":\"3@1\",\"73\":\"4\",\"74\":\"4#概念概述\",\"75\":\"4#pipeline\",\"76\":\"4#python-sdk\",\"77\":\"4#dsl-compiler\",\"78\":\"4#pipeline-service\",\"79\":\"4#kubernetes-resources\",\"80\":\"4#orchestration-controllers\",\"81\":\"4#artifact-storage\",\"82\":\"4#persistence-agent-and-ml-metadata\",\"83\":\"4#pipeline-web-server\",\"84\":\"4#pipeline-1\",\"85\":\"4#component\",\"86\":\"4#组件代码\",\"87\":\"4#组件定义\",\"88\":\"4#容器化组件\",\"89\":\"4#graph\",\"90\":\"4#experiment\",\"91\":\"4#主要的-argo-工作流执行器类型包括\",\"92\":\"4#如何选择适合的执行器\",\"93\":\"4#controller-manager\",\"94\":\"4#官网地址\",\"95\":\"4#kubernetes-应用程序\",\"96\":\"4#它提供了\",\"97\":\"4#这可以被以下用户使用\",\"98\":\"4#目标\",\"99\":\"4#非目标\",\"100\":\"4#什么是-katib\",\"101\":\"4#为什么选择-katib\",\"102\":\"4#pipeline服务注册流程\",\"103\":\"4#api-v1beta1-注册的服务\",\"104\":\"4#api-v2beta1-注册的服务\",\"105\":\"4#其他\",\"106\":\"4#总结\",\"107\":\"4#pipeline创建流程\",\"108\":\"4#创建runs\",\"109\":\"4@0\",\"110\":\"4@1\",\"111\":\"5\",\"112\":\"5#operator-的基本概念\",\"113\":\"5#operator-的工作原理\",\"114\":\"5#operator-的应用场景\",\"115\":\"5#operator-的优势\",\"116\":\"5#使用-operator-的示例\",\"117\":\"5#开发-operator-的工具\",\"118\":\"5#总结\",\"119\":\"5@0\",\"120\":\"5@1\",\"121\":\"6\",\"122\":\"6#编程语言\",\"123\":\"6#技术栈\",\"124\":\"6#mlops\",\"125\":\"6#前端开发\",\"126\":\"6#项目经验\",\"127\":\"6#联系方式\",\"128\":\"6@0\",\"129\":\"6@1\",\"130\":\"7\",\"131\":\"7@0\",\"132\":\"7@1\",\"133\":\"8\",\"134\":\"8#地址\",\"135\":\"8#文档\",\"136\":\"8#配置\",\"137\":\"8#docker-compose\",\"138\":\"8#访问\",\"139\":\"8#fastgpt\",\"140\":\"8#oneapi\",\"141\":\"8#地址-1\",\"142\":\"8#文档-1\",\"143\":\"8#docker-compose-1\",\"144\":\"8@0\",\"145\":\"8@1\",\"146\":\"9\",\"147\":\"9#主要功能\",\"148\":\"9#使用场景\",\"149\":\"9#示例代码\",\"150\":\"9#总结\",\"151\":\"9#spmd-模型的核心思想\",\"152\":\"9#spmd-与其他并行模型的比较\",\"153\":\"9#应用场景\",\"154\":\"9#示例\",\"155\":\"9#总结-1\",\"156\":\"9#mpmd-模型的核心思想\",\"157\":\"9#mpmd-与-spmd-的比较\",\"158\":\"9#应用场景-1\",\"159\":\"9#示例场景\",\"160\":\"9#实现-mpmd-的框架\",\"161\":\"9#总结-2\",\"162\":\"9#mpi-的核心概念\",\"163\":\"9#mpi-的主要功能\",\"164\":\"9#使用场景-1\",\"165\":\"9#示例代码-1\",\"166\":\"9#总结-3\",\"167\":\"9@0\",\"168\":\"9@1\",\"169\":\"10\",\"170\":\"10#ubuntu\",\"171\":\"10#ping-安装\",\"172\":\"10#获取公网ip\",\"173\":\"10@0\",\"174\":\"10@1\",\"175\":\"11\",\"176\":\"11#地址\",\"177\":\"11#论文\",\"178\":\"11#介绍\",\"179\":\"11#重要亮点\",\"180\":\"11@0\",\"181\":\"11@1\",\"182\":\"12\",\"183\":\"12#解释命令\",\"184\":\"12#使用场景\",\"185\":\"12#注意事项\",\"186\":\"12#扩容磁盘\",\"187\":\"12#_1-卸载并删除-nvme0n1p1-分区\",\"188\":\"12#_2-创建新的分区并标记为-lvm\",\"189\":\"12#_3-将新分区添加到-lvm-物理卷\",\"190\":\"12#_4-扩展逻辑卷-centos-root\",\"191\":\"12#_5-扩展-xfs-文件系统\",\"192\":\"12#_6-验证扩展结果\",\"193\":\"12@0\",\"194\":\"12@1\",\"195\":\"13\",\"196\":\"13#_1-协议基础\",\"197\":\"13#_2-连接管理\",\"198\":\"13#_3-多路复用\",\"199\":\"13#_4-头部压缩\",\"200\":\"13#_5-服务器推送\",\"201\":\"13#_6-优先级和流控制\",\"202\":\"13#_7-加密和安全\",\"203\":\"13#_8-协议扩展性\",\"204\":\"13#_9-性能改进\",\"205\":\"13#总结\",\"206\":\"13#查看系统中已有的veth设备对或确认已创建的veth设备对-可以使用以下几种方法\",\"207\":\"13#使用-ip-命令\",\"208\":\"13#使用-ifconfig-命令\",\"209\":\"13#查看具体veth设备对的详细信息\",\"210\":\"13#示例\",\"211\":\"13#检查命名空间中的veth设备\",\"212\":\"13#vlan-与vxlan\",\"213\":\"13#vlan-virtual-local-area-network\",\"214\":\"13#vxlan-virtual-extensible-lan\",\"215\":\"13#对比\",\"216\":\"13#总结-1\",\"217\":\"13#vxlan与vtep\",\"218\":\"13#vxlan-virtual-extensible-lan-1\",\"219\":\"13#vtep-vxlan-tunnel-endpoint\",\"220\":\"13#vxlan-和-vtep-的工作流程\",\"221\":\"13#总结-2\",\"222\":\"13#ip-neigh-show\",\"223\":\"13#总结-3\",\"224\":\"13#bridge-fdb-show\",\"225\":\"13#示例输出\",\"226\":\"13#输出字段解释\",\"227\":\"13#常用选项\",\"228\":\"13#使用示例\",\"229\":\"13#总结-4\",\"230\":\"13#arp协议\",\"231\":\"13#arp-工作原理\",\"232\":\"13#arp-报文格式\",\"233\":\"13#arp-缓存\",\"234\":\"13#arp的安全问题\",\"235\":\"13#arp欺骗的防御措施\",\"236\":\"13#总结-5\",\"237\":\"13#bgp协议\",\"238\":\"13#bgp-的主要特性和工作原理\",\"239\":\"13#bgp-的工作过程\",\"240\":\"13#bgp-的优势和挑战\",\"241\":\"13#优势\",\"242\":\"13#挑战\",\"243\":\"13#总结-6\",\"244\":\"13#ifconfig、ip-a、ip-link、ip-route-和-iptables-是网络管理中常用的命令。它们各自有不同的功能-但一起使用时可以全面管理和配置网络接口、路由和防火墙规则。以下是这些命令的功能及其关系的详细介绍\",\"245\":\"13#ifconfig\",\"246\":\"13#功能\",\"247\":\"13#用法\",\"248\":\"13#ip-a-也称-ip-addr\",\"249\":\"13#功能-1\",\"250\":\"13#用法-1\",\"251\":\"13#ip-link\",\"252\":\"13#功能-2\",\"253\":\"13#用法-2\",\"254\":\"13#ip-route\",\"255\":\"13#功能-3\",\"256\":\"13#用法-3\",\"257\":\"13#iptables\",\"258\":\"13#功能-4\",\"259\":\"13#用法-4\",\"260\":\"13#关系\",\"261\":\"13#七层网络模型\",\"262\":\"13#_1-物理层-physical-layer\",\"263\":\"13#_2-数据链路层-data-link-layer\",\"264\":\"13#_3-网络层-network-layer\",\"265\":\"13#_4-传输层-transport-layer\",\"266\":\"13#_5-会话层-session-layer\",\"267\":\"13#_6-表示层-presentation-layer\",\"268\":\"13#_7-应用层-application-layer\",\"269\":\"13#各层之间的关系\",\"270\":\"13#应用示例\",\"271\":\"13#总结-7\",\"272\":\"13@0\",\"273\":\"13@1\",\"274\":\"14\",\"275\":\"14@0\",\"276\":\"14@1\",\"277\":\"15\",\"278\":\"15#问题背景\",\"279\":\"15#论文创新点\",\"280\":\"15#实验方法\",\"281\":\"15#结论\",\"282\":\"15#ii-背景与动机\",\"283\":\"15#操作间并行\",\"284\":\"15#gpu内存消耗的问题\",\"285\":\"15#内存优化及其局限性\",\"286\":\"15#硬件趋势与机遇\",\"287\":\"15#iii-mpress-内部原理\",\"288\":\"15#a-设计原则\",\"289\":\"15#b-mpress的总体概述及工作流程\",\"290\":\"15#c-d2d交换\",\"291\":\"15#d-内存压缩规划\",\"292\":\"15#e-实现细节\",\"293\":\"15#e-实现细节-1\",\"294\":\"15#iv-评估\",\"295\":\"15#a-实验设置\",\"296\":\"15#b-mpress在pipedream上的性能\",\"297\":\"15#c-mpress在dapple上的性能\",\"298\":\"15#d-敏感性分析\",\"299\":\"15#d2d交换优化的影响\",\"300\":\"15#内存压缩方法的成本比较\",\"301\":\"15#mpress选择的策略\",\"302\":\"15#v-硬件见解\",\"303\":\"15#vi-相关工作\",\"304\":\"15#vii-结论\",\"305\":\"15@0\",\"306\":\"15@1\",\"307\":\"16\",\"308\":\"17\",\"309\":\"18\",\"310\":\"19\",\"311\":\"20\",\"312\":\"21\",\"313\":\"22\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[1,152],\"1\":[null,null,1],\"2\":[null,null,1],\"3\":[1,2],\"4\":[4,16],\"5\":[4,13],\"6\":[3,20],\"7\":[2,16],\"8\":[2,13],\"9\":[2,16],\"10\":[2,11],\"11\":[1,27],\"12\":[1,23],\"13\":[1,9],\"14\":[1,10],\"15\":[1,40],\"16\":[1,13],\"17\":[1,10],\"18\":[1,12],\"19\":[1,14],\"20\":[1,45],\"21\":[1,13],\"22\":[1,10],\"23\":[1,23],\"24\":[1],\"25\":[1,27],\"26\":[3,43],\"27\":[3,40],\"28\":[1,31],\"29\":[1,34],\"30\":[1,10],\"31\":[2,147],\"32\":[4,17],\"33\":[3,35],\"34\":[1,17],\"35\":[3,37],\"36\":[5,7],\"37\":[3,22],\"38\":[2,44],\"39\":[1,21],\"40\":[1,20],\"41\":[3,19],\"42\":[1,22],\"43\":[1,22],\"44\":[1,11],\"45\":[1,16],\"46\":[1,92],\"47\":[9,10],\"48\":[6,6],\"49\":[1,32],\"50\":[5,7],\"51\":[1,26],\"52\":[5,10],\"53\":[1,32],\"54\":[6,7],\"55\":[1,26],\"56\":[4,73],\"57\":[1,138],\"58\":[null,null,1],\"59\":[null,null,1],\"60\":[1,3],\"61\":[2,29],\"62\":[2,3],\"63\":[2,23],\"64\":[2,10],\"65\":[2,13],\"66\":[2,19],\"67\":[2,12],\"68\":[2,13],\"69\":[2,14],\"70\":[1,257],\"71\":[null,null,1],\"72\":[null,null,3],\"73\":[2,35],\"74\":[1,11],\"75\":[1,3],\"76\":[3,5],\"77\":[1,3],\"78\":[1,2],\"79\":[1,4],\"80\":[1,7],\"81\":[1,17],\"82\":[1,6],\"83\":[1,7],\"84\":[1,33],\"85\":[1,18],\"86\":[1,24],\"87\":[1,22],\"88\":[1,13],\"89\":[1,29],\"90\":[1,106],\"91\":[4,41],\"92\":[2,220],\"93\":[2,64],\"94\":[1,6],\"95\":[2,21],\"96\":[2,14],\"97\":[2,13],\"98\":[1,24],\"99\":[1,6],\"100\":[3,64],\"101\":[3,45],\"102\":[1,5],\"103\":[3,42],\"104\":[3,19],\"105\":[1,6],\"106\":[1,28],\"107\":[1,2],\"108\":[1,5],\"109\":[null,null,1],\"110\":[null,null,1],\"111\":[2,17],\"112\":[2,29],\"113\":[2,23],\"114\":[2,19],\"115\":[2,16],\"116\":[3,18],\"117\":[3,20],\"118\":[1,17],\"119\":[null,null,1],\"120\":[null,null,1],\"121\":[1,12],\"122\":[1,26],\"123\":[1,23],\"124\":[1,7],\"125\":[1,23],\"126\":[1,18],\"127\":[1,1],\"128\":[null,null,1],\"129\":[null,null,1],\"130\":[1],\"131\":[null,null,1],\"132\":[null,null,2],\"133\":[3,1],\"134\":[1,5],\"135\":[1,6],\"136\":[1,177],\"137\":[2,319],\"138\":[1],\"139\":[1,8],\"140\":[1,6],\"141\":[1,7],\"142\":[1,8],\"143\":[2,110],\"144\":[null,null,1],\"145\":[null,null,4],\"146\":[1,15],\"147\":[1,39],\"148\":[1,10],\"149\":[1,38],\"150\":[1,19],\"151\":[2,25],\"152\":[2,19],\"153\":[1,21],\"154\":[1,13],\"155\":[1,24],\"156\":[2,30],\"157\":[4,20],\"158\":[1,23],\"159\":[1,17],\"160\":[3,8],\"161\":[1,30],\"162\":[2,55],\"163\":[2,19],\"164\":[1,19],\"165\":[1,46],\"166\":[1,7],\"167\":[null,null,1],\"168\":[null,null,2],\"169\":[1],\"170\":[1],\"171\":[2,4],\"172\":[1,5],\"173\":[null,null,1],\"174\":[null,null,1],\"175\":[1,4],\"176\":[1,5],\"177\":[1,5],\"178\":[1,8],\"179\":[1,47],\"180\":[null,null,1],\"181\":[null,null,1],\"182\":[1,8],\"183\":[2,12],\"184\":[2,14],\"185\":[2,170],\"186\":[1,15],\"187\":[3,26],\"188\":[3,28],\"189\":[4,11],\"190\":[2,11],\"191\":[3,11],\"192\":[2,14],\"193\":[null,null,1],\"194\":[null,null,1],\"195\":[1,12],\"196\":[2,10],\"197\":[2,19],\"198\":[2,15],\"199\":[2,14],\"200\":[2,13],\"201\":[2,13],\"202\":[2,14],\"203\":[2,11],\"204\":[2,11],\"205\":[1,36],\"206\":[3],\"207\":[2,13],\"208\":[2,7],\"209\":[1,5],\"210\":[1,37],\"211\":[1,70],\"212\":[2,12],\"213\":[6,28],\"214\":[5,25],\"215\":[1,32],\"216\":[1,6],\"217\":[1],\"218\":[5,23],\"219\":[5,29],\"220\":[4,15],\"221\":[1,10],\"222\":[3,50],\"223\":[1,12],\"224\":[3,12],\"225\":[1,20],\"226\":[1,22],\"227\":[1,12],\"228\":[1,9],\"229\":[1,6],\"230\":[1,12],\"231\":[2,26],\"232\":[2,39],\"233\":[2,7],\"234\":[1,9],\"235\":[1,13],\"236\":[1,6],\"237\":[1,16],\"238\":[2,48],\"239\":[2,23],\"240\":[2],\"241\":[2,9],\"242\":[2,9],\"243\":[1,8],\"244\":[7],\"245\":[1],\"246\":[2,10],\"247\":[2,17],\"248\":[2],\"249\":[2,9],\"250\":[2,3],\"251\":[1],\"252\":[2,6],\"253\":[2,10],\"254\":[1],\"255\":[2,6],\"256\":[2,18],\"257\":[1],\"258\":[2,11],\"259\":[2,17],\"260\":[1,31],\"261\":[1,11],\"262\":[5,15],\"263\":[6,18],\"264\":[5,15],\"265\":[5,13],\"266\":[5,10],\"267\":[5,15],\"268\":[5,16],\"269\":[1,9],\"270\":[1,10],\"271\":[1,5],\"272\":[null,null,1],\"273\":[null,null,1],\"274\":[1,98],\"275\":[null,null,1],\"276\":[null,null,1],\"277\":[2,29],\"278\":[2,11],\"279\":[2,15],\"280\":[2,12],\"281\":[2,4],\"282\":[2,64],\"283\":[1,24],\"284\":[1,24],\"285\":[1,27],\"286\":[1,14],\"287\":[3],\"288\":[2,23],\"289\":[2,45],\"290\":[2,40],\"291\":[2,64],\"292\":[2],\"293\":[2,44],\"294\":[2,8],\"295\":[2,124],\"296\":[2,82],\"297\":[2,112],\"298\":[2,11],\"299\":[1,40],\"300\":[1,49],\"301\":[1,64],\"302\":[2,70],\"303\":[2,80],\"304\":[2,23],\"305\":[null,null,1],\"306\":[null,null,2],\"307\":[1,3],\"308\":[1],\"309\":[1],\"310\":[1],\"311\":[1],\"312\":[1],\"313\":[1]},\"averageFieldLength\":[1.846353776774071,28.38373641524169,0.7876920787956179],\"storedFields\":{\"0\":{\"h\":\"etcd\",\"t\":[\"etcd获取分布式锁\",\"cli, err := clientv3.New(clientv3.Config{Endpoints: endpoints}) if err != nil { log.Fatal(err) } defer cli.Close() // create two separate sessions for lock competition s1, err := concurrency.NewSession(cli, concurrency.WithTTL(10)) if err != nil { log.Fatal(err) } defer s1.Close() m1 := concurrency.NewMutex(s1, \\\"/my-lock/\\\") // acquire lock for s1 if err := m1.Lock(context.TODO()); err != nil { log.Fatal(err) } fmt.Println(\\\"acquired lock for s1\\\") if err := m1.Unlock(context.TODO()); err != nil { log.Fatal(err) } fmt.Println(\\\"released lock for s1\\\")\",\"1、首先通过 concurrency.NewSession 方法创建 Session，本质是创建了一个 TTL 为 10 的 Lease。\",\"2、其次得到 session 对象后，通过 concurrency.NewMutex 创建了一个 mutex 对象，包含 Lease、key prefix 等信息。\",\"3、然后通过 mutex 对象的 Lock 方法尝试获取锁。\",\"当 CreateRevision 为 0 时，它会创建一个 prefix 为 /my-lock 的 key（ /my-lock + LeaseID)，并获取到 /my-lock prefix 下面最早创建的一个 key（revision 最小），分布式锁最终是由写入此 key 的 client 获得，其他 client 则进入等待模式。\",\"4、最后使用结束，可通过 mutex 对象的 Unlock 方法释放锁。\",\"未获得锁的 client 是如何等待的呢?\",\"// wait for deletion revisions prior to myKey hdr, werr := waitDeletes(ctx, client, m.pfx, m.myRev-1) // release lock key if wait failed if werr != nil { m.Unlock(client.Ctx()) } else { m.hdr = hdr }\",\"通过 Watch 机制各自监听 prefix 相同，revision 比自己小的 key，因为只有 revision 比自己小的 key 释放锁，我才能有机会，获得锁，如下代码所示，其中 waitDelete 会使用我们上面的介绍的 Watch 去监听比自己小的 key\",\"为什么使用etcd分布式锁比redis分布式锁更好？\",\"相比 Redis 基于主备异步复制导致锁的安全性问题，etcd 是基于 Raft 共识算法实现的，一个写请求需要经过集群多数节点确认。因此一旦分布式锁申请返回给 client 成功后，它一定是持久化到了集群多数节点上，不会出现 Redis 主备异步复制可能导致丢数据的问题，具备更高的安全性。\",\"分布式锁的三个主要核心要素\",\"安全性、互斥性。在同一时间内，不允许多个 client 同时获得锁。\",\"活性。无论 client 出现 crash 还是遭遇网络分区，你都需要确保任意故障场景下，都不会出现死锁，常用的解决方案是超时和自动过期机制。\",\"高可用、高性能。加锁、释放锁的过程性能开销要尽量低，同时要保证高可用，避免单点故障。\"]},\"1\":{\"c\":[\"etcd\"]},\"2\":{\"c\":[\"分布式锁\"]},\"3\":{\"h\":\"k8s知识点\",\"t\":[\"k8s 笔记总结\"]},\"4\":{\"h\":\"访问模式（Access Modes）\",\"t\":[\"Kubernetes支持的访问模式如下。\",\"ReadWriteOnce（RWO）：读写权限，并且只能被单个Node挂 载。\",\"ReadOnlyMany（ROX）：只读权限，允许被多个Node挂载。\",\"ReadWriteMany（RWX）：读写权限，允许被多个Node挂载。\",\"某些PV可能支持多种访问模式，但PV在挂载时只能使用一种访问模式，多种访问模式不能同时生效。\"]},\"5\":{\"h\":\"回收策略（Reclaim Policy）\",\"t\":[\"Kubernetes支持的回收策略如下。\",\"Retain：保留数据，需要手工处理。\",\"Recycle：简单清除文件的操作。\",\"Delete：与PV相连的后端存储完成Volume的删除操作。\",\"目前只有NFS和HostPath两种类型的PV支持Recycle策略； AWSElasticBlockStore、GCEPersistentDisk、AzureDisk和Cinder类型的PV支持Delete策略。\"]},\"6\":{\"h\":\"PV (STATUS)\",\"t\":[\"在 Kubernetes 中，PersistentVolume (PV) 是一个集群级别的资源，用于表示集群中持久化存储的详细信息和状态。PV 的状态由其 STATUS 字段来表示，它反映了存储卷的当前状态。了解这些状态有助于掌握 PV 在生命周期中的位置，以及它是否能够被持久卷声明 (PersistentVolumeClaim, PVC) 使用。\",\"以下是 Kubernetes 中 PV 的几种可能的状态：\"]},\"7\":{\"h\":\"1.\",\"t\":[\"描述: 该状态表示 PV 可以被绑定到 PVC。PV 处于 Available 状态时，它未被任何 PVC 使用，可以供新的 PVC 绑定。\",\"特点: \",\"PV 还未与任何 PVC 绑定。\",\"准备好用于新的 PVC 绑定。\"]},\"8\":{\"h\":\"2.\",\"t\":[\"描述: 该状态表示 PV 已经被绑定到一个 PVC，且正被 PVC 使用。\",\"特点: \",\"PV 已经与一个 PVC 绑定。\",\"它不能再被其他 PVC 绑定，直到被释放。\"]},\"9\":{\"h\":\"3.\",\"t\":[\"描述: 该状态表示 PV 之前已经绑定的 PVC 已经被删除，但是 PV 本身还没有被集群中的任何新 PVC 再次使用。\",\"特点: \",\"PVC 已被删除。\",\"数据可能仍然存在于 PV 上，但它还未被新的 PVC 重新绑定。\"]},\"10\":{\"h\":\"4.\",\"t\":[\"描述: 该状态表示 PV 由于某种原因无法使用，通常是因为与 PV 相关的存储设备出现了错误或问题。\",\"特点: \",\"PV 在操作过程中遇到错误，无法正常使用。\",\"可能需要管理员干预以修复问题。\"]},\"11\":{\"h\":\"状态转换\",\"t\":[\"PV 的状态转换通常遵循以下过程：\",\"初始状态: PV 被创建后，处于 Available 状态。\",\"绑定: 一个 PVC 请求匹配 PV，PV 被绑定到 PVC 后，状态变为 Bound。\",\"释放: PVC 被删除后，PV 状态变为 Released。\",\"再利用或删除: \",\"如果允许再利用，管理员可以手动将 PV 状态重置为 Available，使其可以绑定到新的 PVC。\",\"如果 PV 被认为不再需要，可能会被删除。\"]},\"12\":{\"h\":\"状态图示\",\"t\":[\"以下是状态转换的示意图：\",\"Available | | PVC 绑定 V Bound | | PVC 删除 V Released | | 删除或再利用 V Failed (或) Available\",\"在 Kubernetes（K8s）集群中，ResourceQuotas 和 LimitRanges 是两种用于资源管理和控制的机制。它们帮助管理员确保资源的公平分配和高效利用。以下是对这两者的详细介绍：\"]},\"13\":{\"h\":\"ResourceQuotas\",\"t\":[\"ResourceQuotas 是一种在 Kubernetes 中用来限制命名空间（Namespace）内资源总量的机制。它们用于防止某个命名空间消耗过多的集群资源，从而影响其他命名空间的正常运行。\"]},\"14\":{\"h\":\"作用\",\"t\":[\"限制命名空间资源使用: ResourceQuotas 确保每个命名空间不会消耗超过指定的资源限额。\",\"控制资源分配: 它们帮助管理员公平分配集群资源，防止资源耗尽。\",\"提升资源管理能力: 通过设置资源限额，管理员可以更好地管理和监控资源使用情况。\"]},\"15\":{\"h\":\"配置示例\",\"t\":[\"以下是一个 ResourceQuota 的 YAML 配置示例，它限制了某个命名空间内的 CPU 和内存总量，以及对象数量（如 Pod 和 Service）：\",\"apiVersion: v1 kind: ResourceQuota metadata: name: example-quota namespace: example-namespace spec: hard: pods: \\\"10\\\" # 限制 Pod 的总数量 services: \\\"5\\\" # 限制 Service 的总数量 requests.cpu: \\\"4\\\" # 限制 CPU 请求总量 requests.memory: \\\"8Gi\\\" # 限制内存请求总量 limits.cpu: \\\"10\\\" # 限制 CPU 使用总量 limits.memory: \\\"16Gi\\\" # 限制内存使用总量\"]},\"16\":{\"h\":\"主要字段\",\"t\":[\"hard: 定义了资源的硬性限制，包括 CPU、内存、存储和对象数量等。\",\"scopes: 可选字段，指定了 ResourceQuota 适用的对象范围（如仅应用于某些特定的资源类型）。\"]},\"17\":{\"h\":\"使用场景\",\"t\":[\"开发环境: 限制资源以确保测试环境不会占用过多的生产资源。\",\"多租户环境: 在共享集群中，控制不同租户（命名空间）之间的资源使用。\",\"成本管理: 控制资源使用来管理和控制成本。\"]},\"18\":{\"h\":\"LimitRanges\",\"t\":[\"LimitRanges 是一种在 Kubernetes 中用于限制命名空间内单个 Pod 或容器资源使用的机制。与 ResourceQuotas 的整体限制不同，LimitRanges 主要控制单个 Pod 或容器的资源使用范围。\"]},\"19\":{\"h\":\"作用\",\"t\":[\"设置默认资源限制: 如果 Pod 或容器没有指定资源请求和限制，LimitRanges 可以提供默认值。\",\"防止资源过度消耗: 通过限制单个容器或 Pod 的资源使用，防止过多的资源消耗影响整个集群的性能。\",\"鼓励合理的资源分配: 鼓励开发人员在部署 Pod 时合理设置资源请求和限制。\"]},\"20\":{\"h\":\"配置示例\",\"t\":[\"以下是一个 LimitRange 的 YAML 配置示例，它为容器设置了 CPU 和内存的默认值和最大/最小值：\",\"apiVersion: v1 kind: LimitRange metadata: name: example-limits namespace: example-namespace spec: limits: - max: cpu: \\\"1\\\" # 容器的最大 CPU 使用量 memory: \\\"1Gi\\\" # 容器的最大内存使用量 min: cpu: \\\"100m\\\" # 容器的最小 CPU 使用量 memory: \\\"128Mi\\\" # 容器的最小内存使用量 default: cpu: \\\"500m\\\" # 容器的默认 CPU 请求量 memory: \\\"512Mi\\\" # 容器的默认内存请求量 defaultRequest: cpu: \\\"250m\\\" # 容器的默认 CPU 请求 memory: \\\"256Mi\\\" # 容器的默认内存请求 type: Container # 应用类型\"]},\"21\":{\"h\":\"主要字段\",\"t\":[\"max: 定义了单个容器可以请求的最大资源量。\",\"min: 定义了单个容器必须请求的最小资源量。\",\"default: 定义了容器没有指定资源请求和限制时的默认值。\",\"defaultRequest: 定义了容器没有指定资源请求时的默认请求值。\",\"type: 指定了限制适用于 Pod 还是容器。\"]},\"22\":{\"h\":\"使用场景\",\"t\":[\"应用程序标准化: 在命名空间内强制执行资源使用标准，确保所有容器符合预期的资源使用模式。\",\"资源优化: 防止资源过度配置或资源不足，从而优化集群性能和资源利用率。\",\"开发与测试环境: 在不同环境中设置不同的限制，确保资源的合理分配和使用。\"]},\"23\":{\"h\":\"比较与总结\",\"t\":[\"ResourceQuotas:\",\"范围: 适用于整个命名空间的资源总量。\",\"目的: 控制命名空间内的资源使用上限，确保集群资源的公平分配和高效利用。\",\"典型场景: 多租户环境、开发环境中的资源限制。\",\"LimitRanges:\",\"范围: 适用于单个 Pod 或容器的资源使用。\",\"目的: 设置资源使用的默认值和最大/最小限制，防止个体资源过度消耗。\",\"典型场景: 应用程序的资源标准化和资源优化。\",\"两者结合使用，可以在 Kubernetes 集群中提供强大的资源管理能力，确保资源的公平分配和高效使用。\"]},\"24\":{\"h\":\"k8s技能图谱\"},\"25\":{\"h\":\"静态pod\",\"t\":[\"Static Pod 是 Kubernetes 中的一种特殊类型的 Pod，它由 kubelet 直接管理，而不是通过 Kubernetes API Server 来创建和管理。Static Pod 通常用于集群管理工具（如 Kubernetes 本身）的部署和管理，尤其是在 Kubernetes 控制平面组件（如 etcd、kube-apiserver、kube-controller-manager 和 kube-scheduler）自身的管理中。\"]},\"26\":{\"h\":\"Static Pod 的特点\",\"t\":[\"由 kubelet 管理：\",\"Static Pod 由运行在节点上的 kubelet 直接管理，不需要 API Server 的参与。\",\"kubelet 会定期扫描特定的目录（通常是 /etc/kubernetes/manifests）中的 Pod 定义文件，并根据这些文件创建和管理 Pod。\",\"没有 ReplicaSet 或 Deployment：\",\"Static Pod 不是通过 Deployment、ReplicaSet 或其他控制器管理的，因此它们没有自动伸缩、滚动更新等高级特性。\",\"静态配置：\",\"Static Pod 的配置是静态文件，通常是 JSON 或 YAML 格式，存放在节点的文件系统中。\",\"这些配置文件不会因为 API Server 或 etcd 的故障而丢失，因此非常适合用于管理集群的核心组件。\",\"自动重启：\",\"如果 Static Pod 崩溃或被删除，kubelet 会根据配置文件自动重新创建它们，保证这些关键组件的高可用性。\"]},\"27\":{\"h\":\"创建 Static Pod\",\"t\":[\"要创建一个 Static Pod，你需要在节点的特定目录中（通常是 /etc/kubernetes/manifests）创建一个包含 Pod 定义的 YAML 文件。以下是一个示例：\",\"# 文件路径：/etc/kubernetes/manifests/static-pod-example.yaml apiVersion: v1 kind: Pod metadata: name: static-pod-example namespace: kube-system spec: containers: - name: nginx image: nginx:latest ports: - containerPort: 80\",\"将上述 YAML 文件保存到节点的 /etc/kubernetes/manifests 目录中后，kubelet 会自动检测到该文件并创建对应的 Pod。\"]},\"28\":{\"h\":\"使用场景\",\"t\":[\"Static Pod 通常用于以下场景：\",\"Kubernetes 控制平面组件：\",\"部署和管理 Kubernetes 控制平面组件（如 etcd、kube-apiserver、kube-controller-manager 和 kube-scheduler），这些组件必须在集群启动时运行，不能依赖于 Kubernetes 自身来管理。\",\"集群启动和恢复：\",\"在集群启动或恢复过程中，使用 Static Pod 确保关键组件能够独立于 Kubernetes API Server 和 etcd 正常启动。\",\"简化的节点管理：\",\"在一些简化的集群管理方案中，可能会使用 Static Pod 来运行节点级别的服务或代理，而不依赖于 Kubernetes 控制器。\"]},\"29\":{\"h\":\"监控和管理\",\"t\":[\"由于 Static Pod 由 kubelet 直接管理，因此它们的一些管理和监控操作与普通 Pod 略有不同：\",\"日志查看：你仍然可以使用 kubectl logs 命令查看 Static Pod 的日志。\",\"状态检查：可以使用 kubectl get pod -n kube-system 命令查看 Static Pod 的状态。\",\"更新 Pod：要更新 Static Pod，需要手动编辑对应的 YAML 文件，kubelet 会自动检测到文件的变化并重新创建 Pod。\",\"Static Pod 是 Kubernetes 提供的一种灵活机制，用于确保关键组件的高可用性和独立性，是集群稳定运行的关键保障之一。\"]},\"30\":{\"h\":\"Taint\",\"t\":[\"Taint 是 Kubernetes 中的一种机制，用于限制 Pod 在节点上运行的条件。Taint 可以应用于节点，并指定一个键值对，用于限制 Pod 在节点上运行的条件。\"]},\"31\":{\"h\":\"Taint 机制\",\"t\":[\"Taint 是应用在节点上的属性，表示这个节点对某些 Pod 来说是不合适的。每个 Taint 由三个部分组成：\",\"键（Key）：标识 Taint 的名称。\",\"值（Value）：标识 Taint 的具体值。\",\"效果（Effect）：标识 Taint 的作用方式。常见的效果有三种： \",\"NoSchedule：新的 Pod 不会被调度到这个节点上。\",\"PreferNoSchedule：尽量避免将新的 Pod 调度到这个节点上，但如果没有其他合适的节点，也可能会调度。\",\"NoExecute：已经运行在这个节点上的 Pod 会被驱逐，新 Pod 也不会被调度到这个节点上。\",\"节点设置taint\",\"kubectl taint no minikube level=high:NoSchedule\",\"移除 Taint\",\"kubectl taint no minikube level=high:NoSchedule-\",\"Pod设置toleration\",\"apiVersion: apps/v1 kind: Deployment metadata: name: nginx spec: replicas: 1 selector: matchLabels: app: nginx template: metadata: labels: app: nginx spec: containers: - name: nginx command: [\\\"python3\\\"] args: [\\\"-m\\\", \\\"http.server\\\", \\\"9999\\\"] image: \\\"registry.cnbita.com:5000/wangshi/python:3.10\\\" imagePullPolicy: IfNotPresent ports: - name: http containerPort: 80 protocol: TCP resources: requests: cpu: 100m memory: 128Mi limits: cpu: 500m memory: 256Mi tolerations: - key: \\\"level\\\" operator: \\\"Equal\\\" value: \\\"high\\\" effect: \\\"NoSchedule\\\"\",\"上述配置说明pod能够容忍节点设置taint的level=high:NoSchedule，如果pod不设置亲和性tolerations，则无法进行部署。如下所示：\",\"Tolerations: node.kubernetes.io/not-ready:NoExecute op=Exists for 300s node.kubernetes.io/unreachable:NoExecute op=Exists for 300s Events: Type Reason Age From Message ---- ------ ---- ---- ------- Warning FailedScheduling 3m57s default-scheduler 0/1 nodes are available: 1 node(s) had untolerated taint {level: high}. preemption: 0/1 nodes are available: 1 Preemption is not helpful for scheduling..\",\"在 Kubernetes 中，taint 是用于节点管理的机制，通过标记节点来影响 Pod 的调度。Taints 可以防止某些 Pod 调度到特定节点上，除非这些 Pod 具有相应的 toleration。这种机制有助于确保工作负载在集群中得到更好地分布和隔离。\"]},\"32\":{\"h\":\"无头服务（Headless Services）\",\"t\":[\"在 Kubernetes 中，Headless Service 是一种特殊类型的 Service，不会分配集群 IP（ClusterIP）。这种服务类型主要用于暴露 StatefulSet 的每个 Pod，并且允许直接访问每个 Pod。下面是对 Kubernetes Headless Service 的详细介绍：\"]},\"33\":{\"h\":\"Headless Service 的特点\",\"t\":[\"没有 Cluster IP：\",\"与普通的 Kubernetes Service 不同，Headless Service 不会为服务分配一个 Cluster IP。它通过将 ClusterIP 字段设置为 None 来实现这一点。\",\"直接访问 Pod：\",\"Headless Service 允许客户端直接访问服务后端的每个 Pod，而不是通过负载均衡器来访问。这对于需要直接与特定 Pod 进行通信的场景非常有用，例如 StatefulSet 中的数据库分片或有状态应用。\",\"DNS 解析：\",\"Headless Service 会为每个 Pod 创建一个 DNS 记录，这样客户端可以通过 DNS 名称直接访问特定的 Pod。对于 StatefulSet，每个 Pod 都有一个稳定的 DNS 名称。\"]},\"34\":{\"h\":\"使用场景\",\"t\":[\"Headless Service 主要用于以下几种场景：\",\"StatefulSet：\",\"StatefulSet 通常用于部署有状态应用，例如数据库集群或分布式文件系统。Headless Service 允许这些有状态应用中的各个 Pod 直接相互访问。\",\"自定义服务发现：\",\"在某些情况下，应用需要自定义的服务发现机制，而不是 Kubernetes 提供的负载均衡。Headless Service 允许应用自行管理和发现服务实例。\"]},\"35\":{\"h\":\"Headless Service 的定义示例\",\"t\":[\"以下是一个 Headless Service 的 YAML 定义示例：\",\"apiVersion: v1 kind: Service metadata: name: headless-service namespace: default spec: clusterIP: None selector: app: my-app ports: - name: http port: 80 targetPort: 8080\",\"这个示例定义了一个名为 headless-service 的服务，没有 ClusterIP。它选择了带有标签 app: my-app 的 Pod，并将流量从服务的 80 端口转发到 Pod 的 8080 端口。\"]},\"36\":{\"h\":\"StatefulSet 与 Headless Service 的结合\",\"t\":[\"以下是一个使用 Headless Service 的 StatefulSet 示例：\"]},\"37\":{\"h\":\"定义 Headless Service\",\"t\":[\"apiVersion: v1 kind: Service metadata: name: my-stateful-service namespace: default spec: clusterIP: None selector: app: my-stateful-app ports: - name: http port: 80 targetPort: 8080\"]},\"38\":{\"h\":\"定义 StatefulSet\",\"t\":[\"apiVersion: apps/v1 kind: StatefulSet metadata: name: my-stateful-app namespace: default spec: serviceName: \\\"my-stateful-service\\\" replicas: 3 selector: matchLabels: app: my-stateful-app template: metadata: labels: app: my-stateful-app spec: containers: - name: my-container image: my-image ports: - containerPort: 8080\",\"在这个例子中，my-stateful-service 是一个 Headless Service，它与 my-stateful-app StatefulSet 结合使用。每个 StatefulSet Pod 都有一个稳定的 DNS 名称，例如 my-stateful-app-0.my-stateful-service.default.svc.cluster.local。\"]},\"39\":{\"h\":\"总结\",\"t\":[\"Headless Service 是 Kubernetes 中的一种特殊服务类型，适用于需要直接访问每个 Pod 的场景。它通过不分配 Cluster IP 来实现这一点，并为每个 Pod 提供稳定的 DNS 记录。Headless Service 通常用于有状态应用和自定义服务发现场景，尤其是在 StatefulSet 中。\"]},\"40\":{\"h\":\"Kubelet的\",\"t\":[\"Kubelet 的 hairpin-mode 是一个配置选项，它决定了 Pod 内的容器是否能够通过 Pod 的 IP 访问自身以及同一 Pod 中的其他容器的服务。这种访问模式被称为“发夹模式（Hairpin Mode）”。具体来说，hairpin-mode 的作用是在容器网络接口上设置发夹规则，使得流量可以从容器发出后，又从同一个网络接口回到容器内部。\"]},\"41\":{\"h\":\"Hairpin Mode 的工作原理\",\"t\":[\"在发夹模式下，容器内的应用可以通过服务 IP 或者 Pod IP 访问同一 Pod 内的其他容器。这种模式主要用于以下情况：\",\"自访问：容器需要通过 Pod IP 访问自己，例如某些服务需要通过自身的外部 IP 进行健康检查。\",\"内部通信：同一个 Pod 内的多个容器之间的通信，通过 Pod 的网络接口实现内循环。\"]},\"42\":{\"h\":\"配置\",\"t\":[\"Kubelet 提供了几个选项来配置 hairpin-mode：\",\"hairpin-veth：启用发夹模式，这是默认模式。Kubelet 会在创建容器网络接口时启用发夹规则。\",\"promiscuous-bridge：使用混杂模式的网桥。这种模式在性能上可能有一些开销，但在某些网络插件或环境下可能是必要的。\",\"none：禁用发夹模式。这种模式下，容器无法通过 Pod IP 访问自身或同一 Pod 内的其他容器。\"]},\"43\":{\"h\":\"配置示例\",\"t\":[\"要配置 hairpin-mode，可以在 Kubelet 的启动参数中设置。例如，在 kubelet 配置文件中：\",\"apiVersion: kubelet.config.k8s.io/v1beta1 kind: KubeletConfiguration hairpinMode: hairpin-veth\",\"或者在启动 Kubelet 时通过命令行参数：\",\"kubelet --hairpin-mode=hairpin-veth\"]},\"44\":{\"h\":\"使用场景\",\"t\":[\"服务自身健康检查：某些服务需要通过 Pod IP 对自身进行健康检查。\",\"同一 Pod 内的容器通信：Pod 内部的不同容器通过 Pod IP 进行通信，简化网络配置。\"]},\"45\":{\"h\":\"总结\",\"t\":[\"hairpin-mode 是 Kubelet 的一个重要配置选项，用于控制容器是否能够通过 Pod IP 进行自访问和内部通信。根据具体的应用场景和需求，可以选择适当的发夹模式配置。常见的选择是默认的 hairpin-veth 模式，它能够在大多数场景下提供良好的性能和功能支持。\"]},\"46\":{\"h\":\"资源短缺\",\"t\":[\"QoS 划分的主要应用场景，是当宿主机资源紧张的时候，kubelet 对 Pod 进行 Eviction（即资源回收）时需要用到的。\",\"具体地说，当 Kubernetes 所管理的宿主机上不可压缩资源短缺时，就有可能触发 Eviction。比如，可用内存（memory.available）、可用的宿主机磁盘空间（nodefs.available），以及容器运行时镜像存储空间（imagefs.available）等等。\",\"目前，Kubernetes 为你设置的 Eviction 的默认阈值如下所示：\",\"memory.available<100Mi nodefs.available<10% nodefs.inodesFree<5% imagefs.available<15%\",\"上述各个触发条件在 kubelet 里都是可配置的\",\"kubelet --eviction-hard=imagefs.available<10%,memory.available<500Mi,nodefs.available<5%,nodefs.inodesFree<5% --eviction-soft=imagefs.available<30%,nodefs.available<10% --eviction-soft-grace-period=imagefs.available=2m,nodefs.available=2m --eviction-max-pod-grace-period=600\",\"Eviction 在 Kubernetes 里其实分为 Soft 和 Hard 两种模式。\",\"其中，Soft Eviction 允许你为 Eviction 过程设置一段“优雅时间”，比如上面例子里的 imagefs.available=2m，就意味着当 imagefs 不足的阈值达到 2 分钟之后，kubelet 才会开始 Eviction 的过程。\",\"而 Hard Eviction 模式下，Eviction 过程就会在阈值达到之后立刻开始。\",\"Kubernetes 计算 Eviction 阈值的数据来源，主要依赖于从 Cgroups 读取到的值，以及使用 cAdvisor 监控到的数据。\",\"Pod 的 QoS 类别： Guaranteed > Burstable > BestEffort\",\"Kubernetes 会保证只有当 Guaranteed 类别的 Pod 的资源使用量超过了其 limits 的限制，或者宿主机本身正处于 Memory Pressure 状态时，Guaranteed 的 Pod 才可能被选中进行 Eviction 操作。\"]},\"47\":{\"h\":\"如何能够让 Kubernetes 的调度器尽可能地将 Pod 分布在不同机器上，避免“堆叠”呢?\",\"t\":[\"在 Kubernetes 中，可以通过以下几种方式配置调度策略，以尽可能地将 Pod 分布在不同的节点上，避免“堆叠”：\"]},\"48\":{\"h\":\"1. Pod 反亲和性（Pod Anti-Affinity）\",\"t\":[\"Pod 反亲和性是一种调度约束，允许用户指定某些 Pod 不应该与其他特定 Pod 运行在同一个节点上。\"]},\"49\":{\"h\":\"示例\",\"t\":[\"apiVersion: v1 kind: Pod metadata: name: example-pod spec: affinity: podAntiAffinity: requiredDuringSchedulingIgnoredDuringExecution: - labelSelector: matchExpressions: - key: app operator: In values: - myapp topologyKey: \\\"kubernetes.io/hostname\\\"\",\"在这个示例中，podAntiAffinity 指定了具有相同标签 app=myapp 的 Pod 不应该被调度到相同的节点上。topologyKey 为 kubernetes.io/hostname，表示约束作用在节点级别。\"]},\"50\":{\"h\":\"2. 节点亲和性（Node Affinity）\",\"t\":[\"Node Affinity 允许调度器根据节点标签选择合适的节点。这可以用于避免将所有 Pod 调度到相同的节点。\"]},\"51\":{\"h\":\"示例\",\"t\":[\"apiVersion: v1 kind: Pod metadata: name: example-pod spec: affinity: nodeAffinity: requiredDuringSchedulingIgnoredDuringExecution: nodeSelectorTerms: - matchExpressions: - key: disktype operator: In values: - ssd\",\"这个示例展示了如何使用节点标签（disktype=ssd）进行调度，以确保 Pod 被调度到带有特定标签的节点上。\"]},\"52\":{\"h\":\"3. 分布式调度策略（Spread Constraints）\",\"t\":[\"Kubernetes 1.18 引入了 TopologySpreadConstraints，允许用户定义分布式调度策略，确保 Pod 均匀地分布在集群的不同节点上。\"]},\"53\":{\"h\":\"示例\",\"t\":[\"apiVersion: v1 kind: Pod metadata: name: example-pod spec: topologySpreadConstraints: - maxSkew: 1 topologyKey: kubernetes.io/hostname whenUnsatisfiable: DoNotSchedule labelSelector: matchLabels: app: myapp containers: - name: my-container image: my-image\",\"在这个示例中，topologySpreadConstraints 指定 Pod 应该均匀地分布在不同的节点上。maxSkew 表示同一节点上的 Pod 数量与其他节点上的最大偏差不超过1。\"]},\"54\":{\"h\":\"4. 自定义调度器策略（Custom Scheduler Policies）\",\"t\":[\"Kubernetes 允许使用自定义调度策略文件来自定义调度行为。例如，可以设置 EvenPodsSpreadPriority 来实现均匀调度。\"]},\"55\":{\"h\":\"示例\",\"t\":[\"自定义调度策略文件（scheduler-policy-config.json）：\",\"{ \\\"kind\\\": \\\"Policy\\\", \\\"apiVersion\\\": \\\"v1\\\", \\\"priorities\\\": [ { \\\"name\\\": \\\"EvenPodsSpreadPriority\\\", \\\"weight\\\": 1 } ] }\",\"启动调度器时使用该策略文件：\",\"kube-scheduler --policy-config-file=scheduler-policy-config.json\",\"通过配置这些策略，可以显著改善 Pod 在集群中的分布情况，避免“堆叠”问题，实现资源的更高效利用。\"]},\"56\":{\"h\":\"kubelet如何实现 exec、logs 等接口\",\"t\":[\"gRPC 接口调用期间，kubelet 需要跟容器项目维护一个长连接来传输数据。这种 API，我们就称之为 Streaming API。\",\"CRI shim 里对 Streaming API 的实现，依赖于一套独立的 Streaming Server 机制。\",\"可以看到，当我们对一个容器执行 kubectl exec 命令的时候，这个请求首先交给 API Server，然后 API Server 就会调用 kubelet 的 Exec API。\",\"这时，kubelet 就会调用 CRI 的 Exec 接口，而负责响应这个接口的，自然就是具体的 CRI shim。\",\"但在这一步，CRI shim 并不会直接去调用后端的容器项目（比如 Docker ）来进行处理，而只会返回一个 URL 给 kubelet。这个 URL，就是该 CRI shim 对应的 Streaming Server 的地址和端口。\",\"而 kubelet 在拿到这个 URL 之后，就会把它以 Redirect 的方式返回给 API Server。所以这时候，API Server 就会通过重定向来向 Streaming Server 发起真正的 /exec 请求，与它建立长连接\",\"当然，这个 Streaming Server 本身，是需要通过使用 SIG-Node 为你维护的 Streaming API 库来实现的。并且，Streaming Server 会在 CRI shim 启动时就一起启动。此外，Stream Server 这一部分具体怎么实现，完全可以由 CRI shim 的维护者自行决定。比如，对于 Docker 项目来说，dockershim 就是直接调用 Docker 的 Exec API 来作为实现的。\"]},\"57\":{\"h\":\"集群安装\",\"t\":[\"kubeadm init --cri-socket unix:///var/run/cri-dockerd.sock\",\"kubeadm reset --cri-socket unix:///var/run/cri-dockerd.sock\",\"解决\",\"l 29 15:07:31 DESKTOP-P54EAF3 kubelet[3437386]: I0729 15:07:31.604995 3437386 server.go:469] \\\"Golang settings\\\" GOGC=\\\"\\\" GOMAXPROCS=\\\"\\\" GOTRACEBACK=\\\"\\\" Jul 29 15:07:31 DESKTOP-P54EAF3 kubelet[3437386]: I0729 15:07:31.605172 3437386 server.go:895] \\\"Client rotation is on, will bootstrap in background\\\" Jul 29 15:07:31 DESKTOP-P54EAF3 kubelet[3437386]: I0729 15:07:31.607274 3437386 certificate_store.go:130] Loading cert/key pair from \\\"/var/lib/kubelet/pki/kubelet-client-current.pem\\\". Jul 29 15:07:31 DESKTOP-P54EAF3 kubelet[3437386]: I0729 15:07:31.608035 3437386 dynamic_cafile_content.go:157] \\\"Starting controller\\\" name=\\\"client-ca-bundle::/etc/kubernetes/pki/ca.crt\\\" Jul 29 15:07:31 DESKTOP-P54EAF3 kubelet[3437386]: W0729 15:07:31.611818 3437386 sysinfo.go:203] Nodes topology is not available, providing CPU topology Jul 29 15:07:31 DESKTOP-P54EAF3 kubelet[3437386]: I0729 15:07:31.619656 3437386 server.go:725] \\\"--cgroups-per-qos enabled, but --cgroup-root was not specified. defaulting to /\\\" Jul 29 15:07:31 DESKTOP-P54EAF3 kubelet[3437386]: E0729 15:07:31.619995 3437386 run.go:74] \\\"command failed\\\" err=\\\"failed to run Kubelet: running with swap on is not supported, please disable swap! or set --fail-swap-on flag to false. /proc/swaps contained: [Filename\\\\t\\\\t\\\\t\\\\tType\\\\t\\\\tSize\\\\t\\\\tUsed\\\\t\\\\tPriority /dev/sdb partition\\\\t4194304\\\\t\\\\t8580\\\\t\\\\t-2]\\\" Jul 29 15:07:31 DESKTOP-P54EAF3 systemd[1]: kubelet.service: Main process exited, code=exited, status=1/FAILURE Jul 29 15:07:31 DESKTOP-P54EAF3 systemd[1]: kubelet.service: Failed with result 'exit-code'.\"]},\"58\":{\"c\":[\"k8s\"]},\"59\":{\"c\":[\"笔记\"]},\"60\":{\"h\":\"Kong和Nginx部署服务\",\"t\":[\"Kong和Nginx创建服务和路由\",\"下面是你使用Kong和Nginx创建服务和路由的步骤总结：\"]},\"61\":{\"h\":\"1. Nginx容器启动\",\"t\":[\"你通过以下命令启动了一个Nginx容器，该容器暴露8088端口并挂载了配置文件和项目目录：\",\"docker run -itd --name nginx --privileged --restart=always --network=kong-net -m 2GB -p 8088:8088 -v /mnt/d/docker/nginx/project:/data/project -v /mnt/d/docker/nginx/conf/nginx.conf:/etc/nginx/nginx.conf nginx:latest\",\"容器名: nginx\",\"网络: kong-net\",\"端口映射: 8088:8088\",\"挂载: 项目目录和nginx配置文件\"]},\"62\":{\"h\":\"2. 安装Kong\",\"t\":[\"按照Kong官方文档安装指南安装了Kong，并确保Kong服务已正确启动。\"]},\"63\":{\"h\":\"3. 创建服务\",\"t\":[\"通过以下命令在Kong中创建了一个名为 hello_service 的服务，指向Nginx服务中的 index.html 文件：\",\"curl -i -s -X POST http://localhost:8001/services \\\\ --data name=hello_service \\\\ --data url='http://nginx:8088/index.html'\"]},\"64\":{\"h\":\"4. 查询服务\",\"t\":[\"通过以下命令查询了服务是否成功创建：\",\"curl -X GET http://localhost:8001/services/hello_service\"]},\"65\":{\"h\":\"5. 删除服务\",\"t\":[\"如果需要删除服务，可以使用以下命令：\",\"curl -i -s -X DELETE http://localhost:8001/services/hello_service\"]},\"66\":{\"h\":\"6. 创建路由\",\"t\":[\"为 hello_service 创建了一个路由 hello_route，设置路径为 /hello：\",\"curl -i -X POST http://localhost:8001/services/hello_service/routes \\\\ --data 'paths[]=/hello' \\\\ --data name=hello_route\"]},\"67\":{\"h\":\"7. 查询路由\",\"t\":[\"通过以下命令查询了路由是否成功创建：\",\"curl -X GET http://localhost:8001/services/hello_service/routes/hello_route\"]},\"68\":{\"h\":\"8. 删除路由\",\"t\":[\"如果需要删除路由，可以使用以下命令：\",\"curl -i -s -X DELETE http://localhost:8001/routes/hello_route\"]},\"69\":{\"h\":\"9. 访问服务\",\"t\":[\"最终，你可以通过以下命令访问Kong代理的服务：\",\"curl -X GET http://localhost:8000/hello\",\"这将通过Kong访问到Nginx提供的 index.html 页面。\"]},\"70\":{\"h\":\"总结\",\"t\":[\"Nginx容器: 用于提供静态文件，通过Kong路由访问。\",\"Kong服务: 用于管理和代理请求，将Kong中的服务映射到Nginx容器中的资源。\",\"Kong路由: 用于定义访问路径，将特定的路径请求路由到相应的服务。\",\"验证和管理: 通过 curl 命令查询、删除服务和路由，确保配置正确。\",\"这个配置实现了通过Kong网关将请求转发到Nginx容器中的具体路径。\",\"index.html\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\"> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\"> <title>Hello World</title> <style> body { display: flex; justify-content: center; align-items: center; height: 100vh; margin: 0; background: linear-gradient(to right, #ff7e5f, #feb47b); /* 渐变背景 */ color: white; font-family: Arial, sans-serif; font-size: 48px; } h1 { margin: 0; } footer { text-align: center; position: absolute; bottom: 10px; width: 100%; font-size: 14px; color: #ffffff; } </style> </head> <body> <h1>Hello, World!</h1> <footer> <p><a href=\\\"https://beian.miit.gov.cn/\\\" target=\\\"_blank\\\" style=\\\"color: white;\\\">8888888</a></p> </footer> </body> </html>\",\"nginx.conf\",\"worker_processes 1; events { worker_connections 1024; } http { include mime.types; default_type application/octet-stream; access_log off; error_log /dev/null crit; sendfile on; keepalive_timeout 65; server { listen 8088; server_name localhost; ssl_session_cache shared:SSL:1m; ssl_session_timeout 30m; ssl_prefer_server_ciphers on; # 安全链接可选的加密协议 ssl_protocols TLSv1.1 TLSv1.2 TLSv1.3; # 配置加密套件/加密算法，写法遵循 openssl 标准。 ssl_ciphers EECDH+CHACHA20:EECDH+CHACHA20-draft:EECDH+AES128:RSA+AES128:EECDH+AES256:RSA+AES256:EECDH+3DES:RSA+3DES:!MD5; location / { proxy_redirect off; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection \\\"upgrade\\\"; proxy_read_timeout 3600s; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; proxy_set_header X-Forwarded-Port $server_port; add_header backendIP $upstream_addr; add_header backendCode $upstream_status; # 允许跨域的请求，可以自定义变量$http_origin，*表示所有 add_header 'Access-Control-Allow-Origin' *; # 允许携带cookie请求 add_header 'Access-Control-Allow-Credentials' 'true'; # 允许跨域请求的方法：GET,POST,OPTIONS,PUT add_header 'Access-Control-Allow-Methods' 'GET,POST,OPTIONS,PUT'; # 允许请求时携带的头部信息，*表示所有 add_header 'Access-Control-Allow-Headers' *; # 允许发送按段获取资源的请求 add_header 'Access-Control-Expose-Headers' 'Content-Length,Content-Range'; add_header X-Frame-Options SAMEORIGIN always; # 禁用缓存 proxy_cache off; # 添加 Cache-Control 响应头 add_header Cache-Control \\\"no-cache, no-store\\\"; # 一定要有！！！否则Post请求无法进行跨域！ # 在发送Post跨域请求前，会以Options方式发送预检请求，服务器接受时才会正式请求 if ($request_method = 'OPTIONS') { add_header 'Access-Control-Max-Age' 1728000; add_header 'Content-Type' 'text/plain; charset=utf-8'; add_header 'Content-Length' 0; # 对于Options方式的请求返回204，表示接受跨域请求 return 204; } root /data/project; index index.html; # 默认文件名 } } }\"]},\"71\":{\"c\":[\"kong\"]},\"72\":{\"c\":[\"kong\",\"nginx\",\"html\"]},\"73\":{\"h\":\"Kubeflow 简介\",\"t\":[\"k8s 云原生之Kubeflow 简介\",\"https://www.kubeflow.org/docs/started/introduction/\",\"Kubeflow 简介 Kubeflow 项目致力于让机器学习 (ML) 工作流在 Kubernetes 上的部署变得简单、可移植且可扩展。我们的目标不是重新创建其他服务，而是提供一种简单的方法，将最佳的 ML 开源系统部署到各种基础设施中。只要您运行 Kubernetes，就可以运行 Kubeflow。 下图展示了主要的 Kubeflow 组件，涵盖 Kubernetes 之上 ML 生命周期的每个步骤。 \",\"Kubeflow 是一个面向想要构建和试验 ML 管道的数据科学家的平台。Kubeflow 还适用于想要将 ML 系统部署到各种环境以进行开发、测试和生产级服务的 ML 工程师和运营团队。\"]},\"74\":{\"h\":\"概念概述\",\"t\":[\"Kubeflow 是_Kubernetes 的 ML 工具包_。 下图展示了 Kubeflow 作为在 Kubernetes 之上安排 ML 系统组件的平台： \"]},\"75\":{\"h\":\"Pipeline\",\"t\":[\"在高层次上，管道的执行过程如下：\"]},\"76\":{\"h\":\"Python SDK：\",\"t\":[\"使用Kubeflow Pipelines特定领域语言（DSL）创建组件或指定管道。\"]},\"77\":{\"h\":\"：\",\"t\":[\"DSL编译器将您的管道的Python代码转换为静态配置（YAML）。\"]},\"78\":{\"h\":\"：\",\"t\":[\"调用管道服务以从静态配置创建管道运行。\"]},\"79\":{\"h\":\"：\",\"t\":[\"管道服务调用Kubernetes API服务器以创建运行管道所需的必要Kubernetes资源（CRD）。\"]},\"80\":{\"h\":\"：\",\"t\":[\"一组编排控制器执行完成管道所需的容器。这些容器在虚拟机上的Kubernetes Pod中执行。一个示例控制器是Argo Workflow控制器，它编排基于任务的工作流。\"]},\"81\":{\"h\":\"：\",\"t\":[\"Pod存储两种类型的数据：\",\"Metadata：实验、作业、管道运行和单个标量指标。度量数据被聚合用于排序和过滤。Kubeflow Pipelines将元数据存储在MySQL数据库中。\",\"Artifacts：管道包、视图和大规模指标（时间序列）。使用大规模指标来调试管道运行或调查单个运行的性能。Kubeflow Pipelines将工件存储在像Minio服务器或Cloud Storage之类的工件存储中。\",\"MySQL数据库和Minio服务器都由Kubernetes持久卷子系统支持。\"]},\"82\":{\"h\":\"：\",\"t\":[\"管道持久性代理监视管道服务创建的Kubernetes资源，并将这些资源的状态持久化到ML元数据服务中。管道持久性代理记录已执行的容器集合及其输入和输出。输入/输出包括容器参数或数据工件URI。\"]},\"83\":{\"h\":\"：\",\"t\":[\"管道Web服务器从各种服务中收集数据以显示相关视图：当前运行的管道列表、管道执行历史记录、数据工件列表、有关单个管道运行的调试信息、有关单个管道运行的执行状态。\"]},\"84\":{\"h\":\"Pipeline\",\"t\":[\"在 Kubeflow Pipelines 中，管道是对机器学习（ML）工作流的描述，包括工作流中的所有组件及其相互关系，以图的形式呈现。管道配置包括运行管道所需的输入（参数）的定义，以及每个组件的输入和输出。 当你运行一个管道时，系统会启动一个或多个 Kubernetes Pod，这些 Pod 对应于工作流（管道）中的各个步骤（组件）。这些 Pod 会启动 Docker 容器，而容器则会启动你的程序。 开发完成管道后，你可以使用 Kubeflow Pipelines UI 或 Kubeflow Pipelines SDK 上传你的管道。\"]},\"85\":{\"h\":\"Component\",\"t\":[\"在 Kubeflow Pipelines 中，组件是一个独立的代码集，它执行机器学习（ML）工作流（管道）中的某一步骤，例如数据预处理、数据转换、模型训练等。组件类似于函数，具有名称、参数、返回值和主体。\"]},\"86\":{\"h\":\"组件代码\",\"t\":[\"每个组件的代码包括以下部分：\",\"客户端代码：与端点通信以提交作业的代码。例如，与 Google Dataproc API 通信以提交 Spark 作业的代码。\",\"运行时代码：执行实际作业的代码，通常在集群中运行。例如，将原始数据转换为预处理数据的 Spark 代码。\",\"关于客户端代码和运行时代码的命名约定——对于名为“mytask”的任务：\",\"mytask.py 程序包含客户端代码。\",\"mytask 目录包含所有运行时代码。\"]},\"87\":{\"h\":\"组件定义\",\"t\":[\"用 YAML 格式的组件规范描述 Kubeflow Pipelines 系统中的组件。组件定义包括以下部分：\",\"元数据：名称、描述等。\",\"接口：输入/输出规范（名称、类型、描述、默认值等）。\",\"实现：描述在给定组件输入参数值的情况下如何运行组件的规范。实现部分还描述了组件完成运行后如何获取输出值。\",\"有关组件的完整定义，请参见组件规范。\"]},\"88\":{\"h\":\"容器化组件\",\"t\":[\"你必须将组件打包为 Docker 镜像。组件代表容器内的特定程序或入口点。 管道中的每个组件独立执行。组件不会在同一进程中运行，也不能直接共享内存数据。你必须将传递给组件之间的数据序列化（转换为字符串或文件），以便数据可以在分布式网络上传输。然后，必须反序列化这些数据以供下游组件使用。\"]},\"89\":{\"h\":\"Graph\",\"t\":[\"在 Kubeflow Pipelines 中，图（Graph）是管道运行时在 Kubeflow Pipelines UI 中的图形表示。图显示了管道运行已执行或正在执行的步骤，箭头指示了管道组件之间的父/子关系。运行一开始，就可以查看这个图。图中的每个节点对应管道中的一个步骤，并进行相应的标注。 每个节点的右上角有一个图标，指示其状态：运行中（running）、成功（succeeded）、失败（failed）或跳过（skipped）。当节点的父节点包含条件语句时，节点可能会被跳过。\"]},\"90\":{\"h\":\"Experiment\",\"t\":[\"实验是一个工作空间，你可以在其中尝试管道的不同配置。你可以使用实验将你的运行组织成逻辑组。实验可以包含任意的运行，包括定期运行。\",\"一次运行（run）是对管道的单次执行。运行包含你尝试的所有实验的不可变日志，设计为自包含的，以便于重现。你可以通过查看 Kubeflow Pipelines UI 上的运行详情页面来跟踪运行的进度，在那里你可以看到运行时的图表、输出工件和每个步骤的日志。 定期运行（recurring run）或在 Kubeflow Pipelines 后端 API 中称为作业（job），是管道的可重复运行。定期运行的配置包括指定所有参数值的管道副本和运行触发器。你可以在任何实验中启动定期运行，它会定期启动运行配置的新副本。你可以从 Kubeflow Pipelines UI 启用/禁用定期运行。你还可以指定最大并发运行数，以限制并行启动的运行数量。如果管道预计运行时间较长且触发频繁运行，这会很有帮助。\",\"运行触发器是一个标志，用于告知系统何时生成新的定期运行配置。可用的运行触发器类型包括：\",\"周期性（Periodic）：基于时间间隔调度运行（例如：每2小时或每45分钟）。\",\"Cron：使用 cron 语法调度运行。\",\"步骤（step）是管道中某个组件的执行。步骤与其组件之间的关系是一种实例化关系，类似于运行与其管道之间的关系。在复杂的管道中，组件可以在循环中多次执行，或在解析管道代码中的 if/else 类似子句后有条件地执行。\",\"输出工件（output artifact）是由管道组件发出的输出，Kubeflow Pipelines UI 能理解并呈现为丰富的可视化内容。包括工件在内的管道组件非常有用，因为它们可以用于性能评估、快速决策或不同运行间的比较。工件还使得理解管道各个组件的工作方式成为可能。工件可以是简单的文本数据视图，也可以是丰富的交互式可视化。\",\"注意：Kubeflow Pipelines 已从使用 kubeflow/metadata 转向使用 google/ml-metadata 作为元数据依赖。 Kubeflow Pipelines 后端将管道运行的运行时信息存储在元数据存储中。运行时信息包括任务的状态、工件的可用性、与执行或工件关联的自定义属性等。了解更多信息，请参阅 ML Metadata 入门指南。 如果一个工件被多个不同运行中的执行使用，你可以查看跨管道运行的工件和执行之间的连接。这种连接可视化称为谱系图（Lineage Graph）。\",\"Argo 工作流执行器是一个符合特定接口的进程，使 Argo 能够执行某些操作，如监控 Pod 日志、收集工件、管理容器生命周期等。 Kubeflow Pipelines 使用 Argo Workflows 作为工作流引擎，因此 Kubeflow Pipelines 用户需要选择一个工作流执行器。\"]},\"91\":{\"h\":\"主要的 Argo 工作流执行器类型包括：\",\"t\":[\"K8sAPIExecutor：通过 Kubernetes API 直接与集群交互，执行和监控容器。这是默认的执行器，适用于大多数场景。\",\"PNSExecutor：通过共享的进程命名空间（Process Namespace Sharing），使主容器可以访问子容器的文件系统和进程。这对于需要在容器之间共享数据的工作流特别有用。\",\"EmissaryExecutor：基于 Emissary-Ingress，专为高效的文件操作和网络操作设计，适用于需要高效处理大量小文件的工作流。 自 2022 年 2 月 Kubeflow Pipelines 1.8 正式发布以来，Emissary 执行器一直是 Kubeflow Pipelines 的默认执行器。\",\"DockerExecutor：直接与 Docker 守护进程交互来管理容器。这种方法依赖于 Docker，在某些 Kubernetes 配置中可能不适用。\"]},\"92\":{\"h\":\"如何选择适合的执行器：\",\"t\":[\"选择合适的工作流执行器取决于工作流的具体需求和集群环境：\",\"默认选择 K8sAPIExecutor：如果你的工作流不需要特别的资源共享或文件处理，默认的 K8sAPIExecutor 通常是最合适的选择。\",\"选择 PNSExecutor：如果你的工作流步骤之间需要共享文件或进程命名空间，那么 PNSExecutor 是一个好的选择。\",\"选择 EmissaryExecutor：如果你的工作流需要高效处理大量文件操作，尤其是小文件，可以选择 EmissaryExecutor。\",\"选择 DockerExecutor：如果你更熟悉 Docker 并且你的集群配置支持 Docker，可以考虑 DockerExecutor，但要注意其兼容性问题。\",\"注意，Argo Workflows 支持其他工作流执行器，但 Kubeflow Pipelines 团队仅推荐在 Emissary 执行器和 Docker 执行器之间进行选择。在配置 Kubeflow Pipelines 时，用户可以根据具体需求和工作流特点选择合适的 Argo 工作流执行器，以优化管道的执行效率和资源管理。\",\"[root@yigou-stg-101-61 ~]# kubectl get po -n kubeflow NAME READY STATUS RESTARTS AGE controller-manager-78d9bcc678-bgwtr 1/1 Running 0 17h katib-controller-7d7dffdb8f-7c6vk 1/1 Running 0 17h katib-db-manager-77d684cf4-tqtgh 1/1 Running 0 17h katib-ui-849479cf5f-rgmgf 1/1 Running 0 17h metadata-grpc-deployment-66457c4745-q9ddn 1/1 Running 0 17h metadata-writer-9956596d8-92g5h 1/1 Running 0 17h ml-pipeline-7cc7c5b47-k8r6z 1/1 Running 1 (17h ago) 17h ml-pipeline-persistenceagent-6c686b5b54-9bzwq 1/1 Running 0 17h ml-pipeline-scheduledworkflow-d894ffcd8-65j6h 1/1 Running 0 17h ml-pipeline-ui-57dbbdfd77-5bbh9 1/1 Running 0 17h ml-pipeline-viewer-crd-86868f775c-thcd8 1/1 Running 0 17h ml-pipeline-visualizationserver-5499555669-fsgks 1/1 Running 0 17h workflow-controller-799c5f4b48-nv8km 1/1 Running 0 17h\",\"下面是每个 Pod 的功能简介：\",\"controller-manager-78d9bcc678-bgwtr：\",\"控制器管理器 Pod，负责管理 Kubernetes 集群中的控制器，如 ReplicaSet、Deployment 等。\",\"katib-controller-7d7dffdb8f-7c6vk：\",\"Katib 控制器 Pod，是 Katib（超参数调优工具）的控制器组件，负责管理和调度超参数搜索任务。\",\"katib-db-manager-77d684cf4-tqtgh：\",\"Katib 数据库管理器 Pod，负责管理 Katib 的数据库，存储超参数调优任务的状态和结果。\",\"katib-ui-849479cf5f-rgmgf：\",\"Katib 用户界面 Pod，提供 Katib 的 Web 用户界面，用于查看和监控超参数调优任务的状态和结果。\",\"metadata-grpc-deployment-66457c4745-q9ddn：\",\"元数据 gRPC 服务 Pod，提供 Kubernetes 元数据服务，允许用户在 Kubeflow Pipelines 中创建和管理元数据。\",\"metadata-writer-9956596d8-92g5h：\",\"元数据写入器 Pod，负责将元数据写入到存储后端，与元数据 gRPC 服务一起用于 Kubeflow Pipelines。\",\"ml-pipeline-7cc7c5b47-k8r6z：\",\"ML Pipeline Pod，是 Kubeflow Pipelines 的核心组件之一，提供了机器学习工作流的定义、运行和监控功能。\",\"registry.cnbita.com:5000/kubeflow-pipelines/api-server\",\"backend/src/apiserver\",\"backend\\\\Dockerfile\",\"ml-pipeline-persistenceagent-6c686b5b54-9bzwq：\",\"ML Pipeline 持久化代理 Pod，负责管理 Kubeflow Pipelines 的持久化存储，存储工作流定义和执行状态。\",\"ml-pipeline-scheduledworkflow-d894ffcd8-65j6h：\",\"ML Pipeline 定时工作流 Pod，负责调度和执行 Kubeflow Pipelines 中的定时任务。\",\"ml-pipeline-ui-57dbbdfd77-5bbh9：\",\"ML Pipeline 用户界面 Pod，提供 Kubeflow Pipelines 的 Web 用户界面，用于创建、运行和监控机器学习工作流。\",\"ml-pipeline-viewer-crd-86868f775c-thcd8：\",\"ML Pipeline 视图 CRD Pod，用于自定义 Kubeflow Pipelines 中的自定义资源定义（CRD）的展示。\",\"ml-pipeline-visualizationserver-5499555669-fsgks：\",\"ML Pipeline 可视化服务器 Pod，提供 Kubeflow Pipelines 的可视化服务，用于展示机器学习工作流的执行状态和结果。\",\"workflow-controller-799c5f4b48-nv8km：\",\"工作流控制器 Pod，是 Kubeflow Pipelines 的控制器组件之一，负责管理和执行工作流任务。\",\"这些 Pod 组成了 Kubeflow 中的各个核心组件，提供了从超参数调优到机器学习工作流管理的完整功能。这些 Pod 之间有一定的关联关系，它们共同组成了 Kubeflow 平台，用于支持机器学习工作流的定义、运行、监控和优化。以下是它们之间的一些主要关联关系：\",\"控制器管理器 (controller-manager)：\",\"负责管理 Kubernetes 集群中的各种控制器，确保其他 Pod 和服务正常运行。\",\"Katib 组件：\",\"katib-controller：管理和调度超参数调优任务。\",\"katib-db-manager：管理存储 Katib 数据的数据库。\",\"katib-ui：提供 Katib 的 Web 用户界面。\",\"Katib 的各个组件通过数据库和控制器进行通信和协调，共同实现超参数调优功能。\",\"元数据服务 (metadata-grpc-deployment 和 metadata-writer)：\",\"metadata-grpc-deployment：提供 gRPC 接口，用于管理元数据。\",\"metadata-writer：负责将元数据写入到持久化存储中。\",\"这些组件通过元数据存储和 gRPC 接口进行通信，支持 Kubeflow Pipelines 中的元数据管理。\",\"Kubeflow Pipelines 组件：\",\"ml-pipeline：核心组件，负责机器学习工作流的定义、运行和监控。\",\"ml-pipeline-persistenceagent：管理工作流的持久化存储。\",\"ml-pipeline-scheduledworkflow：调度和执行定时任务。\",\"ml-pipeline-ui：提供 Web 用户界面，允许用户交互和监控工作流。\",\"ml-pipeline-viewer-crd：展示自定义资源定义（CRD）。\",\"ml-pipeline-visualizationserver：提供工作流执行状态和结果的可视化。\",\"这些组件通过存储系统、API 和用户界面进行紧密集成，形成完整的机器学习工作流管理平台。\",\"工作流控制器 (workflow-controller)：\",\"负责管理和执行工作流任务，确保工作流按照定义的步骤顺利执行。\",\"与 Kubeflow Pipelines 组件紧密合作，管理和协调工作流的各个部分。\",\"总体而言，这些 Pod 通过 Kubernetes 集群中的服务和控制器进行通信和协调，共同提供了一个功能强大的机器学习工作流管理平台。\"]},\"93\":{\"h\":\"controller-manager\",\"t\":[\"apiVersion: apps/v1 kind: Deployment metadata: name: controller-manager labels: control-plane: controller-manager controller-tools.k8s.io: \\\"1.0\\\" spec: selector: matchLabels: control-plane: controller-manager controller-tools.k8s.io: \\\"1.0\\\" template: metadata: labels: control-plane: controller-manager controller-tools.k8s.io: \\\"1.0\\\" spec: containers: - command: - /kube-app-manager # Built from https://github.com/kubernetes-sigs/application master branch on the date specified in the image tag. image: gcr.io/ml-pipeline/application-crd-controller:20231101 imagePullPolicy: IfNotPresent name: manager env: - name: NAMESPACE valueFrom: fieldRef: fieldPath: metadata.namespace resources: limits: cpu: 100m memory: 30Mi requests: cpu: 100m memory: 20Mi serviceAccountName: application\"]},\"94\":{\"h\":\"官网地址\",\"t\":[\"https://github.com/kubernetes-sigs/application\"]},\"95\":{\"h\":\"Kubernetes 应用程序\",\"t\":[\"Kubernetes 是一个开源系统，用于自动化部署、扩展和管理容器化应用程序。 上述描述来自 Kubernetes 主页，主要集中在容器化应用程序上。然而，Kubernetes 的元数据、对象和可视化（例如在 Dashboard 中）都集中在容器基础设施上，而不是应用程序本身。 本项目中的应用程序 CRD（自定义资源定义）和控制器旨在改变这种状况，使其能够在众多支持工具之间实现互操作。\"]},\"96\":{\"h\":\"它提供了：\",\"t\":[\"描述应用程序元数据的能力（例如，运行一个像 WordPress 这样的应用程序）\",\"一个连接基础设施（例如 Deployments）的根对象。这对于将各种资源联系在一起甚至清理（即垃圾回收）很有用\",\"为支持应用程序提供信息，帮助它们查询和理解支持应用程序的对象\",\"应用程序级别的健康检查\"]},\"97\":{\"h\":\"这可以被以下用户使用：\",\"t\":[\"希望以应用程序为中心进行操作的应用程序运营商\",\"像 Helm 这样的工具，它们将其软件包发布集中在应用程序安装上，并且希望与其他工具（例如 Dashboard）实现互操作\",\"希望可视化应用程序（不仅仅是基础设施视图）的 Dashboards\"]},\"98\":{\"h\":\"目标\",\"t\":[\"提供一个用于在 Kubernetes 中创建、查看和管理应用程序的标准 API。\",\"提供通过 kubectl 与应用程序 API 交互的 CLI 实现。\",\"提供应用程序的安装状态和垃圾回收。\",\"提供一种标准方式，使应用程序能够向 UI 展示基本的健康检查。\",\"提供一种明确的机制，使应用程序能够声明对另一个应用程序的依赖关系。\",\"通过创建工具可以实现的标准，促进生态系统工具和 UI 之间的互操作性。\",\"促进 Kubernetes 应用程序使用通用的标签和注释。\"]},\"99\":{\"h\":\"非目标\",\"t\":[\"创建一个所有工具必须实现的标准。\",\"提供一种方式，使 UI 能够显示应用程序的指标。\"]},\"100\":{\"h\":\"什么是 Katib？\",\"t\":[\"Katib 是一个原生于 Kubernetes 的自动化机器学习（AutoML）项目。Katib 支持超参数调优、提前停止和神经架构搜索（NAS）。了解更多 AutoML 信息，请访问 fast.ai、Google Cloud、Microsoft Azure 或 Amazon SageMaker。 Katib 是一个与机器学习（ML）框架无关的项目。它可以调优用任何用户选择的语言编写的应用程序的超参数，并且本身支持许多 ML 框架，例如 TensorFlow、MXNet、PyTorch、XGBoost 等。 Katib 支持多种 AutoML 算法，例如贝叶斯优化（Bayesian optimization）、帕尔森估计树（Tree of Parzen Estimators）、随机搜索（Random Search）、协方差矩阵自适应进化策略（Covariance Matrix Adaptation Evolution Strategy）、Hyperband、高效神经架构搜索（Efficient Neural Architecture Search）、可微分架构搜索（Differentiable Architecture Search）等等。更多算法支持即将推出。 Katib 项目是开源的。开发者指南是希望为该项目做出贡献的开发者的良好起点。 \"]},\"101\":{\"h\":\"为什么选择 Katib？\",\"t\":[\"Katib 解决了 AI/ML 生命周期中的自动化机器学习（AutoML）步骤中的超参数优化或神经架构搜索问题，如下图所示： \",\"多节点和多GPU分布式训练：Katib 可以协调多节点和多GPU的分布式训练工作负载。\",\"与 Kubeflow Training Operator 集成：Katib 与 Kubeflow 的训练操作（如 PyTorchJob）集成，允许优化任何规模的大模型的超参数。\",\"此外，Katib 可以协调更高级的优化工作流，如 Argo Workflows 和 Tekton Pipelines。\",\"可扩展性和可移植性：Katib 是可扩展和可移植的。Katib 运行 Kubernetes 容器来执行超参数调优任务，这使得 Katib 可以与任何 ML 训练框架一起使用。\",\"用户甚至可以使用 Katib 来优化非ML任务，只要能够收集优化指标。\",\"丰富的优化算法支持：Katib 与许多优化框架（如 Hyperopt 和 Optuna）集成，这些框架实现了大多数最先进的优化算法。\",\"用户可以利用 Katib 控制平面来实现和基准测试他们自己的优化算法。\"]},\"102\":{\"h\":\"pipeline服务注册流程\",\"t\":[\" 其他服务注册在 startRpcServer 函数中，注册了以下服务：\"]},\"103\":{\"h\":\"API v1beta1 注册的服务\",\"t\":[\"ExperimentService: 实验服务\",\"apiv1beta1.RegisterExperimentServiceServer(s, sharedExperimentServer)\",\"PipelineService: 流水线服务\",\"apiv1beta1.RegisterPipelineServiceServer(s, sharedPipelineServer)\",\"JobService: 作业服务\",\"apiv1beta1.RegisterJobServiceServer(s, sharedJobServer)\",\"RunService: 运行服务\",\"apiv1beta1.RegisterRunServiceServer(s, sharedRunServer)\",\"TaskService: 任务服务\",\"apiv1beta1.RegisterTaskServiceServer(s, server.NewTaskServer(resourceManager))\",\"ReportService: 报告服务\",\"apiv1beta1.RegisterReportServiceServer(s, server.NewReportServer(resourceManager))\",\"VisualizationService: 可视化服务\",\"apiv1beta1.RegisterVisualizationServiceServer( s, server.NewVisualizationServer( resourceManager, common.GetStringConfig(cm.VisualizationServiceHost), common.GetStringConfig(cm.VisualizationServicePort), ))\",\"AuthService: 认证服务\",\"apiv1beta1.RegisterAuthServiceServer(s, server.NewAuthServer(resourceManager))\"]},\"104\":{\"h\":\"API v2beta1 注册的服务\",\"t\":[\"ExperimentService: 实验服务\",\"apiv2beta1.RegisterExperimentServiceServer(s, sharedExperimentServer)\",\"PipelineService: 流水线服务\",\"apiv2beta1.RegisterPipelineServiceServer(s, sharedPipelineServer)\",\"RecurringRunService: 定期运行服务\",\"apiv2beta1.RegisterRecurringRunServiceServer(s, sharedJobServer)\",\"RunService: 运行服务\",\"apiv2beta1.RegisterRunServiceServer(s, sharedRunServer)\"]},\"105\":{\"h\":\"其他\",\"t\":[\"ReflectionService: 反射服务\",\"reflection.Register(s)\"]},\"106\":{\"h\":\"总结\",\"t\":[\"在这个 startRpcServer 函数中，注册了以下 13 个服务：\",\"ExperimentService（v1beta1 和 v2beta1）\",\"PipelineService（v1beta1 和 v2beta1）\",\"JobService（v1beta1）\",\"RunService（v1beta1 和 v2beta1）\",\"TaskService（v1beta1）\",\"ReportService（v1beta1）\",\"VisualizationService（v1beta1）\",\"AuthService（v1beta1）\",\"RecurringRunService（v2beta1）\",\"ReflectionService\",\"这些服务涵盖了实验管理、流水线管理、作业管理、运行管理、任务管理、报告生成、数据可视化和认证功能，并且支持不同版本的API。 \"]},\"107\":{\"h\":\"pipeline创建流程\",\"t\":[\" 创建流水线只是把相关参数信息写入数据库。\"]},\"108\":{\"h\":\"创建Runs\",\"t\":[\" Runs创建过程是 请求apiserver->请求workflow,然后保存相关数据\"]},\"109\":{\"c\":[\"云原生\"]},\"110\":{\"c\":[\"Kubeflow\"]},\"111\":{\"h\":\"k8s operator\",\"t\":[\"什么是 Kubernetes Operator？\",\"Kubernetes Operator 是一种软件扩展，使用 Kubernetes 原生的 API 和工具来自动管理复杂应用的生命周期。Operator 可以将人类操作员（例如系统管理员）的操作自动化，管理 Kubernetes 应用程序的配置、部署、升级、备份和故障处理等任务。\"]},\"112\":{\"h\":\"Operator 的基本概念\",\"t\":[\"Custom Resource (自定义资源，CR): Kubernetes 的内置资源（如 Pod、Service）可能无法满足所有应用的需求。CR 提供了定义自定义对象的能力，使得用户可以在 Kubernetes 中引入新的资源类型。\",\"Custom Resource Definition (自定义资源定义，CRD): CRD 是 Kubernetes 用于定义 CR 结构的机制。通过 CRD，用户可以创建和管理新的自定义资源。\",\"Controller (控制器): 控制器是 Kubernetes 中一个不断循环检查资源实际状态并使其符合预期状态的逻辑组件。Operator 就是一个高级的控制器，专门用于管理自定义资源。\"]},\"113\":{\"h\":\"Operator 的工作原理\",\"t\":[\"定义 CRD: 开发者首先需要定义 CRD，这描述了自定义资源的结构和规范。CRD 定义了资源的 API 和行为方式。\",\"实现控制器: 控制器监控自定义资源的状态，并根据用户定义的逻辑执行相应的操作。控制器的核心任务是不断将资源的实际状态调整为期望状态。\",\"部署 Operator: Operator 本质上是一个 Kubernetes 应用，它包括了 CRD 和控制器的实现。部署 Operator 后，用户可以使用 kubectl 等工具创建和管理自定义资源。\"]},\"114\":{\"h\":\"Operator 的应用场景\",\"t\":[\"应用部署和管理: Operator 可以自动化复杂应用的部署和管理过程。例如，数据库集群的创建、分片、复制等任务都可以通过 Operator 自动执行。\",\"自动化升级: Operator 可以监控应用的新版本，并自动执行无中断的滚动升级。\",\"备份和恢复: Operator 可以定期备份应用的数据，并在出现故障时自动进行恢复。\",\"自愈能力: Operator 可以监控应用的健康状态，自动修复出现的问题，例如重新启动故障的组件。\"]},\"115\":{\"h\":\"Operator 的优势\",\"t\":[\"简化运维操作: Operator 自动化了许多日常的运维任务，减少了人为操作的复杂性和风险。\",\"标准化管理流程: 通过 Operator，可以将最佳实践和操作流程编码成标准化的流程，使得复杂应用的管理变得更一致和可靠。\",\"增强 Kubernetes 的能力: Operator 将 Kubernetes 的管理能力扩展到了自定义应用领域，使得 Kubernetes 可以管理更复杂的工作负载。\"]},\"116\":{\"h\":\"使用 Operator 的示例\",\"t\":[\"Prometheus Operator: 用于简化 Prometheus 集群的部署和管理，自动处理 Prometheus 配置、目标发现和告警管理。\",\"ElasticSearch Operator: 管理 ElasticSearch 集群的部署、升级和扩展，确保高可用性和数据一致性。\",\"MySQL Operator: 自动化 MySQL 数据库的创建、备份和恢复，简化数据库集群的管理。\"]},\"117\":{\"h\":\"开发 Operator 的工具\",\"t\":[\"Operator SDK: 一个流行的工具包，提供了从生成基础代码到测试和部署的全流程支持，简化了 Operator 的开发过程。\",\"Kubebuilder: 提供了面向 Go 语言的开发框架和工具，用于生成和管理 Kubernetes API 扩展。\",\"KUDO (Kubernetes Universal Declarative Operator): 提供了一种声明性的方式来定义和管理 Operator，使得创建复杂的应用管理变得更简单。\"]},\"118\":{\"h\":\"总结\",\"t\":[\"Kubernetes Operator 是一种强大的工具，可以自动化和简化复杂应用的管理。通过定义自定义资源和控制器，Operator 能够将人类操作员的经验和最佳实践转化为自动化的操作流程，大大增强了 Kubernetes 的管理能力。无论是管理数据库、消息队列，还是大数据处理集群，Operator 都可以帮助实现高效的运维管理。\",\"如果你对开发 Kubernetes Operator 有兴趣，可以先从简单的示例开始，逐步深入理解其背后的原理和应用场景。\"]},\"119\":{\"c\":[\"云原生\"]},\"120\":{\"c\":[\"operator\"]},\"121\":{\"h\":\"个人介绍\",\"t\":[\"个人简介\",\"大家好，我是一名充满热情的全栈开发工程师，具备广泛的编程语言知识和丰富的实际项目经验。我始终追求技术创新，致力于通过高效、优质的代码解决复杂的业务问题。在开发过程中，我不仅关注性能优化和可扩展性，还注重代码的可维护性和团队协作，能够快速适应不同的项目需求。\"]},\"122\":{\"h\":\"编程语言\",\"t\":[\"Java: 我在Java领域有着深厚的积累，尤其擅长使用Spring Boot框架开发企业级应用，能够设计并实现高并发、高性能的后端服务，保障系统的稳定性与可扩展性。\",\"C++: 扎实的C++功底让我在系统级应用开发中游刃有余，能够编写高效、稳定的底层代码，解决复杂的系统问题。\",\"C: 精通C语言，擅长底层系统开发，具备处理硬件交互及操作系统底层模块的经验。\",\"Python: 熟练掌握Python，尤其在数据分析、机器学习领域有丰富经验，能够快速构建高效的分析和自动化工具。\",\"Go: 熟练使用Go语言开发高并发应用，善于利用其高效的内存管理机制和原生的协程支持，构建稳定的后端服务。\"]},\"123\":{\"h\":\"技术栈\",\"t\":[\"Kubernetes (k8s): 熟练掌握容器编排技术，能够高效部署和管理复杂的微服务架构，保障系统的弹性伸缩和高可用性。\",\"Spring Boot: 深入理解Spring Boot生态体系，擅长快速搭建和优化企业级应用，确保项目能够快速上线并稳定运行。\",\"MySQL: 精通MySQL数据库的设计与性能优化，具备大规模数据存储与查询优化的经验，能够提升系统的数据处理能力。\",\"Redis: 擅长利用Redis进行高效的缓存与存储操作，提升系统响应速度，优化用户体验。\",\"Nacos: 熟悉Nacos的服务发现与配置管理，能够确保微服务架构中各组件的稳定运行与快速扩展。\"]},\"124\":{\"h\":\"MLOps\",\"t\":[\"Kubeflow: 精通Kubeflow流水线的设计与实现，能够为机器学习模型的开发、训练、部署提供一体化解决方案，加速AI项目的落地与应用。\"]},\"125\":{\"h\":\"前端开发\",\"t\":[\"Vue: 熟练使用Vue.js进行动态、响应式的用户界面开发，能够设计出简洁美观且用户体验友好的前端页面。\",\"TypeScript (TS): 精通TypeScript，能够编写高质量、健壮的代码，确保前端应用的可维护性和稳定性。\",\"HTML: 掌握HTML的各种技术细节，具备良好的网页结构设计能力，能够实现高效、语义化的页面布局。\",\"Element-UI: 精通Element-UI库的使用，能够快速开发美观实用的前端组件，提升项目的开发效率与用户体验。\"]},\"126\":{\"h\":\"项目经验\",\"t\":[\"飞鸟云课堂\",\"日活流量：1GB+\",\"累计注册用户：5000+\",\"营销收入：80万元+\",\"《飞鸟云课堂》是一款专注于在线教育的产品，通过丰富的教学资源和优质的用户体验，吸引了大量用户并实现了显著的商业变现。\",\"我拥有将技术与商业需求相结合的能力，擅长从需求分析到产品落地的全流程开发。如果你正在寻找一位能够推动项目成功、具备创新能力的全栈开发工程师，欢迎联系我！期待与您合作，共同实现卓越的技术和商业目标。\"]},\"127\":{\"h\":\"联系方式\",\"t\":[\"微信\"]},\"128\":{\"c\":[\"个人介绍\"]},\"129\":{\"c\":[\"个人\"]},\"130\":{\"h\":\"clash节点转为V2ray\"},\"131\":{\"c\":[\"代理\"]},\"132\":{\"c\":[\"clash\",\"v2ray\"]},\"133\":{\"h\":\"FastGpt+chatgpt-on-web\",\"t\":[\"FastGpt\"]},\"134\":{\"h\":\"地址\",\"t\":[\"https://github.com/labring/FastGPT\"]},\"135\":{\"h\":\"文档\",\"t\":[\"https://doc.tryfastgpt.ai/docs/\"]},\"136\":{\"h\":\"配置\",\"t\":[\"// 已使用 json5 进行解析，会自动去掉注释，无需手动去除 { \\\"feConfigs\\\": { \\\"lafEnv\\\": \\\"https://laf.dev\\\" // laf环境。 https://laf.run （杭州阿里云） ,或者私有化的laf环境。如果使用 Laf openapi 功能，需要最新版的 laf 。 }, \\\"systemEnv\\\": { \\\"vectorMaxProcess\\\": 15, \\\"qaMaxProcess\\\": 15, \\\"pgHNSWEfSearch\\\": 100 // 向量搜索参数。越大，搜索越精确，但是速度越慢。设置为100，有99%+精度。 }, \\\"llmModels\\\": [ { \\\"model\\\": \\\"gpt-3.5-turbo\\\", // 模型名(对应OneAPI中渠道的模型名) \\\"name\\\": \\\"gpt-3.5-turbo\\\", // 模型别名 \\\"avatar\\\": \\\"/imgs/model/openai.svg\\\", // 模型的logo \\\"maxContext\\\": 125000, // 最大上下文 \\\"maxResponse\\\": 16000, // 最大回复 \\\"quoteMaxToken\\\": 120000, // 最大引用内容 \\\"maxTemperature\\\": 1.2, // 最大温度 \\\"charsPointsPrice\\\": 0, // n积分/1k token（商业版） \\\"censor\\\": false, // 是否开启敏感校验（商业版） \\\"vision\\\": true, // 是否支持图片输入 \\\"datasetProcess\\\": true, // 是否设置为知识库处理模型（QA），务必保证至少有一个为true，否则知识库会报错 \\\"usedInClassify\\\": true, // 是否用于问题分类（务必保证至少有一个为true） \\\"usedInExtractFields\\\": true, // 是否用于内容提取（务必保证至少有一个为true） \\\"usedInToolCall\\\": true, // 是否用于工具调用（务必保证至少有一个为true） \\\"usedInQueryExtension\\\": true, // 是否用于问题优化（务必保证至少有一个为true） \\\"toolChoice\\\": true, // 是否支持工具选择（分类，内容提取，工具调用会用到。目前只有gpt支持） \\\"functionCall\\\": false, // 是否支持函数调用（分类，内容提取，工具调用会用到。会优先使用 toolChoice，如果为false，则使用 functionCall，如果仍为 false，则使用提示词模式） \\\"customCQPrompt\\\": \\\"\\\", // 自定义文本分类提示词（不支持工具和函数调用的模型 \\\"customExtractPrompt\\\": \\\"\\\", // 自定义内容提取提示词 \\\"defaultSystemChatPrompt\\\": \\\"\\\", // 对话默认携带的系统提示词 \\\"defaultConfig\\\": {} // 请求API时，挟带一些默认配置（比如 GLM4 的 top_p） }, { \\\"model\\\": \\\"SparkDesk-v3.5\\\", \\\"name\\\": \\\"星火\\\", \\\"avatar\\\": \\\"/imgs/model/openai.svg\\\", \\\"maxContext\\\": 125000, \\\"maxResponse\\\": 4000, \\\"quoteMaxToken\\\": 120000, \\\"maxTemperature\\\": 1.2, \\\"charsPointsPrice\\\": 0, \\\"censor\\\": false, \\\"vision\\\": true, \\\"datasetProcess\\\": false, \\\"usedInClassify\\\": true, \\\"usedInExtractFields\\\": true, \\\"usedInToolCall\\\": true, \\\"usedInQueryExtension\\\": true, \\\"toolChoice\\\": true, \\\"functionCall\\\": false, \\\"customCQPrompt\\\": \\\"\\\", \\\"customExtractPrompt\\\": \\\"\\\", \\\"defaultSystemChatPrompt\\\": \\\"\\\", \\\"defaultConfig\\\": {} } ], \\\"vectorModels\\\": [ { \\\"model\\\": \\\"text-embedding-ada-002\\\", // 模型名（与OneAPI对应） \\\"name\\\": \\\"Embedding-2\\\", // 模型展示名 \\\"avatar\\\": \\\"/imgs/model/openai.svg\\\", // logo \\\"charsPointsPrice\\\": 0, // n积分/1k token \\\"defaultToken\\\": 700, // 默认文本分割时候的 token \\\"maxToken\\\": 3000, // 最大 token \\\"weight\\\": 100, // 优先训练权重 \\\"defaultConfig\\\": {}, // 自定义额外参数。例如，如果希望使用 embedding3-large 的话，可以传入 dimensions:1024，来返回1024维度的向量。（目前必须小于1536维度） \\\"dbConfig\\\": {}, // 存储时的额外参数（非对称向量模型时候需要用到） \\\"queryConfig\\\": {} // 参训时的额外参数 }, { \\\"model\\\": \\\"text-embedding-3-large\\\", \\\"name\\\": \\\"text-embedding-3-large\\\", \\\"avatar\\\": \\\"/imgs/model/openai.svg\\\", \\\"charsPointsPrice\\\": 0, \\\"defaultToken\\\": 512, \\\"maxToken\\\": 3000, \\\"weight\\\": 100, \\\"defaultConfig\\\": { \\\"dimensions\\\": 1024 } }, { \\\"model\\\": \\\"text-embedding-3-small\\\", \\\"name\\\": \\\"text-embedding-3-small\\\", \\\"avatar\\\": \\\"/imgs/model/openai.svg\\\", \\\"charsPointsPrice\\\": 0, \\\"defaultToken\\\": 512, \\\"maxToken\\\": 3000, \\\"weight\\\": 100 } ], \\\"reRankModels\\\": [], \\\"audioSpeechModels\\\": [ { \\\"model\\\": \\\"tts-1\\\", \\\"name\\\": \\\"OpenAI TTS1\\\", \\\"charsPointsPrice\\\": 0, \\\"voices\\\": [ { \\\"label\\\": \\\"Alloy\\\", \\\"value\\\": \\\"alloy\\\", \\\"bufferId\\\": \\\"openai-Alloy\\\" }, { \\\"label\\\": \\\"Echo\\\", \\\"value\\\": \\\"echo\\\", \\\"bufferId\\\": \\\"openai-Echo\\\" }, { \\\"label\\\": \\\"Fable\\\", \\\"value\\\": \\\"fable\\\", \\\"bufferId\\\": \\\"openai-Fable\\\" }, { \\\"label\\\": \\\"Onyx\\\", \\\"value\\\": \\\"onyx\\\", \\\"bufferId\\\": \\\"openai-Onyx\\\" }, { \\\"label\\\": \\\"Nova\\\", \\\"value\\\": \\\"nova\\\", \\\"bufferId\\\": \\\"openai-Nova\\\" }, { \\\"label\\\": \\\"Shimmer\\\", \\\"value\\\": \\\"shimmer\\\", \\\"bufferId\\\": \\\"openai-Shimmer\\\" } ] } ], \\\"whisperModel\\\": { \\\"model\\\": \\\"whisper-1\\\", \\\"name\\\": \\\"Whisper1\\\", \\\"charsPointsPrice\\\": 0 } }\"]},\"137\":{\"h\":\"docker-compose\",\"t\":[\"# 数据库的默认账号和密码仅首次运行时设置有效 # 如果修改了账号密码，记得改数据库和项目连接参数，别只改一处~ # 该配置文件只是给快速启动，测试使用。正式使用，记得务必修改账号密码，以及调整合适的知识库参数，共享内存等。 # 如何无法访问 dockerhub 和 git，可以用阿里云（阿里云没有arm包） version: '3.3' services: minio: container_name: minio image: minio/minio:RELEASE.2023-03-20T20-16-18Z environment: MINIO_ACCESS_KEY: minioadmin MINIO_SECRET_KEY: minioadmin ports: - '9001:9001' - '9000:9000' networks: - fastgpt volumes: - ./minio:/minio_data command: minio server /minio_data --console-address \\\":9001\\\" healthcheck: test: ['CMD', 'curl', '-f', 'http://localhost:9000/minio/health/live'] interval: 30s timeout: 20s retries: 3 # milvus milvusEtcd: container_name: milvusEtcd image: quay.io/coreos/etcd:v3.5.5 environment: - ETCD_AUTO_COMPACTION_MODE=revision - ETCD_AUTO_COMPACTION_RETENTION=1000 - ETCD_QUOTA_BACKEND_BYTES=4294967296 - ETCD_SNAPSHOT_COUNT=50000 networks: - fastgpt volumes: - ./milvus/etcd:/etcd command: etcd -advertise-client-urls=http://127.0.0.1:2379 -listen-client-urls http://0.0.0.0:2379 --data-dir /etcd healthcheck: test: ['CMD', 'etcdctl', 'endpoint', 'health'] interval: 30s timeout: 20s retries: 3 milvusStandalone: container_name: milvusStandalone image: milvusdb/milvus:v2.4.3 command: ['milvus', 'run', 'standalone'] security_opt: - seccomp:unconfined environment: ETCD_ENDPOINTS: milvusEtcd:2379 MINIO_ADDRESS: minio:9000 networks: - fastgpt volumes: - ./milvus/data:/var/lib/milvus healthcheck: test: ['CMD', 'curl', '-f', 'http://localhost:9091/healthz'] interval: 30s start_period: 90s timeout: 20s retries: 3 depends_on: - 'milvusEtcd' - 'minio' mongo: image: registry.cn-hangzhou.aliyuncs.com/fastgpt/mongo:5.0.18 # 阿里云 container_name: mongo restart: always ports: - 27017:27017 networks: - fastgpt command: mongod --keyFile /data/mongodb.key --replSet rs0 environment: - MONGO_INITDB_ROOT_USERNAME=myusername - MONGO_INITDB_ROOT_PASSWORD=mypassword volumes: - mongo_data:/data/db entrypoint: - bash - -c - | openssl rand -base64 128 > /data/mongodb.key chmod 400 /data/mongodb.key chown 999:999 /data/mongodb.key echo 'const isInited = rs.status().ok === 1 if(!isInited){ rs.initiate({ _id: \\\"rs0\\\", members: [ { _id: 0, host: \\\"mongo:27017\\\" } ] }) }' > /data/initReplicaSet.js # 启动MongoDB服务 exec docker-entrypoint.sh \\\"$$@\\\" & # 等待MongoDB服务启动 until mongo -u myusername -p mypassword --authenticationDatabase admin --eval \\\"print('waited for connection')\\\" > /dev/null 2>&1; do echo \\\"Waiting for MongoDB to start...\\\" sleep 2 done # 执行初始化副本集的脚本 mongo -u myusername -p mypassword --authenticationDatabase admin /data/initReplicaSet.js # 等待docker-entrypoint.sh脚本执行的MongoDB服务进程 wait $$! # fastgpt sandbox: container_name: sandbox image: ghcr.io/labring/fastgpt-sandbox:latest # git # image: registry.cn-hangzhou.aliyuncs.com/fastgpt/fastgpt-sandbox:latest # 阿里云 networks: - fastgpt restart: always fastgpt: container_name: fastgpt image: ghcr.io/labring/fastgpt:v4.8.9 # git # image: registry.cn-hangzhou.aliyuncs.com/fastgpt/fastgpt:v4.8.9 # 阿里云 ports: - 3000:3000 networks: - fastgpt depends_on: - mongo - milvusStandalone - sandbox restart: always environment: # root 密码，用户名为: root。如果需要修改 root 密码，直接修改这个环境变量，并重启即可。 - DEFAULT_ROOT_PSW=1234 # AI模型的API地址哦。务必加 /v1。这里默认填写了OneApi的访问地址。 - OPENAI_BASE_URL=http://oneapi:3000/v1 # AI模型的API Key。（这里默认填写了OneAPI的快速默认key，测试通后，务必及时修改） - CHAT_API_KEY=sk-Aq0UoGRk8uJSAZfy3e986c5993Bb4aF3A9C3Eb20708144F4 # 数据库最大连接数 - DB_MAX_LINK=30 # 登录凭证密钥 - TOKEN_KEY=any # root的密钥，常用于升级时候的初始化请求 - ROOT_KEY=root_key # 文件阅读加密 - FILE_TOKEN_KEY=filetoken # MongoDB 连接参数. 用户名myusername,密码mypassword。 - MONGODB_URI=mongodb://myusername:mypassword@mongo:27017/fastgpt?authSource=admin # zilliz 连接参数 - MILVUS_ADDRESS=http://milvusStandalone:19530 - MILVUS_TOKEN=none # sandbox 地址 - SANDBOX_URL=http://sandbox:3000 # 日志等级: debug, info, warn, error - LOG_LEVEL=info - STORE_LOG_LEVEL=warn volumes: - ./config.json:/app/data/config.json # oneapi mysql: image: mysql:5.7.16 # 阿里云 # image: mysql:8.0.36 container_name: mysql restart: always ports: - 3307:3306 networks: - fastgpt command: --default-authentication-plugin=mysql_native_password environment: # 默认root密码，仅首次运行有效 MYSQL_ROOT_PASSWORD: oneapimmysql MYSQL_DATABASE: oneapi volumes: - ./mysql:/var/lib/mysql oneapi: container_name: oneapi image: ghcr.io/songquanpeng/one-api:v0.6.7 # image: registry.cn-hangzhou.aliyuncs.com/fastgpt/one-api:v0.6.6 # 阿里云 ports: - 3001:3000 depends_on: - mysql networks: - fastgpt restart: always environment: # mysql 连接参数 - SQL_DSN=root:oneapimmysql@tcp(mysql:3306)/oneapi # 登录凭证加密密钥 - SESSION_SECRET=oneapikey # 内存缓存 - MEMORY_CACHE_ENABLED=true # 启动聚合更新，减少数据交互频率 - BATCH_UPDATE_ENABLED=true # 聚合更新时长 - BATCH_UPDATE_INTERVAL=10 # 初始化的 root 密钥（建议部署完后更改，否则容易泄露） - INITIAL_ROOT_TOKEN=fastgpt - http_proxy=http://192.168.6.10:7897 - https_proxy=http://192.168.6.10:7897 volumes: - ./oneapi:/data networks: fastgpt: volumes: mongo_data:\",\"上述fastgpt 配置的CHAT_API_KEY、OPENAI_BASE_URL是oneapi中的令牌地址 \"]},\"138\":{\"h\":\"访问\"},\"139\":{\"h\":\"fastgpt\",\"t\":[\"http://localhost:3000/app/list 账户密码：root/1234\"]},\"140\":{\"h\":\"oneapi\",\"t\":[\"http://localhost:3001/ 账户密码： root/12345678\"]},\"141\":{\"h\":\"地址\",\"t\":[\"https://github.com/zhayujie/chatgpt-on-wechat\"]},\"142\":{\"h\":\"文档\",\"t\":[\"https://docs.link-ai.tech/cow/quick-start\"]},\"143\":{\"h\":\"docker-compose\",\"t\":[\"version: '2.0' services: chatgpt-on-wechat: image: registry.cn-hangzhou.aliyuncs.com/software_hub/chatgpt-on-wechat:zhayujie-v1 container_name: chatgpt-on-wechat security_opt: - seccomp:unconfined environment: OPEN_AI_API_KEY: 'fastgpt-yvdq8kJ9kaFfDN9AgZHLDcu1vOVOGROVVabX1DD4mBGuDazLqIPfqWmIjS' OPEN_AI_API_BASE: 'http://fastgpt:3000/api/v1' MODEL: 'gpt-3.5-turbo' CHANNEL_TYPE: 'wx' PROXY: '' HOT_RELOAD: 'False' SINGLE_CHAT_PREFIX: '[\\\"bot\\\", \\\"@bot\\\"]' SINGLE_CHAT_REPLY_PREFIX: '\\\"[bot] \\\"' GROUP_CHAT_PREFIX: '[\\\"@bot\\\"]' GROUP_NAME_WHITE_LIST: '[\\\"ChatGPT测试群\\\", \\\"ChatGPT测试群2\\\", \\\"AI助手百科全书\\\", \\\"知识助手\\\", \\\"我的家人\\\"]' IMAGE_CREATE_PREFIX: '[\\\"画\\\", \\\"看\\\", \\\"找\\\"]' CONVERSATION_MAX_TOKENS: 1000 SPEECH_RECOGNITION: 'False' CHARACTER_DESC: '你是ChatGPT, 一个由OpenAI训练的大型语言模型, 你旨在回答并解决人们的任何问题，并且可以使用多种语言与人交流。' SUBSCRIBE_MSG: '感谢您的关注！\\\\n这里是ChatGPT，可以自由对话。\\\\n支持语音对话。\\\\n支持图片输入。\\\\n支持图片输出，画字开头的消息将按要求创作图片。\\\\n支持tool、角色扮演和文字冒险等丰富的插件。\\\\n输入{trigger_prefix}#help 查看详细指令。' EXPIRES_IN_SECONDS: 3600 USE_GLOBAL_PLUGIN_CONFIG: 'True' USE_LINKAI: 'False' LINKAI_API_KEY: '' networks: - fastgpt networks: fastgpt: name: fatgpt_fastgpt external: true\",\"使用fastgpt apikey \"]},\"144\":{\"c\":[\"AIGC\"]},\"145\":{\"c\":[\"FastGpt\",\"chatgpt-on-web\"]},\"146\":{\"h\":\"PyTorch\",\"t\":[\"PyTorch c10d\",\"PyTorch 的 c10d 通信库是用于分布式计算的核心组件，特别是在需要跨多个设备（如多个GPU或多台机器）进行并行计算时。c10d 提供了分布式数据并行（Distributed Data Parallel, DDP）的底层实现，支持高效的数据同步和通信操作。\"]},\"147\":{\"h\":\"主要功能\",\"t\":[\"通信后端： c10d 支持多种通信后端（Backend），如：\",\"NCCL: 适用于GPU间通信，特别是在NVIDIA硬件上。\",\"GLOO: 适用于CPU和GPU的跨平台通信。\",\"MPI: 基于Message Passing Interface，适合大规模分布式系统。\",\"进程组（Process Group）： c10d 中的进程组是通信的基本单元，可以将多个进程组织成一个组，以便它们之间进行通信。可以在不同的进程组之间进行广播、归约、全归约等操作。\",\"广播和同步： c10d 提供了对数据进行广播和同步的接口，确保在多个进程或设备之间一致地传递数据。例如，在多GPU训练中，同步不同GPU上的模型参数。\",\"梯度同步： 在分布式数据并行训练中，c10d 自动同步各个设备计算出的梯度，从而确保在所有设备上更新后的模型参数保持一致。\",\"AllReduce操作： c10d 支持AllReduce操作，这是在分布式训练中非常常用的操作，能够高效地合并不同设备上的梯度并更新模型参数。\"]},\"148\":{\"h\":\"使用场景\",\"t\":[\"分布式训练：c10d 被广泛应用于分布式深度学习训练中，特别是在需要处理大规模数据集或模型时，能够显著缩短训练时间。\",\"多GPU训练：通过 c10d，用户可以方便地将训练任务分布在多个GPU上，从而充分利用硬件资源。\"]},\"149\":{\"h\":\"示例代码\",\"t\":[\"以下是一个简单的使用 c10d 进行广播操作的示例：\",\"import torch import torch.distributed as dist # 初始化通信库，选择GLOO后端 dist.init_process_group(backend='gloo') # 获取当前进程的rank rank = dist.get_rank() # 创建一个张量 tensor = torch.zeros(1) if rank == 0: tensor += 1 # 只有rank为0的进程修改张量 # 进行广播操作，将rank 0的张量值广播到所有进程 dist.broadcast(tensor, src=0) print(f\\\"Rank {rank} has tensor {tensor[0]}\\\")\"]},\"150\":{\"h\":\"总结\",\"t\":[\"c10d 是 PyTorch 中实现高效分布式计算的关键组件，通过提供灵活的通信后端和强大的同步机制，极大地简化了在多设备或多机器环境中进行并行计算的复杂性。\",\"SPMD 模型\",\"SPMD（Single Program, Multiple Data）模型是一种并行计算模型，在这种模型中，多个处理单元同时执行相同的程序代码，但每个处理单元处理不同的数据。这种模型广泛应用于高性能计算和分布式计算领域，特别适合需要大规模并行处理的任务。\"]},\"151\":{\"h\":\"SPMD 模型的核心思想\",\"t\":[\"单一程序： 在 SPMD 模型中，所有处理单元（通常是不同的CPU或GPU）执行相同的程序代码。这意味着每个处理单元的代码路径是相同的，但可以根据处理单元的ID或索引来执行不同的操作。\",\"多数据流： 尽管所有处理单元执行相同的程序代码，但每个处理单元处理的输入数据是不同的。这通常通过划分数据集来实现，每个处理单元处理其特定的数据子集。\",\"并行性： SPMD 模型通过同时在多个处理单元上执行相同的程序代码来实现并行性。这种并行性可以大幅提高计算效率，特别是在处理大规模数据集时。\",\"通信与同步： 在 SPMD 模型中，处理单元通常需要在某些阶段进行通信和同步。例如，处理单元可能需要共享部分计算结果或交换数据。为了确保数据的一致性，通常需要同步操作来协调各个处理单元的执行。\"]},\"152\":{\"h\":\"SPMD 与其他并行模型的比较\",\"t\":[\"SIMD（Single Instruction, Multiple Data）：与 SPMD 不同，SIMD 是在所有处理单元上执行相同的指令，并且每个处理单元处理不同的数据。在 SIMD 模型中，处理单元的操作是完全同步的。\",\"MIMD（Multiple Instruction, Multiple Data）：MIMD 模型允许每个处理单元执行不同的程序代码并处理不同的数据，与 SPMD 相比，MIMD 提供了更大的灵活性，但通常也更复杂。\"]},\"153\":{\"h\":\"应用场景\",\"t\":[\"SPMD 模型在许多并行计算任务中得到了广泛应用，典型的应用场景包括：\",\"分布式深度学习：在深度学习中，SPMD 模型通常用于分布式训练，每个处理单元（如 GPU）处理一部分数据集，并在训练过程中共享模型参数。\",\"科学计算：许多科学计算任务涉及大规模矩阵或向量操作，可以通过 SPMD 模型并行化这些操作，从而显著提高计算速度。\",\"数值模拟：SPMD 模型在气候模拟、物理仿真等领域中也得到广泛应用，允许并行处理不同区域或不同时间步的计算。\"]},\"154\":{\"h\":\"示例\",\"t\":[\"在分布式训练中，使用 SPMD 模型的一个简单示例可能是，每个 GPU 处理一个 mini-batch 的数据，然后通过通信操作将所有 GPU 的梯度进行合并并同步模型参数。\"]},\"155\":{\"h\":\"总结\",\"t\":[\"SPMD 模型是一种高效的并行计算模型，通过让多个处理单元执行相同的程序代码并处理不同的数据，能够大幅提高计算效率。它的简洁性和高效性使其成为许多并行和分布式计算任务的首选模型。\",\"MPMD\",\"MPMD（Multiple Program, Multiple Data）是一种并行计算模型，与 SPMD（Single Program, Multiple Data）模型相对应。在 MPMD 模型中，多个处理单元（如 CPU 核心或计算节点）可以执行不同的程序，并处理不同的数据集。这种模型适用于更复杂的并行计算任务，特别是在各个处理单元需要执行不同类型的计算时。\"]},\"156\":{\"h\":\"MPMD 模型的核心思想\",\"t\":[\"多个程序： 与 SPMD 模型不同，在 MPMD 模型中，每个处理单元可以运行不同的程序代码。这种灵活性允许处理单元根据任务需求执行不同的操作或算法。\",\"多数据流： 与多个程序相对应，每个处理单元处理不同的数据集。数据的划分方式可以根据具体应用进行调整，以实现负载均衡和计算资源的优化利用。\",\"并行性： MPMD 模型通过允许不同的处理单元并行执行不同的任务，最大化了计算资源的利用率。每个处理单元都可以独立处理自己的任务，互不干扰。\",\"通信与同步： 尽管处理单元运行不同的程序，但它们仍可能需要在某些阶段进行通信和数据交换。MPI（Message Passing Interface）等并行计算框架通常支持 MPMD 模型，通过消息传递机制实现进程间的通信与同步。\"]},\"157\":{\"h\":\"MPMD 与 SPMD 的比较\",\"t\":[\"灵活性：MPMD 提供了更大的灵活性，因为每个处理单元可以执行不同的程序。相比之下，SPMD 模型中所有处理单元执行相同的程序，只是数据不同。\",\"复杂性：由于 MPMD 允许不同的程序同时运行，因此任务协调和进程管理可能更加复杂。处理单元之间的通信需求可能更高，且需要精心设计。\",\"应用场景：MPMD 更适合那些需要同时执行多种任务的复杂应用。例如，某些科学计算或仿真任务可能需要不同的计算步骤，这些步骤可以由不同的程序在不同的处理单元上并行执行。\"]},\"158\":{\"h\":\"应用场景\",\"t\":[\"多物理场仿真：在一些复杂的物理仿真中，可能涉及多个物理场（如流体动力学和热传导）的计算。这些场的计算方法不同，可以在不同的处理单元上并行运行各自的程序。\",\"复杂工作流处理：在需要并行处理不同任务的工作流中，如在大规模数据处理或分析任务中，不同的处理单元可以负责不同的任务或数据集，从而加快整个工作流的执行。\",\"异构计算：在涉及多种计算架构（如 CPU 和 GPU）的应用中，MPMD 模型可以将不同的程序分配给不同的架构，以充分利用各自的计算优势。\"]},\"159\":{\"h\":\"示例场景\",\"t\":[\"假设有一个科学模拟项目，需要同时计算两个独立的物理过程。第一个进程在 CPU 上运行大气模拟程序，而第二个进程在 GPU 上运行海洋模拟程序。这两部分模拟数据可能会在某些阶段相互依赖，因此需要通过通信机制进行数据交换。使用 MPMD 模型可以分别启动两个不同的程序，并通过 MPI 等工具进行协调和通信。\"]},\"160\":{\"h\":\"实现 MPMD 的框架\",\"t\":[\"MPI 是最常用的实现 MPMD 模型的框架之一。MPI 允许用户在同一个应用程序中启动多个不同的程序实例，每个实例可以有自己的任务和数据，同时提供通信接口以在它们之间进行消息传递。\"]},\"161\":{\"h\":\"总结\",\"t\":[\"MPMD（Multiple Program, Multiple Data）模型是一种强大的并行计算模型，允许多个处理单元并行执行不同的程序，并处理不同的数据集。它的灵活性使其非常适合处理复杂的并行任务，特别是在不同任务需要不同计算资源或算法的情况下。MPI 等并行计算框架为 MPMD 模型提供了实现途径，广泛应用于科学计算、数据分析和异构计算等领域。\",\"MPI\",\"MPI（Message Passing Interface）是一种用于并行计算的标准接口，广泛应用于分布式计算和高性能计算（HPC）领域。MPI 提供了一组标准的 API，允许程序在多个处理单元（如 CPU 核心或计算节点）之间进行消息传递和协调，从而实现大规模并行计算。\"]},\"162\":{\"h\":\"MPI 的核心概念\",\"t\":[\"进程模型： MPI 采用进程并行模型，即每个并行任务在一个独立的进程中运行。进程之间通过消息传递进行通信，而不是共享内存。这种设计使得 MPI 非常适合在分布式内存系统（如计算集群）上运行。\",\"通信机制：\",\"点对点通信：两个进程之间直接进行消息传递，典型的函数有 MPI_Send 和 MPI_Recv，分别用于发送和接收消息。\",\"集体通信：MPI 提供了多种集体通信操作，如广播（broadcast）、归约（reduction）、散播（scatter）和聚集（gather），这些操作涉及多个进程之间的通信。\",\"进程组和通信域： MPI 中的进程可以组织成进程组，每个进程组拥有一个通信域（communicator）。MPI_COMM_WORLD 是所有 MPI 程序默认的通信域，包含了所有进程。用户也可以定义自己的进程组和通信域，以便更灵活地管理和组织进程。\",\"同步与异步通信： MPI 支持同步和异步的消息传递模式。同步通信要求发送方等待接收方确认消息接收，确保消息传递的顺序和一致性；异步通信则允许发送方在消息发送后立即继续执行，而不必等待接收方确认。\",\"并行I/O： MPI-IO 是 MPI 的一个子集，专门用于并行文件输入输出操作。MPI-IO 允许多个进程同时读写大规模数据集，为并行计算中的数据管理提供了高效的解决方案。\"]},\"163\":{\"h\":\"MPI 的主要功能\",\"t\":[\"并行计算：MPI 允许程序在多个处理单元上并行运行，从而加速计算任务的执行。适用于数值模拟、数据处理等需要处理大量计算的场景。\",\"跨平台兼容：MPI 是一种标准接口，支持多种硬件和操作系统平台。常见的 MPI 实现包括 OpenMPI、MPICH 等，它们在不同的计算环境中均能有效运行。\",\"高效的消息传递：MPI 针对不同的通信模式进行了优化，能够在高性能计算环境中提供低延迟和高带宽的通信服务。\"]},\"164\":{\"h\":\"使用场景\",\"t\":[\"数值模拟：在流体力学、气象预报、天体物理等领域，MPI 常用于实现复杂的数值模拟，这些任务通常需要处理非常大的数据集和复杂的计算过程。\",\"数据分析：在大规模数据分析任务中，MPI 可以将计算任务分布到多个节点，从而提高数据处理的速度和效率。\",\"机器学习和深度学习：MPI 也可以用于分布式机器学习，尤其是在需要跨多个节点或多个 GPU 进行训练的情况下，通过 MPI 实现模型的并行训练和参数同步。\"]},\"165\":{\"h\":\"示例代码\",\"t\":[\"以下是一个简单的 MPI 程序示例，展示了如何使用 MPI 实现基本的点对点通信：\",\"#include <mpi.h> #include <stdio.h> int main(int argc, char** argv) { MPI_Init(&argc, &argv); int world_rank; MPI_Comm_rank(MPI_COMM_WORLD, &world_rank); int world_size; MPI_Comm_size(MPI_COMM_WORLD, &world_size); if (world_rank == 0) { int data = 100; MPI_Send(&data, 1, MPI_INT, 1, 0, MPI_COMM_WORLD); printf(\\\"Process 0 sent data %d to process 1\\\\n\\\", data); } else if (world_rank == 1) { int data; MPI_Recv(&data, 1, MPI_INT, 0, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE); printf(\\\"Process 1 received data %d from process 0\\\\n\\\", data); } MPI_Finalize(); return 0; }\"]},\"166\":{\"h\":\"总结\",\"t\":[\"MPI 是并行计算领域的重要工具，提供了灵活且高效的消息传递机制，使得程序能够在多处理单元环境中高效运行。MPI 的标准化设计和广泛支持使其成为高性能计算、分布式计算和大规模数据处理任务中的主流选择。\"]},\"167\":{\"c\":[\"分布式\"]},\"168\":{\"c\":[\"PyTorch\",\"c10d\"]},\"169\":{\"h\":\"常用工具总结\"},\"170\":{\"h\":\"ubuntu\"},\"171\":{\"h\":\"ping 安装\",\"t\":[\"apt install iputils-ping\"]},\"172\":{\"h\":\"获取公网ip\",\"t\":[\"curl ip.sb curl ipinfo.io\"]},\"173\":{\"c\":[\"工具\"]},\"174\":{\"c\":[\"skill\"]},\"175\":{\"h\":\"开源技术\",\"t\":[\"MInference：通过动态稀疏注意力加速长上下文 LLM 的预填充\"]},\"176\":{\"h\":\"地址\",\"t\":[\"https://github.com/microsoft/MInference\"]},\"177\":{\"h\":\"论文\",\"t\":[\"https://hqjiang.com/minference.html\"]},\"178\":{\"h\":\"介绍\",\"t\":[\"论文介绍了一种名为 MInference 的动态稀疏注意力方法，用于解决长上下文 LLM 推理中的问题，并通过多种实验和测试展示了其效果。\"]},\"179\":{\"h\":\"重要亮点\",\"t\":[\"MInference 的提出背景：长上下文 LLM 推理面临预填充阶段注意力延迟长、KV 缓存存储和传输成本高等挑战，之前方法难以低成本在单个 A100 GPU 实现百万级标记提示的可接受延迟，MInference 应运而生。\",\"MInference 的工作原理：利用动态稀疏注意的静态空间聚合模式，离线确定每个头的最佳动态稀疏模式，在推理中动态近似动态稀疏索引，使用优化的 GPU 内核执行高效计算，显著减少预填充阶段延迟。\",\"MInference 的主要贡献：加速长上下文 LLM 的预填充阶段多达 10 倍；将动态稀疏注意力分为三种模式并设计搜索算法；引入在线近似方法和优化内核，提出最佳推理代码库；通过四个基准测试评估，在成本效率和系统延迟方面表现出色。\",\"长上下文基准测试中的实验结果：在问答、编码、基于检索等一系列任务中测试 MInference，有效保留或扩展实际上下文窗口处理能力，在不同模型和方法对比中性能良好。\",\"内核中的延迟细分和稀疏模式：展示三种注意力模式和 FlashAttention 的微基准测试结果，Vertical-Slash 虽慢但仍有显著加速，还展示了 Vertical-Slash 头部 kernel 中的稀疏索引。\"]},\"180\":{\"c\":[\"开源技术\"]},\"181\":{\"c\":[\"推理引擎\"]},\"182\":{\"h\":\"操作系统\",\"t\":[\"strace命令\",\"strace 是一个用于跟踪系统调用和信号的工具，它可以帮助你诊断程序的行为或调试程序。-p 选项用于附加到一个正在运行的进程上，并实时显示它的系统调用。\"]},\"183\":{\"h\":\"解释命令：\",\"t\":[\"strace -p 871\",\"strace：调用 strace 工具。\",\"-p 871：指定进程ID（PID）为 871 的进程。strace 会附加到这个进程，并跟踪它的系统调用。\"]},\"184\":{\"h\":\"使用场景：\",\"t\":[\"实时跟踪系统调用：你可以看到进程 871 进行的每个系统调用，这有助于了解程序在做什么。\",\"调试和排错：如果某个进程表现异常，比如挂起、资源消耗过高等，通过 strace 可以查看它在调用哪些系统调用，以便分析问题的根本原因。\"]},\"185\":{\"h\":\"注意事项：\",\"t\":[\"权限：如果目标进程由另一个用户（比如 root）启动，可能需要相应的权限（例如通过 sudo）来使用 strace。\",\"性能影响：strace 会对被跟踪的进程产生一定的性能开销，尤其是在处理大量系统调用时，所以应在必要时使用。\",\"运行该命令后，你会看到进程871的系统调用输出，直到你停止 strace (通常通过 Ctrl+C)。\",\"top命令解释\",\"我们可以用上面这张图，把这些值挨个解释一下。\",\"假设一个用户程序开始运行了，那么就对应着第一个\\\"us\\\"框，\\\"us\\\"是\\\"user\\\"的缩写，代表 Linux 的用户态 CPU Usage。普通用户程序代码中，只要不是调用系统调用（System Call），这些代码的指令消耗的 CPU 就都属于\\\"us\\\"。\",\"当这个用户程序代码中调用了系统调用，比如说 read() 去读取一个文件，这时候这个用户进程就会从用户态切换到内核态。\",\"内核态 read() 系统调用在读到真正 disk 上的文件前，就会进行一些文件系统层的操作。那么这些代码指令的消耗就属于\\\"sy\\\"，这里就对应上面图里的第二个框。\\\"sy\\\"是 \\\"system\\\"的缩写，代表内核态 CPU 使用。\",\"接下来，这个 read() 系统调用会向 Linux 的 Block Layer 发出一个 I/O Request，触发一个真正的磁盘读取操作。\",\"这时候，这个进程一般会被置为 TASK_UNINTERRUPTIBLE。而 Linux 会把这段时间标示成\\\"wa\\\"，对应图中的第三个框。\\\"wa\\\"是\\\"iowait\\\"的缩写，代表等待 I/O 的时间，这里的 I/O 是指 Disk I/O。\",\"紧接着，当磁盘返回数据时，进程在内核态拿到数据，这里仍旧是内核态的 CPU 使用中的\\\"sy\\\"，也就是图中的第四个框。\",\"然后，进程再从内核态切换回用户态，在用户态得到文件数据，这里进程又回到用户态的 CPU 使用，\\\"us\\\"，对应图中第五个框。\",\"好，这里我们假设一下，这个用户进程在读取数据之后，没事可做就休眠了。并且我们可以进一步假设，这时在这个 CPU 上也没有其他需要运行的进程了，那么系统就会进入\\\"id\\\"这个步骤，也就是第六个框。\\\"id\\\"是\\\"idle\\\"的缩写，代表系统处于空闲状态。\",\"如果这时这台机器在网络收到一个网络数据包，网卡就会发出一个中断（interrupt）。相应地，CPU 会响应中断，然后进入中断服务程序。\",\"这时，CPU 就会进入\\\"hi\\\"，也就是第七个框。\\\"hi\\\"是\\\"hardware irq\\\"的缩写，代表 CPU 处理硬中断的开销。由于我们的中断服务处理需要关闭中断，所以这个硬中断的时间不能太长。\",\"但是，发生中断后的工作是必须要完成的，如果这些工作比较耗时那怎么办呢？Linux 中有一个软中断的概念（softirq），它可以完成这些耗时比较长的工作。\",\"你可以这样理解这个软中断，从网卡收到数据包的大部分工作，都是通过软中断来处理的。那么，CPU 就会进入到第八个框，\\\"si\\\"。这里\\\"si\\\"是\\\"softirq\\\"的缩写，代表 CPU 处理软中断的开销。\",\"这里你要注意，无论是\\\"hi\\\"还是\\\"si\\\"，它们的 CPU 时间都不会计入进程的 CPU 时间。这是因为本身它们在处理的时候就不属于任何一个进程。\",\"好了，通过这个场景假设，我们介绍了大部分的 Linux CPU 使用。\",\"不过，我们还剩两个类型的 CPU 使用没讲到，我想给你做个补充，一次性带你做个全面了解。这样以后你解决相关问题时，就不会再犹豫，这些值到底影不影响 CPU Cgroup 中的限制了。下面我给你具体讲一下。\",\"一个是\\\"ni\\\"，是\\\"nice\\\"的缩写，这里表示如果进程的 nice 值是正值（1-19），代表优先级比较低的进程运行时所占用的 CPU。\",\"另外一个是\\\"st\\\"，\\\"st\\\"是\\\"steal\\\"的缩写，是在虚拟机里用的一个 CPU 使用类型，表示有多少时间是被同一个宿主机上的其他虚拟机抢走的。\"]},\"186\":{\"h\":\"扩容磁盘\",\"t\":[\"要将 nvme0n1p1 的空间扩展到 /dev/mapper/centos-root，你需要执行以下步骤。这包括删除 nvme0n1p1 分区，重新分配空间，并将其添加到现有的 LVM 逻辑卷中。\"]},\"187\":{\"h\":\"1. 卸载并删除 分区\",\"t\":[\"首先，你需要确保 nvme0n1p1 上没有重要数据，并且它未被挂载。如果已经挂载，请先卸载：\",\"sudo umount /dev/nvme0n1p1\",\"然后，使用 fdisk 删除 nvme0n1p1 分区：\",\"sudo fdisk /dev/nvme0n1\",\"进入 fdisk 命令行后：\",\"输入 d 选择删除分区，然后输入分区号 1 删除 nvme0n1p1。\",\"输入 w 写入更改并退出 fdisk。\"]},\"188\":{\"h\":\"2. 创建新的分区并标记为 LVM\",\"t\":[\"在释放 nvme0n1p1 的空间后，你需要重新创建一个新的分区，覆盖以前的分区空间，并将其类型设置为 Linux LVM。\",\"仍然使用 fdisk 来创建新分区：\",\"sudo fdisk /dev/nvme0n1\",\"进入 fdisk 命令行后：\",\"输入 n 创建一个新的分区。\",\"使用默认的开始和结束扇区，覆盖以前的 nvme0n1p1 分区空间。\",\"输入 t 设置新分区的类型为 8e（Linux LVM）。\",\"输入 w 写入更改并退出 fdisk。\"]},\"189\":{\"h\":\"3. 将新分区添加到 LVM 物理卷\",\"t\":[\"新分区创建并标记为 LVM 后，将其添加到 LVM 的物理卷中：\",\"sudo pvcreate /dev/nvme0n1p1 sudo vgextend centos /dev/nvme0n1p1\"]},\"190\":{\"h\":\"4. 扩展逻辑卷\",\"t\":[\"现在，你可以将新的空间分配给逻辑卷 centos-root：\",\"sudo lvextend -l +100%FREE /dev/mapper/centos-root\"]},\"191\":{\"h\":\"5. 扩展 文件系统\",\"t\":[\"最后，使用 xfs_growfs 来扩展文件系统，使其利用新增的空间：\",\"sudo xfs_growfs /dev/mapper/centos-root\"]},\"192\":{\"h\":\"6. 验证扩展结果\",\"t\":[\"扩展完成后，使用 df -h / 来检查根文件系统的大小：\",\"df -h /\",\"这个命令将显示根文件系统的更新后的容量，确认 nvme0n1p1 的空间已经成功分配给 /dev/mapper/centos-root。\"]},\"193\":{\"c\":[\"操作系统\"]},\"194\":{\"c\":[\"操作系统\"]},\"195\":{\"h\":\"计算机网络\",\"t\":[\"http2与http1区别?\",\"HTTP/2 是对 HTTP/1.x 协议的重大升级，旨在提高网络性能和效率。以下是 HTTP/2 相对于 HTTP/1 的一些关键区别和改进：\"]},\"196\":{\"h\":\"1. 协议基础\",\"t\":[\"HTTP/1.x: 基于纯文本的协议，使用新行符分隔的文本消息进行通信。\",\"HTTP/2: 基于二进制的协议，使用二进制帧传输数据，更高效地解析和传输数据。\"]},\"197\":{\"h\":\"2. 连接管理\",\"t\":[\"HTTP/1.x:\",\"每个请求/响应对通常需要一个单独的TCP连接（HTTP/1.0）。\",\"HTTP/1.1 引入了连接保持（Keep-Alive），允许在同一个TCP连接上复用多个请求，但在同一时刻只能处理一个请求（串行化处理）。\",\"HTTP/2:\",\"单个TCP连接上可以处理多个并发的请求/响应对。\",\"使用流的概念，每个请求/响应对在一个单独的流中，流之间可以独立并行处理。\"]},\"198\":{\"h\":\"3. 多路复用\",\"t\":[\"HTTP/1.x: 在一个连接上，只有一个请求/响应对可以被处理（头部阻塞问题），需要等待当前请求完成后，才能开始下一个请求。\",\"HTTP/2: 允许多个请求/响应对在同一连接上的多个流中并发传输，不同的流可以独立处理，不会相互阻塞。\"]},\"199\":{\"h\":\"4. 头部压缩\",\"t\":[\"HTTP/1.x: HTTP头部是以纯文本格式传输的，每个请求都需要发送完整的头部信息，导致冗余和带宽浪费。\",\"HTTP/2: 使用 HPACK 算法对头部进行压缩，减少了传输数据量。头部信息仅在第一次请求时完整传输，后续请求只需发送差异部分。\"]},\"200\":{\"h\":\"5. 服务器推送\",\"t\":[\"HTTP/1.x: 客户端必须明确请求每个资源，服务器只能响应客户端的请求。\",\"HTTP/2: 支持服务器推送功能，服务器可以在客户端请求之前主动发送资源，这有助于减少延迟和提升性能。例如，当客户端请求HTML页面时，服务器可以主动推送相关的CSS和JavaScript文件。\"]},\"201\":{\"h\":\"6. 优先级和流控制\",\"t\":[\"HTTP/1.x: 没有内建的优先级控制机制，所有请求被平等对待。\",\"HTTP/2: 支持流的优先级，客户端可以指定不同流的优先级，允许更重要的请求先行处理。同时，HTTP/2 提供流量控制机制，确保没有流会独占带宽。\"]},\"202\":{\"h\":\"7. 加密和安全\",\"t\":[\"HTTP/1.x: 加密是可选的（通过HTTP或HTTPS），但非加密的HTTP请求仍然普遍存在。\",\"HTTP/2: 大多数实现强制要求使用加密（通过HTTPS），尽管协议本身不强制这一点。现代浏览器和服务器在实际应用中通常要求 HTTP/2 使用 TLS。\"]},\"203\":{\"h\":\"8. 协议扩展性\",\"t\":[\"HTTP/1.x: 由于是文本协议，扩展和添加新功能变得复杂。\",\"HTTP/2: 作为二进制协议，HTTP/2 更容易扩展，添加新功能可以通过新帧类型和更复杂的协议操作来实现，而不影响现有的功能。\"]},\"204\":{\"h\":\"9. 性能改进\",\"t\":[\"HTTP/1.x: 多个小的请求可能会因为串行化处理导致较高的延迟和低效的带宽利用。\",\"HTTP/2: 通过多路复用、头部压缩和服务器推送等功能，HTTP/2 显著降低了延迟，改善了带宽利用，提升了整体性能。\"]},\"205\":{\"h\":\"总结\",\"t\":[\"特性\",\"HTTP/1.x\",\"HTTP/2\",\"协议类型\",\"基于纯文本\",\"基于二进制\",\"连接管理\",\"每个请求通常需要一个TCP连接\",\"单个连接处理多个并发请求\",\"多路复用\",\"不支持（有头部阻塞问题）\",\"支持\",\"头部压缩\",\"不支持\",\"使用HPACK算法进行压缩\",\"服务器推送\",\"不支持\",\"支持\",\"优先级和流控制\",\"不支持\",\"支持\",\"加密和安全\",\"可选（但非强制）\",\"大多数实现要求加密（HTTPS）\",\"协议扩展性\",\"扩展复杂\",\"更容易扩展\",\"性能\",\"受限于串行化处理和头部阻塞\",\"显著提升（多路复用、压缩、推送）\",\"HTTP/2 带来了显著的改进和优化，使得网络应用能够更高效地传输数据，提升了用户体验和网络性能。\"]},\"206\":{\"h\":\"查看系统中已有的veth设备对或确认已创建的veth设备对，可以使用以下几种方法：\"},\"207\":{\"h\":\"使用 命令\",\"t\":[\"ip 命令是查看和管理网络设备的主要工具：\",\"列出所有网络接口：\",\"ip link show\",\"该命令会列出系统中所有的网络接口，包括veth设备对。\",\"过滤veth设备：\",\"ip link show | grep veth\",\"通过grep过滤出veth设备。\"]},\"208\":{\"h\":\"使用 命令\",\"t\":[\"ifconfig命令也可以用于查看网络接口：\",\"ifconfig\",\"同样，可以使用grep过滤出veth设备：\",\"ifconfig | grep veth\"]},\"209\":{\"h\":\"查看具体veth设备对的详细信息\",\"t\":[\"可以使用以下命令查看某个veth设备对的详细信息：\",\"ip link show veth0\"]},\"210\":{\"h\":\"示例\",\"t\":[\"假设创建了一个veth设备对：\",\"ip link add veth0 type veth peer name veth1\",\"然后，可以使用以下命令查看：\",\"ip link show | grep veth\",\"输出可能类似于：\",\"10: veth0@veth1: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000 11: veth1@veth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000\",\"这表明veth0和veth1是一对互相连接的虚拟以太网设备。\"]},\"211\":{\"h\":\"检查命名空间中的veth设备\",\"t\":[\"如果将veth设备移动到不同的命名空间，可以使用以下命令查看特定命名空间中的网络接口：\",\"ip netns exec ns1 ip link show ip netns exec ns1 ip link show 1: lo: <LOOPBACK> mtu 65536 qdisc noop state DOWN mode DEFAULT group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 28: veth1@if29: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP mode DEFAULT group default qlen 1000 link/ether 52:7e:e0:b6:47:d2 brd ff:ff:ff:ff:ff:ff link-netnsid 0 ip netns exec ns1 ip a 1: lo: <LOOPBACK> mtu 65536 qdisc noop state DOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 28: veth1@if29: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP group default qlen 1000 link/ether 52:7e:e0:b6:47:d2 brd ff:ff:ff:ff:ff:ff link-netnsid 0 inet 192.168.1.2/24 scope global veth1 valid_lft forever preferred_lft forever inet6 fe80::507e:e0ff:feb6:47d2/64 scope link valid_lft forever preferred_lft forever\",\"假设veth1被移动到命名空间ns1，可以在ns1命名空间中看到它。\",\"通过这些命令，可以方便地查看和管理系统中的veth设备对。\"]},\"212\":{\"h\":\"VLAN 与VXLAN\",\"t\":[\"VLAN（Virtual Local Area Network）和VXLAN（Virtual Extensible LAN）是两种用于网络分段和虚拟化的技术，它们各自有不同的应用场景和特点。以下是对它们的解析：\"]},\"213\":{\"h\":\"VLAN（Virtual Local Area Network）\",\"t\":[\"VLAN是一种用于在同一物理网络上创建多个逻辑网络的技术。它的主要特点和用途如下：\",\"网络分段：通过VLAN，可以将一个物理网络分割成多个逻辑网络，使得不同VLAN之间的通信受到限制，从而提高网络的安全性和性能。\",\"标记帧：VLAN使用IEEE 802.1Q标准，在以太网帧中添加一个4字节的标签，标记帧属于哪个VLAN。\",\"VLAN ID：每个VLAN都有一个唯一的VLAN ID，范围是1到4094。网络设备根据这个ID来区分不同的VLAN。\",\"配置简单：VLAN的配置相对简单，只需要在交换机上配置相关的端口或接口即可。\",\"常见用途：\",\"提高网络安全性，通过分割网络减少广播域。\",\"提高网络性能，通过减少广播流量和冲突域。\",\"提供灵活的网络管理和用户分组。\"]},\"214\":{\"h\":\"VXLAN（Virtual Extensible LAN）\",\"t\":[\"VXLAN是一种用于在大规模数据中心和云环境中创建虚拟网络的技术。它的主要特点和用途如下：\",\"扩展性：VXLAN使用24位的VNI（VXLAN Network Identifier），理论上支持多达1600万个虚拟网络，大大超过了VLAN的4094个限制。\",\"基于隧道：VXLAN通过UDP隧道封装，将二层以太网帧封装在三层IP包中，从而可以跨越传统的二层边界在IP网络上传输。\",\"分布式架构：VXLAN适用于大规模的分布式数据中心环境，支持跨多个物理位置的虚拟机迁移和负载均衡。\",\"网络虚拟化：VXLAN可以在现有的IP网络基础上创建虚拟网络，使得虚拟机和容器之间的通信更加灵活和高效。\",\"常见用途：\",\"数据中心和云环境中的大规模虚拟化网络。\",\"跨多个数据中心的虚拟机迁移和高可用性。\",\"支持多租户环境，每个租户可以有独立的虚拟网络。\"]},\"215\":{\"h\":\"对比\",\"t\":[\"特点\",\"VLAN\",\"VXLAN\",\"标识符\",\"12位VLAN ID（最多4094个）\",\"24位VNI（最多1600万个）\",\"封装层\",\"二层以太网（IEEE 802.1Q）\",\"三层IP（UDP隧道封装）\",\"应用场景\",\"小规模网络、局域网\",\"大规模数据中心、云环境、跨数据中心\",\"配置复杂度\",\"简单\",\"较复杂，需要配置隧道端点（VTEP）\",\"扩展性\",\"有限，最多4094个VLAN\",\"高扩展性，支持多达1600万个虚拟网络\"]},\"216\":{\"h\":\"总结\",\"t\":[\"VLAN适用于较小规模的网络分段和隔离，而VXLAN适用于大规模数据中心和云环境中的网络虚拟化和扩展。它们各自有不同的优缺点和应用场景，根据具体需求选择合适的技术可以提高网络的性能、安全性和管理灵活性。\"]},\"217\":{\"h\":\"VXLAN与VTEP\"},\"218\":{\"h\":\"VXLAN（Virtual Extensible LAN）\",\"t\":[\"VXLAN是一种用于扩展二层网络的技术，特别适合在大型数据中心和云环境中使用。其主要特性包括：\",\"扩展性：VXLAN使用24位的VNI（VXLAN Network Identifier），支持多达1600万个虚拟网络，远远超过传统VLAN的4094个限制。\",\"隧道封装：VXLAN通过UDP隧道封装将二层以太网帧封装在三层IP包中，从而可以在三层IP网络上进行传输。这种方式允许二层流量跨越不同的三层网络，使得虚拟机可以在不同的物理位置之间自由迁移。\",\"多租户支持：VXLAN允许在同一个物理网络基础设施上运行多个独立的虚拟网络，每个虚拟网络可以有自己的VNI，从而支持多租户环境。\",\"弹性和高可用性：VXLAN可以在现有的IP网络上实现二层网络的扩展和弹性，支持负载均衡和高可用性。\"]},\"219\":{\"h\":\"VTEP（VXLAN Tunnel Endpoint）\",\"t\":[\"VTEP是VXLAN架构中的关键组件，负责VXLAN隧道的端点操作。其主要功能包括：\",\"隧道端点：VTEP是VXLAN隧道的起点和终点，负责VXLAN包的封装和解封装。每个VTEP有两个主要接口：一个是连接到传统二层网络的接口，另一个是连接到IP网络的接口。\",\"封装和解封装：当VTEP接收到来自二层网络的以太网帧时，它将帧封装在UDP包中，附加上VNI，然后通过IP网络发送到目标VTEP。目标VTEP解封装UDP包，并将以太网帧发送到其二层网络接口。\",\"VNI映射：VTEP负责将二层网络中的VLAN ID映射到VXLAN的VNI，从而在VXLAN隧道中维护虚拟网络的隔离和标识。\",\"MAC地址学习：VTEP通过监听网络流量和ARP（Address Resolution Protocol）请求，学习和维护虚拟网络中MAC地址到VTEP的映射关系。这类似于传统二层交换机的MAC地址表。\"]},\"220\":{\"h\":\"VXLAN 和 VTEP 的工作流程\",\"t\":[\"帧封装：当主机A发送一个以太网帧给主机B时，该帧首先被发送到本地的VTEP。\",\"VXLAN包封装：VTEP将该帧封装到一个UDP包中，并附加上对应的VNI。UDP包的源IP和目的IP是VTEP的IP地址。\",\"通过IP网络传输：封装好的VXLAN包通过三层IP网络传输到目的VTEP。\",\"帧解封装：目的VTEP接收到VXLAN包后，解封装出原始的以太网帧。\",\"帧传递：解封装的以太网帧被发送到目标主机B所在的二层网络。\"]},\"221\":{\"h\":\"总结\",\"t\":[\"VXLAN通过在现有的三层IP网络上创建虚拟二层网络，实现了大规模的数据中心和云环境中的网络虚拟化和扩展。VTEP作为VXLAN架构中的关键组件，负责隧道的端点操作，完成VXLAN包的封装和解封装。VXLAN和VTEP的结合，使得跨越不同物理位置的虚拟机能够像在同一个二层网络中一样进行通信，从而实现了高效、灵活和可扩展的网络架构。\"]},\"222\":{\"h\":\"ip neigh show\",\"t\":[\"ip neigh show dev flannel.1命令用于显示指定网络设备（在这里是flannel.1）的邻居表项。邻居表存储了网络设备的邻居节点的信息，包括其IP地址和MAC地址。\",\"在使用flannel的Kubernetes集群中，flannel.1通常是用于Overlay网络的设备接口。运行这个命令会列出该接口的所有邻居节点的信息。每个邻居节点条目通常包含以下信息：\",\"IP地址：邻居节点的IP地址。\",\"MAC地址：邻居节点的MAC地址。\",\"状态：邻居节点的状态，例如REACHABLE（可达）、STALE（陈旧）、DELAY（延迟）、PROBE（探测）等。\",\"例如，运行ip neigh show dev flannel.1可能得到以下输出：\",\"10.244.2.1 dev flannel.1 lladdr 0a:58:0a:f4:02:01 REACHABLE 10.244.2.2 dev flannel.1 lladdr 0a:58:0a:f4:02:02 STALE\",\"在这个例子中：\",\"10.244.2.1 是一个邻居节点的IP地址，0a:58:0a:f4:02:01 是其MAC地址，状态是REACHABLE。\",\"10.244.2.2 是另一个邻居节点的IP地址，0a:58:0a:f4:02:02 是其MAC地址，状态是STALE。\"]},\"223\":{\"h\":\"总结\",\"t\":[\"ip neigh show dev flannel.1命令用于查看指定设备（如flannel.1）的邻居节点信息，帮助管理员了解当前网络设备与其他节点的连接状态和MAC地址映射情况。这对于排查网络问题和管理网络连接非常有用。\"]},\"224\":{\"h\":\"bridge fdb show\",\"t\":[\"bridge fdb show命令用于显示Linux桥接设备的前向数据库（Forwarding Database，FDB）。FDB记录了MAC地址与网络接口的映射关系，帮助桥接设备确定数据帧的转发路径。通过这个命令，可以查看桥接设备当前的MAC地址表，了解哪些MAC地址通过哪些接口连接。\"]},\"225\":{\"h\":\"示例输出\",\"t\":[\"运行bridge fdb show命令的示例输出可能如下所示：\",\"33:33:00:00:00:01 dev ens3 self permanent 01:00:5e:00:00:01 dev ens3 self permanent 02:42:ac:11:00:02 dev docker0 vlan 1 master docker0 02:42:ac:11:00:03 dev docker0 vlan 1 master docker0\"]},\"226\":{\"h\":\"输出字段解释\",\"t\":[\"MAC地址：如33:33:00:00:00:01，这是设备的MAC地址。\",\"dev：后面跟随的是设备名，如ens3或docker0，表示该MAC地址对应的设备。\",\"self：表示该条目是本地接口的MAC地址。\",\"permanent：表示该条目是永久性的，而不是动态学习到的。\",\"vlan：VLAN ID，表示该条目所属的VLAN。\",\"master：表示该设备所属的主设备。\"]},\"227\":{\"h\":\"常用选项\",\"t\":[\"bridge fdb show [dev DEVICE]：显示特定设备的FDB条目。例如，bridge fdb show dev br0显示设备br0的FDB。\",\"bridge fdb show [br BRIDGE]：显示特定桥接设备的FDB条目。\"]},\"228\":{\"h\":\"使用示例\",\"t\":[\"显示所有桥接设备的FDB条目：\",\"bridge fdb show\",\"显示特定设备的FDB条目：\",\"bridge fdb show dev br0\",\"显示特定桥接设备的FDB条目：\",\"bridge fdb show br br0\"]},\"229\":{\"h\":\"总结\",\"t\":[\"bridge fdb show命令用于查看Linux桥接设备的前向数据库，帮助管理员了解网络中MAC地址的分布情况和转发路径。这对于网络故障排查和性能优化非常有用。\"]},\"230\":{\"h\":\"ARP协议\",\"t\":[\"ARP（Address Resolution Protocol，地址解析协议）是一种用于在IPv4网络中将IP地址解析为物理地址（如MAC地址）的网络协议。它在以太网等局域网环境中起着关键作用，使得设备能够通过IP地址找到目标设备的物理地址，从而进行通信。\"]},\"231\":{\"h\":\"ARP 工作原理\",\"t\":[\"ARP 请求：\",\"当设备A需要向设备B发送数据时，它知道设备B的IP地址，但不知道设备B的MAC地址。设备A会先在本地的ARP缓存中查找设备B的IP地址对应的MAC地址。\",\"如果在ARP缓存中找不到设备B的MAC地址，设备A会广播一条ARP请求帧到网络中。该ARP请求包含设备B的IP地址，并询问“谁是这个IP地址的拥有者？请告诉我你的MAC地址。”\",\"ARP 响应：\",\"网络中的所有设备都会接收到这个ARP请求帧。当设备B接收到这个ARP请求时，它会检查其中的IP地址。\",\"如果设备B的IP地址与请求中的IP地址匹配，设备B会发送一条ARP响应帧。该响应帧包含设备B的MAC地址，并单播发送给设备A。\",\"更新ARP缓存：\",\"设备A接收到设备B的ARP响应后，会将设备B的IP地址和MAC地址映射关系存储在本地的ARP缓存中，以便后续通信时可以直接使用，而无需再次发送ARP请求。\"]},\"232\":{\"h\":\"ARP 报文格式\",\"t\":[\"ARP报文包含两个主要部分：ARP请求和ARP响应。其报文格式如下：\",\"硬件类型（Hardware Type）：通常为1，表示以太网。\",\"协议类型（Protocol Type）：通常为0x0800，表示IPv4。\",\"硬件地址长度（Hardware Address Length）：表示硬件地址的长度，通常为6（MAC地址长度）。\",\"协议地址长度（Protocol Address Length）：表示协议地址的长度，通常为4（IPv4地址长度）。\",\"操作码（Operation Code）：1表示ARP请求，2表示ARP响应。\",\"发送方硬件地址（Sender Hardware Address）：发送设备的MAC地址。\",\"发送方协议地址（Sender Protocol Address）：发送设备的IP地址。\",\"目标硬件地址（Target Hardware Address）：目标设备的MAC地址（ARP请求中该字段为空）。\",\"目标协议地址（Target Protocol Address）：目标设备的IP地址。\"]},\"233\":{\"h\":\"ARP 缓存\",\"t\":[\"为了提高效率，设备会将最近解析的IP地址和MAC地址映射关系存储在ARP缓存中。ARP缓存中的条目通常有一个生存时间（TTL），超过该时间后条目将被删除，以保证ARP缓存的最新性。\"]},\"234\":{\"h\":\"ARP的安全问题\",\"t\":[\"ARP协议本身没有安全机制，因此容易受到ARP欺骗（ARP Spoofing）攻击。攻击者可以发送伪造的ARP响应，将其MAC地址伪装成另一个设备的MAC地址，从而拦截或篡改网络通信。\"]},\"235\":{\"h\":\"ARP欺骗的防御措施\",\"t\":[\"静态ARP表：手动配置IP地址和MAC地址的映射，防止ARP欺骗。\",\"ARP检测：使用网络设备（如交换机）提供的ARP检测功能，过滤掉伪造的ARP报文。\",\"VPN：通过虚拟专用网络（VPN）加密通信，防止中间人攻击。\"]},\"236\":{\"h\":\"总结\",\"t\":[\"ARP协议在IPv4网络中起到了关键的地址解析作用，使设备能够通过IP地址找到目标设备的MAC地址，从而进行通信。虽然ARP协议本身存在安全隐患，但通过适当的防御措施可以有效防止ARP欺骗攻击。\"]},\"237\":{\"h\":\"BGP协议\",\"t\":[\"BGP（Border Gateway Protocol，边界网关协议）是互联网核心路由协议，用于在不同自治系统（AS, Autonomous Systems）之间交换路由信息。BGP是唯一能够处理互联网中如此大规模路由的协议，被广泛应用于ISP（互联网服务提供商）、大型企业和数据中心网络中。\"]},\"238\":{\"h\":\"BGP 的主要特性和工作原理\",\"t\":[\"自治系统（AS）：\",\"一个AS是一组由同一管理实体管理的IP网络和路由器。每个AS都有一个唯一的AS编号（ASN）。\",\"BGP 会话：\",\"BGP运行在TCP之上（端口179），通过建立BGP会话来交换路由信息。这些会话通常是静态配置的，由网络管理员手动设置。\",\"路径向量协议：\",\"BGP是一种路径向量协议，通过维护到达每个目标网络的路径信息来选择最佳路径。路径信息包括多个AS路径，以避免环路。\",\"路由选择：\",\"BGP使用一套复杂的路由选择规则来确定最佳路径。这些规则包括： \",\"最短的AS路径\",\"优先级最高的本地优先级（local preference）\",\"最小的多出口判别器（MED, Multi-Exit Discriminator）\",\"最稳定的路径（考虑路由抖动）\",\"最小的路由器ID\",\"策略控制：\",\"BGP允许网络管理员基于策略控制路由选择和路由传播。管理员可以设置各种策略，例如路由过滤、路由聚合和路由优先级，以满足特定的网络需求。\",\"类型：\",\"iBGP（内部BGP）：在同一AS内的路由器之间运行，用于传播内部路由信息。\",\"eBGP（外部BGP）：在不同AS之间的路由器之间运行，用于交换外部路由信息。\"]},\"239\":{\"h\":\"BGP 的工作过程\",\"t\":[\"建立BGP会话：\",\"两个BGP路由器（称为BGP对等体或邻居）首先建立TCP连接，然后交换BGP OPEN消息以建立BGP会话。\",\"交换路由信息：\",\"一旦会话建立，BGP对等体之间就开始交换完整的BGP路由表。之后，路由器仅在路由信息发生变化时交换更新。\",\"路由传播：\",\"BGP路由器根据接收到的路由信息更新其路由表，并根据策略决定是否将这些路由信息传播给其他对等体。\",\"路由更新和撤销：\",\"当网络拓扑发生变化时，BGP路由器会发送路由更新（UPDATE）或撤销（WITHDRAW）消息，以通知其他对等体。\"]},\"240\":{\"h\":\"BGP 的优势和挑战\"},\"241\":{\"h\":\"优势：\",\"t\":[\"可扩展性：BGP能够处理大量的路由信息，非常适合大规模的网络环境。\",\"灵活性：BGP允许管理员根据特定需求配置路由策略。\",\"稳定性：BGP设计用于在大型、复杂的网络环境中保持稳定和高效。\"]},\"242\":{\"h\":\"挑战：\",\"t\":[\"复杂性：BGP配置和管理相对复杂，需要深入的网络知识。\",\"收敛时间：BGP在处理大型网络拓扑变化时的收敛时间较长。\",\"安全性：BGP缺乏内置的安全机制，需要额外的配置和措施来防止路由劫持和攻击。\"]},\"243\":{\"h\":\"总结\",\"t\":[\"BGP是互联网的关键路由协议，负责在不同AS之间交换路由信息。它的路径向量机制、策略控制能力和高可扩展性使其成为管理互联网复杂路由需求的理想选择。然而，BGP的配置和管理也相对复杂，需要专业知识和经验。\"]},\"244\":{\"h\":\"、 、 、 和 是网络管理中常用的命令。它们各自有不同的功能，但一起使用时可以全面管理和配置网络接口、路由和防火墙规则。以下是这些命令的功能及其关系的详细介绍：\"},\"245\":{\"h\":\"\"},\"246\":{\"h\":\"功能：\",\"t\":[\"ifconfig 是一个传统的工具，用于配置网络接口。它可以查看和修改接口配置，包括 IP 地址、子网掩码、广播地址等。\"]},\"247\":{\"h\":\"用法：\",\"t\":[\"查看网络接口信息：\",\"ifconfig\",\"启用或禁用接口：\",\"sudo ifconfig eth0 up sudo ifconfig eth0 down\",\"配置 IP 地址：\",\"sudo ifconfig eth0 192.168.1.100 netmask 255.255.255.0\"]},\"248\":{\"h\":\"(也称 )\"},\"249\":{\"h\":\"功能：\",\"t\":[\"ip a 是 ip 命令套件的一部分，用于显示或修改网络接口的地址信息。相比 ifconfig，ip 提供了更丰富和更强大的功能。\"]},\"250\":{\"h\":\"用法：\",\"t\":[\"查看所有接口的地址信息：\",\"ip a\"]},\"251\":{\"h\":\"\"},\"252\":{\"h\":\"功能：\",\"t\":[\"ip link 是 ip 命令套件的一部分，用于显示和修改网络接口的属性。\"]},\"253\":{\"h\":\"用法：\",\"t\":[\"查看所有接口的链路状态：\",\"ip link show\",\"启用或禁用接口：\",\"sudo ip link set eth0 up sudo ip link set eth0 down\"]},\"254\":{\"h\":\"\"},\"255\":{\"h\":\"功能：\",\"t\":[\"ip route 用于显示和管理路由表。它可以添加、删除和查看路由规则。\"]},\"256\":{\"h\":\"用法：\",\"t\":[\"查看当前的路由表：\",\"ip route show\",\"添加路由：\",\"sudo ip route add 192.168.2.0/24 via 192.168.1.1 dev eth0\",\"删除路由：\",\"sudo ip route del 192.168.2.0/24\"]},\"257\":{\"h\":\"\"},\"258\":{\"h\":\"功能：\",\"t\":[\"iptables 是一个用户空间实用程序，用于配置 Linux 内核防火墙实现（在 netfilter 框架下）。它用于管理入站、出站和转发的数据包过滤规则。\"]},\"259\":{\"h\":\"用法：\",\"t\":[\"查看所有规则：\",\"sudo iptables -L -v -n\",\"添加规则：\",\"sudo iptables -A INPUT -p tcp --dport 22 -j ACCEPT\",\"删除规则：\",\"sudo iptables -D INPUT -p tcp --dport 22 -j ACCEPT\"]},\"260\":{\"h\":\"关系\",\"t\":[\"这些命令一起使用可以全面管理和配置网络：\",\"接口配置：使用 ifconfig、ip a 和 ip link 可以查看和配置网络接口的状态和地址。\",\"路由管理：使用 ip route 可以添加、删除和查看路由规则，决定数据包如何在网络中转发。\",\"防火墙规则：使用 iptables 可以设置防火墙规则，控制数据包的流入、流出和转发。\",\"ifconfig 是一个较老的工具，功能相对有限，但在某些系统上仍然可用。ip 命令套件（包括 ip a、ip link 和 ip route）是现代的、功能更强大的替代品。iptables 提供了强大的防火墙配置能力，可以与 ip 命令一起使用，实现全面的网络管理。\"]},\"261\":{\"h\":\"七层网络模型\",\"t\":[\"七层网络模型，也称为OSI（开放系统互连）模型，是由国际标准化组织（ISO）制定的一种网络通信标准框架。它将网络通信过程划分为七个层次，每个层次都有其特定的功能和协议。以下是七层网络模型的详细介绍：\"]},\"262\":{\"h\":\"1. 物理层（Physical Layer）\",\"t\":[\"功能：负责在物理介质上传输比特流，包括定义硬件设备的电气、机械、过程和功能特性。\",\"协议和设备：电缆、网卡、集线器（Hub）、传输介质（如双绞线、光纤）等。\"]},\"263\":{\"h\":\"2. 数据链路层（Data Link Layer）\",\"t\":[\"功能：提供节点之间的可靠数据传输，负责帧的创建、传输、错误检测和纠正。\",\"协议和设备：以太网（Ethernet）、Wi-Fi（802.11）、交换机（Switch）、网桥（Bridge）等。\"]},\"264\":{\"h\":\"3. 网络层（Network Layer）\",\"t\":[\"功能：负责逻辑地址的管理和数据包的路由选择，确保数据包从源节点到达目标节点。\",\"协议和设备：IP（互联网协议）、ICMP（Internet Control Message Protocol）、路由器（Router）等。\"]},\"265\":{\"h\":\"4. 传输层（Transport Layer）\",\"t\":[\"功能：提供端到端的通信服务，确保数据在主机之间可靠、有序地传输。主要负责流量控制、数据分段和重组、错误检测和恢复。\",\"协议和设备：TCP（传输控制协议）、UDP（用户数据报协议）。\"]},\"266\":{\"h\":\"5. 会话层（Session Layer）\",\"t\":[\"功能：管理应用程序之间的会话，负责建立、管理和终止会话。它还提供同步和对话控制。\",\"协议和设备：NetBIOS、RPC（远程过程调用）。\"]},\"267\":{\"h\":\"6. 表示层（Presentation Layer）\",\"t\":[\"功能：负责数据格式的转换和表示，包括数据加密、解密、压缩和解压缩。确保不同系统间的数据格式一致。\",\"协议和设备：SSL/TLS（安全套接层/传输层安全）、JPEG、MPEG、GIF。\"]},\"268\":{\"h\":\"7. 应用层（Application Layer）\",\"t\":[\"功能：提供网络服务和应用程序接口，是用户与网络交互的界面。负责识别通信伙伴、资源分配和同步通信。\",\"协议和设备：HTTP（超文本传输协议）、FTP（文件传输协议）、SMTP（简单邮件传输协议）、DNS（域名系统）等。\"]},\"269\":{\"h\":\"各层之间的关系\",\"t\":[\"层次依赖：每一层依赖于下一层提供的服务。例如，传输层依赖于网络层提供的路由和地址服务。\",\"封装和解封装：当数据从发送端传输到接收端时，每一层会添加或移除相应的协议头。这种过程称为封装和解封装。\"]},\"270\":{\"h\":\"应用示例\",\"t\":[\"网页浏览：用户在浏览器中输入网址，应用层的HTTP协议将请求传递到传输层的TCP协议，TCP将数据包分段并传递到网络层的IP协议，IP协议进行路由选择，将数据包通过数据链路层和物理层传输到目标服务器。服务器接收到数据后，逆向处理，最终将网页内容展示给用户。\"]},\"271\":{\"h\":\"总结\",\"t\":[\"OSI模型通过将网络通信过程划分为七个独立的层次，使得网络设计和实现更加模块化和清晰。这种分层模型有助于不同网络设备和协议的互操作性和标准化，从而促进了网络技术的发展和普及。\"]},\"272\":{\"c\":[\"网络\"]},\"273\":{\"c\":[\"http\"]},\"274\":{\"h\":\"独立开发者一点思考\",\"t\":[\"杂谈之独立开发者一点思考\",\"https://indiehacker.one/\",\"全文总结 本文主要介绍了独立开发者的相关内容，包括什么是独立开发者、为什么要做独立开发者、有哪些牛逼的独立开发者、独立开发者面临的困境、独立开发的一些基本流程、想法、如何判断想法的是不是可以赚钱、三大核心问题、如何解决用户的问题、使用什么样的编程语言、采用什么样的产品形态、一个 MVP 产品最少需要做多少工作、一周开发一个新产品、三点金规铁律、发布、别人说你的产品是垃圾，伪需求怎么办、增长、心态、如何保持积极的心态、如何面对压力等。\",\"重要亮点\",\"什么是独立开发者：指的是一类独立的、自主运营并开发自己的在线业务以获得收入的人。\",\"为什么要做独立开发者：成为一名独立开发者可以提供很多传统工作所无法提供的优点，包括人身自由、财务自由、成长与学习、实现自己的想法等。\",\"有哪些牛逼的独立开发者：levelsio 和 Baye aka 威力狈是公认的独立开发者中的牛逼人物。\",\"独立开发者面临的困境：包括美工问题、营销问题、生活压力、保持动力等。\",\"独立开发的一些基本流程：包括想法、开发、发布等环节。\",\"想法：想法是一个产品的起始点，需要大致正确即可，在实践的过程中，想法可能会发生改变，产品方向也会发生改变。\",\"如何判断想法的是不是可以赚钱：做好一个 DEMO 页面，罗列你的想法和产品特点，中间加个具有号召性的按钮。然后把这个页面推广出去。最后做数据分析。根据分析结果，你很快就会知道你的想法是不是可以赚到钱。\",\"三大核心问题：包括产品有什么核心功能和特点、产品的目标客户是谁、目标客户会经常出现在那里。\",\"如何解决用户的问题：用户并不知道自己需要什么，直到我们拿出自己的产品，他们就会发现，这就是我想要的。\",\"使用什么样的编程语言：你会哪个就用哪个，熟悉哪个就用哪个。\",\"采用什么样的产品形态：需要考虑产品适合使用哪种产品形态、目标客户更愿意使用哪种产品、目前有能力提供哪种产品形态。\",\"一个 MVP 产品最少需要做多少工作：答案是 9 个页面和 9 个接口。\",\"一周开发一个新产品：对于一个中等水平的技术人员来说，一周的时间足够开发一个新产品。\",\"三点金规铁律：包括不要熬夜做产品、不做免费的产品、不做完美的产品。\",\"发布：当你的产品完成了最小 MVP 的时候，就可以发布了。\",\"别人说你的产品是垃圾，伪需求怎么办：需要重申审视是不是你的产品功能和特性不够，他是不是你的目标客户。\",\"如何保持积极的心态：积极是暂时的，不积极才是常态，关键是不要消极。\",\"如何面对压力：独立开发和创业一样有风险，需要有心理准备，最好有以下几方面准备：将独立开发当作\",\"全文总结 本文主要介绍了独立开发者的相关内容，包括什么是独立开发者、为什么要做独立开发者、有哪些牛逼的独立开发者、独立开发者面临的困境、独立开发的一些基本流程、想法、如何判断想法的是不是可以赚钱、三大核心问题、如何解决用户的问题、使用什么样的编程语言、采用什么样的产品形态、一个 MVP 产品最少需要做多少工作、一周开发一个新产品、三点金规铁律、发布、别人说你的产品是垃圾，伪需求怎么办、增长、心态、如何保持积极的心态、如何面对压力等。\",\"重要亮点\",\"什么是独立开发者：指的是一类独立的、自主运营并开发自己的在线业务以获得收入的人。\",\"为什么要做独立开发者：成为一名独立开发者可以提供很多传统工作所无法提供的优点，包括人身自由、财务自由、成长与学习、实现自己的想法等。\",\"有哪些牛逼的独立开发者：levelsio 和 Baye aka 威力狈是公认的独立开发者中的牛逼人物。\",\"独立开发者面临的困境：包括美工问题、营销问题、生活压力、保持动力等。\",\"独立开发的一些基本流程：包括想法、开发、发布等环节。\",\"想法：想法是一个产品的起始点，需要大致正确即可，在实践的过程中，想法可能会发生改变，产品方向也会发生改变。\",\"如何判断想法的是不是可以赚钱：做好一个 DEMO 页面，罗列你的想法和产品特点，中间加个具有号召性的按钮。然后把这个页面推广出去。最后做数据分析。根据分析结果，你很快就会知道你的想法是不是可以赚到钱。\",\"三大核心问题：包括产品有什么核心功能和特点、产品的目标客户是谁、目标客户会经常出现在那里。\",\"如何解决用户的问题：用户并不知道自己需要什么，直到我们拿出自己的产品，他们就会发现，这就是我想要的。\",\"使用什么样的编程语言：你会哪个就用哪个，熟悉哪个就用哪个。\",\"采用什么样的产品形态：需要考虑产品适合使用哪种产品形态、目标客户更愿意使用哪种产品、目前有能力提供哪种产品形态。\",\"一个 MVP 产品最少需要做多少工作：答案是 9 个页面和 9 个接口。\",\"一周开发一个新产品：对于一个中等水平的技术人员来说，一周的时间足够开发一个新产品。\",\"三点金规铁律：包括不要熬夜做产品、不做免费的产品、不做完美的产品。\",\"发布：当你的产品完成了最小 MVP 的时候，就可以发布了。\",\"别人说你的产品是垃圾，伪需求怎么办：需要重申审视是不是你的产品功能和特性不够，他是不是你的目标客户。\",\"如何保持积极的心态：积极是暂时的，不积极才是常态，关键是不要消极。\",\"如何面对压力：独立开发和创业一样有风险，需要有心理准备，最好有以下几方面准备：将独立开发当作\"]},\"275\":{\"c\":[\"杂谈\"]},\"276\":{\"c\":[\"独立开发者\"]},\"277\":{\"h\":\"MPress 通过存储保存算子间并行性在多GPU服务器上实现十亿规模级模型训练的民主化\",\"t\":[\"MPress: Democratizing Billion-Scale Model Training on Multi-GPU Servers via Memory-Saving Inter-Operator Parallelism\",\"地址：https://par.nsf.gov/servlets/purl/10410479\",\"这篇论文的题目是《MPress: Democratizing Billion-Scale Model Training on Multi-GPU Servers via Memory-Saving Inter-Operator Parallelism》（MPress：通过节省内存的操作间并行化民主化十亿规模模型训练）。论文来自中国科学技术大学、安徵省高性能计算实验室和美国休斯顿大学。\"]},\"278\":{\"h\":\"问题背景：\",\"t\":[\"深度神经网络（DNN）模型的规模不断扩大，参数数量已经从百万级增长到数十亿级。这导致了GPU内存的极大需求，单一GPU无法满足如此大规模模型的训练需求。现有的一些内存节省技术如GPU-CPU交换、重计算等虽然可以减少部分内存消耗，但会带来额外的计算或通信开销。\"]},\"279\":{\"h\":\"论文创新点：\",\"t\":[\"MPress提出了一种新的单服务器多GPU系统，旨在突破十亿规模模型训练中的GPU内存壁垒，同时最小化额外的成本。它结合了多种内存优化技术，包括：\",\"操作间并行性，减少GPU间的通信开销。\",\"新的D2D交换技术，利用多条高速NVLink链路将张量交换至轻载GPU，以充分利用闲置的GPU内存。\",\"综合了重新计算、GPU-CPU交换和D2D交换的优势，通过智能调度优化性能和内存使用。\"]},\"280\":{\"h\":\"实验方法：\",\"t\":[\"MPress被集成到现有的两种操作间并行训练系统中（PipeDream和DAPPLE）。实验使用了BERT和GPT两种模型，分别在现代GPU服务器（如DGX-1和DGX-2）上进行训练。实验结果表明，MPress在相同内存优化下训练速度大幅提升，并且能够训练比基线更大的模型。\"]},\"281\":{\"h\":\"结论：\",\"t\":[\"MPress显著提升了多GPU服务器上十亿规模DNN模型的训练效率，能够在不牺牲性能的前提下，突破GPU内存瓶颈。\"]},\"282\":{\"h\":\"II. 背景与动机\",\"t\":[\"由于深度神经网络（DNN）计算资源的高需求，将模型训练任务并行化到多个GPU设备上已经成为常态。主要有三种并行训练方法，每种方法对应不同的分区策略，分别是通过输入样本分区（数据并行）、通过网络结构分区（模型并行）和通过层级分区（流水线并行）。为了便于理解模型并行和流水线并行的区别，本文参考了最近的Alpa工作，将现有解决方案分类为两种正交方向：即操作内并行和操作间并行。\",\"操作内并行依赖于一个操作符在具有多个维度的张量上工作，将张量沿某些维度进行分区，并将结果分配给多个设备。数据并行作为最简单的操作内并行，将输入张量进行分片，并将数据片段分配给GPU设备来训练共享的复制模型。与此不同，操作间并行训练将目标DNN模型划分为不相交的阶段，每个阶段对应一组连续的模型层，并映射到单独的GPU上进行计算。微批次训练数据通过这些阶段以流水线的方式进行处理。\",\"不幸的是，所有这些并行策略在支持十亿规模的单服务器训练时都会遇到GPU内存瓶颈。我们选择操作间并行作为研究的出发点，原因如下：\",\"首先，与其他两种方法相比，数据并行训练带来了最重的内存负担和跨GPU通信开销，因为每个GPU都会复制相同数量的模型数据，并定期交换与模型参数等大小的梯度。因此，单靠数据并行难以满足快速增长的模型规模所带来的巨大内存需求。操作内并行则通过将操作符拆分成更小的部分来工作，但它需要大量通信来收集和汇总部分结果，以触发后续的计算，而这些通信位于训练的关键路径上。\",\"相比之下，操作间并行训练引入的通信开销最少，因为对于大规模的自然语言处理模型，只有激活值在阶段之间传输，而且这些激活值通常很小。例如，对于Bert-0.64B模型，两个主机连续阶段的GPU之间仅交换每个微批次1.5MB的数据。此外，操作间并行已受到工业界和学术界的广泛关注，许多训练系统，如PipeDream、DAPPLE、GPipe、DeepSpeed和Megatron-LM，已经集成了该技术。因此，我们专注于通过操作间并行实现十亿规模模型的高效训练。\"]},\"283\":{\"h\":\"操作间并行\",\"t\":[\"图1展示了操作间并行DNN训练的工作流程。每个GPU设备（即“工人”）负责训练一个不相交的连续模型层集。每个训练数据的微批次被进一步分为多个子批次，进入整个执行流水线。工人1从第一微批次开始前向传播，并将计算传递给工人2，以启动第二阶段。同时，工人1处理第二个微批次。工人3则处理第三阶段的子批次。当工人3完成第一个微批次的前向传播计算后，立即开始相应的反向传播，并从工人3回流至工人1。\",\"在相邻的微批次之间有两种调度执行方式，即异步和同步模式。PipeDream中使用的异步模式允许第二个微批次的前向传播与第一个微批次的反向传播并行进行。例如，第二个微批次中的第七个子批次在第四个子批次的反向传播完成后立即由工人1执行。与此相反，GPipe和DAPPLE中使用的同步模式则要求不同微批次的计算是串行的。\"]},\"284\":{\"h\":\"GPU内存消耗的问题\",\"t\":[\"为了探索操作间并行训练中GPU内存的利用情况，我们使用PipeDream和DAPPLE两个代表性系统训练了两个流行的DNN模型Bert和GPT。在一台AWS EC2 p3dn.24xlarge GPU服务器上进行实验，该服务器配备了8个V100 GPU（每个GPU具有32GB内存），并设置了最大可持续的模型规模。\",\"对于PipeDream，设置微批次大小为12时，它能够支持训练参数最多为6亿的Bert模型，再往上则会出现GPU内存不足的错误。当微批次大小缩小到2时，PipeDream可以支持2亿参数的Bert模型。在相同的硬件配置下，DAPPLE能够训练最多具有53亿参数的GPT模型，微批次大小同样为2。PipeDream和DAPPLE之间可支持模型规模的差异在于，PipeDream使用异步调度，需要保存多版本的模型数据。\"]},\"285\":{\"h\":\"内存优化及其局限性\",\"t\":[\"内存平衡的分区策略能够解决GPU内存不平衡的问题。然而我们发现，采用这种分区策略付出的代价是计算时间不均衡，导致训练性能下降34%。重计算技术可以通过丢弃前向传播生成的激活值并在需要时重新计算，节省内存，并已被许多主流系统采用。然而，单靠重计算有两个主要缺点：一是它无法减少优化器状态、参数和梯度的内存消耗，而这些数据占用了大量GPU内存；二是重新执行前向传播会与反向传播竞争GPU资源，并引入额外的延迟，可能导致训练时间延长33%。\",\"GPU-CPU交换利用了CPU内存的大容量来扩展GPU内存空间，然而，由于PCIe带宽有限，GPU-CPU交换会大幅降低训练吞吐量。例如，在PipeDream中对39%的BERT数据应用GPU-CPU交换后，训练吞吐量降低了67%。ZeRO系列通过在数据并行训练中消除数据冗余来减少GPU内存消耗，但也引入了不可忽视的跨GPU通信开销。\"]},\"286\":{\"h\":\"硬件趋势与机遇\",\"t\":[\"随着硬件的快速发展，现代GPU服务器已经集成了超高速的GPU间互连。2016年，NVIDIA的P100 GPU引入了第一代NVLink，提供高达160GB/s的双向数据传输带宽，是PCIe Gen3x16带宽的近5倍。\",\"我们提出了一种新的GPU D2D交换技术，通过NVLink将张量从高内存压力的GPU卸载到有空闲内存的GPU，从而缓解GPU内存的限制。\"]},\"287\":{\"h\":\"III. MPress 内部原理\"},\"288\":{\"h\":\"A. 设计原则\",\"t\":[\"我们提出了MPress，这是一个高效的操作间并行深度神经网络（DNN）训练系统，使用异构内存优化技术来应对著名的GPU内存墙问题。MPress采用了一种新的设备间（D2D）交换技术，利用多个高带宽的NVLink互连将模型数据从内存压力较大的GPU卸载到轻负载的GPU。由于GPU资源有限，我们只对少量生命周期较短的模型数据应用D2D交换，这些数据的生命周期过短，无法承受重新计算或GPU-CPU交换的延迟。\",\"D2D交换的快速速度对于避免重新计算和GPU-CPU交换所带来的高额性能损失至关重要，并且允许D2D交换更好地与DNN计算重叠。通过精心映射流水线阶段到GPU设备，我们可以积极满足每个GPU的内存交换带宽需求。为了克服GPU总体交换空间有限的局限，MPress还采用了重新计算和GPU-CPU交换技术来进一步减少GPU内存消耗。\"]},\"289\":{\"h\":\"B. MPress的总体概述及工作流程\",\"t\":[\"图5展示了MPress系统架构的高级视图，MPress的逻辑横跨静态和运行时部分。静态部分的任务是生成内存节省计划，该计划确定在内存压力下应用内存优化的张量候选、应用哪种优化以及何时执行相应的优化或恢复被节省的张量。\",\"在MPress的静态部分，首先通过训练目标DNN模型，获取基础的张量大小、正向和反向计算的延迟等基本统计数据。表III展示了收集的统计数据示例。然后，规划器根据成本模型探索可能的配置，该模型比较不同优化方法的时间成本，以选择对性能影响最小的优化方法。\",\"随后，生成的初步计划将被传递给重写器，重写器进一步修改输入的数据流图，将这些优化策略嵌入到合适的位置，以符合操作的依赖关系。我们使用模拟器根据修改后的数据流图执行一次训练迭代，并收集GPU内存节省量及引入的开销。最终，反馈信息将从模拟器传递给规划器，以确定当前的配置是否接近最佳配置，并与之前的运行结果进行比较。\",\"需要注意的是，MPress静态部分是离线运行的，因此不会带来运行时开销。与实际训练可能需要运行数百万次迭代以实现模型收敛不同，模拟器只需要执行有限的几次训练步骤。\",\"MPress运行时部分与操作间并行训练框架的运行时部分共同工作，主要包括执行器、内存管理器和压缩库三个关键系统组件。首先，压缩库提供三种内存优化技术的高效实现，其中包括我们提出的D2D交换。同时，运行时流程如下：执行器接收来自MPress静态部分的仪器化数据流图，并触发启用了内存压缩的操作间并行训练。普通操作将直接通过底层训练框架运行时处理，而内存优化操作则由执行器执行，以释放已使用的GPU内存，并根据需要恢复状态。\"]},\"290\":{\"h\":\"C. D2D交换\",\"t\":[\"在设计D2D交换技术时，我们必须综合考虑以下两个关键因素：1）不同GPU之间的带宽和连接链路数量可能存在硬件异构性；2）内存交换需求与目标操作间并行训练任务中空闲GPU内存资源的多样性。\",\"为此，我们引入了以下两项关键技术来优化D2D交换。\",\"数据分条：每个GPU设备可以将张量交换到多个NVLink可达的轻负载GPU，因此我们引入了数据分条技术，将目标张量划分为若干子块，并通过不同链路并行传输。在对称NVLink拓扑结构中，GPU间完全通过同质的链路连接，我们将子块划分为等大小，并让其总数量与目标接收GPU的数量一致。\",\"在不对称的拓扑结构中（如DGX-1架构），GPU对之间的带宽可能会有所不同。为了反映这种差异，我们进一步演进了数据分条技术，结合NVLink链路带宽对子块大小进行加权，大小与链路带宽成正比。\",\"此外，我们还管理了一个元数据表，用于跟踪经过D2D交换的张量状态。对于每个张量，我们在执行交换操作之前记录子块数量、每个子块的大小和目标GPU设备的索引。\",\"设备映射：我们设计了一种设备-阶段映射算法，能够将轻负载的GPU分配到高内存压力的GPU附近，以最大化这些GPU的交换带宽。这个算法首先枚举所有可能的设备映射方案，并为每个映射方案确定合适的内存分配策略，最终选择时间成本最小的映射方案。\"]},\"291\":{\"h\":\"D. 内存压缩规划\",\"t\":[\"探索将D2D交换、GPU-CPU交换和重计算结合起来的最佳配置，以最大化GPU内存节省的同时最小化训练过程中引入的额外延迟是一个非常具有挑战性的问题。为了解决这一问题，我们提出了一个近似搜索算法，并基于以下几个关键观察来进行简化。\",\"与重计算相比，两种交换方法的优势在于它们不消耗GPU的计算资源，并且能够与GPU上的前向和后向计算并行运行。当被适当地应用时，也就是当目标张量的生命周期（即从生成到再次使用之间的时间）长于这两种交换方法的时间成本时，就不会引入额外的时间延迟。\",\"我们应该优先考虑对模型的后期层使用重计算来缓解内存限制，原因有两个：首先，反向传播首先从流水线执行的后半部分的后期层开始；其次，不可避免的额外重计算延迟会扩大早期层的生命周期，从而为应用GPU-CPU交换腾出更多空间。\",\"选择对连续层的张量应用重计算是一个不错的选择，这可以进一步减少除了第一层操作符的输入之外的内存消耗，因为第一层操作符的输出是前一层的输入。\",\"由于GPU的空闲内存资源有限，且D2D交换比GPU-CPU交换要快得多，为了发挥其全部潜力，我们应该只将D2D交换应用于性能至关重要的情况，以最大限度地减少GPU-CPU交换和重计算带来的额外延迟。\",\"基于以上观察和权衡，我们引入了一个近似的搜索算法，首先积极地为适当的张量分配GPU-CPU交换和重计算优化，然后通过逐步将部分GPU-CPU交换和重计算替换为D2D交换来优化配置。具体而言，我们首先执行生命周期变量分析来计算每个张量的生命周期。接着我们构建了初步配置，将GPU-CPU交换分配给生命周期特别长的张量，同时将重计算分配给激活张量，前提是重计算引入的额外延迟小于GPU-CPU交换的成本。最后，我们将GPU-CPU交换分配给剩余的张量，以满足目标内存节省需求。\",\"我们的算法会经历一些迭代步骤来逐步更新内存减少优化配置。在每个步骤中，我们使用模拟器运行最新的配置（仅需要执行一次训练迭代）来过滤出一组减少的张量，这些张量的优化引入了最大的额外开销。对于这些张量，我们尽量使用D2D交换来减少它们的内存占用，前提是存在空闲的GPU内存。如果新的配置比之前的配置性能更好，我们就接受它。该算法会在后续配置相较于前一个配置的性能提升不明显时终止。\"]},\"292\":{\"h\":\"E. 实现细节\"},\"293\":{\"h\":\"E. 实现细节\",\"t\":[\"我们将上述设计原则集成到开源训练系统MPress中，该系统由2000行C++和Python代码组成。为了展示其在操作间并行训练中优化GPU内存使用的通用性，我们将MPress集成到了PipeDream和DAPPLE这两个最近的操作间并行训练系统中。其后端引擎是PyTorch。我们通过将PipeDream的原始PyTorch版本从1.1升级到1.2，并启用其NCCL库以使用NVLink在阶段之间传输数据，改进了PipeDream系统。需要注意的是，MPress是通用的，可以应用于其他操作间并行训练系统，如GPipe。我们将继续使MPress适用于这些系统。\",\"内存管理：我们的内存管理器负责为张量分配和释放GPU/CPU内存空间，并监控每个设备的内存使用情况。首先，针对GPU内存分配，管理器直接使用PyTorch中的原生GPU内存分配器。其次，在主机内存请求方面，考虑到固定内存（pinned memory）与GPU内存之间的数据传输速度快于普通可分页内存（pageable memory），我们决定使用固定内存作为交换空间。为了避免频繁分配和释放固定内存的高成本，我们进一步构建了一个独立于PyTorch运行时的主机固定内存池。\",\"内存交换：对于D2D交换，执行器为执行交换操作的swap-in和swap-out任务分别管理两个额外的线程，这些线程使用系统启动时通过调用cudaStreamCreate创建的不同CUDA流（streams）。这种设计允许执行器在不阻塞主线程的情况下，启动张量传输任务并与DNN计算同步检查其状态。因此，GPU之间的数据移动可以与DNN计算异步进行。\"]},\"294\":{\"h\":\"IV. 评估\",\"t\":[\"我们的评估旨在回答以下几个问题：\",\"MPress是否能有效缓解GPU内存限制，支持操作间并行训练中的大规模模型训练，同时比基线方法提供更好的训练性能？\",\"独立的D2D交换、设备映射和内存压缩策略的性能影响是什么？\",\"这三种内存优化技术对GPU内存节省的贡献各自是多少？\"]},\"295\":{\"h\":\"A. 实验设置\",\"t\":[\"机器配置：我们在DGX-1和DGX-2 GPU服务器上进行实验以评估MPress和基线方法。DGX-1服务器是AWS EC2 p3dn.24xlarge实例，配备96个虚拟CPU、8个NVIDIA Tesla V100 GPU（每个GPU的内存为32GB，连接方式为不对称的NVLink），以及768GB的CPU内存。我们还使用了另一台提供商的DGX-2服务器，因为AWS EC2上这种高端GPU服务器的配额非常有限，我们的配额申请多次失败。这台DGX-2服务器有164个虚拟CPU，8个NVIDIA Tesla A100 GPU（每个GPU的内存为40GB，连接方式为对称的NVLink），以及948GB的CPU内存和6TB的NVMe SSD。两台机器都运行了Ubuntu 18.04、CUDA 11.7、NCCL 2.8.4、PyTorch 1.2.0等软件。\",\"模型和数据集：我们选择了两个广泛使用的DNN模型BERT和GPT，它们都来自自然语言处理领域。我们使用SQuAD v1.1数据集训练BERT，使用维基百科数据集训练GPT。\",\"我们在PipeDream上运行MPress，训练了不同规模的BERT模型。根据文献，我们通过调整编码器层的数量和隐藏层的大小，使BERT模型变得更深、更宽。表II展示了我们使用的BERT变体的参数规模。BERT-0.35B表示最小的BERT模型，其总GPU内存需求为108.8GB，每个阶段最大内存需求为24.77GB。显然，这一GPU内存需求可以通过我们测试的GPU服务器在没有内存优化的情况下满足。BERT-0.64B是一个中等规模的模型，其最大和最小阶段内存需求分别高于和低于每个GPU的内存容量。此外，BERT模型的参数数量分别为1.67B和4B，表示内存需求超过每个GPU容量的大模型。最后，BERT-6.2B是一个超大模型，其总内存需求是服务器GPU内存供应量的5倍。我们将微批次大小设置为12，这是文献中推荐的大小。\",\"同样，我们使用调整后的参数对GPT及其变体进行训练，并在DAPPLE上运行MPress。如表II所示，GPT-5.3B是最小的模型，原生的DAPPLE可以训练该模型。然而，其他四个GPT配置的每阶段最大GPU内存需求为56.4-140.1GB，已超过单个GPU的容量。我们将微批次大小设置为2，这是DAPPLE文献中推荐的最小批次大小。\",\"基线和系统配置：对于基于PipeDream的操作间并行训练，我们使用原始的PipeDream作为没有内存优化的基线操作间并行训练系统。我们还部署了两种系统作为基线，分别是启用GPU-CPU交换的系统和启用重计算的系统，通过启用PipeDream中的内存交换和重计算优化实现内存压缩。此外，我们运行了两种MPress变体，其中一种仅使用D2D交换，另一种结合了三种内存优化技术。\",\"对于基于DAPPLE的MPress，我们将原始DAPPLE作为自然基线，并启用了高性能重计算的DAPPLE+Recomp。此外，我们还运行了两个最先进的训练系统，ZeRO-Offload和ZeRO-Infinity，它们可以通过数据并行进行大规模模型训练。\",\"我们使用BERT和GPT模型推荐的计算平衡阶段分区策略。此外，重计算基线系统按照文献的建议丢弃特定的张量。最后，MPress变体采用我们之前算法生成的设备映射和内存节省计划。\",\"评估指标：我们测量了每秒处理的样本总数、每秒浮点运算次数（FLOPS）、D2D交换、GPU-CPU交换和重计算的时间成本，以及三种方法各自的内存减少情况。类似于其他现有的FLOPS计算工具或方法，我们通过测量模型前向传播的FLOPS，并估算相应的反向传播的FLOPS为前向传播的两倍。\"]},\"296\":{\"h\":\"B. MPress在PipeDream上的性能\",\"t\":[\"图7对比了在五种不同系统配置下，使用不同规模的BERT变体进行操作间并行训练时的性能（用TFLOPS表示）。我们通过以下几个方面分析了结果：\",\"小规模模型：我们首先分析了参数规模为0.35B的最小BERT模型。五个系统都成功训练了该模型，且报告的性能数据相同。这是因为普通的操作间并行训练已经能够满足该模型的GPU内存需求，因此不需要触发任何内存压缩优化。\",\"中等规模模型：当模型从BERT-0.35B扩大到BERT-0.64B时，PipeDream出现了GPU内存不足的错误，而其他四个系统成功执行了训练任务。GPU-CPU交换的性能最差，因为PCIe带宽的限制导致交换操作非常慢，从而延迟了相应的DNN计算。重计算比GPU-CPU交换快了143.4%，因为重新计算丢弃激活值的前向传播引入的延迟通常远低于GPU-CPU交换。在这种情况下，两种MPress变体表现最好且性能相同。原因是D2D交换足够缓解内存限制，并且比重计算更快，因此MPress没有使用其他两种优化。\",\"大规模模型：当模型扩大到1.67B时，单独的D2D交换无法满足需求，因为在高内存压力下，空闲的GPU内存不足以容纳从负载较大的GPU卸载的张量。与GPU-CPU交换相比，重计算提高了125.4%的性能，但比MPress慢19.5%。此时，MPress结合了三种优化策略，GPU-CPU交换和重计算为D2D交换腾出了更多空间，提升了整体性能。\",\"有趣的是，重计算在BERT-4B及以上模型中失败了。这是预期中的结果，因为重计算只能减少前向传播生成的激活值的内存消耗，无法处理剩余的模型数据，如参数和梯度，这些数据占用了更多的内存资源。相比之下，GPU-CPU交换依然可行，因为它可以应用于所有类型的模型数据，只要有足够的主机内存空间。然而，通过优先使用更快的D2D交换和尽可能使用重计算，MPress相比GPU-CPU交换实现了1.8倍的训练性能提升。\",\"超大规模模型：最后，我们测试了参数规模为6.2B的BERT模型。在这种情况下，只有GPU-CPU交换和MPress能够成功执行训练任务，而其他系统因内存不足而失败。尽管GPU-CPU交换可以支持相同的超大模型，但MPress通过设备映射优化和三种优化策略的组合，训练性能提升了3.1倍。此外，与最先进的重计算系统相比，MPress支持的模型规模提高了2.7倍。\"]},\"297\":{\"h\":\"C. MPress在DAPPLE上的性能\",\"t\":[\"我们使用不同参数规模的GPT模型在DGX-1和DGX-2 GPU服务器上对MPress进行了测试。这里，我们将MPress与三个强大的基线系统进行了对比，这些系统应用了最先进的内存节省技术：\",\"DAPPLE+Recomp：启用了高性能重计算。\",\"ZeRO-Offload：将优化器状态从GPU卸载到CPU。\",\"ZeRO-Infinity：通过GPU-CPU交换并进一步扩展到NVMe设备。\",\"值得注意的是，ZeRO系列是DeepSpeed框架的一部分。我们在一台高端GPU服务器上运行测试，该服务器具有与前面实验相同的GPU配置，但拥有更大的CPU内存和额外的NVMe SSD存储空间。我们无法在上述Amazon EC2实例上进行这组实验，因为ZeRO-Infinity需要大量的CPU内存来进行初始化，并且需要额外的具有高I/O带宽的存储空间进行张量交换。\",\"图8a总结了在DGX-1 GPU服务器上的性能对比情况。DAPPLE无法支持超过5.3B参数规模的模型，因为其最大每GPU内存需求超过了32GB。与此不同，启用重计算的DAPPLE能够成功训练最多10.3B参数的模型，但其性能比MPress低19.2%。相比之下，ZeRO系列和MPress能够支持从5.3B到20.4B不等规模的所有训练任务。ZeRO-Infinity比ZeRO-Offload的GPU计算效率高出20.6%-23.8%，这是因为ZeRO-Offload将优化器状态卸载到CPU会在每个微批次中导致频繁的数据移动，而ZeRO-Infinity通过GPU-CPU交换取而代之。然而，MPress在模型规模上始终能够保持稳定的训练性能，这得益于D2D交换技术的使用，以及多种内存压缩优化技术的结合。此外，MPress比ZeRO-Infinity的性能提升了37.0%-40.8%。这意味着，仅靠GPU-CPU交换的方案可能可以支持非常大规模的模型训练，但需要牺牲训练速度。MPress通过进一步利用空闲的GPU内存资源，补充了它们的局限性。\",\"图8b展示了在DGX-2 GPU服务器上的类似趋势，性能提升幅度比DGX-1服务器翻了一倍多，原因是DGX-2上A100 GPU的计算密度高于DGX-1上的V100。此外，重计算能够支持模型规模达到15.4B，比在DGX-1上支持的规模更大，因为A100 GPU的内存为40GB，而V100的内存为32GB。与MPress相同，ZeRO系列可以支持参数规模最多达到25.5B的模型，但其训练性能分别比MPress降低了30.4%-44.8%和23.2%-70.0%。有趣的是，在大模型上，ZeRO-Infinity的表现不如ZeRO-Offload。这是因为我们租用的DGX-2服务器的SSD存储带宽显著低于DGX-1。然而，找到可公开访问的、具备可扩展GPU计算能力和存储容量的高端GPU服务器几乎不可能。需要注意的是，即使具有足够的SSD带宽，ZeRO-Infinity也不应显著优于ZeRO-Offload，这一点已被ZeRO-Infinity的原始论文和图8a中的结果验证。\",\"PipeDream和DAPPLE之间的结果差异：有趣的是，PipeDream和DAPPLE之间的模型规模和性能差距较大，这也影响了它们各自的MPress变体。模型规模的差异在前面已经解释过。至于性能差距，DAPPLE显著优于PipeDream，因为DAPPLE默认启用了FP16低精度训练功能。此外，DAPPLE比PipeDream晚了两年发布，并且吸收了来自深度学习社区的各种优化，例如更好的计算和通信重叠技术。\"]},\"298\":{\"h\":\"D. 敏感性分析\",\"t\":[\"为了更好地理解MPress相较于基线系统的优势，我们进行了敏感性分析，以探讨设备映射、独立的三种优化方法（即GPU-CPU交换、重计算、D2D交换）的开销比较，以及内存压缩计划的选择。\"]},\"299\":{\"h\":\"\",\"t\":[\"图9总结了通过逐步添加设备映射和数据分条优化后MPress的性能提升情况，数据是在前面的D2D交换默认设置基础上进行的。结果已被归一化为默认设置，其中阶段按DAPPLE的建议映射到设备，且D2D交换已启用但未进行数据分条。\",\"对于DGX-1服务器，设备映射优化提高了默认设置下的性能17.4%，而数据分条优化使性能进一步提高了33.3%。这是因为前者优化使交换操作能够通过可达的NVLink链路传输数据，而后者则进一步最大化了数据传输带宽。相比之下，在DGX-2服务器上，设备映射对性能没有影响，这在预期之中，因为对称的全互联NVLink连接使得每个GPU拥有相同数量的NVLink连接。然而，数据分条使MPress性能比默认设置提高了11.0%，这是由于数据分条技术利用了多条NVLink的聚合带宽，加速了模型数据的交换。\",\"我们还评估了运行设备映射算法的时间开销。首先，我们设计了一个极端案例，其复杂性远高于图7和图8中的所有实验，以此来测试我们的搜索算法。即使在单线程实现下，MPress也能在47秒内找到最优映射。此外，在我们的所有评估案例中，设备映射搜索仅需几秒钟即可完成。因此，我们得出结论：我们的搜索算法不会带来高额的开销。如果有必要，我们还可以将其优化为多线程版本。\"]},\"300\":{\"h\":\"\",\"t\":[\"表III报告了在BERT和GPT模型中，针对不同大小张量，三种内存优化方法的时间成本。显然，三种方法的性能差异显著，这在决定如何组合这些方法时起到了关键作用。\",\"首先，在BERT模型中，张量t1具有最长的生命周期，足以涵盖GPU-CPU交换和D2D交换的时间成本。因此，MPress会优先选择GPU-CPU交换，因为它的成本可以被隐藏起来，而D2D交换则可以用于其他对性能更关键的任务。对于张量t2，GPU-CPU交换和重计算都会带来额外开销，并会延迟操作间并行训练，因为前者的时间成本超过了t2的生命周期，而重计算引入了3毫秒的额外前向计算。因此，MPress会选择D2D交换，因为它的时间成本只有3毫秒，且能够被轻松隐藏。最后，对于t3，MPress会舍弃GPU-CPU交换，因为它过于缓慢，并优先选择重计算而不是D2D交换，尽管两者的额外开销相同（4毫秒），但重计算不会消耗有限的GPU空闲内存，这些内存或许能更好地用于其他张量。\",\"其次，GPT模型中的情况与BERT类似。对于张量t4，MPress会分配GPU-CPU交换，因为其生命周期较长。而对于t5，MPress优先选择D2D交换，因为它的性能比GPU-CPU交换快了7.6倍。最后，针对t6，MPress选择重计算，因为在三种方法中，重计算的额外开销最小。\"]},\"301\":{\"h\":\"\",\"t\":[\"表IV展示了MPress在高GPU内存压力下，为四个操作间并行训练任务（BERT-1.67B、BERT-6.2B、GPT-10.3B、GPT-20.4B）生成的最佳策略。我们还报告了每种优化方法对GPU内存减少的百分比贡献。在三种方法中，GPU-CPU交换对内存节省的贡献为0%-42.2%，而重计算的贡献最大，达到51.2%-90.6%。D2D交换的内存节省量为3.9%-23.4%，虽然通常少于重计算和GPU-CPU交换，但在避免GPU-CPU交换和重计算带来的额外开销或GPU资源争用方面起到了关键作用。\",\"对于BERT-1.67B，MPress没有使用GPU-CPU交换，因为其时间成本过高。相反，D2D交换节省了23.4%的GPU内存，并被用于将早期阶段的张量（阶段0-3）传输到后续阶段（阶段4-7）。重计算节省了阶段0-6的GPU内存，共减少了76.6%的内存。D2D交换和重计算的组合带来了最佳性能，D2D交换提升了19.5%的速度（见图7）。GPT-20.4B的表现则有所不同。首先，MPress选择对阶段0-7的242GB模型数据应用GPU-CPU交换，实现了42.2%的内存节省。其次，重计算减少了51.2%的GPU内存占用。最后，D2D交换节省了38GB的GPU内存，是这四个训练任务中D2D交换节省内存最多的一次。\"]},\"302\":{\"h\":\"V. 硬件见解\",\"t\":[\"尽管GPU的HBM（高带宽内存）提供了极高的带宽，但要满足未来不断增长的模型需求仍然是一个挑战，因为HBM成本昂贵（例如，最新的GPU只有80GB的HBM）。相比之下，CPU内存更便宜，扩展性更好。两者的价格和容量差异主要是由不同的制造工艺导致的。实际上，NVIDIA的Grace-Hopper架构已经为每个GPU支持专用的CPU侧内存，并通过高带宽（NVLink C2C）连接到GPU。因此，MPress展示了此类架构的潜在优势及其在低硬件成本下解决内存墙问题的示例应用。\",\"为了理解MPress在这种新架构下的优势，我们进行了简单的分析，预测了其理想的性能。我们发现，即使每个GPU拥有96GB（HBM）+ 512GB（Grace CPU内存）的设备内存，训练参数规模为175B的GPT-3模型依然会遇到OOM（内存不足）问题。然而，MPress可以解决这个问题。为了完全隐藏GPU-CPU交换的成本，我们预计每个GPU的PCIe带宽需要超过140GB/s，是Grace-Hopper目前64GB/s带宽的两倍多。因此，MPress中的D2D交换技术在这种情况下仍然有效，既可以节省重计算浪费的25%的资源，又可以避免通过超级芯片与PCIe连接的内存之间的交换所带来的13%的训练时间延长。此外，广泛采用新硬件技术需要时间。例如，AWS EC2上最新的GPU实例仍然使用DGX-2 A100，而且供应量非常有限。因此，MPress可以部分弥补当前硬件的局限性。\",\"最后，MPress为重新思考内存架构提供了帮助。考虑到张量的生命周期以及各种内存技术在成本、容量和带宽方面的权衡，扩展内存层次结构是有益的。最快的内存层存储的是计算立即需要的数据，而速度较慢的层存储生命周期较长的数据。每个内存层都可以有不同的访问带宽，以进一步降低成本。在这种情况下，MPress的规划算法可以扩展，以智能地将不同模型张量分配到合适的内存层。\"]},\"303\":{\"h\":\"VI. 相关工作\",\"t\":[\"我们将本文的相关工作分为以下几类进行讨论：模型并行化、流水线并行、内存优化、GPU-CPU交换和深度学习加速器。\",\"模型并行化：当模型规模超过单个设备的内存容量时，模型并行化将模型的不同部分分配给不同的设备进行计算。近年来，研究者们提出了多种形式的模型并行化。Megatron-LM、GShard等系统通过将每个层的矩阵乘法分块，在多个GPU之间分配模型参数，这种方式被称为张量并行。此外，PipeDream、GPipe和DAPPLE等系统采用了流水线并行，它将模型的不同层分配给不同的设备，以支持更大的模型。MPress与这些工作是互补的，它不仅能够利用现有的流水线并行，还通过进一步减少内存消耗来训练更大规模的模型。\",\"流水线并行：流水线并行是一种常见的训练大规模模型的技术，它通过将模型的层分成多个阶段，分别在不同的GPU上运行。GPipe首先引入了这种技术，随后PipeDream通过引入异步调度来改进GPipe的性能。DAPPLE进一步在流水线并行中添加了高效的调度和通信优化。与这些系统不同，MPress不局限于特定的调度策略，而是将D2D交换、GPU-CPU交换和重计算相结合，优化操作间并行的内存使用。\",\"内存优化：为了应对GPU内存的限制，研究者们提出了多种内存优化技术。重计算（recomputation）是最常见的技术，它通过丢弃中间激活值并在反向传播中重新计算它们，来节省内存。近年来，ZeRO系列通过分片优化器状态、梯度和参数，进一步减少了内存消耗。ZeRO-Offload和ZeRO-Infinity利用CPU内存和NVMe存储来扩展模型规模。然而，MPress通过D2D交换减少了GPU内存需求，并且只在必要时使用GPU-CPU交换，从而避免了过多的性能损失。\",\"GPU-CPU交换：一些研究工作探索了在GPU内存不足时，将张量交换到CPU内存的可能性。vDNN和SuperNeurons等系统在运行时根据内存使用情况，决定哪些张量需要交换到CPU。Tesseract进一步结合了流水线并行和GPU-CPU交换。然而，这些系统的性能往往受限于PCIe带宽，MPress通过优先使用NVLink进行D2D交换，避免了GPU-CPU交换的高延迟，进而提高了训练效率。\",\"深度学习加速器：近年来，Google TPU和Graphcore IPU等专用加速器的兴起，提供了替代传统GPU的硬件选择。它们通过自定义的内存架构和高效的并行计算，提升了训练大规模模型的效率。然而，这些硬件需要定制的软件支持，且不一定适用于现有的GPU计算框架。相比之下，MPress能够在现有的GPU硬件上运行，并且无需对硬件进行额外的修改或优化。\",\"总之，MPress与上述工作不同，它通过结合多种内存优化技术，提供了一种高效的解决方案，能够在现有的多GPU系统上训练超大规模的模型。\"]},\"304\":{\"h\":\"VII. 结论\",\"t\":[\"我们提出了MPress，这是一种新的单服务器多GPU系统，旨在通过节省内存的操作间并行化方法，解决十亿规模模型训练中的GPU内存壁垒问题。MPress结合了三种内存优化技术：重计算、GPU-CPU交换和我们新提出的D2D交换。通过综合运用这些技术，MPress能够高效地减少GPU内存消耗，同时保持较高的训练性能。\",\"我们通过在PipeDream和DAPPLE系统中集成MPress，评估了它在训练BERT和GPT等大规模DNN模型时的表现。实验结果表明，MPress显著提高了训练吞吐量，能够在同样的内存优化下，比现有的系统支持更大规模的模型训练。此外，MPress为未来高带宽异构计算环境中的大规模模型训练提供了设计思路。我们相信，MPress展示了在现有硬件约束下突破模型训练规模限制的潜力，为操作间并行训练和GPU内存优化提供了新的方向。\"]},\"305\":{\"c\":[\"MPress\"]},\"306\":{\"c\":[\"MPress\",\"GPU\"]},\"307\":{\"h\":\"\",\"t\":[\"404 Not Found\"]},\"308\":{\"h\":\"云原生\"},\"309\":{\"h\":\"介绍\"},\"310\":{\"h\":\"工具\"},\"311\":{\"h\":\"技术科普\"},\"312\":{\"h\":\"杂谈\"},\"313\":{\"h\":\"论文\"}},\"dirtCount\":0,\"index\":[[\"技术科普\",{\"0\":{\"311\":1}}],[\"技术栈\",{\"0\":{\"123\":1}}],[\"决定哪些张量需要交换到cpu\",{\"1\":{\"303\":1}}],[\"决定数据包如何在网络中转发\",{\"1\":{\"260\":1}}],[\"梯度和参数\",{\"1\":{\"303\":1}}],[\"梯度同步\",{\"1\":{\"147\":1}}],[\"研究者们提出了多种内存优化技术\",{\"1\":{\"303\":1}}],[\"研究者们提出了多种形式的模型并行化\",{\"1\":{\"303\":1}}],[\"近年来\",{\"1\":{\"303\":3}}],[\"容量和带宽方面的权衡\",{\"1\":{\"302\":1}}],[\"容器来执行超参数调优任务\",{\"1\":{\"101\":1}}],[\"容器化组件\",{\"0\":{\"88\":1}}],[\"容器\",{\"1\":{\"84\":1}}],[\"容器名\",{\"1\":{\"61\":1}}],[\"容器无法通过\",{\"1\":{\"42\":1}}],[\"容器需要通过\",{\"1\":{\"41\":1}}],[\"容器内的应用可以通过服务\",{\"1\":{\"41\":1}}],[\"容器的默认内存请求\",{\"1\":{\"20\":1}}],[\"容器的默认内存请求量\",{\"1\":{\"20\":1}}],[\"容器的默认\",{\"1\":{\"20\":2}}],[\"容器的最小内存使用量\",{\"1\":{\"20\":1}}],[\"容器的最小\",{\"1\":{\"20\":1}}],[\"容器的最大内存使用量\",{\"1\":{\"20\":1}}],[\"容器的最大\",{\"1\":{\"20\":1}}],[\"又可以避免通过超级芯片与pcie连接的内存之间的交换所带来的13\",{\"1\":{\"302\":1}}],[\"又从同一个网络接口回到容器内部\",{\"1\":{\"40\":1}}],[\"既可以节省重计算浪费的25\",{\"1\":{\"302\":1}}],[\"预测了其理想的性能\",{\"1\":{\"302\":1}}],[\"见图7\",{\"1\":{\"301\":1}}],[\"阶段4\",{\"1\":{\"301\":1}}],[\"阶段0\",{\"1\":{\"301\":1}}],[\"阶段映射算法\",{\"1\":{\"290\":1}}],[\"达到51\",{\"1\":{\"301\":1}}],[\"足以涵盖gpu\",{\"1\":{\"300\":1}}],[\"张量t1具有最长的生命周期\",{\"1\":{\"300\":1}}],[\"敏感性分析\",{\"0\":{\"298\":1}}],[\"至于性能差距\",{\"1\":{\"297\":1}}],[\"补充了它们的局限性\",{\"1\":{\"297\":1}}],[\"此时\",{\"1\":{\"296\":1}}],[\"此外\",{\"1\":{\"56\":1,\"101\":1,\"282\":1,\"290\":1,\"295\":4,\"296\":1,\"297\":3,\"299\":1,\"302\":1,\"303\":1,\"304\":1}}],[\"空闲的gpu内存不足以容纳从负载较大的gpu卸载的张量\",{\"1\":{\"296\":1}}],[\"五个系统都成功训练了该模型\",{\"1\":{\"296\":1}}],[\"小规模模型\",{\"1\":{\"296\":1}}],[\"小规模网络\",{\"1\":{\"215\":1}}],[\"基线和系统配置\",{\"1\":{\"295\":1}}],[\"基于以上观察和权衡\",{\"1\":{\"291\":1}}],[\"基于隧道\",{\"1\":{\"214\":1}}],[\"基于二进制\",{\"1\":{\"205\":1}}],[\"基于二进制的协议\",{\"1\":{\"196\":1}}],[\"基于纯文本\",{\"1\":{\"205\":1}}],[\"基于纯文本的协议\",{\"1\":{\"196\":1}}],[\"基于检索等一系列任务中测试\",{\"1\":{\"179\":1}}],[\"基于message\",{\"1\":{\"147\":1}}],[\"基于\",{\"1\":{\"91\":1}}],[\"基于时间间隔调度运行\",{\"1\":{\"90\":1}}],[\"基于主备异步复制导致锁的安全性问题\",{\"1\":{\"0\":1}}],[\"配备96个虚拟cpu\",{\"1\":{\"295\":1}}],[\"配置复杂度\",{\"1\":{\"215\":1}}],[\"配置简单\",{\"1\":{\"213\":1}}],[\"配置的chat\",{\"1\":{\"137\":1}}],[\"配置中可能不适用\",{\"1\":{\"91\":1}}],[\"配置加密套件\",{\"1\":{\"70\":1}}],[\"配置文件中\",{\"1\":{\"43\":1}}],[\"配置\",{\"0\":{\"42\":1,\"136\":1},\"1\":{\"116\":1,\"247\":1}}],[\"配置示例\",{\"0\":{\"15\":1,\"20\":1,\"43\":1},\"1\":{\"15\":1,\"20\":1}}],[\"独立的三种优化方法\",{\"1\":{\"298\":1}}],[\"独立的d2d交换\",{\"1\":{\"294\":1}}],[\"独立开发和创业一样有风险\",{\"1\":{\"274\":2}}],[\"独立开发的一些基本流程\",{\"1\":{\"274\":4}}],[\"独立开发者\",{\"2\":{\"276\":1}}],[\"独立开发者面临的困境\",{\"1\":{\"274\":4}}],[\"独立开发者一点思考\",{\"0\":{\"274\":1}}],[\"评估了它在训练bert和gpt等大规模dnn模型时的表现\",{\"1\":{\"304\":1}}],[\"评估指标\",{\"1\":{\"295\":1}}],[\"评估\",{\"0\":{\"294\":1}}],[\"考虑到张量的生命周期以及各种内存技术在成本\",{\"1\":{\"302\":1}}],[\"考虑到固定内存\",{\"1\":{\"293\":1}}],[\"考虑路由抖动\",{\"1\":{\"238\":1}}],[\"针对t6\",{\"1\":{\"300\":1}}],[\"针对不同大小张量\",{\"1\":{\"300\":1}}],[\"针对不同的通信模式进行了优化\",{\"1\":{\"163\":1}}],[\"针对gpu内存分配\",{\"1\":{\"293\":1}}],[\"改进了pipedream系统\",{\"1\":{\"293\":1}}],[\"改善了带宽利用\",{\"1\":{\"204\":1}}],[\"仅靠gpu\",{\"1\":{\"297\":1}}],[\"仅需要执行一次训练迭代\",{\"1\":{\"291\":1}}],[\"仅首次运行有效\",{\"1\":{\"137\":1}}],[\"前提是存在空闲的gpu内存\",{\"1\":{\"291\":1}}],[\"前提是重计算引入的额外延迟小于gpu\",{\"1\":{\"291\":1}}],[\"前端开发\",{\"0\":{\"125\":1}}],[\"长于这两种交换方法的时间成本时\",{\"1\":{\"291\":1}}],[\"长上下文基准测试中的实验结果\",{\"1\":{\"179\":1}}],[\"长上下文\",{\"1\":{\"179\":1}}],[\"探索将d2d交换\",{\"1\":{\"291\":1}}],[\"探测\",{\"1\":{\"222\":1}}],[\"普通操作将直接通过底层训练框架运行时处理\",{\"1\":{\"289\":1}}],[\"普通用户程序代码中\",{\"1\":{\"185\":1}}],[\"规划器根据成本模型探索可能的配置\",{\"1\":{\"289\":1}}],[\"表iv展示了mpress在高gpu内存压力下\",{\"1\":{\"301\":1}}],[\"表iii报告了在bert和gpt模型中\",{\"1\":{\"300\":1}}],[\"表iii展示了收集的统计数据示例\",{\"1\":{\"289\":1}}],[\"表ii展示了我们使用的bert变体的参数规模\",{\"1\":{\"295\":1}}],[\"表示内存需求超过每个gpu容量的大模型\",{\"1\":{\"295\":1}}],[\"表示层\",{\"0\":{\"267\":1}}],[\"表示协议地址的长度\",{\"1\":{\"232\":1}}],[\"表示硬件地址的长度\",{\"1\":{\"232\":1}}],[\"表示ipv4\",{\"1\":{\"232\":1}}],[\"表示以太网\",{\"1\":{\"232\":1}}],[\"表示该设备所属的主设备\",{\"1\":{\"226\":1}}],[\"表示该条目所属的vlan\",{\"1\":{\"226\":1}}],[\"表示该条目是永久性的\",{\"1\":{\"226\":1}}],[\"表示该条目是本地接口的mac地址\",{\"1\":{\"226\":1}}],[\"表示该mac地址对应的设备\",{\"1\":{\"226\":1}}],[\"表示有多少时间是被同一个宿主机上的其他虚拟机抢走的\",{\"1\":{\"185\":1}}],[\"表示接受跨域请求\",{\"1\":{\"70\":1}}],[\"表示所有\",{\"1\":{\"70\":2}}],[\"表示同一节点上的\",{\"1\":{\"53\":1}}],[\"表示约束作用在节点级别\",{\"1\":{\"49\":1}}],[\"表示这个节点对某些\",{\"1\":{\"31\":1}}],[\"随后pipedream通过引入异步调度来改进gpipe的性能\",{\"1\":{\"303\":1}}],[\"随后\",{\"1\":{\"289\":1}}],[\"随着硬件的快速发展\",{\"1\":{\"286\":1}}],[\"随机搜索\",{\"1\":{\"100\":1}}],[\"二是重新执行前向传播会与反向传播竞争gpu资源\",{\"1\":{\"285\":1}}],[\"二层以太网\",{\"1\":{\"215\":1}}],[\"节省内存\",{\"1\":{\"285\":1}}],[\"节点可能会被跳过\",{\"1\":{\"89\":1}}],[\"节点亲和性\",{\"0\":{\"50\":1}}],[\"节点设置taint\",{\"1\":{\"31\":1}}],[\"导致训练性能下降34\",{\"1\":{\"285\":1}}],[\"导致冗余和带宽浪费\",{\"1\":{\"199\":1}}],[\"第二个微批次中的第七个子批次在第四个子批次的反向传播完成后立即由工人1执行\",{\"1\":{\"283\":1}}],[\"第一个进程在\",{\"1\":{\"159\":1}}],[\"立即开始相应的反向传播\",{\"1\":{\"283\":1}}],[\"许多训练系统\",{\"1\":{\"282\":1}}],[\"许多科学计算任务涉及大规模矩阵或向量操作\",{\"1\":{\"153\":1}}],[\"原因是dgx\",{\"1\":{\"297\":1}}],[\"原因是d2d交换足够缓解内存限制\",{\"1\":{\"296\":1}}],[\"原因有两个\",{\"1\":{\"291\":1}}],[\"原因如下\",{\"1\":{\"282\":1}}],[\"原生的dapple可以训练该模型\",{\"1\":{\"295\":1}}],[\"原生的\",{\"1\":{\"111\":1}}],[\"微批次大小同样为2\",{\"1\":{\"284\":1}}],[\"微批次训练数据通过这些阶段以流水线的方式进行处理\",{\"1\":{\"282\":1}}],[\"微信\",{\"1\":{\"127\":1}}],[\"背景与动机\",{\"0\":{\"282\":1}}],[\"突破gpu内存瓶颈\",{\"1\":{\"281\":1}}],[\"综合了重新计算\",{\"1\":{\"279\":1}}],[\"利用多个高带宽的nvlink互连将模型数据从内存压力较大的gpu卸载到轻负载的gpu\",{\"1\":{\"288\":1}}],[\"利用多条高速nvlink链路将张量交换至轻载gpu\",{\"1\":{\"279\":1}}],[\"利用动态稀疏注意的静态空间聚合模式\",{\"1\":{\"179\":1}}],[\"旨在通过节省内存的操作间并行化方法\",{\"1\":{\"304\":1}}],[\"旨在突破十亿规模模型训练中的gpu内存壁垒\",{\"1\":{\"279\":1}}],[\"旨在提高网络性能和效率\",{\"1\":{\"195\":1}}],[\"深度学习加速器\",{\"1\":{\"303\":1}}],[\"深度神经网络\",{\"1\":{\"278\":1}}],[\"深入理解spring\",{\"1\":{\"123\":1}}],[\"杂谈\",{\"0\":{\"312\":1},\"2\":{\"275\":1}}],[\"杂谈之独立开发者一点思考\",{\"1\":{\"274\":1}}],[\"积极是暂时的\",{\"1\":{\"274\":2}}],[\"他是不是你的目标客户\",{\"1\":{\"274\":2}}],[\"他们就会发现\",{\"1\":{\"274\":2}}],[\"答案是\",{\"1\":{\"274\":2}}],[\"根据文献\",{\"1\":{\"295\":1}}],[\"根据分析结果\",{\"1\":{\"274\":2}}],[\"根据具体需求选择合适的技术可以提高网络的性能\",{\"1\":{\"216\":1}}],[\"根据具体的应用场景和需求\",{\"1\":{\"45\":1}}],[\"罗列你的想法和产品特点\",{\"1\":{\"274\":2}}],[\"做好一个\",{\"1\":{\"274\":2}}],[\"产品的目标客户是谁\",{\"1\":{\"274\":2}}],[\"产品方向也会发生改变\",{\"1\":{\"274\":2}}],[\"产品最少需要做多少工作\",{\"1\":{\"274\":4}}],[\"生成的最佳策略\",{\"1\":{\"301\":1}}],[\"生成的初步计划将被传递给重写器\",{\"1\":{\"289\":1}}],[\"生活压力\",{\"1\":{\"274\":2}}],[\"生命周期中的自动化机器学习\",{\"1\":{\"101\":1}}],[\"生命周期的每个步骤\",{\"1\":{\"73\":1}}],[\"营销问题\",{\"1\":{\"274\":2}}],[\"营销收入\",{\"1\":{\"126\":1}}],[\"威力狈是公认的独立开发者中的牛逼人物\",{\"1\":{\"274\":2}}],[\"财务自由\",{\"1\":{\"274\":2}}],[\"心态\",{\"1\":{\"274\":2}}],[\"增长\",{\"1\":{\"274\":2}}],[\"增强\",{\"1\":{\"115\":1}}],[\"伪需求怎么办\",{\"1\":{\"274\":4}}],[\"别人说你的产品是垃圾\",{\"1\":{\"274\":4}}],[\"别只改一处~\",{\"1\":{\"137\":1}}],[\"采用这种分区策略付出的代价是计算时间不均衡\",{\"1\":{\"285\":1}}],[\"采用什么样的产品形态\",{\"1\":{\"274\":4}}],[\"采用进程并行模型\",{\"1\":{\"162\":1}}],[\"三种方法的性能差异显著\",{\"1\":{\"300\":1}}],[\"三种内存优化方法的时间成本\",{\"1\":{\"300\":1}}],[\"三点金规铁律\",{\"1\":{\"274\":4}}],[\"三大核心问题\",{\"1\":{\"274\":4}}],[\"三层ip\",{\"1\":{\"215\":1}}],[\"想法可能会发生改变\",{\"1\":{\"274\":2}}],[\"想法是一个产品的起始点\",{\"1\":{\"274\":2}}],[\"想法\",{\"1\":{\"274\":4}}],[\"全文总结\",{\"1\":{\"274\":2}}],[\"全归约等操作\",{\"1\":{\"147\":1}}],[\"逆向处理\",{\"1\":{\"270\":1}}],[\"层次依赖\",{\"1\":{\"269\":1}}],[\"各层之间的关系\",{\"0\":{\"269\":1}}],[\"域名系统\",{\"1\":{\"268\":1}}],[\"远程过程调用\",{\"1\":{\"266\":1}}],[\"远远超过传统vlan的4094个限制\",{\"1\":{\"218\":1}}],[\"错误检测和恢复\",{\"1\":{\"265\":1}}],[\"错误检测和纠正\",{\"1\":{\"263\":1}}],[\"传输到后续阶段\",{\"1\":{\"301\":1}}],[\"传输控制协议\",{\"1\":{\"265\":1}}],[\"传输层依赖于网络层提供的路由和地址服务\",{\"1\":{\"269\":1}}],[\"传输层安全\",{\"1\":{\"267\":1}}],[\"传输层\",{\"0\":{\"265\":1}}],[\"传输\",{\"1\":{\"263\":1}}],[\"传输介质\",{\"1\":{\"262\":1}}],[\"光纤\",{\"1\":{\"262\":1}}],[\"电缆\",{\"1\":{\"262\":1}}],[\"制定的一种网络通信标准框架\",{\"1\":{\"261\":1}}],[\"七层网络模型\",{\"0\":{\"261\":1},\"1\":{\"261\":1}}],[\"防火墙规则\",{\"1\":{\"260\":1}}],[\"防止中间人攻击\",{\"1\":{\"235\":1}}],[\"防止arp欺骗\",{\"1\":{\"235\":1}}],[\"防止个体资源过度消耗\",{\"1\":{\"23\":1}}],[\"防止过多的资源消耗影响整个集群的性能\",{\"1\":{\"19\":1}}],[\"防止资源过度配置或资源不足\",{\"1\":{\"22\":1}}],[\"防止资源过度消耗\",{\"1\":{\"19\":1}}],[\"防止资源耗尽\",{\"1\":{\"14\":1}}],[\"关键是不要消极\",{\"1\":{\"274\":2}}],[\"关系\",{\"0\":{\"260\":1}}],[\"关于客户端代码和运行时代码的命名约定\",{\"1\":{\"86\":1}}],[\"出站和转发的数据包过滤规则\",{\"1\":{\"258\":1}}],[\"出现\",{\"1\":{\"0\":1}}],[\"子网掩码\",{\"1\":{\"246\":1}}],[\"子关系\",{\"1\":{\"89\":1}}],[\"收敛时间\",{\"1\":{\"242\":1}}],[\"收集工件\",{\"1\":{\"90\":1}}],[\"挑战\",{\"0\":{\"242\":1}}],[\"稳定性\",{\"1\":{\"241\":1}}],[\"稳定的底层代码\",{\"1\":{\"122\":1}}],[\"消息\",{\"1\":{\"239\":1}}],[\"消息队列\",{\"1\":{\"118\":1}}],[\"交换技术\",{\"1\":{\"288\":1}}],[\"交换机\",{\"1\":{\"263\":1}}],[\"交换路由信息\",{\"1\":{\"239\":1}}],[\"交互的\",{\"1\":{\"98\":1}}],[\"称为bgp对等体或邻居\",{\"1\":{\"239\":1}}],[\"建立bgp会话\",{\"1\":{\"239\":1}}],[\"建议部署完后更改\",{\"1\":{\"137\":1}}],[\"外部bgp\",{\"1\":{\"238\":1}}],[\"策略控制能力和高可扩展性使其成为管理互联网复杂路由需求的理想选择\",{\"1\":{\"243\":1}}],[\"策略控制\",{\"1\":{\"238\":1}}],[\"路由器\",{\"1\":{\"264\":1}}],[\"路由器仅在路由信息发生变化时交换更新\",{\"1\":{\"239\":1}}],[\"路由管理\",{\"1\":{\"260\":1}}],[\"路由和防火墙规则\",{\"0\":{\"244\":1}}],[\"路由更新和撤销\",{\"1\":{\"239\":1}}],[\"路由传播\",{\"1\":{\"239\":1}}],[\"路由聚合和路由优先级\",{\"1\":{\"238\":1}}],[\"路由选择\",{\"1\":{\"238\":1}}],[\"路径信息包括多个as路径\",{\"1\":{\"238\":1}}],[\"路径向量协议\",{\"1\":{\"238\":1}}],[\"边界网关协议\",{\"1\":{\"237\":1}}],[\"虽然通常少于重计算和gpu\",{\"1\":{\"301\":1}}],[\"虽然arp协议本身存在安全隐患\",{\"1\":{\"236\":1}}],[\"虽慢但仍有显著加速\",{\"1\":{\"179\":1}}],[\"手动配置ip地址和mac地址的映射\",{\"1\":{\"235\":1}}],[\"攻击者可以发送伪造的arp响应\",{\"1\":{\"234\":1}}],[\"攻击\",{\"1\":{\"234\":1}}],[\"超大规模模型\",{\"1\":{\"296\":1}}],[\"超文本传输协议\",{\"1\":{\"268\":1}}],[\"超过该时间后条目将被删除\",{\"1\":{\"233\":1}}],[\"超参数调优工具\",{\"1\":{\"92\":1}}],[\"缓存\",{\"0\":{\"233\":1}}],[\"缓存存储和传输成本高等挑战\",{\"1\":{\"179\":1}}],[\"硬件见解\",{\"0\":{\"302\":1}}],[\"硬件趋势与机遇\",{\"0\":{\"286\":1}}],[\"硬件地址长度\",{\"1\":{\"232\":1}}],[\"硬件类型\",{\"1\":{\"232\":1}}],[\"报文格式\",{\"0\":{\"232\":1}}],[\"报告生成\",{\"1\":{\"106\":1}}],[\"报告服务\",{\"1\":{\"103\":1}}],[\"谁是这个ip地址的拥有者\",{\"1\":{\"231\":1}}],[\"显然\",{\"1\":{\"295\":1,\"300\":1}}],[\"显示所有桥接设备的fdb条目\",{\"1\":{\"228\":1}}],[\"显示特定桥接设备的fdb条目\",{\"1\":{\"227\":1,\"228\":1}}],[\"显示特定设备的fdb条目\",{\"1\":{\"227\":1,\"228\":1}}],[\"显著提升\",{\"1\":{\"205\":1}}],[\"显著降低了延迟\",{\"1\":{\"204\":1}}],[\"显著减少预填充阶段延迟\",{\"1\":{\"179\":1}}],[\"帮助管理员了解网络中mac地址的分布情况和转发路径\",{\"1\":{\"229\":1}}],[\"帮助管理员了解当前网络设备与其他节点的连接状态和mac地址映射情况\",{\"1\":{\"223\":1}}],[\"帮助桥接设备确定数据帧的转发路径\",{\"1\":{\"224\":1}}],[\"帮助它们查询和理解支持应用程序的对象\",{\"1\":{\"96\":1}}],[\"延迟\",{\"1\":{\"222\":1}}],[\"陈旧\",{\"1\":{\"222\":1}}],[\"邻居节点的状态\",{\"1\":{\"222\":1}}],[\"邻居节点的mac地址\",{\"1\":{\"222\":1}}],[\"邻居节点的ip地址\",{\"1\":{\"222\":1}}],[\"邻居表存储了网络设备的邻居节点的信息\",{\"1\":{\"222\":1}}],[\"灵活和可扩展的网络架构\",{\"1\":{\"221\":1}}],[\"灵活性\",{\"1\":{\"157\":1,\"241\":1}}],[\"完成vxlan包的封装和解封装\",{\"1\":{\"221\":1}}],[\"完全可以由\",{\"1\":{\"56\":1}}],[\"帧传递\",{\"1\":{\"220\":1}}],[\"帧解封装\",{\"1\":{\"220\":1}}],[\"帧封装\",{\"1\":{\"220\":1}}],[\"学习和维护虚拟网络中mac地址到vtep的映射关系\",{\"1\":{\"219\":1}}],[\"附加上vni\",{\"1\":{\"219\":1}}],[\"封装好的vxlan包通过三层ip网络传输到目的vtep\",{\"1\":{\"220\":1}}],[\"封装和解封装\",{\"1\":{\"219\":1,\"269\":1}}],[\"封装层\",{\"1\":{\"215\":1}}],[\"另一种结合了三种内存优化技术\",{\"1\":{\"295\":1}}],[\"另一个是连接到ip网络的接口\",{\"1\":{\"219\":1}}],[\"另外一个是\",{\"1\":{\"185\":1}}],[\"隧道端点\",{\"1\":{\"219\":1}}],[\"隧道封装\",{\"1\":{\"218\":1}}],[\"弹性和高可用性\",{\"1\":{\"218\":1}}],[\"较复杂\",{\"1\":{\"215\":1}}],[\"云环境\",{\"1\":{\"215\":1}}],[\"云原生\",{\"0\":{\"308\":1},\"2\":{\"109\":1,\"119\":1}}],[\"云原生之kubeflow\",{\"1\":{\"73\":1}}],[\"局域网\",{\"1\":{\"215\":1}}],[\"跨数据中心\",{\"1\":{\"215\":1}}],[\"跨多个数据中心的虚拟机迁移和高可用性\",{\"1\":{\"214\":1}}],[\"跨平台兼容\",{\"1\":{\"163\":1}}],[\"理论上支持多达1600万个虚拟网络\",{\"1\":{\"214\":1}}],[\"检查命名空间中的veth设备\",{\"0\":{\"211\":1}}],[\"过滤掉伪造的arp报文\",{\"1\":{\"235\":1}}],[\"过滤veth设备\",{\"1\":{\"207\":1}}],[\"过程和功能特性\",{\"1\":{\"262\":1}}],[\"过程就会在阈值达到之后立刻开始\",{\"1\":{\"46\":1}}],[\"过程设置一段\",{\"1\":{\"46\":1}}],[\"列出所有网络接口\",{\"1\":{\"207\":1}}],[\"带来了显著的改进和优化\",{\"1\":{\"205\":1}}],[\"推送\",{\"1\":{\"205\":1}}],[\"推理引擎\",{\"2\":{\"181\":1}}],[\"推理面临预填充阶段注意力延迟长\",{\"1\":{\"179\":1}}],[\"推理中的问题\",{\"1\":{\"178\":1}}],[\"压缩库提供三种内存优化技术的高效实现\",{\"1\":{\"289\":1}}],[\"压缩和解压缩\",{\"1\":{\"267\":1}}],[\"压缩\",{\"1\":{\"205\":1}}],[\"受限于串行化处理和头部阻塞\",{\"1\":{\"205\":1}}],[\"性能提升幅度比dgx\",{\"1\":{\"297\":1}}],[\"性能\",{\"1\":{\"205\":1}}],[\"性能改进\",{\"0\":{\"204\":1}}],[\"性能影响\",{\"1\":{\"185\":1}}],[\"现代gpu服务器已经集成了超高速的gpu间互连\",{\"1\":{\"286\":1}}],[\"现代浏览器和服务器在实际应用中通常要求\",{\"1\":{\"202\":1}}],[\"现有的一些内存节省技术如gpu\",{\"1\":{\"278\":1}}],[\"现在\",{\"1\":{\"190\":1}}],[\"客户端可以指定不同流的优先级\",{\"1\":{\"201\":1}}],[\"客户端必须明确请求每个资源\",{\"1\":{\"200\":1}}],[\"客户端代码\",{\"1\":{\"86\":1}}],[\"流出和转发\",{\"1\":{\"260\":1}}],[\"流之间可以独立并行处理\",{\"1\":{\"197\":1}}],[\"流水线并行是一种常见的训练大规模模型的技术\",{\"1\":{\"303\":1}}],[\"流水线并行\",{\"1\":{\"282\":1,\"303\":2}}],[\"流水线管理\",{\"1\":{\"106\":1}}],[\"流水线服务\",{\"1\":{\"103\":1,\"104\":1}}],[\"单独的d2d交换无法满足需求\",{\"1\":{\"296\":1}}],[\"单靠重计算有两个主要缺点\",{\"1\":{\"285\":1}}],[\"单靠数据并行难以满足快速增长的模型规模所带来的巨大内存需求\",{\"1\":{\"282\":1}}],[\"单一gpu无法满足如此大规模模型的训练需求\",{\"1\":{\"278\":1}}],[\"单一程序\",{\"1\":{\"151\":1}}],[\"单个连接处理多个并发请求\",{\"1\":{\"205\":1}}],[\"单个tcp连接上可以处理多个并发的请求\",{\"1\":{\"197\":1}}],[\"串行化处理\",{\"1\":{\"197\":1}}],[\"连接到gpu\",{\"1\":{\"302\":1}}],[\"连接方式为对称的nvlink\",{\"1\":{\"295\":1}}],[\"连接方式为不对称的nvlink\",{\"1\":{\"295\":1}}],[\"连接管理\",{\"0\":{\"197\":1},\"1\":{\"205\":1}}],[\"连接参数\",{\"1\":{\"137\":3}}],[\"协议和设备\",{\"1\":{\"262\":1,\"263\":1,\"264\":1,\"265\":1,\"266\":1,\"267\":1,\"268\":1}}],[\"协议地址长度\",{\"1\":{\"232\":1}}],[\"协议类型\",{\"1\":{\"205\":1,\"232\":1}}],[\"协议扩展性\",{\"0\":{\"203\":1},\"1\":{\"205\":1}}],[\"协议基础\",{\"0\":{\"196\":1}}],[\"协议的重大升级\",{\"1\":{\"195\":1}}],[\"协方差矩阵自适应进化策略\",{\"1\":{\"100\":1}}],[\"确认\",{\"1\":{\"192\":1}}],[\"确保不同系统间的数据格式一致\",{\"1\":{\"267\":1}}],[\"确保数据在主机之间可靠\",{\"1\":{\"265\":1}}],[\"确保数据包从源节点到达目标节点\",{\"1\":{\"264\":1}}],[\"确保没有流会独占带宽\",{\"1\":{\"201\":1}}],[\"确保消息传递的顺序和一致性\",{\"1\":{\"162\":1}}],[\"确保在多个进程或设备之间一致地传递数据\",{\"1\":{\"147\":1}}],[\"确保前端应用的可维护性和稳定性\",{\"1\":{\"125\":1}}],[\"确保项目能够快速上线并稳定运行\",{\"1\":{\"123\":1}}],[\"确保高可用性和数据一致性\",{\"1\":{\"116\":1}}],[\"确保工作流按照定义的步骤顺利执行\",{\"1\":{\"92\":1}}],[\"确保其他\",{\"1\":{\"92\":1}}],[\"确保配置正确\",{\"1\":{\"70\":1}}],[\"确保\",{\"1\":{\"52\":1}}],[\"确保关键组件能够独立于\",{\"1\":{\"28\":1}}],[\"确保资源的公平分配和高效使用\",{\"1\":{\"23\":1}}],[\"确保资源的合理分配和使用\",{\"1\":{\"22\":1}}],[\"确保集群资源的公平分配和高效利用\",{\"1\":{\"23\":1}}],[\"确保所有容器符合预期的资源使用模式\",{\"1\":{\"22\":1}}],[\"确保每个命名空间不会消耗超过指定的资源限额\",{\"1\":{\"14\":1}}],[\"验证扩展结果\",{\"0\":{\"192\":1}}],[\"验证和管理\",{\"1\":{\"70\":1}}],[\"物理层\",{\"0\":{\"262\":1}}],[\"物理卷\",{\"0\":{\"189\":1}}],[\"物理仿真等领域中也得到广泛应用\",{\"1\":{\"153\":1}}],[\"覆盖以前的\",{\"1\":{\"188\":1}}],[\"覆盖以前的分区空间\",{\"1\":{\"188\":1}}],[\"仍然使用\",{\"1\":{\"188\":1}}],[\"写入更改并退出\",{\"1\":{\"187\":1,\"188\":1}}],[\"写法遵循\",{\"1\":{\"70\":1}}],[\"首先积极地为适当的张量分配gpu\",{\"1\":{\"291\":1}}],[\"首先建立tcp连接\",{\"1\":{\"239\":1}}],[\"首先\",{\"1\":{\"187\":1,\"282\":1,\"289\":1,\"291\":1,\"293\":1,\"299\":1,\"300\":1,\"301\":1}}],[\"首先通过训练目标dnn模型\",{\"1\":{\"289\":1}}],[\"首先通过\",{\"1\":{\"0\":1}}],[\"卸载并删除\",{\"0\":{\"187\":1}}],[\"逻辑卷中\",{\"1\":{\"186\":1}}],[\"扩容磁盘\",{\"0\":{\"186\":1}}],[\"扩展内存层次结构是有益的\",{\"1\":{\"302\":1}}],[\"扩展性更好\",{\"1\":{\"302\":1}}],[\"扩展性\",{\"1\":{\"214\":1,\"215\":1,\"218\":1}}],[\"扩展复杂\",{\"1\":{\"205\":1}}],[\"扩展和添加新功能变得复杂\",{\"1\":{\"203\":1}}],[\"扩展和管理容器化应用程序\",{\"1\":{\"95\":1}}],[\"扩展完成后\",{\"1\":{\"192\":1}}],[\"扩展逻辑卷\",{\"0\":{\"190\":1}}],[\"扩展\",{\"0\":{\"191\":1},\"1\":{\"117\":1}}],[\"从网卡收到数据包的大部分工作\",{\"1\":{\"185\":1}}],[\"从而避免了过多的性能损失\",{\"1\":{\"303\":1}}],[\"从而延迟了相应的dnn计算\",{\"1\":{\"296\":1}}],[\"从而为应用gpu\",{\"1\":{\"291\":1}}],[\"从而缓解gpu内存的限制\",{\"1\":{\"286\":1}}],[\"从而促进了网络技术的发展和普及\",{\"1\":{\"271\":1}}],[\"从而拦截或篡改网络通信\",{\"1\":{\"234\":1}}],[\"从而进行通信\",{\"1\":{\"230\":1,\"236\":1}}],[\"从而实现了高效\",{\"1\":{\"221\":1}}],[\"从而实现大规模并行计算\",{\"1\":{\"161\":1}}],[\"从而在vxlan隧道中维护虚拟网络的隔离和标识\",{\"1\":{\"219\":1}}],[\"从而支持多租户环境\",{\"1\":{\"218\":1}}],[\"从而可以在三层ip网络上进行传输\",{\"1\":{\"218\":1}}],[\"从而可以跨越传统的二层边界在ip网络上传输\",{\"1\":{\"214\":1}}],[\"从而提高网络的安全性和性能\",{\"1\":{\"213\":1}}],[\"从而提高数据处理的速度和效率\",{\"1\":{\"164\":1}}],[\"从而加速计算任务的执行\",{\"1\":{\"163\":1}}],[\"从而加快整个工作流的执行\",{\"1\":{\"158\":1}}],[\"从而显著提高计算速度\",{\"1\":{\"153\":1}}],[\"从而充分利用硬件资源\",{\"1\":{\"148\":1}}],[\"从而确保在所有设备上更新后的模型参数保持一致\",{\"1\":{\"147\":1}}],[\"从而优化集群性能和资源利用率\",{\"1\":{\"22\":1}}],[\"从而影响其他命名空间的正常运行\",{\"1\":{\"13\":1}}],[\"网页浏览\",{\"1\":{\"270\":1}}],[\"网桥\",{\"1\":{\"263\":1}}],[\"网卡\",{\"1\":{\"262\":1}}],[\"网卡就会发出一个中断\",{\"1\":{\"185\":1}}],[\"网络层\",{\"0\":{\"264\":1}}],[\"网络中的所有设备都会接收到这个arp请求帧\",{\"1\":{\"231\":1}}],[\"网络虚拟化\",{\"1\":{\"214\":1}}],[\"网络设备根据这个id来区分不同的vlan\",{\"1\":{\"213\":1}}],[\"网络分段\",{\"1\":{\"213\":1}}],[\"网络\",{\"1\":{\"61\":1},\"2\":{\"272\":1}}],[\"没事可做就休眠了\",{\"1\":{\"185\":1}}],[\"没有内建的优先级控制机制\",{\"1\":{\"201\":1}}],[\"没有\",{\"1\":{\"26\":1,\"33\":1,\"35\":1}}],[\"好了\",{\"1\":{\"185\":1}}],[\"好\",{\"1\":{\"185\":1}}],[\"紧接着\",{\"1\":{\"185\":1}}],[\"触发一个真正的磁盘读取操作\",{\"1\":{\"185\":1}}],[\"接着我们构建了初步配置\",{\"1\":{\"291\":1}}],[\"接下来\",{\"1\":{\"185\":1}}],[\"接口配置\",{\"1\":{\"260\":1}}],[\"接口进行通信\",{\"1\":{\"92\":1}}],[\"接口\",{\"1\":{\"56\":1,\"87\":1,\"92\":1}}],[\"接口调用期间\",{\"1\":{\"56\":1}}],[\"去读取一个文件\",{\"1\":{\"185\":1}}],[\"去监听比自己小的\",{\"1\":{\"0\":1}}],[\"框\",{\"1\":{\"185\":1}}],[\"框架下\",{\"1\":{\"258\":1}}],[\"框架\",{\"1\":{\"100\":1}}],[\"框架无关的项目\",{\"1\":{\"100\":1}}],[\"假设veth1被移动到命名空间ns1\",{\"1\":{\"211\":1}}],[\"假设创建了一个veth设备对\",{\"1\":{\"210\":1}}],[\"假设一个用户程序开始运行了\",{\"1\":{\"185\":1}}],[\"假设有一个科学模拟项目\",{\"1\":{\"159\":1}}],[\"把这些值挨个解释一下\",{\"1\":{\"185\":1}}],[\"权限\",{\"1\":{\"185\":1}}],[\"选项用于附加到一个正在运行的进程上\",{\"1\":{\"182\":1}}],[\"选择对连续层的张量应用重计算是一个不错的选择\",{\"1\":{\"291\":1}}],[\"选择删除分区\",{\"1\":{\"187\":1}}],[\"选择gloo后端\",{\"1\":{\"149\":1}}],[\"选择\",{\"1\":{\"92\":3}}],[\"选择合适的工作流执行器取决于工作流的具体需求和集群环境\",{\"1\":{\"92\":1}}],[\"头部信息仅在第一次请求时完整传输\",{\"1\":{\"199\":1}}],[\"头部压缩和服务器推送等功能\",{\"1\":{\"204\":1}}],[\"头部压缩\",{\"0\":{\"199\":1},\"1\":{\"205\":1}}],[\"头部阻塞问题\",{\"1\":{\"198\":1}}],[\"头部\",{\"1\":{\"179\":1}}],[\"编码\",{\"1\":{\"179\":1}}],[\"编程语言\",{\"0\":{\"122\":1}}],[\"引入在线近似方法和优化内核\",{\"1\":{\"179\":1}}],[\"引入了连接保持\",{\"1\":{\"197\":1}}],[\"引入了\",{\"1\":{\"52\":1}}],[\"倍\",{\"1\":{\"179\":1}}],[\"离线确定每个头的最佳动态稀疏模式\",{\"1\":{\"179\":1}}],[\"重写器进一步修改输入的数据流图\",{\"1\":{\"289\":1}}],[\"重计算减少了51\",{\"1\":{\"301\":1}}],[\"重计算节省了阶段0\",{\"1\":{\"301\":1}}],[\"重计算的额外开销最小\",{\"1\":{\"300\":1}}],[\"重计算\",{\"1\":{\"298\":1,\"303\":1,\"304\":1}}],[\"重计算能够支持模型规模达到15\",{\"1\":{\"297\":1}}],[\"重计算在bert\",{\"1\":{\"296\":1}}],[\"重计算提高了125\",{\"1\":{\"296\":1}}],[\"重计算比gpu\",{\"1\":{\"296\":1}}],[\"重计算基线系统按照文献的建议丢弃特定的张量\",{\"1\":{\"295\":1}}],[\"重计算技术可以通过丢弃前向传播生成的激活值并在需要时重新计算\",{\"1\":{\"285\":1}}],[\"重计算等虽然可以减少部分内存消耗\",{\"1\":{\"278\":1}}],[\"重新分配空间\",{\"1\":{\"186\":1}}],[\"重新绑定\",{\"1\":{\"9\":1}}],[\"重要亮点\",{\"0\":{\"179\":1},\"1\":{\"274\":2}}],[\"介绍\",{\"0\":{\"178\":1,\"309\":1}}],[\"论文创新点\",{\"0\":{\"279\":1}}],[\"论文来自中国科学技术大学\",{\"1\":{\"277\":1}}],[\"论文介绍了一种名为\",{\"1\":{\"178\":1}}],[\"论文\",{\"0\":{\"177\":1,\"313\":1}}],[\"天体物理等领域\",{\"1\":{\"164\":1}}],[\"气象预报\",{\"1\":{\"164\":1}}],[\"异步通信则允许发送方在消息发送后立即继续执行\",{\"1\":{\"162\":1}}],[\"异构计算\",{\"1\":{\"158\":1}}],[\"程序示例\",{\"1\":{\"165\":1}}],[\"程序默认的通信域\",{\"1\":{\"162\":1}}],[\"程序包含客户端代码\",{\"1\":{\"86\":1}}],[\"散播\",{\"1\":{\"162\":1}}],[\"点对点通信\",{\"1\":{\"162\":1}}],[\"领域\",{\"1\":{\"161\":1}}],[\"广泛采用新硬件技术需要时间\",{\"1\":{\"302\":1}}],[\"广泛应用于分布式计算和高性能计算\",{\"1\":{\"161\":1}}],[\"广泛应用于科学计算\",{\"1\":{\"161\":1}}],[\"广播地址等\",{\"1\":{\"246\":1}}],[\"广播和同步\",{\"1\":{\"147\":1}}],[\"且不一定适用于现有的gpu计算框架\",{\"1\":{\"303\":1}}],[\"且能够被轻松隐藏\",{\"1\":{\"300\":1}}],[\"且d2d交换已启用但未进行数据分条\",{\"1\":{\"299\":1}}],[\"且d2d交换比gpu\",{\"1\":{\"291\":1}}],[\"且报告的性能数据相同\",{\"1\":{\"296\":1}}],[\"且需要精心设计\",{\"1\":{\"157\":1}}],[\"且正被\",{\"1\":{\"8\":1}}],[\"复杂的网络环境中保持稳定和高效\",{\"1\":{\"241\":1}}],[\"复杂工作流处理\",{\"1\":{\"158\":1}}],[\"复杂性\",{\"1\":{\"157\":1,\"242\":1}}],[\"复制等任务都可以通过\",{\"1\":{\"114\":1}}],[\"互联网协议\",{\"1\":{\"264\":1}}],[\"互联网服务提供商\",{\"1\":{\"237\":1}}],[\"互不干扰\",{\"1\":{\"156\":1}}],[\"互斥性\",{\"1\":{\"0\":1}}],[\"核心或计算节点\",{\"1\":{\"155\":1,\"161\":1}}],[\"核心组件\",{\"1\":{\"92\":1}}],[\"科学计算\",{\"1\":{\"153\":1}}],[\"典型的函数有\",{\"1\":{\"162\":1}}],[\"典型的应用场景包括\",{\"1\":{\"153\":1}}],[\"典型场景\",{\"1\":{\"23\":2}}],[\"处理软中断的开销\",{\"1\":{\"185\":1}}],[\"处理硬中断的开销\",{\"1\":{\"185\":1}}],[\"处理一个\",{\"1\":{\"154\":1}}],[\"处理一部分数据集\",{\"1\":{\"153\":1}}],[\"处理单元之间的通信需求可能更高\",{\"1\":{\"157\":1}}],[\"处理单元的操作是完全同步的\",{\"1\":{\"152\":1}}],[\"处理单元可能需要共享部分计算结果或交换数据\",{\"1\":{\"151\":1}}],[\"处理单元通常需要在某些阶段进行通信和同步\",{\"1\":{\"151\":1}}],[\"处于\",{\"1\":{\"7\":1,\"11\":1}}],[\"尽管两者的额外开销相同\",{\"1\":{\"300\":1}}],[\"尽管gpu的hbm\",{\"1\":{\"302\":1}}],[\"尽管gpu\",{\"1\":{\"296\":1}}],[\"尽管协议本身不强制这一点\",{\"1\":{\"202\":1}}],[\"尽管处理单元运行不同的程序\",{\"1\":{\"156\":1}}],[\"尽管所有处理单元执行相同的程序代码\",{\"1\":{\"151\":1}}],[\"尽量避免将新的\",{\"1\":{\"31\":1}}],[\"极大地简化了在多设备或多机器环境中进行并行计算的复杂性\",{\"1\":{\"150\":1}}],[\"获取基础的张量大小\",{\"1\":{\"289\":1}}],[\"获取公网ip\",{\"0\":{\"172\":1}}],[\"获取当前进程的rank\",{\"1\":{\"149\":1}}],[\"获得锁\",{\"1\":{\"0\":1}}],[\"获得\",{\"1\":{\"0\":1}}],[\"归约\",{\"1\":{\"147\":1,\"162\":1}}],[\"进而提高了训练效率\",{\"1\":{\"303\":1}}],[\"进一步减少了内存消耗\",{\"1\":{\"303\":1}}],[\"进入整个执行流水线\",{\"1\":{\"283\":1}}],[\"进入\",{\"1\":{\"187\":1,\"188\":1}}],[\"进程再从内核态切换回用户态\",{\"1\":{\"185\":1}}],[\"进程在内核态拿到数据\",{\"1\":{\"185\":1}}],[\"进程之间通过消息传递进行通信\",{\"1\":{\"162\":1}}],[\"进程模型\",{\"1\":{\"162\":1}}],[\"进程组和通信域\",{\"1\":{\"162\":1}}],[\"进程组\",{\"1\":{\"147\":1}}],[\"进行的每个系统调用\",{\"1\":{\"184\":1}}],[\"进行训练的情况下\",{\"1\":{\"164\":1}}],[\"进行广播操作\",{\"1\":{\"149\":1}}],[\"进行广播操作的示例\",{\"1\":{\"149\":1}}],[\"进行并行计算时\",{\"1\":{\"146\":1}}],[\"进行解析\",{\"1\":{\"136\":1}}],[\"进行调度\",{\"1\":{\"51\":1}}],[\"进行\",{\"1\":{\"46\":1}}],[\"进行自访问和内部通信\",{\"1\":{\"45\":1}}],[\"进行通信\",{\"1\":{\"44\":1}}],[\"进行通信的场景非常有用\",{\"1\":{\"33\":1}}],[\"进行健康检查\",{\"1\":{\"41\":1}}],[\"适合大规模分布式系统\",{\"1\":{\"147\":1}}],[\"适用于数值模拟\",{\"1\":{\"163\":1}}],[\"适用于cpu和gpu的跨平台通信\",{\"1\":{\"147\":1}}],[\"适用于gpu间通信\",{\"1\":{\"147\":1}}],[\"适用于需要高效处理大量小文件的工作流\",{\"1\":{\"91\":1}}],[\"适用于需要直接访问每个\",{\"1\":{\"39\":1}}],[\"适用于大多数场景\",{\"1\":{\"91\":1}}],[\"适用于单个\",{\"1\":{\"23\":1}}],[\"适用于整个命名空间的资源总量\",{\"1\":{\"23\":1}}],[\"适用的对象范围\",{\"1\":{\"16\":1}}],[\"特性\",{\"1\":{\"205\":1}}],[\"特别适合在大型数据中心和云环境中使用\",{\"1\":{\"218\":1}}],[\"特别适合需要大规模并行处理的任务\",{\"1\":{\"150\":1}}],[\"特别是在不同任务需要不同计算资源或算法的情况下\",{\"1\":{\"161\":1}}],[\"特别是在各个处理单元需要执行不同类型的计算时\",{\"1\":{\"155\":1}}],[\"特别是在处理大规模数据集时\",{\"1\":{\"151\":1}}],[\"特别是在需要处理大规模数据集或模型时\",{\"1\":{\"148\":1}}],[\"特别是在需要跨多个设备\",{\"1\":{\"146\":1}}],[\"特别是在nvidia硬件上\",{\"1\":{\"147\":1}}],[\"特点\",{\"1\":{\"7\":1,\"8\":1,\"9\":1,\"10\":1,\"215\":1}}],[\"角色扮演和文字冒险等丰富的插件\",{\"1\":{\"143\":1}}],[\"感谢您的关注\",{\"1\":{\"143\":1}}],[\"找到可公开访问的\",{\"1\":{\"297\":1}}],[\"找\",{\"1\":{\"143\":1}}],[\"看\",{\"1\":{\"143\":1}}],[\"画字开头的消息将按要求创作图片\",{\"1\":{\"143\":1}}],[\"画\",{\"1\":{\"143\":1}}],[\"知识助手\",{\"1\":{\"143\":1}}],[\"zero系列通过分片优化器状态\",{\"1\":{\"303\":1}}],[\"zero系列通过在数据并行训练中消除数据冗余来减少gpu内存消耗\",{\"1\":{\"285\":1}}],[\"zero系列可以支持参数规模最多达到25\",{\"1\":{\"297\":1}}],[\"zero系列和mpress能够支持从5\",{\"1\":{\"297\":1}}],[\"zero系列是deepspeed框架的一部分\",{\"1\":{\"297\":1}}],[\"zero\",{\"1\":{\"295\":1,\"297\":5,\"303\":1}}],[\"zeros\",{\"1\":{\"149\":1}}],[\"zhayujie\",{\"1\":{\"141\":1,\"143\":1}}],[\"zilliz\",{\"1\":{\"137\":1}}],[\"账户密码\",{\"1\":{\"139\":1,\"140\":1}}],[\"密钥\",{\"1\":{\"137\":1}}],[\"密码mypassword\",{\"1\":{\"137\":1}}],[\"密码\",{\"1\":{\"137\":2}}],[\"初始化通信库\",{\"1\":{\"149\":1}}],[\"初始化的\",{\"1\":{\"137\":1}}],[\"初始状态\",{\"1\":{\"11\":1}}],[\"聚合更新时长\",{\"1\":{\"137\":1}}],[\"减少gpu间的通信开销\",{\"1\":{\"279\":1}}],[\"减少了传输数据量\",{\"1\":{\"199\":1}}],[\"减少了人为操作的复杂性和风险\",{\"1\":{\"115\":1}}],[\"减少数据交互频率\",{\"1\":{\"137\":1}}],[\"登录凭证加密密钥\",{\"1\":{\"137\":1}}],[\"登录凭证密钥\",{\"1\":{\"137\":1}}],[\"务必及时修改\",{\"1\":{\"137\":1}}],[\"务必加\",{\"1\":{\"137\":1}}],[\"务必保证至少有一个为true\",{\"1\":{\"136\":5}}],[\"阿里云\",{\"1\":{\"137\":5}}],[\"阿里云没有arm包\",{\"1\":{\"137\":1}}],[\"测试通后\",{\"1\":{\"137\":1}}],[\"测试使用\",{\"1\":{\"137\":1}}],[\"测试和生产级服务的\",{\"1\":{\"73\":1}}],[\"记得务必修改账号密码\",{\"1\":{\"137\":1}}],[\"记得改数据库和项目连接参数\",{\"1\":{\"137\":1}}],[\"记录\",{\"1\":{\"33\":1,\"39\":1}}],[\"参训时的额外参数\",{\"1\":{\"136\":1}}],[\"参数和梯度的内存消耗\",{\"1\":{\"285\":1}}],[\"参数数量已经从百万级增长到数十亿级\",{\"1\":{\"278\":1}}],[\"参数\",{\"1\":{\"84\":1,\"85\":1}}],[\"非常适合大规模的网络环境\",{\"1\":{\"241\":1}}],[\"非常适合在分布式内存系统\",{\"1\":{\"162\":1}}],[\"非对称向量模型时候需要用到\",{\"1\":{\"136\":1}}],[\"非目标\",{\"0\":{\"99\":1}}],[\"星火\",{\"1\":{\"136\":1}}],[\"挟带一些默认配置\",{\"1\":{\"136\":1}}],[\"否则容易泄露\",{\"1\":{\"137\":1}}],[\"否则知识库会报错\",{\"1\":{\"136\":1}}],[\"否则post请求无法进行跨域\",{\"1\":{\"70\":1}}],[\"商业版\",{\"1\":{\"136\":2}}],[\"搜索越精确\",{\"1\":{\"136\":1}}],[\"越大\",{\"1\":{\"136\":1}}],[\"向量搜索参数\",{\"1\":{\"136\":1}}],[\"功能更强大的替代品\",{\"1\":{\"260\":1}}],[\"功能相对有限\",{\"1\":{\"260\":1}}],[\"功能\",{\"0\":{\"246\":1,\"249\":1,\"252\":1,\"255\":1,\"258\":1},\"1\":{\"136\":1,\"262\":1,\"263\":1,\"264\":1,\"265\":1,\"266\":1,\"267\":1,\"268\":1}}],[\"杭州阿里云\",{\"1\":{\"136\":1}}],[\"文档\",{\"0\":{\"135\":1,\"142\":1}}],[\"文件传输协议\",{\"1\":{\"268\":1}}],[\"文件系统\",{\"0\":{\"191\":1}}],[\"文件阅读加密\",{\"1\":{\"137\":1}}],[\"文件保存到节点的\",{\"1\":{\"27\":1}}],[\"文件路径\",{\"1\":{\"27\":1}}],[\"文件\",{\"1\":{\"27\":1,\"29\":1,\"63\":1}}],[\"地址解析协议\",{\"1\":{\"230\":1}}],[\"地址\",{\"0\":{\"134\":1,\"141\":1,\"176\":1},\"1\":{\"137\":1,\"246\":1,\"247\":1,\"277\":1}}],[\"代表优先级比较低的进程运行时所占用的\",{\"1\":{\"185\":1}}],[\"代表系统处于空闲状态\",{\"1\":{\"185\":1}}],[\"代表等待\",{\"1\":{\"185\":1}}],[\"代表内核态\",{\"1\":{\"185\":1}}],[\"代表\",{\"1\":{\"185\":3}}],[\"代理\",{\"2\":{\"131\":1}}],[\"代码\",{\"1\":{\"86\":1}}],[\"联系方式\",{\"0\":{\"127\":1}}],[\"期待与您合作\",{\"1\":{\"126\":1}}],[\"欢迎联系我\",{\"1\":{\"126\":1}}],[\"吸引了大量用户并实现了显著的商业变现\",{\"1\":{\"126\":1}}],[\"累计注册用户\",{\"1\":{\"126\":1}}],[\"日活流量\",{\"1\":{\"126\":1}}],[\"日志等级\",{\"1\":{\"137\":1}}],[\"日志\",{\"1\":{\"90\":1}}],[\"日志查看\",{\"1\":{\"29\":1}}],[\"飞鸟云课堂\",{\"1\":{\"126\":2}}],[\"掌握html的各种技术细节\",{\"1\":{\"125\":1}}],[\"健壮的代码\",{\"1\":{\"125\":1}}],[\"响应\",{\"1\":{\"231\":1}}],[\"响应对在同一连接上的多个流中并发传输\",{\"1\":{\"198\":1}}],[\"响应对在一个单独的流中\",{\"1\":{\"197\":1}}],[\"响应对可以被处理\",{\"1\":{\"198\":1}}],[\"响应对\",{\"1\":{\"197\":1}}],[\"响应对通常需要一个单独的tcp连接\",{\"1\":{\"197\":1}}],[\"响应式的用户界面开发\",{\"1\":{\"125\":1}}],[\"响应头\",{\"1\":{\"70\":1}}],[\"训练参数规模为175b的gpt\",{\"1\":{\"302\":1}}],[\"训练性能提升了3\",{\"1\":{\"296\":1}}],[\"训练了不同规模的bert模型\",{\"1\":{\"295\":1}}],[\"训练系统\",{\"1\":{\"288\":1}}],[\"训练吞吐量降低了67\",{\"1\":{\"285\":1}}],[\"训练\",{\"1\":{\"124\":1}}],[\"训练框架一起使用\",{\"1\":{\"101\":1}}],[\"熟悉哪个就用哪个\",{\"1\":{\"274\":2}}],[\"熟悉nacos的服务发现与配置管理\",{\"1\":{\"123\":1}}],[\"熟练使用vue\",{\"1\":{\"125\":1}}],[\"熟练使用go语言开发高并发应用\",{\"1\":{\"122\":1}}],[\"熟练掌握容器编排技术\",{\"1\":{\"123\":1}}],[\"熟练掌握python\",{\"1\":{\"122\":1}}],[\"精通element\",{\"1\":{\"125\":1}}],[\"精通typescript\",{\"1\":{\"125\":1}}],[\"精通kubeflow流水线的设计与实现\",{\"1\":{\"124\":1}}],[\"精通mysql数据库的设计与性能优化\",{\"1\":{\"123\":1}}],[\"精通c语言\",{\"1\":{\"122\":1}}],[\"擅长从需求分析到产品落地的全流程开发\",{\"1\":{\"126\":1}}],[\"擅长利用redis进行高效的缓存与存储操作\",{\"1\":{\"123\":1}}],[\"擅长快速搭建和优化企业级应用\",{\"1\":{\"123\":1}}],[\"擅长底层系统开发\",{\"1\":{\"122\":1}}],[\"构建稳定的后端服务\",{\"1\":{\"122\":1}}],[\"善于利用其高效的内存管理机制和原生的协程支持\",{\"1\":{\"122\":1}}],[\"机器配置\",{\"1\":{\"295\":1}}],[\"机器学习和深度学习\",{\"1\":{\"164\":1}}],[\"机器学习领域有丰富经验\",{\"1\":{\"122\":1}}],[\"机械\",{\"1\":{\"262\":1}}],[\"机制\",{\"0\":{\"31\":1},\"1\":{\"56\":1}}],[\"机制各自监听\",{\"1\":{\"0\":1}}],[\"扎实的c++功底让我在系统级应用开发中游刃有余\",{\"1\":{\"122\":1}}],[\"尤其在数据分析\",{\"1\":{\"122\":1}}],[\"尤其擅长使用spring\",{\"1\":{\"122\":1}}],[\"尤其是小文件\",{\"1\":{\"92\":1}}],[\"尤其是在处理大量系统调用时\",{\"1\":{\"185\":1}}],[\"尤其是在需要跨多个节点或多个\",{\"1\":{\"164\":1}}],[\"尤其是在\",{\"1\":{\"25\":1,\"39\":1}}],[\"优化操作间并行的内存使用\",{\"1\":{\"303\":1}}],[\"优化用户体验\",{\"1\":{\"123\":1}}],[\"优势\",{\"0\":{\"241\":1}}],[\"优先级最高的本地优先级\",{\"1\":{\"238\":1}}],[\"优先级和流控制\",{\"0\":{\"201\":1},\"1\":{\"205\":1}}],[\"优先训练权重\",{\"1\":{\"136\":1}}],[\"优质的代码解决复杂的业务问题\",{\"1\":{\"121\":1}}],[\"优雅时间\",{\"1\":{\"46\":1}}],[\"致力于通过高效\",{\"1\":{\"121\":1}}],[\"大规模模型\",{\"1\":{\"296\":1}}],[\"大规模数据中心\",{\"1\":{\"215\":1}}],[\"大小与链路带宽成正比\",{\"1\":{\"290\":1}}],[\"大型企业和数据中心网络中\",{\"1\":{\"237\":1}}],[\"大大超过了vlan的4094个限制\",{\"1\":{\"214\":1}}],[\"大大增强了\",{\"1\":{\"118\":1}}],[\"大多数实现要求加密\",{\"1\":{\"205\":1}}],[\"大多数实现强制要求使用加密\",{\"1\":{\"202\":1}}],[\"大家好\",{\"1\":{\"121\":1}}],[\"个接口\",{\"1\":{\"274\":2}}],[\"个页面和\",{\"1\":{\"274\":2}}],[\"个人\",{\"2\":{\"129\":1}}],[\"个人简介\",{\"1\":{\"121\":1}}],[\"个人介绍\",{\"0\":{\"121\":1},\"2\":{\"128\":1}}],[\"个服务\",{\"1\":{\"106\":1}}],[\"逐步深入理解其背后的原理和应用场景\",{\"1\":{\"118\":1}}],[\"有趣的是\",{\"1\":{\"296\":1,\"297\":2}}],[\"有哪些牛逼的独立开发者\",{\"1\":{\"274\":4}}],[\"有序地传输\",{\"1\":{\"265\":1}}],[\"有限\",{\"1\":{\"215\":1}}],[\"有头部阻塞问题\",{\"1\":{\"205\":1}}],[\"有效保留或扩展实际上下文窗口处理能力\",{\"1\":{\"179\":1}}],[\"有99\",{\"1\":{\"136\":1}}],[\"有兴趣\",{\"1\":{\"118\":1}}],[\"有关组件的完整定义\",{\"1\":{\"87\":1}}],[\"有关单个管道运行的执行状态\",{\"1\":{\"83\":1}}],[\"有关单个管道运行的调试信息\",{\"1\":{\"83\":1}}],[\"语义化的页面布局\",{\"1\":{\"125\":1}}],[\"语言的开发框架和工具\",{\"1\":{\"117\":1}}],[\"语法调度运行\",{\"1\":{\"90\":1}}],[\"备份和恢复\",{\"1\":{\"114\":1,\"116\":1}}],[\"备份和故障处理等任务\",{\"1\":{\"111\":1}}],[\"专门用于并行文件输入输出操作\",{\"1\":{\"162\":1}}],[\"专门用于管理自定义资源\",{\"1\":{\"112\":1}}],[\"专为高效的文件操作和网络操作设计\",{\"1\":{\"91\":1}}],[\"结果已被归一化为默认设置\",{\"1\":{\"299\":1}}],[\"结合nvlink链路带宽对子块大小进行加权\",{\"1\":{\"290\":1}}],[\"结合使用\",{\"1\":{\"38\":1}}],[\"结论\",{\"0\":{\"281\":1,\"304\":1}}],[\"结构的机制\",{\"1\":{\"112\":1}}],[\"升级和扩展\",{\"1\":{\"116\":1}}],[\"升级\",{\"1\":{\"111\":1}}],[\"部署提供一体化解决方案\",{\"1\":{\"124\":1}}],[\"部署\",{\"1\":{\"111\":1,\"113\":2}}],[\"部署和管理\",{\"1\":{\"28\":1}}],[\"任务管理\",{\"1\":{\"106\":1}}],[\"任务服务\",{\"1\":{\"103\":1}}],[\"反向传播首先从流水线执行的后半部分的后期层开始\",{\"1\":{\"291\":1}}],[\"反馈信息将从模拟器传递给规划器\",{\"1\":{\"289\":1}}],[\"反射服务\",{\"1\":{\"105\":1}}],[\"反亲和性是一种调度约束\",{\"1\":{\"48\":1}}],[\"反亲和性\",{\"0\":{\"48\":1}}],[\"认证服务\",{\"1\":{\"103\":1}}],[\"注册了以下\",{\"1\":{\"106\":1}}],[\"注册了以下服务\",{\"1\":{\"102\":1}}],[\"注册的服务\",{\"0\":{\"103\":1,\"104\":1}}],[\"注意事项\",{\"0\":{\"185\":1}}],[\"注意\",{\"1\":{\"90\":1,\"92\":1}}],[\"函数中\",{\"1\":{\"102\":1,\"106\":1}}],[\"丰富的优化算法支持\",{\"1\":{\"101\":1}}],[\"集线器\",{\"1\":{\"262\":1}}],[\"集体通信\",{\"1\":{\"162\":1}}],[\"集成\",{\"1\":{\"101\":3}}],[\"集群的部署\",{\"1\":{\"116\":1}}],[\"集群的部署和管理\",{\"1\":{\"116\":1}}],[\"集群安装\",{\"0\":{\"57\":1}}],[\"集群启动和恢复\",{\"1\":{\"28\":1}}],[\"集群中的服务和控制器进行通信和协调\",{\"1\":{\"92\":1}}],[\"集群中的各种控制器\",{\"1\":{\"92\":1}}],[\"集群中的控制器\",{\"1\":{\"92\":1}}],[\"集群中提供强大的资源管理能力\",{\"1\":{\"23\":1}}],[\"集群中\",{\"1\":{\"12\":1}}],[\"更宽\",{\"1\":{\"295\":1}}],[\"更容易扩展\",{\"1\":{\"203\":1,\"205\":1}}],[\"更高效地解析和传输数据\",{\"1\":{\"196\":1}}],[\"更适合那些需要同时执行多种任务的复杂应用\",{\"1\":{\"157\":1}}],[\"更多算法支持即将推出\",{\"1\":{\"100\":1}}],[\"更新arp缓存\",{\"1\":{\"231\":1}}],[\"更新\",{\"1\":{\"29\":1}}],[\"帕尔森估计树\",{\"1\":{\"100\":1}}],[\"算法对头部进行压缩\",{\"1\":{\"199\":1}}],[\"算法\",{\"1\":{\"100\":1}}],[\"信息\",{\"1\":{\"100\":1}}],[\"什么是独立开发者\",{\"1\":{\"274\":2}}],[\"什么是\",{\"0\":{\"100\":1},\"1\":{\"111\":1}}],[\"促进\",{\"1\":{\"98\":1}}],[\"促进生态系统工具和\",{\"1\":{\"98\":1}}],[\"展示三种注意力模式和\",{\"1\":{\"179\":1}}],[\"展示了如何使用\",{\"1\":{\"165\":1}}],[\"展示基本的健康检查\",{\"1\":{\"98\":1}}],[\"展示自定义资源定义\",{\"1\":{\"92\":1}}],[\"查看所有规则\",{\"1\":{\"259\":1}}],[\"查看所有接口的链路状态\",{\"1\":{\"253\":1}}],[\"查看所有接口的地址信息\",{\"1\":{\"250\":1}}],[\"查看当前的路由表\",{\"1\":{\"256\":1}}],[\"查看网络接口信息\",{\"1\":{\"247\":1}}],[\"查看具体veth设备对的详细信息\",{\"0\":{\"209\":1}}],[\"查看系统中已有的veth设备对或确认已创建的veth设备对\",{\"0\":{\"206\":1}}],[\"查看详细指令\",{\"1\":{\"143\":1}}],[\"查看和管理应用程序的标准\",{\"1\":{\"98\":1}}],[\"查询路由\",{\"0\":{\"67\":1}}],[\"查询服务\",{\"0\":{\"64\":1}}],[\"希望可视化应用程序\",{\"1\":{\"97\":1}}],[\"希望以应用程序为中心进行操作的应用程序运营商\",{\"1\":{\"97\":1}}],[\"像\",{\"1\":{\"97\":1}}],[\"很有用\",{\"1\":{\"96\":1}}],[\"即使每个gpu拥有96gb\",{\"1\":{\"302\":1}}],[\"即使在单线程实现下\",{\"1\":{\"299\":1}}],[\"即使具有足够的ssd带宽\",{\"1\":{\"297\":1}}],[\"即gpu\",{\"1\":{\"298\":1}}],[\"即从生成到再次使用之间的时间\",{\"1\":{\"291\":1}}],[\"即异步和同步模式\",{\"1\":{\"283\":1}}],[\"即\",{\"1\":{\"283\":1}}],[\"即操作内并行和操作间并行\",{\"1\":{\"282\":1}}],[\"即每个并行任务在一个独立的进程中运行\",{\"1\":{\"162\":1}}],[\"即垃圾回收\",{\"1\":{\"96\":1}}],[\"即资源回收\",{\"1\":{\"46\":1}}],[\"然而我们发现\",{\"1\":{\"285\":1}}],[\"然而\",{\"1\":{\"95\":1,\"243\":1,\"285\":2,\"295\":1,\"296\":1,\"297\":2,\"299\":1,\"302\":1,\"303\":3}}],[\"然后把这个页面推广出去\",{\"1\":{\"274\":2}}],[\"然后交换bgp\",{\"1\":{\"239\":1}}],[\"然后输入分区号\",{\"1\":{\"187\":1}}],[\"然后进入中断服务程序\",{\"1\":{\"185\":1}}],[\"然后保存相关数据\",{\"1\":{\"108\":1}}],[\"然后\",{\"1\":{\"56\":1,\"88\":1,\"185\":1,\"187\":1,\"210\":1,\"289\":1}}],[\"然后通过逐步将部分gpu\",{\"1\":{\"291\":1}}],[\"然后通过ip网络发送到目标vtep\",{\"1\":{\"219\":1}}],[\"然后通过通信操作将所有\",{\"1\":{\"154\":1}}],[\"然后通过\",{\"1\":{\"0\":1}}],[\"官网地址\",{\"0\":{\"94\":1}}],[\"总之\",{\"1\":{\"303\":1}}],[\"总体而言\",{\"1\":{\"92\":1}}],[\"总结\",{\"0\":{\"39\":1,\"45\":1,\"70\":1,\"106\":1,\"118\":1,\"150\":1,\"155\":1,\"161\":1,\"166\":1,\"205\":1,\"216\":1,\"221\":1,\"223\":1,\"229\":1,\"236\":1,\"243\":1,\"271\":1}}],[\"形成完整的机器学习工作流管理平台\",{\"1\":{\"92\":1}}],[\"支持操作间并行训练中的大规模模型训练\",{\"1\":{\"294\":1}}],[\"支持负载均衡和高可用性\",{\"1\":{\"218\":1}}],[\"支持多达1600万个虚拟网络\",{\"1\":{\"215\":1,\"218\":1}}],[\"支持多租户环境\",{\"1\":{\"214\":1}}],[\"支持多种硬件和操作系统平台\",{\"1\":{\"163\":1}}],[\"支持多种通信后端\",{\"1\":{\"147\":1}}],[\"支持多种\",{\"1\":{\"100\":1}}],[\"支持跨多个物理位置的虚拟机迁移和负载均衡\",{\"1\":{\"214\":1}}],[\"支持流的优先级\",{\"1\":{\"201\":1}}],[\"支持服务器推送功能\",{\"1\":{\"200\":1}}],[\"支持同步和异步的消息传递模式\",{\"1\":{\"162\":1}}],[\"支持allreduce操作\",{\"1\":{\"147\":1}}],[\"支持高效的数据同步和通信操作\",{\"1\":{\"146\":1}}],[\"支持超参数调优\",{\"1\":{\"100\":1}}],[\"支持\",{\"1\":{\"92\":1,\"205\":3}}],[\"支持其他工作流执行器\",{\"1\":{\"92\":1}}],[\"共减少了76\",{\"1\":{\"301\":1}}],[\"共享内存等\",{\"1\":{\"137\":1}}],[\"共同实现卓越的技术和商业目标\",{\"1\":{\"126\":1}}],[\"共同实现超参数调优功能\",{\"1\":{\"92\":1}}],[\"共同提供了一个功能强大的机器学习工作流管理平台\",{\"1\":{\"92\":1}}],[\"共识算法实现的\",{\"1\":{\"0\":1}}],[\"平台\",{\"1\":{\"92\":1}}],[\"组成了\",{\"1\":{\"92\":1}}],[\"组件紧密合作\",{\"1\":{\"92\":1}}],[\"组件可以在循环中多次执行\",{\"1\":{\"90\":1}}],[\"组件不会在同一进程中运行\",{\"1\":{\"88\":1}}],[\"组件代表容器内的特定程序或入口点\",{\"1\":{\"88\":1}}],[\"组件代码\",{\"0\":{\"86\":1}}],[\"组件定义包括以下部分\",{\"1\":{\"87\":1}}],[\"组件定义\",{\"0\":{\"87\":1}}],[\"组件类似于函数\",{\"1\":{\"85\":1}}],[\"组件是一个独立的代码集\",{\"1\":{\"85\":1}}],[\"组件\",{\"1\":{\"73\":1,\"84\":1,\"92\":2}}],[\"视图\",{\"1\":{\"92\":1}}],[\"视图和大规模指标\",{\"1\":{\"81\":1}}],[\"持久化代理\",{\"1\":{\"92\":1}}],[\"负责训练一个不相交的连续模型层集\",{\"1\":{\"283\":1}}],[\"负责识别通信伙伴\",{\"1\":{\"268\":1}}],[\"负责数据格式的转换和表示\",{\"1\":{\"267\":1}}],[\"负责建立\",{\"1\":{\"266\":1}}],[\"负责逻辑地址的管理和数据包的路由选择\",{\"1\":{\"264\":1}}],[\"负责帧的创建\",{\"1\":{\"263\":1}}],[\"负责在物理介质上传输比特流\",{\"1\":{\"262\":1}}],[\"负责在不同as之间交换路由信息\",{\"1\":{\"243\":1}}],[\"负责隧道的端点操作\",{\"1\":{\"221\":1}}],[\"负责vxlan包的封装和解封装\",{\"1\":{\"219\":1}}],[\"负责vxlan隧道的端点操作\",{\"1\":{\"219\":1}}],[\"负责机器学习工作流的定义\",{\"1\":{\"92\":1}}],[\"负责将元数据写入到持久化存储中\",{\"1\":{\"92\":1}}],[\"负责将元数据写入到存储后端\",{\"1\":{\"92\":1}}],[\"负责调度和执行\",{\"1\":{\"92\":1}}],[\"负责管理和执行工作流任务\",{\"1\":{\"92\":2}}],[\"负责管理和调度超参数搜索任务\",{\"1\":{\"92\":1}}],[\"负责管理\",{\"1\":{\"92\":4}}],[\"~\",{\"1\":{\"92\":1}}],[\"yvdq8kj9kaffdn9agzhldcu1vovogrovvabx1dd4mbgudazlqipfqwmijs\",{\"1\":{\"143\":1}}],[\"yigou\",{\"1\":{\"92\":1}}],[\"yaml\",{\"1\":{\"15\":1,\"20\":1,\"26\":1,\"27\":3,\"29\":1,\"35\":1,\"77\":1,\"87\":1}}],[\"团队仅推荐在\",{\"1\":{\"92\":1}}],[\"那么系统就会进入\",{\"1\":{\"185\":1}}],[\"那么这些代码指令的消耗就属于\",{\"1\":{\"185\":1}}],[\"那么就对应着第一个\",{\"1\":{\"185\":1}}],[\"那么\",{\"1\":{\"92\":1,\"185\":1}}],[\"守护进程交互来管理容器\",{\"1\":{\"91\":1}}],[\"正向和反向计算的延迟等基本统计数据\",{\"1\":{\"289\":1}}],[\"正式使用\",{\"1\":{\"137\":1}}],[\"正式发布以来\",{\"1\":{\"91\":1}}],[\"正常启动\",{\"1\":{\"28\":1}}],[\"月\",{\"1\":{\"91\":1}}],[\"年\",{\"1\":{\"91\":1}}],[\"执行相同的程序代码\",{\"1\":{\"151\":1}}],[\"执行初始化副本集的脚本\",{\"1\":{\"137\":1}}],[\"执行器为执行交换操作的swap\",{\"1\":{\"293\":1}}],[\"执行器接收来自mpress静态部分的仪器化数据流图\",{\"1\":{\"289\":1}}],[\"执行器之间进行选择\",{\"1\":{\"92\":1}}],[\"执行器和\",{\"1\":{\"92\":1}}],[\"执行器一直是\",{\"1\":{\"91\":1}}],[\"执行和监控容器\",{\"1\":{\"91\":1}}],[\"执行实际作业的代码\",{\"1\":{\"86\":1}}],[\"能够将轻负载的gpu分配到高内存压力的gpu附近\",{\"1\":{\"290\":1}}],[\"能够将人类操作员的经验和最佳实践转化为自动化的操作流程\",{\"1\":{\"118\":1}}],[\"能够在同样的内存优化下\",{\"1\":{\"304\":1}}],[\"能够在现有的多gpu系统上训练超大规模的模型\",{\"1\":{\"303\":1}}],[\"能够在不牺牲性能的前提下\",{\"1\":{\"281\":1}}],[\"能够在高性能计算环境中提供低延迟和高带宽的通信服务\",{\"1\":{\"163\":1}}],[\"能够大幅提高计算效率\",{\"1\":{\"155\":1}}],[\"能够显著缩短训练时间\",{\"1\":{\"148\":1}}],[\"能够显示应用程序的指标\",{\"1\":{\"99\":1}}],[\"能够高效地合并不同设备上的梯度并更新模型参数\",{\"1\":{\"147\":1}}],[\"能够高效部署和管理复杂的微服务架构\",{\"1\":{\"123\":1}}],[\"能够实现高效\",{\"1\":{\"125\":1}}],[\"能够编写高质量\",{\"1\":{\"125\":1}}],[\"能够编写高效\",{\"1\":{\"122\":1}}],[\"能够设计出简洁美观且用户体验友好的前端页面\",{\"1\":{\"125\":1}}],[\"能够设计并实现高并发\",{\"1\":{\"122\":1}}],[\"能够为机器学习模型的开发\",{\"1\":{\"124\":1}}],[\"能够确保微服务架构中各组件的稳定运行与快速扩展\",{\"1\":{\"123\":1}}],[\"能够提升系统的数据处理能力\",{\"1\":{\"123\":1}}],[\"能够快速开发美观实用的前端组件\",{\"1\":{\"125\":1}}],[\"能够快速构建高效的分析和自动化工具\",{\"1\":{\"122\":1}}],[\"能够快速适应不同的项目需求\",{\"1\":{\"121\":1}}],[\"能够执行某些操作\",{\"1\":{\"90\":1}}],[\"能理解并呈现为丰富的可视化内容\",{\"1\":{\"90\":1}}],[\"入门指南\",{\"1\":{\"90\":1}}],[\"了解哪些mac地址通过哪些接口连接\",{\"1\":{\"224\":1}}],[\"了解更多\",{\"1\":{\"100\":1}}],[\"了解更多信息\",{\"1\":{\"90\":1}}],[\"了解这些状态有助于掌握\",{\"1\":{\"6\":1}}],[\"转向使用\",{\"1\":{\"90\":1}}],[\"转换为字符串或文件\",{\"1\":{\"88\":1}}],[\"快速决策或不同运行间的比较\",{\"1\":{\"90\":1}}],[\"步骤中的超参数优化或神经架构搜索问题\",{\"1\":{\"101\":1}}],[\"步骤与其组件之间的关系是一种实例化关系\",{\"1\":{\"90\":1}}],[\"步骤\",{\"1\":{\"90\":1}}],[\"每秒浮点运算次数\",{\"1\":{\"295\":1}}],[\"每种方法对应不同的分区策略\",{\"1\":{\"282\":1}}],[\"每一层会添加或移除相应的协议头\",{\"1\":{\"269\":1}}],[\"每一层依赖于下一层提供的服务\",{\"1\":{\"269\":1}}],[\"每2小时或每45分钟\",{\"1\":{\"90\":1}}],[\"每个内存层都可以有不同的访问带宽\",{\"1\":{\"302\":1}}],[\"每个阶段最大内存需求为24\",{\"1\":{\"295\":1}}],[\"每个阶段对应一组连续的模型层\",{\"1\":{\"282\":1}}],[\"每个子块的大小和目标gpu设备的索引\",{\"1\":{\"290\":1}}],[\"每个gpu的内存为40gb\",{\"1\":{\"295\":1}}],[\"每个gpu的内存为32gb\",{\"1\":{\"295\":1}}],[\"每个gpu具有32gb内存\",{\"1\":{\"284\":1}}],[\"每个gpu设备可以将张量交换到多个nvlink可达的轻负载gpu\",{\"1\":{\"290\":1}}],[\"每个gpu设备\",{\"1\":{\"283\":1}}],[\"每个训练数据的微批次被进一步分为多个子批次\",{\"1\":{\"283\":1}}],[\"每个层次都有其特定的功能和协议\",{\"1\":{\"261\":1}}],[\"每个as都有一个唯一的as编号\",{\"1\":{\"238\":1}}],[\"每个邻居节点条目通常包含以下信息\",{\"1\":{\"222\":1}}],[\"每个vtep有两个主要接口\",{\"1\":{\"219\":1}}],[\"每个vlan都有一个唯一的vlan\",{\"1\":{\"213\":1}}],[\"每个虚拟网络可以有自己的vni\",{\"1\":{\"218\":1}}],[\"每个租户可以有独立的虚拟网络\",{\"1\":{\"214\":1}}],[\"每个请求通常需要一个tcp连接\",{\"1\":{\"205\":1}}],[\"每个请求都需要发送完整的头部信息\",{\"1\":{\"199\":1}}],[\"每个请求\",{\"1\":{\"197\":2}}],[\"每个进程组拥有一个通信域\",{\"1\":{\"162\":1}}],[\"每个实例可以有自己的任务和数据\",{\"1\":{\"160\":1}}],[\"每个处理单元都可以独立处理自己的任务\",{\"1\":{\"156\":1}}],[\"每个处理单元处理不同的数据集\",{\"1\":{\"156\":1}}],[\"每个处理单元处理其特定的数据子集\",{\"1\":{\"151\":1}}],[\"每个处理单元可以运行不同的程序代码\",{\"1\":{\"156\":1}}],[\"每个处理单元\",{\"1\":{\"153\":1}}],[\"每个节点的右上角有一个图标\",{\"1\":{\"89\":1}}],[\"每个组件的代码包括以下部分\",{\"1\":{\"86\":1}}],[\"每个\",{\"1\":{\"31\":1,\"33\":1,\"38\":1,\"154\":1}}],[\"周期性\",{\"1\":{\"90\":1}}],[\"定时工作流\",{\"1\":{\"92\":1}}],[\"定期运行服务\",{\"1\":{\"104\":1}}],[\"定期运行的配置包括指定所有参数值的管道副本和运行触发器\",{\"1\":{\"90\":1}}],[\"定期运行\",{\"1\":{\"90\":1}}],[\"定义\",{\"0\":{\"37\":1,\"38\":1},\"1\":{\"113\":1}}],[\"定义示例\",{\"1\":{\"35\":1}}],[\"定义的\",{\"1\":{\"27\":1}}],[\"定义文件\",{\"1\":{\"26\":1}}],[\"定义了资源的\",{\"1\":{\"113\":1}}],[\"定义了资源的硬性限制\",{\"1\":{\"16\":1}}],[\"定义了容器没有指定资源请求时的默认请求值\",{\"1\":{\"21\":1}}],[\"定义了容器没有指定资源请求和限制时的默认值\",{\"1\":{\"21\":1}}],[\"定义了单个容器必须请求的最小资源量\",{\"1\":{\"21\":1}}],[\"定义了单个容器可以请求的最大资源量\",{\"1\":{\"21\":1}}],[\"设计原则\",{\"0\":{\"288\":1}}],[\"设计为自包含的\",{\"1\":{\"90\":1}}],[\"设备映射搜索仅需几秒钟即可完成\",{\"1\":{\"299\":1}}],[\"设备映射对性能没有影响\",{\"1\":{\"299\":1}}],[\"设备映射优化提高了默认设置下的性能17\",{\"1\":{\"299\":1}}],[\"设备映射和内存压缩策略的性能影响是什么\",{\"1\":{\"294\":1}}],[\"设备映射\",{\"1\":{\"290\":1}}],[\"设备会将最近解析的ip地址和mac地址映射关系存储在arp缓存中\",{\"1\":{\"233\":1}}],[\"设备a接收到设备b的arp响应后\",{\"1\":{\"231\":1}}],[\"设备a会广播一条arp请求帧到网络中\",{\"1\":{\"231\":1}}],[\"设备a会先在本地的arp缓存中查找设备b的ip地址对应的mac地址\",{\"1\":{\"231\":1}}],[\"设备b会发送一条arp响应帧\",{\"1\":{\"231\":1}}],[\"设置微批次大小为12时\",{\"1\":{\"284\":1}}],[\"设置新分区的类型为\",{\"1\":{\"188\":1}}],[\"设置为100\",{\"1\":{\"136\":1}}],[\"设置路径为\",{\"1\":{\"66\":1}}],[\"设置资源使用的默认值和最大\",{\"1\":{\"23\":1}}],[\"设置默认资源限制\",{\"1\":{\"19\":1}}],[\"失败\",{\"1\":{\"89\":1}}],[\"箭头指示了管道组件之间的父\",{\"1\":{\"89\":1}}],[\"图9总结了通过逐步添加设备映射和数据分条优化后mpress的性能提升情况\",{\"1\":{\"299\":1}}],[\"图8b展示了在dgx\",{\"1\":{\"297\":1}}],[\"图8a总结了在dgx\",{\"1\":{\"297\":1}}],[\"图7对比了在五种不同系统配置下\",{\"1\":{\"296\":1}}],[\"图5展示了mpress系统架构的高级视图\",{\"1\":{\"289\":1}}],[\"图1展示了操作间并行dnn训练的工作流程\",{\"1\":{\"283\":1}}],[\"图中的每个节点对应管道中的一个步骤\",{\"1\":{\"89\":1}}],[\"图显示了管道运行已执行或正在执行的步骤\",{\"1\":{\"89\":1}}],[\"图\",{\"1\":{\"89\":1}}],[\"必须反序列化这些数据以供下游组件使用\",{\"1\":{\"88\":1}}],[\"镜像\",{\"1\":{\"88\":1}}],[\"请告诉我你的mac地址\",{\"1\":{\"231\":1}}],[\"请先卸载\",{\"1\":{\"187\":1}}],[\"请访问\",{\"1\":{\"100\":1}}],[\"请参阅\",{\"1\":{\"90\":1}}],[\"请参见组件规范\",{\"1\":{\"87\":1}}],[\"请求api时\",{\"1\":{\"136\":1}}],[\"请求apiserver\",{\"1\":{\"108\":1}}],[\"请求\",{\"1\":{\"20\":1,\"56\":1,\"219\":1,\"231\":1}}],[\"请求量\",{\"1\":{\"20\":1}}],[\"请求总量\",{\"1\":{\"15\":1}}],[\"请求匹配\",{\"1\":{\"11\":1}}],[\"默认root密码\",{\"1\":{\"137\":1}}],[\"默认文本分割时候的\",{\"1\":{\"136\":1}}],[\"默认文件名\",{\"1\":{\"70\":1}}],[\"默认的\",{\"1\":{\"92\":1}}],[\"默认选择\",{\"1\":{\"92\":1}}],[\"默认值等\",{\"1\":{\"87\":1}}],[\"类似于其他现有的flops计算工具或方法\",{\"1\":{\"295\":1}}],[\"类似于运行与其管道之间的关系\",{\"1\":{\"90\":1}}],[\"类似子句后有条件地执行\",{\"1\":{\"90\":1}}],[\"类型\",{\"1\":{\"87\":1,\"238\":1}}],[\"类别的\",{\"1\":{\"46\":1}}],[\"类别\",{\"1\":{\"46\":1}}],[\"元数据写入器\",{\"1\":{\"92\":1}}],[\"元数据服务\",{\"1\":{\"92\":2}}],[\"元数据\",{\"1\":{\"87\":1,\"92\":1}}],[\"用tflops表示\",{\"1\":{\"296\":1}}],[\"用法\",{\"0\":{\"247\":1,\"250\":1,\"253\":1,\"256\":1,\"259\":1}}],[\"用户并不知道自己需要什么\",{\"1\":{\"274\":2}}],[\"用户在浏览器中输入网址\",{\"1\":{\"270\":1}}],[\"用户数据报协议\",{\"1\":{\"265\":1}}],[\"用户也可以定义自己的进程组和通信域\",{\"1\":{\"162\":1}}],[\"用户名myusername\",{\"1\":{\"137\":1}}],[\"用户名为\",{\"1\":{\"137\":1}}],[\"用户可以方便地将训练任务分布在多个gpu上\",{\"1\":{\"148\":1}}],[\"用户可以使用\",{\"1\":{\"113\":1}}],[\"用户可以创建和管理新的自定义资源\",{\"1\":{\"112\":1}}],[\"用户可以利用\",{\"1\":{\"101\":1}}],[\"用户可以根据具体需求和工作流特点选择合适的\",{\"1\":{\"92\":1}}],[\"用户甚至可以使用\",{\"1\":{\"101\":1}}],[\"用户界面\",{\"1\":{\"92\":6}}],[\"用户需要选择一个工作流执行器\",{\"1\":{\"90\":1}}],[\"用\",{\"1\":{\"87\":1}}],[\"用于跟踪经过d2d交换的张量状态\",{\"1\":{\"290\":1}}],[\"用于配置\",{\"1\":{\"258\":1}}],[\"用于配置网络接口\",{\"1\":{\"246\":1}}],[\"用于显示和管理路由表\",{\"1\":{\"255\":1}}],[\"用于显示和修改网络接口的属性\",{\"1\":{\"252\":1}}],[\"用于显示或修改网络接口的地址信息\",{\"1\":{\"249\":1}}],[\"用于交换外部路由信息\",{\"1\":{\"238\":1}}],[\"用于传播内部路由信息\",{\"1\":{\"238\":1}}],[\"用于在不同自治系统\",{\"1\":{\"237\":1}}],[\"用于解决长上下文\",{\"1\":{\"178\":1}}],[\"用于生成和管理\",{\"1\":{\"117\":1}}],[\"用于简化\",{\"1\":{\"116\":1}}],[\"用于定义\",{\"1\":{\"112\":1}}],[\"用于定义访问路径\",{\"1\":{\"70\":1}}],[\"用于自动化部署\",{\"1\":{\"95\":1}}],[\"用于自定义\",{\"1\":{\"92\":1}}],[\"用于管理元数据\",{\"1\":{\"92\":1}}],[\"用于管理和代理请求\",{\"1\":{\"70\":1}}],[\"用于支持机器学习工作流的定义\",{\"1\":{\"92\":1}}],[\"用于展示机器学习工作流的执行状态和结果\",{\"1\":{\"92\":1}}],[\"用于创建\",{\"1\":{\"92\":1}}],[\"用于查看和监控超参数调优任务的状态和结果\",{\"1\":{\"92\":1}}],[\"用于告知系统何时生成新的定期运行配置\",{\"1\":{\"90\":1}}],[\"用于提供静态文件\",{\"1\":{\"70\":1}}],[\"用于控制容器是否能够通过\",{\"1\":{\"45\":1}}],[\"用于限制\",{\"1\":{\"30\":2}}],[\"用于确保关键组件的高可用性和独立性\",{\"1\":{\"29\":1}}],[\"用于表示集群中持久化存储的详细信息和状态\",{\"1\":{\"6\":1}}],[\"运行bridge\",{\"1\":{\"225\":1}}],[\"运行ip\",{\"1\":{\"222\":1}}],[\"运行这个命令会列出该接口的所有邻居节点的信息\",{\"1\":{\"222\":1}}],[\"运行该命令后\",{\"1\":{\"185\":1}}],[\"运行管理\",{\"1\":{\"106\":1}}],[\"运行服务\",{\"1\":{\"103\":1,\"104\":1}}],[\"运行一个像\",{\"1\":{\"96\":1}}],[\"运行一开始\",{\"1\":{\"89\":1}}],[\"运行\",{\"1\":{\"92\":1,\"101\":1}}],[\"运行和监控\",{\"1\":{\"92\":1}}],[\"运行和监控机器学习工作流\",{\"1\":{\"92\":1}}],[\"运行和监控功能\",{\"1\":{\"92\":1}}],[\"运行时流程如下\",{\"1\":{\"289\":1}}],[\"运行时信息包括任务的状态\",{\"1\":{\"90\":1}}],[\"运行时代码\",{\"1\":{\"86\":1}}],[\"运行触发器是一个标志\",{\"1\":{\"90\":1}}],[\"运行包含你尝试的所有实验的不可变日志\",{\"1\":{\"90\":1}}],[\"运行中\",{\"1\":{\"89\":1}}],[\"运行在同一个节点上\",{\"1\":{\"48\":1}}],[\"返回值和主体\",{\"1\":{\"85\":1}}],[\"模拟器只需要执行有限的几次训练步骤\",{\"1\":{\"289\":1}}],[\"模型规模的差异在前面已经解释过\",{\"1\":{\"297\":1}}],[\"模型和数据集\",{\"1\":{\"295\":1}}],[\"模型并行化将模型的不同部分分配给不同的设备进行计算\",{\"1\":{\"303\":1}}],[\"模型并行化\",{\"1\":{\"303\":2}}],[\"模型并行化这些操作\",{\"1\":{\"153\":1}}],[\"模型并行\",{\"1\":{\"282\":1}}],[\"模型提供了实现途径\",{\"1\":{\"161\":1}}],[\"模型可以分别启动两个不同的程序\",{\"1\":{\"159\":1}}],[\"模型可以将不同的程序分配给不同的架构\",{\"1\":{\"158\":1}}],[\"模型不同\",{\"1\":{\"156\":1}}],[\"模型相对应\",{\"1\":{\"155\":1}}],[\"模型是一种强大的并行计算模型\",{\"1\":{\"161\":1}}],[\"模型是一种高效的并行计算模型\",{\"1\":{\"155\":1}}],[\"模型是一种并行计算模型\",{\"1\":{\"150\":1}}],[\"模型在气候模拟\",{\"1\":{\"153\":1}}],[\"模型在许多并行计算任务中得到了广泛应用\",{\"1\":{\"153\":1}}],[\"模型通过允许不同的处理单元并行执行不同的任务\",{\"1\":{\"156\":1}}],[\"模型通过同时在多个处理单元上执行相同的程序代码来实现并行性\",{\"1\":{\"151\":1}}],[\"模型通常用于分布式训练\",{\"1\":{\"153\":1}}],[\"模型允许每个处理单元执行不同的程序代码并处理不同的数据\",{\"1\":{\"152\":1}}],[\"模型中所有处理单元执行相同的程序\",{\"1\":{\"157\":1}}],[\"模型中\",{\"1\":{\"151\":2,\"152\":1,\"155\":1,\"156\":1}}],[\"模型的规模不断扩大\",{\"1\":{\"278\":1}}],[\"模型的框架之一\",{\"1\":{\"160\":1}}],[\"模型的一个简单示例可能是\",{\"1\":{\"154\":1}}],[\"模型的核心思想\",{\"0\":{\"151\":1,\"156\":1}}],[\"模型的logo\",{\"1\":{\"136\":1}}],[\"模型\",{\"1\":{\"150\":1,\"156\":1,\"261\":1}}],[\"模型展示名\",{\"1\":{\"136\":1}}],[\"模型别名\",{\"1\":{\"136\":1}}],[\"模型名\",{\"1\":{\"136\":2}}],[\"模型训练等\",{\"1\":{\"85\":1}}],[\"模式下\",{\"1\":{\"46\":1}}],[\"模式\",{\"1\":{\"45\":1}}],[\"输出字段解释\",{\"0\":{\"226\":1}}],[\"输出可能类似于\",{\"1\":{\"210\":1}}],[\"输出工件\",{\"1\":{\"90\":1}}],[\"输出工件和每个步骤的日志\",{\"1\":{\"90\":1}}],[\"输出规范\",{\"1\":{\"87\":1}}],[\"输出包括容器参数或数据工件uri\",{\"1\":{\"82\":1}}],[\"输入\",{\"1\":{\"82\":1,\"87\":1,\"187\":2,\"188\":3}}],[\"度量数据被聚合用于排序和过滤\",{\"1\":{\"81\":1}}],[\"实际上\",{\"1\":{\"302\":1}}],[\"实时跟踪系统调用\",{\"1\":{\"184\":1}}],[\"实现了42\",{\"1\":{\"301\":1}}],[\"实现了大规模的数据中心和云环境中的网络虚拟化和扩展\",{\"1\":{\"221\":1}}],[\"实现细节\",{\"0\":{\"292\":1,\"293\":1}}],[\"实现自己的想法等\",{\"1\":{\"274\":2}}],[\"实现全面的网络管理\",{\"1\":{\"260\":1}}],[\"实现百万级标记提示的可接受延迟\",{\"1\":{\"179\":1}}],[\"实现基本的点对点通信\",{\"1\":{\"165\":1}}],[\"实现模型的并行训练和参数同步\",{\"1\":{\"164\":1}}],[\"实现包括\",{\"1\":{\"163\":1}}],[\"实现控制器\",{\"1\":{\"113\":1}}],[\"实现互操作\",{\"1\":{\"97\":1}}],[\"实现部分还描述了组件完成运行后如何获取输出值\",{\"1\":{\"87\":1}}],[\"实现\",{\"0\":{\"160\":1},\"1\":{\"87\":1,\"98\":1}}],[\"实现资源的更高效利用\",{\"1\":{\"55\":1}}],[\"实验设置\",{\"0\":{\"295\":1}}],[\"实验结果表明\",{\"1\":{\"280\":1,\"304\":1}}],[\"实验使用了bert和gpt两种模型\",{\"1\":{\"280\":1}}],[\"实验方法\",{\"0\":{\"280\":1}}],[\"实验服务\",{\"1\":{\"103\":1,\"104\":1}}],[\"实验可以包含任意的运行\",{\"1\":{\"90\":1}}],[\"实验是一个工作空间\",{\"1\":{\"90\":1}}],[\"实验\",{\"1\":{\"81\":1}}],[\"调试和排错\",{\"1\":{\"184\":1}}],[\"调用\",{\"1\":{\"183\":1}}],[\"调用管道服务以从静态配置创建管道运行\",{\"1\":{\"78\":1}}],[\"调度和执行定时任务\",{\"1\":{\"92\":1}}],[\"调度到相同的节点\",{\"1\":{\"50\":1}}],[\"调度到特定节点上\",{\"1\":{\"31\":1}}],[\"调度到这个节点上\",{\"1\":{\"31\":1}}],[\"系统调用会向\",{\"1\":{\"185\":1}}],[\"系统调用在读到真正\",{\"1\":{\"185\":1}}],[\"系统中的组件\",{\"1\":{\"87\":1}}],[\"系统会启动一个或多个\",{\"1\":{\"84\":1}}],[\"系统组件的平台\",{\"1\":{\"74\":1}}],[\"系统部署到各种环境以进行开发\",{\"1\":{\"73\":1}}],[\"作为二进制协议\",{\"1\":{\"203\":1}}],[\"作为工作流引擎\",{\"1\":{\"90\":1}}],[\"作为元数据依赖\",{\"1\":{\"90\":1}}],[\"作为在\",{\"1\":{\"74\":1}}],[\"作业管理\",{\"1\":{\"106\":1}}],[\"作业服务\",{\"1\":{\"103\":1}}],[\"作业的代码\",{\"1\":{\"86\":1}}],[\"作业\",{\"1\":{\"81\":1}}],[\"作用\",{\"0\":{\"14\":1,\"19\":1}}],[\"概念概述\",{\"0\":{\"74\":1}}],[\"工人3则处理第三阶段的子批次\",{\"1\":{\"283\":1}}],[\"工人1处理第二个微批次\",{\"1\":{\"283\":1}}],[\"工人1从第一微批次开始前向传播\",{\"1\":{\"283\":1}}],[\"工人\",{\"1\":{\"283\":1}}],[\"工作原理\",{\"0\":{\"231\":1}}],[\"工作流控制器\",{\"1\":{\"92\":2}}],[\"工作流执行器\",{\"1\":{\"92\":1}}],[\"工作流执行器类型包括\",{\"0\":{\"91\":1}}],[\"工作流执行器是一个符合特定接口的进程\",{\"1\":{\"90\":1}}],[\"工作流\",{\"1\":{\"85\":1}}],[\"工作流的描述\",{\"1\":{\"84\":1}}],[\"工作流在\",{\"1\":{\"73\":1}}],[\"工具\",{\"0\":{\"310\":1},\"1\":{\"183\":1},\"2\":{\"173\":1}}],[\"工具调用会用到\",{\"1\":{\"136\":2}}],[\"工具包\",{\"1\":{\"74\":1}}],[\"工件的可用性\",{\"1\":{\"90\":1}}],[\"工件可以是简单的文本数据视图\",{\"1\":{\"90\":1}}],[\"工件还使得理解管道各个组件的工作方式成为可能\",{\"1\":{\"90\":1}}],[\"工程师和运营团队\",{\"1\":{\"73\":1}}],[\"管道中的每个组件独立执行\",{\"1\":{\"88\":1}}],[\"管道\",{\"1\":{\"84\":1,\"85\":1}}],[\"管道配置包括运行管道所需的输入\",{\"1\":{\"84\":1}}],[\"管道是对机器学习\",{\"1\":{\"84\":1}}],[\"管道执行历史记录\",{\"1\":{\"83\":1}}],[\"管道web服务器从各种服务中收集数据以显示相关视图\",{\"1\":{\"83\":1}}],[\"管道持久性代理记录已执行的容器集合及其输入和输出\",{\"1\":{\"82\":1}}],[\"管道持久性代理监视管道服务创建的kubernetes资源\",{\"1\":{\"82\":1}}],[\"管道包\",{\"1\":{\"81\":1}}],[\"管道运行和单个标量指标\",{\"1\":{\"81\":1}}],[\"管道服务调用kubernetes\",{\"1\":{\"79\":1}}],[\"管道的执行过程如下\",{\"1\":{\"75\":1}}],[\"管道的数据科学家的平台\",{\"1\":{\"73\":1}}],[\"管理器直接使用pytorch中的原生gpu内存分配器\",{\"1\":{\"293\":1}}],[\"管理应用程序之间的会话\",{\"1\":{\"266\":1}}],[\"管理和终止会话\",{\"1\":{\"266\":1}}],[\"管理和协调工作流的各个部分\",{\"1\":{\"92\":1}}],[\"管理和调度超参数调优任务\",{\"1\":{\"92\":1}}],[\"管理工作流的持久化存储\",{\"1\":{\"92\":1}}],[\"管理存储\",{\"1\":{\"92\":1}}],[\"管理容器生命周期等\",{\"1\":{\"90\":1}}],[\"管理\",{\"1\":{\"26\":1,\"111\":1,\"116\":1}}],[\"管理员可以设置各种策略\",{\"1\":{\"238\":1}}],[\"管理员可以更好地管理和监控资源使用情况\",{\"1\":{\"14\":1}}],[\"管理员可以手动将\",{\"1\":{\"11\":1}}],[\"涵盖\",{\"1\":{\"73\":1}}],[\"下图展示了\",{\"1\":{\"74\":1}}],[\"下图展示了主要的\",{\"1\":{\"73\":1}}],[\"下面我给你具体讲一下\",{\"1\":{\"185\":1}}],[\"下面是每个\",{\"1\":{\"92\":1}}],[\"下面是你使用kong和nginx创建服务和路由的步骤总结\",{\"1\":{\"60\":1}}],[\"下面是对\",{\"1\":{\"32\":1}}],[\"下面最早创建的一个\",{\"1\":{\"0\":1}}],[\"只需要在交换机上配置相关的端口或接口即可\",{\"1\":{\"213\":1}}],[\"只有gpu\",{\"1\":{\"296\":1}}],[\"只有激活值在阶段之间传输\",{\"1\":{\"282\":1}}],[\"只有一个请求\",{\"1\":{\"198\":1}}],[\"只有rank为0的进程修改张量\",{\"1\":{\"149\":1}}],[\"只是数据不同\",{\"1\":{\"157\":1}}],[\"只要有足够的主机内存空间\",{\"1\":{\"296\":1}}],[\"只要不是调用系统调用\",{\"1\":{\"185\":1}}],[\"只要能够收集优化指标\",{\"1\":{\"101\":1}}],[\"只要您运行\",{\"1\":{\"73\":1}}],[\"只读权限\",{\"1\":{\"4\":1}}],[\"开放系统互连\",{\"1\":{\"261\":1}}],[\"开源技术\",{\"0\":{\"175\":1},\"2\":{\"180\":1}}],[\"开源系统部署到各种基础设施中\",{\"1\":{\"73\":1}}],[\"开发\",{\"0\":{\"117\":1},\"1\":{\"274\":2}}],[\"开发者首先需要定义\",{\"1\":{\"113\":1}}],[\"开发者指南是希望为该项目做出贡献的开发者的良好起点\",{\"1\":{\"100\":1}}],[\"开发完成管道后\",{\"1\":{\"84\":1}}],[\"开发与测试环境\",{\"1\":{\"22\":1}}],[\"开发环境中的资源限制\",{\"1\":{\"23\":1}}],[\"开发环境\",{\"1\":{\"17\":1}}],[\"服务器接收到数据后\",{\"1\":{\"270\":1}}],[\"服务器接受时才会正式请求\",{\"1\":{\"70\":1}}],[\"服务器可以主动推送相关的css和javascript文件\",{\"1\":{\"200\":1}}],[\"服务器可以在客户端请求之前主动发送资源\",{\"1\":{\"200\":1}}],[\"服务器只能响应客户端的请求\",{\"1\":{\"200\":1}}],[\"服务器推送\",{\"0\":{\"200\":1},\"1\":{\"205\":1}}],[\"服务一起用于\",{\"1\":{\"92\":1}}],[\"服务\",{\"1\":{\"92\":1}}],[\"服务自身健康检查\",{\"1\":{\"44\":1}}],[\"一些研究工作探索了在gpu内存不足时\",{\"1\":{\"303\":1}}],[\"一是它无法减少优化器状态\",{\"1\":{\"285\":1}}],[\"一周的时间足够开发一个新产品\",{\"1\":{\"274\":2}}],[\"一周开发一个新产品\",{\"1\":{\"274\":4}}],[\"一旦会话建立\",{\"1\":{\"239\":1}}],[\"一次性带你做个全面了解\",{\"1\":{\"185\":1}}],[\"一次运行\",{\"1\":{\"90\":1}}],[\"一组编排控制器执行完成管道所需的容器\",{\"1\":{\"80\":1}}],[\"一定要有\",{\"1\":{\"70\":1}}],[\"一个as是一组由同一管理实体管理的ip网络和路由器\",{\"1\":{\"238\":1}}],[\"一个是连接到传统二层网络的接口\",{\"1\":{\"219\":1}}],[\"一个是\",{\"1\":{\"185\":1}}],[\"一个由openai训练的大型语言模型\",{\"1\":{\"143\":1}}],[\"一个流行的工具包\",{\"1\":{\"117\":1}}],[\"一个连接基础设施\",{\"1\":{\"96\":1}}],[\"一个示例控制器是argo\",{\"1\":{\"80\":1}}],[\"一个\",{\"1\":{\"11\":1,\"274\":4}}],[\"一个写请求需要经过集群多数节点确认\",{\"1\":{\"0\":1}}],[\"添加规则\",{\"1\":{\"259\":1}}],[\"添加路由\",{\"1\":{\"256\":1}}],[\"添加新功能可以通过新帧类型和更复杂的协议操作来实现\",{\"1\":{\"203\":1}}],[\"添加\",{\"1\":{\"70\":1}}],[\"禁用定期运行\",{\"1\":{\"90\":1}}],[\"禁用缓存\",{\"1\":{\"70\":1}}],[\"禁用发夹模式\",{\"1\":{\"42\":1}}],[\"$$\",{\"1\":{\"137\":2}}],[\"$request\",{\"1\":{\"70\":1}}],[\"$remote\",{\"1\":{\"70\":1}}],[\"$upstream\",{\"1\":{\"70\":2}}],[\"$server\",{\"1\":{\"70\":1}}],[\"$scheme\",{\"1\":{\"70\":1}}],[\"$proxy\",{\"1\":{\"70\":1}}],[\"$host\",{\"1\":{\"70\":1}}],[\"$http\",{\"1\":{\"70\":1}}],[\"标记帧属于哪个vlan\",{\"1\":{\"213\":1}}],[\"标记帧\",{\"1\":{\"213\":1}}],[\"标准化管理流程\",{\"1\":{\"115\":1}}],[\"标准\",{\"1\":{\"70\":1}}],[\"标识符\",{\"1\":{\"215\":1}}],[\"标识\",{\"1\":{\"31\":3}}],[\"加密通信\",{\"1\":{\"235\":1}}],[\"加密是可选的\",{\"1\":{\"202\":1}}],[\"加密和安全\",{\"0\":{\"202\":1},\"1\":{\"205\":1}}],[\"加密算法\",{\"1\":{\"70\":1}}],[\"加速了模型数据的交换\",{\"1\":{\"299\":1}}],[\"加速长上下文\",{\"1\":{\"179\":1}}],[\"加速ai项目的落地与应用\",{\"1\":{\"124\":1}}],[\"加锁\",{\"1\":{\"0\":1}}],[\"渐变背景\",{\"1\":{\"70\":1}}],[\"<loopback>\",{\"1\":{\"211\":2}}],[\"<broadcast\",{\"1\":{\"210\":2,\"211\":2}}],[\"<body>\",{\"1\":{\"70\":1}}],[\"<stdio\",{\"1\":{\"165\":1}}],[\"<style>\",{\"1\":{\"70\":1}}],[\"<mpi\",{\"1\":{\"165\":1}}],[\"<meta\",{\"1\":{\"70\":2}}],[\"<p><a\",{\"1\":{\"70\":1}}],[\"<footer>\",{\"1\":{\"70\":1}}],[\"<title>hello\",{\"1\":{\"70\":1}}],[\"<h1>hello\",{\"1\":{\"70\":1}}],[\"<head>\",{\"1\":{\"70\":1}}],[\"<html\",{\"1\":{\"70\":1}}],[\"<\",{\"1\":{\"70\":7}}],[\"将张量交换到cpu内存的可能性\",{\"1\":{\"303\":1}}],[\"将张量沿某些维度进行分区\",{\"1\":{\"282\":1}}],[\"将优化器状态从gpu卸载到cpu\",{\"1\":{\"297\":1}}],[\"将gpu\",{\"1\":{\"291\":1}}],[\"将目标张量划分为若干子块\",{\"1\":{\"290\":1}}],[\"将这些优化策略嵌入到合适的位置\",{\"1\":{\"289\":1}}],[\"将输入张量进行分片\",{\"1\":{\"282\":1}}],[\"将现有解决方案分类为两种正交方向\",{\"1\":{\"282\":1}}],[\"将模型训练任务并行化到多个gpu设备上已经成为常态\",{\"1\":{\"282\":1}}],[\"将独立开发当作\",{\"1\":{\"274\":2}}],[\"将数据包通过数据链路层和物理层传输到目标服务器\",{\"1\":{\"270\":1}}],[\"将其mac地址伪装成另一个设备的mac地址\",{\"1\":{\"234\":1}}],[\"将其添加到\",{\"1\":{\"189\":1}}],[\"将二层以太网帧封装在三层ip包中\",{\"1\":{\"214\":1}}],[\"将新分区添加到\",{\"0\":{\"189\":1}}],[\"将动态稀疏注意力分为三种模式并设计搜索算法\",{\"1\":{\"179\":1}}],[\"将rank\",{\"1\":{\"149\":1}}],[\"将\",{\"1\":{\"115\":1}}],[\"将原始数据转换为预处理数据的\",{\"1\":{\"86\":1}}],[\"将最佳的\",{\"1\":{\"73\":1}}],[\"将特定的路径请求路由到相应的服务\",{\"1\":{\"70\":1}}],[\"将kong中的服务映射到nginx容器中的资源\",{\"1\":{\"70\":1}}],[\"将上述\",{\"1\":{\"27\":1}}],[\"页面\",{\"1\":{\"69\":1,\"274\":2}}],[\"90\",{\"1\":{\"301\":1}}],[\"90s\",{\"1\":{\"137\":1}}],[\"9091\",{\"1\":{\"137\":1}}],[\"9000\",{\"1\":{\"137\":4}}],[\"9001\",{\"1\":{\"137\":3}}],[\"9bzwq\",{\"1\":{\"92\":2}}],[\"92g5h\",{\"1\":{\"92\":2}}],[\"999\",{\"1\":{\"137\":2}}],[\"9999\",{\"1\":{\"31\":1}}],[\"9956596d8\",{\"1\":{\"92\":2}}],[\"9\",{\"0\":{\"69\":1,\"204\":1},\"1\":{\"137\":2,\"274\":4,\"301\":1}}],[\"xfs\",{\"1\":{\"191\":2}}],[\"xgboost\",{\"1\":{\"100\":1}}],[\"x\",{\"1\":{\"63\":1,\"64\":1,\"65\":1,\"66\":1,\"67\":1,\"68\":1,\"69\":1,\"70\":6,\"195\":1,\"196\":1,\"197\":1,\"198\":1,\"199\":1,\"200\":1,\"201\":1,\"202\":1,\"203\":1,\"204\":1,\"205\":1}}],[\"指的是一类独立的\",{\"1\":{\"274\":2}}],[\"指示其状态\",{\"1\":{\"89\":1}}],[\"指向nginx服务中的\",{\"1\":{\"63\":1}}],[\"指定进程id\",{\"1\":{\"183\":1}}],[\"指定\",{\"1\":{\"53\":1}}],[\"指定了具有相同标签\",{\"1\":{\"49\":1}}],[\"指定了限制适用于\",{\"1\":{\"21\":1}}],[\"指定了\",{\"1\":{\"16\":1}}],[\"按照kong官方文档安装指南安装了kong\",{\"1\":{\"62\":1}}],[\"安徵省高性能计算实验室和美国休斯顿大学\",{\"1\":{\"277\":1}}],[\"安装\",{\"0\":{\"171\":1}}],[\"安装kong\",{\"0\":{\"62\":1}}],[\"安全套接层\",{\"1\":{\"267\":1}}],[\"安全链接可选的加密协议\",{\"1\":{\"70\":1}}],[\"安全性和管理灵活性\",{\"1\":{\"216\":1}}],[\"安全性\",{\"1\":{\"0\":1,\"242\":1}}],[\"项目经验\",{\"0\":{\"126\":1}}],[\"项目是开源的\",{\"1\":{\"100\":1}}],[\"项目\",{\"1\":{\"100\":1}}],[\"项目致力于让机器学习\",{\"1\":{\"73\":1}}],[\"项目目录和nginx配置文件\",{\"1\":{\"61\":1}}],[\"项目来说\",{\"1\":{\"56\":1}}],[\"挂载\",{\"1\":{\"61\":1}}],[\"该服务器具有与前面实验相同的gpu配置\",{\"1\":{\"297\":1}}],[\"该服务器配备了8个v100\",{\"1\":{\"284\":1}}],[\"该系统由2000行c++和python代码组成\",{\"1\":{\"293\":1}}],[\"该算法会在后续配置相较于前一个配置的性能提升不明显时终止\",{\"1\":{\"291\":1}}],[\"该模型比较不同优化方法的时间成本\",{\"1\":{\"289\":1}}],[\"该计划确定在内存压力下应用内存优化的张量候选\",{\"1\":{\"289\":1}}],[\"该响应帧包含设备b的mac地址\",{\"1\":{\"231\":1}}],[\"该arp请求包含设备b的ip地址\",{\"1\":{\"231\":1}}],[\"该帧首先被发送到本地的vtep\",{\"1\":{\"220\":1}}],[\"该命令会列出系统中所有的网络接口\",{\"1\":{\"207\":1}}],[\"该配置文件只是给快速启动\",{\"1\":{\"137\":1}}],[\"该容器暴露8088端口并挂载了配置文件和项目目录\",{\"1\":{\"61\":1}}],[\"该状态表示\",{\"1\":{\"7\":1,\"8\":1,\"9\":1,\"10\":1}}],[\"笔记\",{\"2\":{\"59\":1}}],[\"笔记总结\",{\"1\":{\"3\":1}}],[\"7的242gb模型数据应用gpu\",{\"1\":{\"301\":1}}],[\"70\",{\"1\":{\"297\":1}}],[\"700\",{\"1\":{\"136\":1}}],[\"7倍\",{\"1\":{\"296\":1}}],[\"77gb\",{\"1\":{\"295\":1}}],[\"77d684cf4\",{\"1\":{\"92\":2}}],[\"7e\",{\"1\":{\"211\":2}}],[\"7897\",{\"1\":{\"137\":2}}],[\"78d9bcc678\",{\"1\":{\"92\":2}}],[\"799c5f4b48\",{\"1\":{\"92\":2}}],[\"7cc7c5b47\",{\"1\":{\"92\":2}}],[\"7c6vk\",{\"1\":{\"92\":2}}],[\"7d7dffdb8f\",{\"1\":{\"92\":2}}],[\"7\",{\"0\":{\"67\":1,\"202\":1,\"268\":1},\"1\":{\"137\":2,\"295\":1,\"301\":1}}],[\"74\",{\"1\":{\"57\":1}}],[\"725\",{\"1\":{\"57\":1}}],[\"6的gpu内存\",{\"1\":{\"301\":1}}],[\"6倍\",{\"1\":{\"300\":1}}],[\"67b\",{\"1\":{\"301\":2}}],[\"67b时\",{\"1\":{\"296\":1}}],[\"67b和4b\",{\"1\":{\"295\":1}}],[\"64b时\",{\"1\":{\"296\":1}}],[\"64b是一个中等规模的模型\",{\"1\":{\"295\":1}}],[\"64b模型\",{\"1\":{\"282\":1}}],[\"64\",{\"1\":{\"211\":1}}],[\"6c686b5b54\",{\"1\":{\"92\":2}}],[\"66457c4745\",{\"1\":{\"92\":2}}],[\"65536\",{\"1\":{\"211\":2}}],[\"65j6h\",{\"1\":{\"92\":2}}],[\"65\",{\"1\":{\"70\":1}}],[\"6\",{\"0\":{\"66\":1,\"192\":1,\"201\":1,\"267\":1},\"1\":{\"137\":5,\"295\":1,\"297\":1,\"301\":3}}],[\"61\",{\"1\":{\"92\":1}}],[\"619995\",{\"1\":{\"57\":1}}],[\"619656\",{\"1\":{\"57\":1}}],[\"611818\",{\"1\":{\"57\":1}}],[\"608035\",{\"1\":{\"57\":1}}],[\"607274\",{\"1\":{\"57\":1}}],[\"605172\",{\"1\":{\"57\":1}}],[\"604995\",{\"1\":{\"57\":1}}],[\"o带宽的存储空间进行张量交换\",{\"1\":{\"297\":1}}],[\"out任务分别管理两个额外的线程\",{\"1\":{\"293\":1}}],[\"output\",{\"1\":{\"90\":1}}],[\"osi模型通过将网络通信过程划分为七个独立的层次\",{\"1\":{\"271\":1}}],[\"o\",{\"1\":{\"162\":1,\"185\":4}}],[\"ok\",{\"1\":{\"137\":1}}],[\"of\",{\"1\":{\"100\":1}}],[\"offload将优化器状态卸载到cpu会在每个微批次中导致频繁的数据移动\",{\"1\":{\"297\":1}}],[\"offload的gpu计算效率高出20\",{\"1\":{\"297\":1}}],[\"offload\",{\"1\":{\"297\":3}}],[\"offload和zero\",{\"1\":{\"295\":1,\"303\":1}}],[\"off\",{\"1\":{\"70\":3}}],[\"octet\",{\"1\":{\"70\":1}}],[\"org\",{\"1\":{\"73\":1}}],[\"origin\",{\"1\":{\"70\":2}}],[\"or\",{\"1\":{\"57\":1}}],[\"one\",{\"1\":{\"137\":2,\"274\":1}}],[\"oneapimmysql\",{\"1\":{\"137\":2}}],[\"oneapi\",{\"0\":{\"140\":1},\"1\":{\"137\":7}}],[\"onyx\",{\"1\":{\"136\":3}}],[\"on\",{\"0\":{\"133\":1},\"1\":{\"57\":3,\"70\":2,\"93\":1,\"137\":3,\"141\":1,\"143\":3,\"277\":2},\"2\":{\"145\":1}}],[\"opt\",{\"1\":{\"137\":1,\"143\":1}}],[\"optuna\",{\"1\":{\"101\":1}}],[\"optimization\",{\"1\":{\"100\":1}}],[\"options\",{\"1\":{\"70\":4}}],[\"operation\",{\"1\":{\"232\":1}}],[\"operator\",{\"0\":{\"111\":1,\"112\":1,\"113\":1,\"114\":1,\"115\":1,\"116\":1,\"117\":1},\"1\":{\"31\":1,\"49\":1,\"51\":1,\"101\":1,\"111\":3,\"112\":1,\"113\":3,\"114\":5,\"115\":3,\"116\":3,\"117\":4,\"118\":4,\"277\":2},\"2\":{\"120\":1}}],[\"open消息以建立bgp会话\",{\"1\":{\"239\":1}}],[\"openmpi\",{\"1\":{\"163\":1}}],[\"open\",{\"1\":{\"143\":2}}],[\"openai\",{\"1\":{\"136\":12,\"137\":2}}],[\"openapi\",{\"1\":{\"136\":1}}],[\"openssl\",{\"1\":{\"70\":1,\"137\":1}}],[\"op=exists\",{\"1\":{\"31\":2}}],[\"jpeg\",{\"1\":{\"267\":1}}],[\"j\",{\"1\":{\"259\":2}}],[\"js\",{\"1\":{\"137\":2}}],[\"js进行动态\",{\"1\":{\"125\":1}}],[\"json5\",{\"1\":{\"136\":1}}],[\"json\",{\"1\":{\"26\":1,\"55\":2,\"137\":2}}],[\"java\",{\"1\":{\"122\":1}}],[\"jobservice\",{\"1\":{\"103\":1,\"106\":1}}],[\"job\",{\"1\":{\"90\":1}}],[\"justify\",{\"1\":{\"70\":1}}],[\"jul\",{\"1\":{\"57\":8}}],[\"解密\",{\"1\":{\"267\":1}}],[\"解封装的以太网帧被发送到目标主机b所在的二层网络\",{\"1\":{\"220\":1}}],[\"解封装出原始的以太网帧\",{\"1\":{\"220\":1}}],[\"解释命令\",{\"0\":{\"183\":1}}],[\"解决十亿规模模型训练中的gpu内存壁垒问题\",{\"1\":{\"304\":1}}],[\"解决复杂的系统问题\",{\"1\":{\"122\":1}}],[\"解决了\",{\"1\":{\"101\":1}}],[\"解决\",{\"1\":{\"57\":1}}],[\"解析\",{\"1\":{\"33\":1}}],[\"库来实现的\",{\"1\":{\"56\":1}}],[\"发布等环节\",{\"1\":{\"274\":2}}],[\"发布\",{\"1\":{\"274\":4}}],[\"发送设备的ip地址\",{\"1\":{\"232\":1}}],[\"发送设备的mac地址\",{\"1\":{\"232\":1}}],[\"发送方协议地址\",{\"1\":{\"232\":1}}],[\"发送方硬件地址\",{\"1\":{\"232\":1}}],[\"发生中断后的工作是必须要完成的\",{\"1\":{\"185\":1}}],[\"发出一个\",{\"1\":{\"185\":1}}],[\"发起真正的\",{\"1\":{\"56\":1}}],[\"发夹模式\",{\"1\":{\"40\":1}}],[\"所有这些并行策略在支持十亿规模的单服务器训练时都会遇到gpu内存瓶颈\",{\"1\":{\"282\":1}}],[\"所有请求被平等对待\",{\"1\":{\"201\":1}}],[\"所有处理单元\",{\"1\":{\"151\":1}}],[\"所以这个硬中断的时间不能太长\",{\"1\":{\"185\":1}}],[\"所以这时候\",{\"1\":{\"56\":1}}],[\"所以应在必要时使用\",{\"1\":{\"185\":1}}],[\"所管理的宿主机上不可压缩资源短缺时\",{\"1\":{\"46\":1}}],[\"给\",{\"1\":{\"56\":1}}],[\"udp\",{\"1\":{\"265\":1}}],[\"udp包的源ip和目的ip是vtep的ip地址\",{\"1\":{\"220\":1}}],[\"udp隧道封装\",{\"1\":{\"215\":1}}],[\"umount\",{\"1\":{\"187\":1}}],[\"usage\",{\"1\":{\"185\":1}}],[\"us\",{\"1\":{\"185\":4}}],[\"user\",{\"1\":{\"185\":1}}],[\"username=myusername\",{\"1\":{\"137\":1}}],[\"use\",{\"1\":{\"143\":2}}],[\"usedinqueryextension\",{\"1\":{\"136\":2}}],[\"usedintoolcall\",{\"1\":{\"136\":2}}],[\"usedinextractfields\",{\"1\":{\"136\":2}}],[\"usedinclassify\",{\"1\":{\"136\":2}}],[\"ubuntu\",{\"0\":{\"170\":1}}],[\"up>\",{\"1\":{\"210\":2,\"211\":2}}],[\"up\",{\"1\":{\"210\":2,\"211\":4,\"247\":1,\"253\":1}}],[\"update\",{\"1\":{\"137\":2,\"239\":1}}],[\"upgrade\",{\"1\":{\"70\":3}}],[\"uri=mongodb\",{\"1\":{\"137\":1}}],[\"url是oneapi中的令牌地址\",{\"1\":{\"137\":1}}],[\"urls\",{\"1\":{\"137\":1}}],[\"urls=http\",{\"1\":{\"137\":1}}],[\"url=http\",{\"1\":{\"137\":2}}],[\"url=\",{\"1\":{\"63\":1}}],[\"url\",{\"1\":{\"56\":3}}],[\"u\",{\"1\":{\"137\":2}}],[\"ui库的使用\",{\"1\":{\"125\":1}}],[\"ui\",{\"1\":{\"84\":1,\"89\":1,\"90\":3,\"92\":6,\"98\":2,\"99\":1,\"125\":1}}],[\"utf\",{\"1\":{\"70\":1}}],[\"unknown\",{\"1\":{\"210\":2}}],[\"until\",{\"1\":{\"137\":1}}],[\"untolerated\",{\"1\":{\"31\":1}}],[\"unconfined\",{\"1\":{\"137\":1,\"143\":1}}],[\"uninterruptible\",{\"1\":{\"185\":1}}],[\"universal\",{\"1\":{\"117\":1}}],[\"unix\",{\"1\":{\"57\":2}}],[\"unreachable\",{\"1\":{\"31\":1}}],[\"unlock\",{\"1\":{\"0\":3}}],[\"依赖于一套独立的\",{\"1\":{\"56\":1}}],[\"我想给你做个补充\",{\"1\":{\"185\":1}}],[\"我的家人\",{\"1\":{\"143\":1}}],[\"我拥有将技术与商业需求相结合的能力\",{\"1\":{\"126\":1}}],[\"我在java领域有着深厚的积累\",{\"1\":{\"122\":1}}],[\"我不仅关注性能优化和可扩展性\",{\"1\":{\"121\":1}}],[\"我始终追求技术创新\",{\"1\":{\"121\":1}}],[\"我是一名充满热情的全栈开发工程师\",{\"1\":{\"121\":1}}],[\"我们相信\",{\"1\":{\"304\":1}}],[\"我们预计每个gpu的pcie带宽需要超过140gb\",{\"1\":{\"302\":1}}],[\"我们发现\",{\"1\":{\"302\":1}}],[\"我们得出结论\",{\"1\":{\"299\":1}}],[\"我们设计了一个极端案例\",{\"1\":{\"299\":1}}],[\"我们设计了一种设备\",{\"1\":{\"290\":1}}],[\"我们进行了简单的分析\",{\"1\":{\"302\":1}}],[\"我们进行了敏感性分析\",{\"1\":{\"298\":1}}],[\"我们进一步构建了一个独立于pytorch运行时的主机固定内存池\",{\"1\":{\"293\":1}}],[\"我们进一步演进了数据分条技术\",{\"1\":{\"290\":1}}],[\"我们无法在上述amazon\",{\"1\":{\"297\":1}}],[\"我们测试了参数规模为6\",{\"1\":{\"296\":1}}],[\"我们测量了每秒处理的样本总数\",{\"1\":{\"295\":1}}],[\"我们首先分析了参数规模为0\",{\"1\":{\"296\":1}}],[\"我们首先执行生命周期变量分析来计算每个张量的生命周期\",{\"1\":{\"291\":1}}],[\"我们运行了两种mpress变体\",{\"1\":{\"295\":1}}],[\"我们通过在pipedream和dapple系统中集成mpress\",{\"1\":{\"304\":1}}],[\"我们通过以下几个方面分析了结果\",{\"1\":{\"296\":1}}],[\"我们通过测量模型前向传播的flops\",{\"1\":{\"295\":1}}],[\"我们通过调整编码器层的数量和隐藏层的大小\",{\"1\":{\"295\":1}}],[\"我们通过将pipedream的原始pytorch版本从1\",{\"1\":{\"293\":1}}],[\"我们选择了两个广泛使用的dnn模型bert和gpt\",{\"1\":{\"295\":1}}],[\"我们选择操作间并行作为研究的出发点\",{\"1\":{\"282\":1}}],[\"我们在一台高端gpu服务器上运行测试\",{\"1\":{\"297\":1}}],[\"我们在pipedream上运行mpress\",{\"1\":{\"295\":1}}],[\"我们在dgx\",{\"1\":{\"295\":1}}],[\"我们在执行交换操作之前记录子块数量\",{\"1\":{\"290\":1}}],[\"我们决定使用固定内存作为交换空间\",{\"1\":{\"293\":1}}],[\"我们就接受它\",{\"1\":{\"291\":1}}],[\"我们就称之为\",{\"1\":{\"56\":1}}],[\"我们尽量使用d2d交换来减少它们的内存占用\",{\"1\":{\"291\":1}}],[\"我们的搜索算法不会带来高额的开销\",{\"1\":{\"299\":1}}],[\"我们的配额申请多次失败\",{\"1\":{\"295\":1}}],[\"我们的评估旨在回答以下几个问题\",{\"1\":{\"294\":1}}],[\"我们的内存管理器负责为张量分配和释放gpu\",{\"1\":{\"293\":1}}],[\"我们的算法会经历一些迭代步骤来逐步更新内存减少优化配置\",{\"1\":{\"291\":1}}],[\"我们的目标不是重新创建其他服务\",{\"1\":{\"73\":1}}],[\"我们将本文的相关工作分为以下几类进行讨论\",{\"1\":{\"303\":1}}],[\"我们将mpress与三个强大的基线系统进行了对比\",{\"1\":{\"297\":1}}],[\"我们将mpress集成到了pipedream和dapple这两个最近的操作间并行训练系统中\",{\"1\":{\"293\":1}}],[\"我们将原始dapple作为自然基线\",{\"1\":{\"295\":1}}],[\"我们将微批次大小设置为2\",{\"1\":{\"295\":1}}],[\"我们将微批次大小设置为12\",{\"1\":{\"295\":1}}],[\"我们将继续使mpress适用于这些系统\",{\"1\":{\"293\":1}}],[\"我们将上述设计原则集成到开源训练系统mpress中\",{\"1\":{\"293\":1}}],[\"我们将gpu\",{\"1\":{\"291\":1}}],[\"我们将子块划分为等大小\",{\"1\":{\"290\":1}}],[\"我们引入了一个近似的搜索算法\",{\"1\":{\"291\":1}}],[\"我们引入了以下两项关键技术来优化d2d交换\",{\"1\":{\"290\":1}}],[\"我们应该只将d2d交换应用于性能至关重要的情况\",{\"1\":{\"291\":1}}],[\"我们应该优先考虑对模型的后期层使用重计算来缓解内存限制\",{\"1\":{\"291\":1}}],[\"我们还报告了每种优化方法对gpu内存减少的百分比贡献\",{\"1\":{\"301\":1}}],[\"我们还可以将其优化为多线程版本\",{\"1\":{\"299\":1}}],[\"我们还评估了运行设备映射算法的时间开销\",{\"1\":{\"299\":1}}],[\"我们还运行了两个最先进的训练系统\",{\"1\":{\"295\":1}}],[\"我们还部署了两种系统作为基线\",{\"1\":{\"295\":1}}],[\"我们还使用了另一台提供商的dgx\",{\"1\":{\"295\":1}}],[\"我们还管理了一个元数据表\",{\"1\":{\"290\":1}}],[\"我们还剩两个类型的\",{\"1\":{\"185\":1}}],[\"我们必须综合考虑以下两个关键因素\",{\"1\":{\"290\":1}}],[\"我们使用不同参数规模的gpt模型在dgx\",{\"1\":{\"297\":1}}],[\"我们使用bert和gpt模型推荐的计算平衡阶段分区策略\",{\"1\":{\"295\":1}}],[\"我们使用原始的pipedream作为没有内存优化的基线操作间并行训练系统\",{\"1\":{\"295\":1}}],[\"我们使用调整后的参数对gpt及其变体进行训练\",{\"1\":{\"295\":1}}],[\"我们使用squad\",{\"1\":{\"295\":1}}],[\"我们使用模拟器运行最新的配置\",{\"1\":{\"291\":1}}],[\"我们使用模拟器根据修改后的数据流图执行一次训练迭代\",{\"1\":{\"289\":1}}],[\"我们使用pipedream和dapple两个代表性系统训练了两个流行的dnn模型bert和gpt\",{\"1\":{\"284\":1}}],[\"我们可以积极满足每个gpu的内存交换带宽需求\",{\"1\":{\"288\":1}}],[\"我们可以用上面这张图\",{\"1\":{\"185\":1}}],[\"我们只对少量生命周期较短的模型数据应用d2d交换\",{\"1\":{\"288\":1}}],[\"我们提出了一个近似搜索算法\",{\"1\":{\"291\":1}}],[\"我们提出了一种新的gpu\",{\"1\":{\"286\":1}}],[\"我们提出了mpress\",{\"1\":{\"288\":1,\"304\":1}}],[\"我们专注于通过操作间并行实现十亿规模模型的高效训练\",{\"1\":{\"282\":1}}],[\"我们介绍了大部分的\",{\"1\":{\"185\":1}}],[\"我才能有机会\",{\"1\":{\"0\":1}}],[\"需要注意的是\",{\"1\":{\"289\":1,\"293\":1,\"297\":1}}],[\"需要保存多版本的模型数据\",{\"1\":{\"284\":1}}],[\"需要有心理准备\",{\"1\":{\"274\":2}}],[\"需要重申审视是不是你的产品功能和特性不够\",{\"1\":{\"274\":2}}],[\"需要考虑产品适合使用哪种产品形态\",{\"1\":{\"274\":2}}],[\"需要大致正确即可\",{\"1\":{\"274\":2}}],[\"需要专业知识和经验\",{\"1\":{\"243\":1}}],[\"需要额外的配置和措施来防止路由劫持和攻击\",{\"1\":{\"242\":1}}],[\"需要深入的网络知识\",{\"1\":{\"242\":1}}],[\"需要配置隧道端点\",{\"1\":{\"215\":1}}],[\"需要等待当前请求完成后\",{\"1\":{\"198\":1}}],[\"需要同时计算两个独立的物理过程\",{\"1\":{\"159\":1}}],[\"需要最新版的\",{\"1\":{\"136\":1}}],[\"需要跟容器项目维护一个长连接来传输数据\",{\"1\":{\"56\":1}}],[\"需要手动编辑对应的\",{\"1\":{\"29\":1}}],[\"需要手工处理\",{\"1\":{\"5\":1}}],[\"问题背景\",{\"0\":{\"278\":1}}],[\"问题\",{\"1\":{\"55\":1,\"302\":1}}],[\"启用重计算的dapple能够成功训练最多10\",{\"1\":{\"297\":1}}],[\"启用了高性能重计算\",{\"1\":{\"297\":1}}],[\"启用或禁用接口\",{\"1\":{\"247\":1,\"253\":1}}],[\"启用\",{\"1\":{\"90\":1}}],[\"启用发夹模式\",{\"1\":{\"42\":1}}],[\"启动张量传输任务并与dnn计算同步检查其状态\",{\"1\":{\"293\":1}}],[\"启动\",{\"1\":{\"185\":1}}],[\"启动聚合更新\",{\"1\":{\"137\":1}}],[\"启动mongodb服务\",{\"1\":{\"137\":1}}],[\"启动时就一起启动\",{\"1\":{\"56\":1}}],[\"启动调度器时使用该策略文件\",{\"1\":{\"55\":1}}],[\"数值模拟\",{\"1\":{\"153\":1,\"164\":1}}],[\"数据是在前面的d2d交换默认设置基础上进行的\",{\"1\":{\"299\":1}}],[\"数据并行训练带来了最重的内存负担和跨gpu通信开销\",{\"1\":{\"282\":1}}],[\"数据并行作为最简单的操作内并行\",{\"1\":{\"282\":1}}],[\"数据并行\",{\"1\":{\"282\":1}}],[\"数据分条使mpress性能比默认设置提高了11\",{\"1\":{\"299\":1}}],[\"数据分条\",{\"1\":{\"290\":1}}],[\"数据分段和重组\",{\"1\":{\"265\":1}}],[\"数据分析\",{\"1\":{\"164\":1}}],[\"数据分析和异构计算等领域\",{\"1\":{\"161\":1}}],[\"数据链路层\",{\"0\":{\"263\":1}}],[\"数据中心和云环境中的大规模虚拟化网络\",{\"1\":{\"214\":1}}],[\"数据处理等需要处理大量计算的场景\",{\"1\":{\"163\":1}}],[\"数据的划分方式可以根据具体应用进行调整\",{\"1\":{\"156\":1}}],[\"数据的数据库\",{\"1\":{\"92\":1}}],[\"数据库最大连接数\",{\"1\":{\"137\":1}}],[\"数据库的默认账号和密码仅首次运行时设置有效\",{\"1\":{\"137\":1}}],[\"数据库的创建\",{\"1\":{\"116\":1}}],[\"数据库集群的创建\",{\"1\":{\"114\":1}}],[\"数据库管理器\",{\"1\":{\"92\":1}}],[\"数据可视化和认证功能\",{\"1\":{\"106\":1}}],[\"数据可能仍然存在于\",{\"1\":{\"9\":1}}],[\"数据转换\",{\"1\":{\"85\":1}}],[\"数据工件列表\",{\"1\":{\"83\":1}}],[\"数量与其他节点上的最大偏差不超过1\",{\"1\":{\"53\":1}}],[\"应运而生\",{\"1\":{\"179\":1}}],[\"应该均匀地分布在不同的节点上\",{\"1\":{\"53\":1}}],[\"应用哪种优化以及何时执行相应的优化或恢复被节省的张量\",{\"1\":{\"289\":1}}],[\"应用示例\",{\"0\":{\"270\":1}}],[\"应用层的http协议将请求传递到传输层的tcp协议\",{\"1\":{\"270\":1}}],[\"应用层\",{\"0\":{\"268\":1}}],[\"应用场景\",{\"0\":{\"153\":1,\"158\":1},\"1\":{\"157\":1,\"215\":1}}],[\"应用部署和管理\",{\"1\":{\"114\":1}}],[\"应用\",{\"1\":{\"113\":1}}],[\"应用需要自定义的服务发现机制\",{\"1\":{\"34\":1}}],[\"应用程序的配置\",{\"1\":{\"111\":1}}],[\"应用程序的资源标准化和资源优化\",{\"1\":{\"23\":1}}],[\"应用程序使用通用的标签和注释\",{\"1\":{\"98\":1}}],[\"应用程序级别的健康检查\",{\"1\":{\"96\":1}}],[\"应用程序\",{\"0\":{\"95\":1}}],[\"应用程序标准化\",{\"1\":{\"22\":1}}],[\"应用类型\",{\"1\":{\"20\":1}}],[\"均匀地分布在集群的不同节点上\",{\"1\":{\"52\":1}}],[\"呢\",{\"0\":{\"47\":1}}],[\"堆叠\",{\"0\":{\"47\":1},\"1\":{\"47\":1,\"55\":1}}],[\"避免了gpu\",{\"1\":{\"303\":1}}],[\"避免\",{\"0\":{\"47\":1},\"1\":{\"47\":1,\"55\":1}}],[\"避免单点故障\",{\"1\":{\"0\":1}}],[\"操作内并行则通过将操作符拆分成更小的部分来工作\",{\"1\":{\"282\":1}}],[\"操作内并行依赖于一个操作符在具有多个维度的张量上工作\",{\"1\":{\"282\":1}}],[\"操作间并行\",{\"0\":{\"283\":1}}],[\"操作间并行已受到工业界和学术界的广泛关注\",{\"1\":{\"282\":1}}],[\"操作间并行训练引入的通信开销最少\",{\"1\":{\"282\":1}}],[\"操作间并行训练将目标dnn模型划分为不相交的阶段\",{\"1\":{\"282\":1}}],[\"操作间并行性\",{\"1\":{\"279\":1}}],[\"操作码\",{\"1\":{\"232\":1}}],[\"操作系统\",{\"0\":{\"182\":1},\"2\":{\"193\":1,\"194\":1}}],[\"操作\",{\"1\":{\"46\":1}}],[\"才能开始下一个请求\",{\"1\":{\"198\":1}}],[\"才可能被选中进行\",{\"1\":{\"46\":1}}],[\"才会开始\",{\"1\":{\"46\":1}}],[\">请求workflow\",{\"1\":{\"108\":1}}],[\">8888888<\",{\"1\":{\"70\":1}}],[\">\",{\"1\":{\"46\":2,\"70\":3,\"137\":3}}],[\"监控和优化\",{\"1\":{\"92\":1}}],[\"监控和管理\",{\"0\":{\"29\":1}}],[\"监控到的数据\",{\"1\":{\"46\":1}}],[\"读取到的值\",{\"1\":{\"46\":1}}],[\"读写权限\",{\"1\":{\"4\":2}}],[\"阈值的数据来源\",{\"1\":{\"46\":1}}],[\"计算资源的高需求\",{\"1\":{\"282\":1}}],[\"计算机网络\",{\"0\":{\"195\":1}}],[\"计算\",{\"1\":{\"46\":1}}],[\"而是将d2d交换\",{\"1\":{\"303\":1}}],[\"而是提供一种简单的方法\",{\"1\":{\"73\":1}}],[\"而速度较慢的层存储生命周期较长的数据\",{\"1\":{\"302\":1}}],[\"而且供应量非常有限\",{\"1\":{\"302\":1}}],[\"而且这些激活值通常很小\",{\"1\":{\"282\":1}}],[\"而重计算的贡献最大\",{\"1\":{\"301\":1}}],[\"而重计算引入了3毫秒的额外前向计算\",{\"1\":{\"300\":1}}],[\"而对于t5\",{\"1\":{\"300\":1}}],[\"而d2d交换则可以用于其他对性能更关键的任务\",{\"1\":{\"300\":1}}],[\"而后者则进一步最大化了数据传输带宽\",{\"1\":{\"299\":1}}],[\"而数据分条优化使性能进一步提高了33\",{\"1\":{\"299\":1}}],[\"而v100的内存为32gb\",{\"1\":{\"297\":1}}],[\"而vxlan适用于大规模数据中心和云环境中的网络虚拟化和扩展\",{\"1\":{\"216\":1}}],[\"而zero\",{\"1\":{\"297\":1}}],[\"而其他系统因内存不足而失败\",{\"1\":{\"296\":1}}],[\"而其他四个系统成功执行了训练任务\",{\"1\":{\"296\":1}}],[\"而内存优化操作则由执行器执行\",{\"1\":{\"289\":1}}],[\"而这些数据占用了大量gpu内存\",{\"1\":{\"285\":1}}],[\"而这些通信位于训练的关键路径上\",{\"1\":{\"282\":1}}],[\"而无需再次发送arp请求\",{\"1\":{\"231\":1}}],[\"而第二个进程在\",{\"1\":{\"159\":1}}],[\"而容器则会启动你的程序\",{\"1\":{\"84\":1}}],[\"而只会返回一个\",{\"1\":{\"56\":1}}],[\"而负责响应这个接口的\",{\"1\":{\"56\":1}}],[\"而\",{\"1\":{\"46\":1,\"56\":1,\"185\":1}}],[\"而不影响现有的功能\",{\"1\":{\"203\":1}}],[\"而不必等待接收方确认\",{\"1\":{\"162\":1}}],[\"而不是动态学习到的\",{\"1\":{\"226\":1}}],[\"而不是共享内存\",{\"1\":{\"162\":1}}],[\"而不是应用程序本身\",{\"1\":{\"95\":1}}],[\"而不是\",{\"1\":{\"34\":1}}],[\"而不是通过负载均衡器来访问\",{\"1\":{\"33\":1}}],[\"而不是通过\",{\"1\":{\"25\":1}}],[\"而不依赖于\",{\"1\":{\"28\":1}}],[\"分别在不同的gpu上运行\",{\"1\":{\"303\":1}}],[\"分别在现代gpu服务器\",{\"1\":{\"280\":1}}],[\"分别是启用gpu\",{\"1\":{\"295\":1}}],[\"分别是通过输入样本分区\",{\"1\":{\"282\":1}}],[\"分别用于发送和接收消息\",{\"1\":{\"162\":1}}],[\"分区空间\",{\"1\":{\"188\":1}}],[\"分区\",{\"0\":{\"187\":1},\"1\":{\"186\":1,\"187\":1}}],[\"分类\",{\"1\":{\"136\":2}}],[\"分片\",{\"1\":{\"114\":1}}],[\"分布式架构\",{\"1\":{\"214\":1}}],[\"分布式\",{\"2\":{\"167\":1}}],[\"分布式计算和大规模数据处理任务中的主流选择\",{\"1\":{\"166\":1}}],[\"分布式深度学习\",{\"1\":{\"153\":1}}],[\"分布式训练\",{\"1\":{\"148\":1}}],[\"分布式调度策略\",{\"0\":{\"52\":1}}],[\"分布式锁\",{\"2\":{\"2\":1}}],[\"分布式锁的三个主要核心要素\",{\"1\":{\"0\":1}}],[\"分布式锁最终是由写入此\",{\"1\":{\"0\":1}}],[\"分布在不同的节点上\",{\"1\":{\"47\":1}}],[\"分布在不同机器上\",{\"0\":{\"47\":1}}],[\"分钟之后\",{\"1\":{\"46\":1}}],[\"就不会引入额外的时间延迟\",{\"1\":{\"291\":1}}],[\"就不会再犹豫\",{\"1\":{\"185\":1}}],[\"就都属于\",{\"1\":{\"185\":1}}],[\"就可以发布了\",{\"1\":{\"274\":2}}],[\"就可以查看这个图\",{\"1\":{\"89\":1}}],[\"就可以运行\",{\"1\":{\"73\":1}}],[\"就是一个高级的控制器\",{\"1\":{\"112\":1}}],[\"就是直接调用\",{\"1\":{\"56\":1}}],[\"就是该\",{\"1\":{\"56\":1}}],[\"就会进入到第八个框\",{\"1\":{\"185\":1}}],[\"就会进入\",{\"1\":{\"185\":1}}],[\"就会进行一些文件系统层的操作\",{\"1\":{\"185\":1}}],[\"就会通过重定向来向\",{\"1\":{\"56\":1}}],[\"就会把它以\",{\"1\":{\"56\":1}}],[\"就会调用\",{\"1\":{\"56\":2}}],[\"就意味着当\",{\"1\":{\"46\":1}}],[\"就有可能触发\",{\"1\":{\"46\":1}}],[\"两者的价格和容量差异主要是由不同的制造工艺导致的\",{\"1\":{\"302\":1}}],[\"两者结合使用\",{\"1\":{\"23\":1}}],[\"两台机器都运行了ubuntu\",{\"1\":{\"295\":1}}],[\"两种mpress变体表现最好且性能相同\",{\"1\":{\"296\":1}}],[\"两种交换方法的优势在于它们不消耗gpu的计算资源\",{\"1\":{\"291\":1}}],[\"两种模式\",{\"1\":{\"46\":1}}],[\"两个主机连续阶段的gpu之间仅交换每个微批次1\",{\"1\":{\"282\":1}}],[\"两个bgp路由器\",{\"1\":{\"239\":1}}],[\"两个进程之间直接进行消息传递\",{\"1\":{\"162\":1}}],[\"里对\",{\"1\":{\"56\":1}}],[\"里其实分为\",{\"1\":{\"46\":1}}],[\"里都是可配置的\",{\"1\":{\"46\":1}}],[\"等并行计算框架为\",{\"1\":{\"161\":1}}],[\"等并行计算框架通常支持\",{\"1\":{\"156\":1}}],[\"等工具进行协调和通信\",{\"1\":{\"159\":1}}],[\"等工具创建和管理自定义资源\",{\"1\":{\"113\":1}}],[\"等待docker\",{\"1\":{\"137\":1}}],[\"等待mongodb服务启动\",{\"1\":{\"137\":1}}],[\"等\",{\"1\":{\"92\":1,\"100\":1,\"163\":1,\"222\":1,\"262\":1,\"263\":1,\"264\":1,\"268\":1}}],[\"等接口\",{\"0\":{\"56\":1}}],[\"等等\",{\"1\":{\"46\":1,\"100\":1}}],[\"等信息\",{\"1\":{\"0\":1}}],[\"划分的主要应用场景\",{\"1\":{\"46\":1}}],[\"qlen\",{\"1\":{\"210\":2,\"211\":4}}],[\"qdisc\",{\"1\":{\"210\":2,\"211\":4}}],[\"quick\",{\"1\":{\"142\":1}}],[\"quay\",{\"1\":{\"137\":1}}],[\"queryconfig\",{\"1\":{\"136\":1}}],[\"quotemaxtoken\",{\"1\":{\"136\":2}}],[\"quota\",{\"1\":{\"15\":1,\"137\":1}}],[\"qa\",{\"1\":{\"136\":1}}],[\"qamaxprocess\",{\"1\":{\"136\":1}}],[\"q9ddn\",{\"1\":{\"92\":2}}],[\"qos\",{\"1\":{\"46\":2,\"57\":1}}],[\"资源分配和同步通信\",{\"1\":{\"268\":1}}],[\"资源消耗过高等\",{\"1\":{\"184\":1}}],[\"资源短缺\",{\"0\":{\"46\":1}}],[\"资源优化\",{\"1\":{\"22\":1}}],[\"某些科学计算或仿真任务可能需要不同的计算步骤\",{\"1\":{\"157\":1}}],[\"某些服务需要通过\",{\"1\":{\"44\":1}}],[\"某些pv可能支持多种访问模式\",{\"1\":{\"4\":1}}],[\"b\",{\"0\":{\"289\":1,\"296\":1}}],[\"billion\",{\"1\":{\"277\":2}}],[\"bgp的配置和管理也相对复杂\",{\"1\":{\"243\":1}}],[\"bgp缺乏内置的安全机制\",{\"1\":{\"242\":1}}],[\"bgp在处理大型网络拓扑变化时的收敛时间较长\",{\"1\":{\"242\":1}}],[\"bgp配置和管理相对复杂\",{\"1\":{\"242\":1}}],[\"bgp设计用于在大型\",{\"1\":{\"241\":1}}],[\"bgp允许管理员根据特定需求配置路由策略\",{\"1\":{\"241\":1}}],[\"bgp允许网络管理员基于策略控制路由选择和路由传播\",{\"1\":{\"238\":1}}],[\"bgp能够处理大量的路由信息\",{\"1\":{\"241\":1}}],[\"bgp路由器会发送路由更新\",{\"1\":{\"239\":1}}],[\"bgp路由器根据接收到的路由信息更新其路由表\",{\"1\":{\"239\":1}}],[\"bgp对等体之间就开始交换完整的bgp路由表\",{\"1\":{\"239\":1}}],[\"bgp使用一套复杂的路由选择规则来确定最佳路径\",{\"1\":{\"238\":1}}],[\"bgp是互联网的关键路由协议\",{\"1\":{\"243\":1}}],[\"bgp是一种路径向量协议\",{\"1\":{\"238\":1}}],[\"bgp是唯一能够处理互联网中如此大规模路由的协议\",{\"1\":{\"237\":1}}],[\"bgp运行在tcp之上\",{\"1\":{\"238\":1}}],[\"bgp\",{\"0\":{\"238\":1,\"239\":1,\"240\":1},\"1\":{\"237\":1,\"238\":1}}],[\"bgp协议\",{\"0\":{\"237\":1}}],[\"bgwtr\",{\"1\":{\"92\":2}}],[\"b6\",{\"1\":{\"211\":2}}],[\"block\",{\"1\":{\"185\":1}}],[\"blank\",{\"1\":{\"70\":1}}],[\"bytes=4294967296\",{\"1\":{\"137\":1}}],[\"baye\",{\"1\":{\"274\":2}}],[\"bayesian\",{\"1\":{\"100\":1}}],[\"batch\",{\"1\":{\"137\":2,\"154\":1}}],[\"base\",{\"1\":{\"137\":2,\"143\":1}}],[\"base64\",{\"1\":{\"137\":1}}],[\"bash\",{\"1\":{\"137\":1}}],[\"backend=\",{\"1\":{\"149\":1}}],[\"backend\",{\"1\":{\"92\":2,\"137\":1,\"147\":1}}],[\"backendcode\",{\"1\":{\"70\":1}}],[\"backendip\",{\"1\":{\"70\":1}}],[\"background\",{\"1\":{\"57\":1,\"70\":1}}],[\"br0\",{\"1\":{\"228\":2}}],[\"br0显示设备br0的fdb\",{\"1\":{\"227\":1}}],[\"br\",{\"1\":{\"227\":1,\"228\":1}}],[\"brd\",{\"1\":{\"211\":4}}],[\"broadcast\",{\"1\":{\"149\":1,\"162\":1}}],[\"branch\",{\"1\":{\"93\":1}}],[\"bridge\",{\"0\":{\"224\":1},\"1\":{\"42\":1,\"224\":1,\"227\":4,\"228\":3,\"229\":1,\"263\":1}}],[\"bert模型的参数数量分别为1\",{\"1\":{\"295\":1}}],[\"bert\",{\"1\":{\"295\":3,\"301\":2}}],[\"beian\",{\"1\":{\"70\":1}}],[\"besteffort\",{\"1\":{\"46\":1}}],[\"bufferid\",{\"1\":{\"136\":6}}],[\"built\",{\"1\":{\"93\":1}}],[\"but\",{\"1\":{\"57\":1}}],[\"bundle\",{\"1\":{\"57\":1}}],[\"burstable\",{\"1\":{\"46\":1}}],[\"border\",{\"1\":{\"237\":1}}],[\"bot\",{\"1\":{\"143\":4}}],[\"bottom\",{\"1\":{\"70\":1}}],[\"boot生态体系\",{\"1\":{\"123\":1}}],[\"boot\",{\"1\":{\"123\":1}}],[\"boot框架开发企业级应用\",{\"1\":{\"122\":1}}],[\"bootstrap\",{\"1\":{\"57\":1}}],[\"body>\",{\"1\":{\"70\":1}}],[\"body\",{\"1\":{\"70\":1}}],[\"bound\",{\"1\":{\"11\":1,\"12\":1}}],[\"同样\",{\"1\":{\"208\":1,\"295\":1}}],[\"同步通信要求发送方等待接收方确认消息接收\",{\"1\":{\"162\":1}}],[\"同步与异步通信\",{\"1\":{\"162\":1}}],[\"同步不同gpu上的模型参数\",{\"1\":{\"147\":1}}],[\"同一\",{\"1\":{\"44\":1}}],[\"同一个\",{\"1\":{\"41\":1}}],[\"同时保持较高的训练性能\",{\"1\":{\"304\":1}}],[\"同时比基线方法提供更好的训练性能\",{\"1\":{\"294\":1}}],[\"同时将重计算分配给激活张量\",{\"1\":{\"291\":1}}],[\"同时最小化额外的成本\",{\"1\":{\"279\":1}}],[\"同时\",{\"1\":{\"201\":1,\"283\":1,\"289\":1}}],[\"同时提供通信接口以在它们之间进行消息传递\",{\"1\":{\"160\":1}}],[\"同时要保证高可用\",{\"1\":{\"0\":1}}],[\"同时获得锁\",{\"1\":{\"0\":1}}],[\"访问\",{\"0\":{\"138\":1}}],[\"访问服务\",{\"0\":{\"69\":1}}],[\"访问自身或同一\",{\"1\":{\"42\":1}}],[\"访问自身以及同一\",{\"1\":{\"40\":1}}],[\"访问自己\",{\"1\":{\"41\":1}}],[\"访问同一\",{\"1\":{\"41\":1}}],[\"访问模式\",{\"0\":{\"4\":1}}],[\"示例输出\",{\"0\":{\"225\":1}}],[\"示例场景\",{\"0\":{\"159\":1}}],[\"示例代码\",{\"0\":{\"149\":1,\"165\":1}}],[\"示例\",{\"0\":{\"49\":1,\"51\":1,\"53\":1,\"55\":1,\"154\":1,\"210\":1},\"1\":{\"36\":1}}],[\"端口179\",{\"1\":{\"238\":1}}],[\"端口映射\",{\"1\":{\"61\":1}}],[\"端口\",{\"1\":{\"35\":1}}],[\"端口转发到\",{\"1\":{\"35\":1}}],[\"名称\",{\"1\":{\"33\":1,\"38\":1,\"87\":2}}],[\"名称直接访问特定的\",{\"1\":{\"33\":1}}],[\"都是通过软中断来处理的\",{\"1\":{\"185\":1}}],[\"都可以帮助实现高效的运维管理\",{\"1\":{\"118\":1}}],[\"都集中在容器基础设施上\",{\"1\":{\"95\":1}}],[\"都有一个稳定的\",{\"1\":{\"33\":1,\"38\":1}}],[\"都不会出现死锁\",{\"1\":{\"0\":1}}],[\"对比\",{\"0\":{\"215\":1}}],[\"对话默认携带的系统提示词\",{\"1\":{\"136\":1}}],[\"对应图中第五个框\",{\"1\":{\"185\":1}}],[\"对应图中的第三个框\",{\"1\":{\"185\":1}}],[\"对应oneapi中渠道的模型名\",{\"1\":{\"136\":1}}],[\"对应于工作流\",{\"1\":{\"84\":1}}],[\"对应的\",{\"1\":{\"56\":1}}],[\"对\",{\"1\":{\"46\":1}}],[\"对自身进行健康检查\",{\"1\":{\"44\":1}}],[\"对于张量t4\",{\"1\":{\"300\":1}}],[\"对于张量t2\",{\"1\":{\"300\":1}}],[\"对于t3\",{\"1\":{\"300\":1}}],[\"对于dgx\",{\"1\":{\"299\":1}}],[\"对于d2d交换\",{\"1\":{\"293\":1}}],[\"对于基于dapple的mpress\",{\"1\":{\"295\":1}}],[\"对于基于pipedream的操作间并行训练\",{\"1\":{\"295\":1}}],[\"对于这些张量\",{\"1\":{\"291\":1}}],[\"对于每个张量\",{\"1\":{\"290\":1}}],[\"对于pipedream\",{\"1\":{\"284\":1}}],[\"对于bert\",{\"1\":{\"282\":1,\"301\":1}}],[\"对于一个中等水平的技术人员来说\",{\"1\":{\"274\":2}}],[\"对于名为\",{\"1\":{\"86\":1}}],[\"对于options方式的请求返回204\",{\"1\":{\"70\":1}}],[\"对于\",{\"1\":{\"33\":1,\"56\":1}}],[\"对象和可视化\",{\"1\":{\"95\":1}}],[\"对象的\",{\"1\":{\"0\":2}}],[\"对象\",{\"1\":{\"0\":1}}],[\"对象后\",{\"1\":{\"0\":1}}],[\"dgx\",{\"1\":{\"295\":1}}],[\"dnn\",{\"1\":{\"278\":1,\"282\":1,\"288\":1}}],[\"dns\",{\"1\":{\"33\":4,\"38\":1,\"39\":1,\"268\":1}}],[\"dport\",{\"1\":{\"259\":2}}],[\"d2d交换节省了38gb的gpu内存\",{\"1\":{\"301\":1}}],[\"d2d交换节省了23\",{\"1\":{\"301\":1}}],[\"d2d交换提升了19\",{\"1\":{\"301\":1}}],[\"d2d交换和重计算的组合带来了最佳性能\",{\"1\":{\"301\":1}}],[\"d2d交换的内存节省量为3\",{\"1\":{\"301\":1}}],[\"d2d交换的快速速度对于避免重新计算和gpu\",{\"1\":{\"288\":1}}],[\"d2d交换\",{\"0\":{\"290\":1},\"1\":{\"295\":1,\"298\":1}}],[\"d2d交换技术\",{\"1\":{\"286\":1}}],[\"d2d\",{\"1\":{\"288\":1}}],[\"d2\",{\"1\":{\"211\":2}}],[\"df\",{\"1\":{\"192\":2}}],[\"ddp\",{\"1\":{\"146\":1}}],[\"dsn=root\",{\"1\":{\"137\":1}}],[\"dsl编译器将您的管道的python代码转换为静态配置\",{\"1\":{\"77\":1}}],[\"dsl\",{\"1\":{\"76\":1}}],[\"dir\",{\"1\":{\"137\":1}}],[\"dimensions\",{\"1\":{\"136\":2}}],[\"differentiable\",{\"1\":{\"100\":1}}],[\"discriminator\",{\"1\":{\"238\":1}}],[\"disk\",{\"1\":{\"185\":2}}],[\"disktype=ssd\",{\"1\":{\"51\":1}}],[\"disktype\",{\"1\":{\"51\":1}}],[\"dist\",{\"1\":{\"149\":4}}],[\"distributed\",{\"1\":{\"146\":1,\"149\":1}}],[\"display\",{\"1\":{\"70\":1}}],[\"disable\",{\"1\":{\"57\":1}}],[\"dapple进一步在流水线并行中添加了高效的调度和通信优化\",{\"1\":{\"303\":1}}],[\"dapple比pipedream晚了两年发布\",{\"1\":{\"297\":1}}],[\"dapple显著优于pipedream\",{\"1\":{\"297\":1}}],[\"dapple无法支持超过5\",{\"1\":{\"297\":1}}],[\"dapple+recomp\",{\"1\":{\"297\":1}}],[\"dapple能够训练最多具有53亿参数的gpt模型\",{\"1\":{\"284\":1}}],[\"dapple\",{\"1\":{\"282\":1}}],[\"dashboards\",{\"1\":{\"97\":1}}],[\"dashboard\",{\"1\":{\"95\":1,\"97\":1}}],[\"date\",{\"1\":{\"93\":1}}],[\"database\",{\"1\":{\"137\":1,\"224\":1}}],[\"datasetprocess\",{\"1\":{\"136\":2}}],[\"dataproc\",{\"1\":{\"86\":1}}],[\"data\",{\"0\":{\"263\":1},\"1\":{\"61\":1,\"63\":2,\"66\":2,\"70\":1,\"137\":15,\"146\":1,\"150\":1,\"152\":2,\"155\":2,\"161\":1,\"165\":8}}],[\"d894ffcd8\",{\"1\":{\"92\":2}}],[\"dbconfig\",{\"1\":{\"136\":1}}],[\"db\",{\"1\":{\"92\":3,\"137\":2}}],[\"draft\",{\"1\":{\"70\":1}}],[\"d\",{\"0\":{\"291\":1,\"298\":1},\"1\":{\"61\":2,\"165\":2,\"187\":1,\"259\":1}}],[\"dynamic\",{\"1\":{\"57\":1}}],[\"down\",{\"1\":{\"211\":2,\"247\":1,\"253\":1}}],[\"done\",{\"1\":{\"137\":1}}],[\"donotschedule\",{\"1\":{\"53\":1}}],[\"do\",{\"1\":{\"137\":1}}],[\"doc\",{\"1\":{\"135\":1}}],[\"docs\",{\"1\":{\"73\":1,\"135\":1,\"142\":1}}],[\"doctype\",{\"1\":{\"70\":1}}],[\"docker0\",{\"1\":{\"225\":4}}],[\"dockerhub\",{\"1\":{\"137\":1}}],[\"dockerfile\",{\"1\":{\"92\":1}}],[\"dockerexecutor\",{\"1\":{\"91\":1,\"92\":2}}],[\"dockerd\",{\"1\":{\"57\":2}}],[\"dockershim\",{\"1\":{\"56\":1}}],[\"docker\",{\"0\":{\"137\":1,\"143\":1},\"1\":{\"56\":3,\"61\":3,\"84\":1,\"88\":1,\"91\":2,\"92\":3,\"137\":1}}],[\"deepspeed和megatron\",{\"1\":{\"282\":1}}],[\"democratizing\",{\"1\":{\"277\":2}}],[\"demo\",{\"1\":{\"274\":2}}],[\"del\",{\"1\":{\"256\":1}}],[\"delay\",{\"1\":{\"222\":1}}],[\"delete\",{\"1\":{\"5\":1,\"65\":1,\"68\":1}}],[\"deletion\",{\"1\":{\"0\":1}}],[\"desc\",{\"1\":{\"143\":1}}],[\"desktop\",{\"1\":{\"57\":9}}],[\"debug\",{\"1\":{\"137\":1}}],[\"depends\",{\"1\":{\"137\":3}}],[\"deployments\",{\"1\":{\"96\":1}}],[\"deployment\",{\"1\":{\"26\":2,\"31\":1,\"92\":5,\"93\":1}}],[\"declarative\",{\"1\":{\"117\":1}}],[\"device\",{\"1\":{\"227\":1}}],[\"dev\",{\"1\":{\"57\":1,\"70\":1,\"136\":1,\"137\":1,\"186\":1,\"187\":2,\"188\":1,\"189\":2,\"190\":1,\"191\":1,\"192\":1,\"222\":4,\"223\":1,\"225\":4,\"226\":1,\"227\":2,\"228\":1,\"256\":1}}],[\"definition\",{\"1\":{\"112\":1}}],[\"defaulttoken\",{\"1\":{\"136\":3}}],[\"defaultconfig\",{\"1\":{\"136\":4}}],[\"defaultsystemchatprompt\",{\"1\":{\"136\":2}}],[\"defaulting\",{\"1\":{\"57\":1}}],[\"defaultrequest\",{\"1\":{\"20\":1,\"21\":1}}],[\"default\",{\"1\":{\"20\":1,\"21\":1,\"31\":1,\"35\":1,\"37\":1,\"38\":2,\"70\":1,\"137\":2,\"210\":4,\"211\":6}}],[\"defer\",{\"1\":{\"0\":2}}],[\"例如更好的计算和通信重叠技术\",{\"1\":{\"297\":1}}],[\"例如路由过滤\",{\"1\":{\"238\":1}}],[\"例如reachable\",{\"1\":{\"222\":1}}],[\"例如通过\",{\"1\":{\"185\":1}}],[\"例如重新启动故障的组件\",{\"1\":{\"114\":1}}],[\"例如系统管理员\",{\"1\":{\"111\":1}}],[\"例如贝叶斯优化\",{\"1\":{\"100\":1}}],[\"例如在\",{\"1\":{\"95\":1}}],[\"例如数据预处理\",{\"1\":{\"85\":1}}],[\"例如数据库集群或分布式文件系统\",{\"1\":{\"34\":1}}],[\"例如某些服务需要通过自身的外部\",{\"1\":{\"41\":1}}],[\"例如\",{\"1\":{\"33\":1,\"38\":1,\"43\":1,\"54\":1,\"86\":2,\"90\":1,\"96\":2,\"97\":1,\"100\":1,\"114\":1,\"136\":1,\"147\":1,\"151\":1,\"157\":1,\"200\":1,\"222\":1,\"227\":1,\"269\":1,\"282\":1,\"283\":1,\"285\":1,\"302\":2}}],[\"允许更重要的请求先行处理\",{\"1\":{\"201\":1}}],[\"允许在同一个tcp连接上复用多个请求\",{\"1\":{\"197\":1}}],[\"允许多个请求\",{\"1\":{\"198\":1}}],[\"允许多个进程同时读写大规模数据集\",{\"1\":{\"162\":1}}],[\"允许多个处理单元并行执行不同的程序\",{\"1\":{\"161\":1}}],[\"允许程序在多个处理单元上并行运行\",{\"1\":{\"163\":1}}],[\"允许程序在多个处理单元\",{\"1\":{\"161\":1}}],[\"允许不同的程序同时运行\",{\"1\":{\"157\":1}}],[\"允许并行处理不同区域或不同时间步的计算\",{\"1\":{\"153\":1}}],[\"允许优化任何规模的大模型的超参数\",{\"1\":{\"101\":1}}],[\"允许发送按段获取资源的请求\",{\"1\":{\"70\":1}}],[\"允许请求时携带的头部信息\",{\"1\":{\"70\":1}}],[\"允许跨域请求的方法\",{\"1\":{\"70\":1}}],[\"允许跨域的请求\",{\"1\":{\"70\":1}}],[\"允许携带cookie请求\",{\"1\":{\"70\":1}}],[\"允许使用自定义调度策略文件来自定义调度行为\",{\"1\":{\"54\":1}}],[\"允许用户交互和监控工作流\",{\"1\":{\"92\":1}}],[\"允许用户在同一个应用程序中启动多个不同的程序实例\",{\"1\":{\"160\":1}}],[\"允许用户在\",{\"1\":{\"92\":1}}],[\"允许用户定义分布式调度策略\",{\"1\":{\"52\":1}}],[\"允许用户指定某些\",{\"1\":{\"48\":1}}],[\"允许调度器根据节点标签选择合适的节点\",{\"1\":{\"50\":1}}],[\"允许你为\",{\"1\":{\"46\":1}}],[\"允许应用自行管理和发现服务实例\",{\"1\":{\"34\":1}}],[\"允许这些有状态应用中的各个\",{\"1\":{\"34\":1}}],[\"允许客户端直接访问服务后端的每个\",{\"1\":{\"33\":1}}],[\"允许被多个node挂载\",{\"1\":{\"4\":2}}],[\"字段设置为\",{\"1\":{\"33\":1}}],[\"字段来表示\",{\"1\":{\"6\":1}}],[\"这在决定如何组合这些方法时起到了关键作用\",{\"1\":{\"300\":1}}],[\"这在预期之中\",{\"1\":{\"299\":1}}],[\"这也影响了它们各自的mpress变体\",{\"1\":{\"297\":1}}],[\"这意味着\",{\"1\":{\"297\":1}}],[\"这意味着每个处理单元的代码路径是相同的\",{\"1\":{\"151\":1}}],[\"这得益于d2d交换技术的使用\",{\"1\":{\"297\":1}}],[\"这一点已被zero\",{\"1\":{\"297\":1}}],[\"这一gpu内存需求可以通过我们测试的gpu服务器在没有内存优化的情况下满足\",{\"1\":{\"295\":1}}],[\"这一部分具体怎么实现\",{\"1\":{\"56\":1}}],[\"这台dgx\",{\"1\":{\"295\":1}}],[\"这三种内存优化技术对gpu内存节省的贡献各自是多少\",{\"1\":{\"294\":1}}],[\"这导致了gpu内存的极大需求\",{\"1\":{\"278\":1}}],[\"这篇论文的题目是\",{\"1\":{\"277\":1}}],[\"这就是我想要的\",{\"1\":{\"274\":2}}],[\"这类似于传统二层交换机的mac地址表\",{\"1\":{\"219\":1}}],[\"这表明veth0和veth1是一对互相连接的虚拟以太网设备\",{\"1\":{\"210\":1}}],[\"这有助于减少延迟和提升性能\",{\"1\":{\"200\":1}}],[\"这有助于了解程序在做什么\",{\"1\":{\"184\":1}}],[\"这包括删除\",{\"1\":{\"186\":1}}],[\"这里表示如果进程的\",{\"1\":{\"185\":1}}],[\"这里你要注意\",{\"1\":{\"185\":1}}],[\"这里\",{\"1\":{\"185\":1,\"297\":1}}],[\"这里我们假设一下\",{\"1\":{\"185\":1}}],[\"这里进程又回到用户态的\",{\"1\":{\"185\":1}}],[\"这里仍旧是内核态的\",{\"1\":{\"185\":1}}],[\"这里的\",{\"1\":{\"185\":1}}],[\"这里就对应上面图里的第二个框\",{\"1\":{\"185\":1}}],[\"这里默认填写了oneapi的快速默认key\",{\"1\":{\"137\":1}}],[\"这里默认填写了oneapi的访问地址\",{\"1\":{\"137\":1}}],[\"这两部分模拟数据可能会在某些阶段相互依赖\",{\"1\":{\"159\":1}}],[\"这通常通过划分数据集来实现\",{\"1\":{\"151\":1}}],[\"这是一种新的单服务器多gpu系统\",{\"1\":{\"304\":1}}],[\"这是一个高效的操作间并行深度神经网络\",{\"1\":{\"288\":1}}],[\"这是由于数据分条技术利用了多条nvlink的聚合带宽\",{\"1\":{\"299\":1}}],[\"这是预期中的结果\",{\"1\":{\"296\":1}}],[\"这是因为前者优化使交换操作能够通过可达的nvlink链路传输数据\",{\"1\":{\"299\":1}}],[\"这是因为我们租用的dgx\",{\"1\":{\"297\":1}}],[\"这是因为zero\",{\"1\":{\"297\":1}}],[\"这是因为普通的操作间并行训练已经能够满足该模型的gpu内存需求\",{\"1\":{\"296\":1}}],[\"这是因为本身它们在处理的时候就不属于任何一个进程\",{\"1\":{\"185\":1}}],[\"这是dapple文献中推荐的最小批次大小\",{\"1\":{\"295\":1}}],[\"这是文献中推荐的大小\",{\"1\":{\"295\":1}}],[\"这是设备的mac地址\",{\"1\":{\"226\":1}}],[\"这是在分布式训练中非常常用的操作\",{\"1\":{\"147\":1}}],[\"这是默认的执行器\",{\"1\":{\"91\":1}}],[\"这是默认模式\",{\"1\":{\"42\":1}}],[\"这描述了自定义资源的结构和规范\",{\"1\":{\"113\":1}}],[\"这使得\",{\"1\":{\"101\":1}}],[\"这可以进一步减少除了第一层操作符的输入之外的内存消耗\",{\"1\":{\"291\":1}}],[\"这可以被以下用户使用\",{\"0\":{\"97\":1}}],[\"这可以用于避免将所有\",{\"1\":{\"50\":1}}],[\"这对于网络故障排查和性能优化非常有用\",{\"1\":{\"229\":1}}],[\"这对于排查网络问题和管理网络连接非常有用\",{\"1\":{\"223\":1}}],[\"这对于将各种资源联系在一起甚至清理\",{\"1\":{\"96\":1}}],[\"这对于需要在容器之间共享数据的工作流特别有用\",{\"1\":{\"91\":1}}],[\"这对于需要直接与特定\",{\"1\":{\"33\":1}}],[\"这样以后你解决相关问题时\",{\"1\":{\"185\":1}}],[\"这样的工具\",{\"1\":{\"97\":1}}],[\"这样的应用程序\",{\"1\":{\"96\":1}}],[\"这样客户端可以通过\",{\"1\":{\"33\":1}}],[\"这会很有帮助\",{\"1\":{\"90\":1}}],[\"这将通过kong访问到nginx提供的\",{\"1\":{\"69\":1}}],[\"这时在这个\",{\"1\":{\"185\":1}}],[\"这时候\",{\"1\":{\"185\":1}}],[\"这时候这个用户进程就会从用户态切换到内核态\",{\"1\":{\"185\":1}}],[\"这时\",{\"1\":{\"56\":1,\"185\":1}}],[\"这个算法首先枚举所有可能的设备映射方案\",{\"1\":{\"290\":1}}],[\"这个命令将显示根文件系统的更新后的容量\",{\"1\":{\"192\":1}}],[\"这个步骤\",{\"1\":{\"185\":1}}],[\"这个用户进程在读取数据之后\",{\"1\":{\"185\":1}}],[\"这个进程一般会被置为\",{\"1\":{\"185\":1}}],[\"这个配置实现了通过kong网关将请求转发到nginx容器中的具体路径\",{\"1\":{\"70\":1}}],[\"这个\",{\"1\":{\"56\":2,\"185\":1}}],[\"这个请求首先交给\",{\"1\":{\"56\":1}}],[\"这个示例展示了如何使用节点标签\",{\"1\":{\"51\":1}}],[\"这个示例定义了一个名为\",{\"1\":{\"35\":1}}],[\"这种设计允许执行器在不阻塞主线程的情况下\",{\"1\":{\"293\":1}}],[\"这种设计使得\",{\"1\":{\"162\":1}}],[\"这种分层模型有助于不同网络设备和协议的互操作性和标准化\",{\"1\":{\"271\":1}}],[\"这种过程称为封装和解封装\",{\"1\":{\"269\":1}}],[\"这种方式被称为张量并行\",{\"1\":{\"303\":1}}],[\"这种方式允许二层流量跨越不同的三层网络\",{\"1\":{\"218\":1}}],[\"这种方法依赖于\",{\"1\":{\"91\":1}}],[\"这种灵活性允许处理单元根据任务需求执行不同的操作或算法\",{\"1\":{\"156\":1}}],[\"这种并行性可以大幅提高计算效率\",{\"1\":{\"151\":1}}],[\"这种模型适用于更复杂的并行计算任务\",{\"1\":{\"155\":1}}],[\"这种模型广泛应用于高性能计算和分布式计算领域\",{\"1\":{\"150\":1}}],[\"这种模式下\",{\"1\":{\"42\":1}}],[\"这种模式在性能上可能有一些开销\",{\"1\":{\"42\":1}}],[\"这种模式主要用于以下情况\",{\"1\":{\"41\":1}}],[\"这种连接可视化称为谱系图\",{\"1\":{\"90\":1}}],[\"这种\",{\"1\":{\"56\":1}}],[\"这种访问模式被称为\",{\"1\":{\"40\":1}}],[\"这种服务类型主要用于暴露\",{\"1\":{\"32\":1}}],[\"这种机制有助于确保工作负载在集群中得到更好地分布和隔离\",{\"1\":{\"31\":1}}],[\"这些硬件需要定制的软件支持\",{\"1\":{\"303\":1}}],[\"这些系统的性能往往受限于pcie带宽\",{\"1\":{\"303\":1}}],[\"这些系统应用了最先进的内存节省技术\",{\"1\":{\"297\":1}}],[\"这些内存或许能更好地用于其他张量\",{\"1\":{\"300\":1}}],[\"这些数据占用了更多的内存资源\",{\"1\":{\"296\":1}}],[\"这些数据的生命周期过短\",{\"1\":{\"288\":1}}],[\"这些线程使用系统启动时通过调用cudastreamcreate创建的不同cuda流\",{\"1\":{\"293\":1}}],[\"这些张量的优化引入了最大的额外开销\",{\"1\":{\"291\":1}}],[\"这些命令一起使用可以全面管理和配置网络\",{\"1\":{\"260\":1}}],[\"这些规则包括\",{\"1\":{\"238\":1}}],[\"这些会话通常是静态配置的\",{\"1\":{\"238\":1}}],[\"这些值到底影不影响\",{\"1\":{\"185\":1}}],[\"这些代码的指令消耗的\",{\"1\":{\"185\":1}}],[\"这些任务通常需要处理非常大的数据集和复杂的计算过程\",{\"1\":{\"164\":1}}],[\"这些操作涉及多个进程之间的通信\",{\"1\":{\"162\":1}}],[\"这些场的计算方法不同\",{\"1\":{\"158\":1}}],[\"这些步骤可以由不同的程序在不同的处理单元上并行执行\",{\"1\":{\"157\":1}}],[\"这些服务涵盖了实验管理\",{\"1\":{\"106\":1}}],[\"这些框架实现了大多数最先进的优化算法\",{\"1\":{\"101\":1}}],[\"这些组件通过存储系统\",{\"1\":{\"92\":1}}],[\"这些组件通过元数据存储和\",{\"1\":{\"92\":1}}],[\"这些组件必须在集群启动时运行\",{\"1\":{\"28\":1}}],[\"这些\",{\"1\":{\"84\":2,\"92\":3}}],[\"这些容器在虚拟机上的kubernetes\",{\"1\":{\"80\":1}}],[\"这些配置文件不会因为\",{\"1\":{\"26\":1}}],[\"具备可扩展gpu计算能力和存储容量的高端gpu服务器几乎不可能\",{\"1\":{\"297\":1}}],[\"具备创新能力的全栈开发工程师\",{\"1\":{\"126\":1}}],[\"具备良好的网页结构设计能力\",{\"1\":{\"125\":1}}],[\"具备大规模数据存储与查询优化的经验\",{\"1\":{\"123\":1}}],[\"具备处理硬件交互及操作系统底层模块的经验\",{\"1\":{\"122\":1}}],[\"具备广泛的编程语言知识和丰富的实际项目经验\",{\"1\":{\"121\":1}}],[\"具备更高的安全性\",{\"1\":{\"0\":1}}],[\"具有名称\",{\"1\":{\"85\":1}}],[\"具有相应的\",{\"1\":{\"31\":1}}],[\"具体而言\",{\"1\":{\"291\":1}}],[\"具体地说\",{\"1\":{\"46\":1}}],[\"具体来说\",{\"1\":{\"40\":1}}],[\"除非这些\",{\"1\":{\"31\":1}}],[\"则使用提示词模式\",{\"1\":{\"136\":1}}],[\"则使用\",{\"1\":{\"136\":1}}],[\"则无法进行部署\",{\"1\":{\"31\":1}}],[\"则进入等待模式\",{\"1\":{\"0\":1}}],[\"移除\",{\"1\":{\"31\":1}}],[\"也称为osi\",{\"1\":{\"261\":1}}],[\"也称\",{\"0\":{\"248\":1}}],[\"也就是当目标张量的生命周期\",{\"1\":{\"291\":1}}],[\"也就是第七个框\",{\"1\":{\"185\":1}}],[\"也就是第六个框\",{\"1\":{\"185\":1}}],[\"也就是图中的第四个框\",{\"1\":{\"185\":1}}],[\"也可以用于分布式机器学习\",{\"1\":{\"164\":1}}],[\"也可以是丰富的交互式可视化\",{\"1\":{\"90\":1}}],[\"也可能会调度\",{\"1\":{\"31\":1}}],[\"也不能直接共享内存数据\",{\"1\":{\"88\":1}}],[\"也不会被调度到这个节点上\",{\"1\":{\"31\":1}}],[\"新分区创建并标记为\",{\"1\":{\"189\":1}}],[\"新\",{\"1\":{\"31\":1}}],[\"新的d2d交换技术\",{\"1\":{\"279\":1}}],[\"新的\",{\"1\":{\"31\":1}}],[\"常见用途\",{\"1\":{\"213\":1,\"214\":1}}],[\"常见的\",{\"1\":{\"163\":1}}],[\"常见的选择是默认的\",{\"1\":{\"45\":1}}],[\"常见的效果有三种\",{\"1\":{\"31\":1}}],[\"常用选项\",{\"0\":{\"227\":1}}],[\"常用工具总结\",{\"0\":{\"169\":1}}],[\"常用于实现复杂的数值模拟\",{\"1\":{\"164\":1}}],[\"常用于升级时候的初始化请求\",{\"1\":{\"137\":1}}],[\"常用的解决方案是超时和自动过期机制\",{\"1\":{\"0\":1}}],[\"效果\",{\"1\":{\"31\":1}}],[\"值得注意的是\",{\"1\":{\"297\":1}}],[\"值是正值\",{\"1\":{\"185\":1}}],[\"值\",{\"1\":{\"31\":1}}],[\"键\",{\"1\":{\"31\":1}}],[\"提高网络性能\",{\"1\":{\"213\":1}}],[\"提高网络安全性\",{\"1\":{\"213\":1}}],[\"提出最佳推理代码库\",{\"1\":{\"179\":1}}],[\"提升了训练大规模模型的效率\",{\"1\":{\"303\":1}}],[\"提升了用户体验和网络性能\",{\"1\":{\"205\":1}}],[\"提升了整体性能\",{\"1\":{\"204\":1,\"296\":1}}],[\"提升项目的开发效率与用户体验\",{\"1\":{\"125\":1}}],[\"提升系统响应速度\",{\"1\":{\"123\":1}}],[\"提升资源管理能力\",{\"1\":{\"14\":1}}],[\"提前停止和神经架构搜索\",{\"1\":{\"100\":1}}],[\"提供高达160gb\",{\"1\":{\"286\":1}}],[\"提供网络服务和应用程序接口\",{\"1\":{\"268\":1}}],[\"提供端到端的通信服务\",{\"1\":{\"265\":1}}],[\"提供节点之间的可靠数据传输\",{\"1\":{\"263\":1}}],[\"提供灵活的网络管理和用户分组\",{\"1\":{\"213\":1}}],[\"提供流量控制机制\",{\"1\":{\"201\":1}}],[\"提供一种方式\",{\"1\":{\"99\":1}}],[\"提供一种明确的机制\",{\"1\":{\"98\":1}}],[\"提供一种标准方式\",{\"1\":{\"98\":1}}],[\"提供一个用于在\",{\"1\":{\"98\":1}}],[\"提供应用程序的安装状态和垃圾回收\",{\"1\":{\"98\":1}}],[\"提供通过\",{\"1\":{\"98\":1}}],[\"提供工作流执行状态和结果的可视化\",{\"1\":{\"92\":1}}],[\"提供了替代传统gpu的硬件选择\",{\"1\":{\"303\":1}}],[\"提供了极高的带宽\",{\"1\":{\"302\":1}}],[\"提供了强大的防火墙配置能力\",{\"1\":{\"260\":1}}],[\"提供了更丰富和更强大的功能\",{\"1\":{\"249\":1}}],[\"提供了更大的灵活性\",{\"1\":{\"152\":1,\"157\":1}}],[\"提供了灵活且高效的消息传递机制\",{\"1\":{\"166\":1}}],[\"提供了多种集体通信操作\",{\"1\":{\"162\":1}}],[\"提供了一种高效的解决方案\",{\"1\":{\"303\":1}}],[\"提供了一种声明性的方式来定义和管理\",{\"1\":{\"117\":1}}],[\"提供了一组标准的\",{\"1\":{\"161\":1}}],[\"提供了对数据进行广播和同步的接口\",{\"1\":{\"147\":1}}],[\"提供了分布式数据并行\",{\"1\":{\"146\":1}}],[\"提供了面向\",{\"1\":{\"117\":1}}],[\"提供了从生成基础代码到测试和部署的全流程支持\",{\"1\":{\"117\":1}}],[\"提供了从超参数调优到机器学习工作流管理的完整功能\",{\"1\":{\"92\":1}}],[\"提供了定义自定义对象的能力\",{\"1\":{\"112\":1}}],[\"提供了机器学习工作流的定义\",{\"1\":{\"92\":1}}],[\"提供了几个选项来配置\",{\"1\":{\"42\":1}}],[\"提供\",{\"1\":{\"92\":7}}],[\"提供稳定的\",{\"1\":{\"39\":1}}],[\"提供的arp检测功能\",{\"1\":{\"235\":1}}],[\"提供的负载均衡\",{\"1\":{\"34\":1}}],[\"提供的一种灵活机制\",{\"1\":{\"29\":1}}],[\"要将\",{\"1\":{\"186\":1}}],[\"要配置\",{\"1\":{\"43\":1}}],[\"要更新\",{\"1\":{\"29\":1}}],[\"要创建一个\",{\"1\":{\"27\":1}}],[\"gshard等系统通过将每个层的矩阵乘法分块\",{\"1\":{\"303\":1}}],[\"gen3x16带宽的近5倍\",{\"1\":{\"286\":1}}],[\"getstringconfig\",{\"1\":{\"103\":2}}],[\"get\",{\"1\":{\"29\":1,\"64\":1,\"67\":1,\"69\":1,\"70\":2,\"92\":1,\"149\":1}}],[\"gif\",{\"1\":{\"267\":1}}],[\"git\",{\"1\":{\"137\":3}}],[\"github\",{\"1\":{\"93\":1,\"94\":1,\"134\":1,\"141\":1,\"176\":1}}],[\"gateway\",{\"1\":{\"237\":1}}],[\"gather\",{\"1\":{\"162\":1}}],[\"gpipe首先引入了这种技术\",{\"1\":{\"303\":1}}],[\"gpipe和dapple等系统采用了流水线并行\",{\"1\":{\"303\":1}}],[\"gpipe和dapple中使用的同步模式则要求不同微批次的计算是串行的\",{\"1\":{\"283\":1}}],[\"gpipe\",{\"1\":{\"282\":1}}],[\"gpu的内存为40gb\",{\"1\":{\"297\":1}}],[\"gpu的计算密度高于dgx\",{\"1\":{\"297\":1}}],[\"gpu服务器上的类似趋势\",{\"1\":{\"297\":1}}],[\"gpu服务器上的性能对比情况\",{\"1\":{\"297\":1}}],[\"gpu服务器上对mpress进行了测试\",{\"1\":{\"297\":1}}],[\"gpu服务器上进行实验以评估mpress和基线方法\",{\"1\":{\"295\":1}}],[\"gpu服务器上进行实验\",{\"1\":{\"284\":1}}],[\"gpu之间的数据移动可以与dnn计算异步进行\",{\"1\":{\"293\":1}}],[\"gpu对之间的带宽可能会有所不同\",{\"1\":{\"290\":1}}],[\"gpu间完全通过同质的链路连接\",{\"1\":{\"290\":1}}],[\"gpu引入了第一代nvlink\",{\"1\":{\"286\":1}}],[\"gpu内存消耗的问题\",{\"0\":{\"284\":1}}],[\"gpu\",{\"1\":{\"153\":1,\"154\":2,\"158\":1,\"159\":1,\"164\":1,\"179\":2,\"277\":2,\"279\":1,\"284\":1,\"285\":2,\"291\":1,\"295\":3,\"296\":3,\"300\":1,\"301\":1,\"303\":3,\"304\":1},\"2\":{\"306\":1}}],[\"gpt模型中的情况与bert类似\",{\"1\":{\"300\":1}}],[\"gpt\",{\"1\":{\"136\":2,\"143\":1,\"295\":1,\"301\":3}}],[\"gloo\",{\"1\":{\"147\":1,\"149\":1}}],[\"global\",{\"1\":{\"143\":1,\"211\":1}}],[\"glm4\",{\"1\":{\"136\":1}}],[\"ghcr\",{\"1\":{\"137\":3}}],[\"gcr\",{\"1\":{\"93\":1}}],[\"gcepersistentdisk\",{\"1\":{\"5\":1}}],[\"google\",{\"1\":{\"86\":1,\"90\":1,\"100\":1,\"303\":1}}],[\"gov\",{\"1\":{\"70\":1,\"277\":1}}],[\"gotraceback=\",{\"1\":{\"57\":1}}],[\"gomaxprocs=\",{\"1\":{\"57\":1}}],[\"gogc=\",{\"1\":{\"57\":1}}],[\"golang\",{\"1\":{\"57\":1}}],[\"go\",{\"1\":{\"57\":7,\"117\":1,\"122\":1}}],[\"grep\",{\"1\":{\"207\":1,\"208\":1,\"210\":1}}],[\"growfs\",{\"1\":{\"191\":2}}],[\"group\",{\"1\":{\"143\":2,\"147\":1,\"149\":1,\"210\":2,\"211\":4}}],[\"graph\",{\"0\":{\"89\":1},\"1\":{\"89\":1,\"90\":1}}],[\"gradient\",{\"1\":{\"70\":1}}],[\"grace\",{\"1\":{\"46\":2,\"302\":1}}],[\"grpc\",{\"1\":{\"56\":1,\"92\":8}}],[\"guaranteed\",{\"1\":{\"46\":3}}],[\"命令一起使用\",{\"1\":{\"260\":1}}],[\"命令套件\",{\"1\":{\"260\":1}}],[\"命令套件的一部分\",{\"1\":{\"249\":1,\"252\":1}}],[\"命令是查看和管理网络设备的主要工具\",{\"1\":{\"207\":1}}],[\"命令\",{\"0\":{\"207\":1,\"208\":1}}],[\"命令行后\",{\"1\":{\"187\":1,\"188\":1}}],[\"命令查询\",{\"1\":{\"70\":1}}],[\"命令查看\",{\"1\":{\"29\":2}}],[\"命令的时候\",{\"1\":{\"56\":1}}],[\"命名空间\",{\"1\":{\"17\":1}}],[\"略有不同\",{\"1\":{\"29\":1}}],[\"来节省内存\",{\"1\":{\"303\":1}}],[\"来过滤出一组减少的张量\",{\"1\":{\"291\":1}}],[\"来检查根文件系统的大小\",{\"1\":{\"192\":1}}],[\"来扩展文件系统\",{\"1\":{\"191\":1}}],[\"来创建新分区\",{\"1\":{\"188\":1}}],[\"来创建和管理\",{\"1\":{\"25\":1}}],[\"来使用\",{\"1\":{\"185\":1}}],[\"来返回1024维度的向量\",{\"1\":{\"136\":1}}],[\"来优化非ml任务\",{\"1\":{\"101\":1}}],[\"来作为实现的\",{\"1\":{\"56\":1}}],[\"来进行处理\",{\"1\":{\"56\":1}}],[\"来实现均匀调度\",{\"1\":{\"54\":1}}],[\"来实现这一点\",{\"1\":{\"33\":1,\"39\":1}}],[\"来说是不合适的\",{\"1\":{\"31\":1}}],[\"来运行节点级别的服务或代理\",{\"1\":{\"28\":1}}],[\"简单邮件传输协议\",{\"1\":{\"268\":1}}],[\"简单\",{\"1\":{\"215\":1}}],[\"简单清除文件的操作\",{\"1\":{\"5\":1}}],[\"简介\",{\"0\":{\"73\":1},\"1\":{\"73\":2}}],[\"简化了\",{\"1\":{\"117\":1}}],[\"简化数据库集群的管理\",{\"1\":{\"116\":1}}],[\"简化运维操作\",{\"1\":{\"115\":1}}],[\"简化网络配置\",{\"1\":{\"44\":1}}],[\"简化的节点管理\",{\"1\":{\"28\":1}}],[\"8倍的训练性能提升\",{\"1\":{\"296\":1}}],[\"8gb\",{\"1\":{\"295\":1}}],[\"8gi\",{\"1\":{\"15\":1}}],[\"8个nvidia\",{\"1\":{\"295\":2}}],[\"8e\",{\"1\":{\"188\":1}}],[\"871\",{\"1\":{\"183\":3,\"184\":1}}],[\"86868f775c\",{\"1\":{\"92\":2}}],[\"849479cf5f\",{\"1\":{\"92\":2}}],[\"8\",{\"0\":{\"68\":1,\"203\":1},\"1\":{\"70\":2,\"91\":1,\"137\":3,\"295\":1,\"297\":3}}],[\"895\",{\"1\":{\"57\":1}}],[\"802\",{\"1\":{\"213\":1,\"215\":1,\"263\":1}}],[\"80万元+\",{\"1\":{\"126\":1}}],[\"8000\",{\"1\":{\"69\":1}}],[\"8001\",{\"1\":{\"63\":1,\"64\":1,\"65\":1,\"66\":1,\"67\":1,\"68\":1}}],[\"8088\",{\"1\":{\"61\":4,\"63\":1,\"70\":1}}],[\"8080\",{\"1\":{\"35\":2,\"37\":1,\"38\":1}}],[\"80\",{\"1\":{\"27\":1,\"31\":1,\"35\":2,\"37\":1}}],[\"iv\",{\"0\":{\"294\":1}}],[\"iii\",{\"0\":{\"287\":1}}],[\"ii\",{\"0\":{\"282\":1}}],[\"icmp\",{\"1\":{\"264\":1}}],[\"ibgp\",{\"1\":{\"238\":1}}],[\"ieee\",{\"1\":{\"215\":1}}],[\"irq\",{\"1\":{\"185\":1}}],[\"ignore\",{\"1\":{\"165\":1}}],[\"id映射到vxlan的vni\",{\"1\":{\"219\":1}}],[\"identifier\",{\"1\":{\"214\":1,\"218\":1}}],[\"idle\",{\"1\":{\"185\":1}}],[\"id\",{\"1\":{\"137\":2,\"185\":2,\"213\":2,\"215\":1,\"226\":1}}],[\"import\",{\"1\":{\"149\":2}}],[\"imgs\",{\"1\":{\"136\":5}}],[\"imagefs\",{\"1\":{\"46\":4}}],[\"imagepullpolicy\",{\"1\":{\"31\":1,\"93\":1}}],[\"image\",{\"1\":{\"27\":1,\"31\":1,\"38\":2,\"53\":2,\"93\":2,\"137\":12,\"143\":2}}],[\"items\",{\"1\":{\"70\":1}}],[\"itd\",{\"1\":{\"61\":1}}],[\"i\",{\"1\":{\"63\":1,\"65\":1,\"66\":1,\"68\":1,\"185\":4}}],[\"i0729\",{\"1\":{\"57\":5}}],[\"infinity利用cpu内存和nvme存储来扩展模型规模\",{\"1\":{\"303\":1}}],[\"infinity也不应显著优于zero\",{\"1\":{\"297\":1}}],[\"infinity的原始论文和图8a中的结果验证\",{\"1\":{\"297\":1}}],[\"infinity的表现不如zero\",{\"1\":{\"297\":1}}],[\"infinity的性能提升了37\",{\"1\":{\"297\":1}}],[\"infinity通过gpu\",{\"1\":{\"297\":1}}],[\"infinity比zero\",{\"1\":{\"297\":1}}],[\"infinity需要大量的cpu内存来进行初始化\",{\"1\":{\"297\":1}}],[\"infinity\",{\"1\":{\"295\":1,\"297\":1}}],[\"info\",{\"1\":{\"137\":1}}],[\"in和swap\",{\"1\":{\"293\":1}}],[\"indiehacker\",{\"1\":{\"274\":1}}],[\"index\",{\"1\":{\"63\":2,\"69\":1,\"70\":3}}],[\"input\",{\"1\":{\"259\":2}}],[\"inet6\",{\"1\":{\"211\":1}}],[\"inet\",{\"1\":{\"211\":1}}],[\"install\",{\"1\":{\"171\":1}}],[\"instruction\",{\"1\":{\"152\":2}}],[\"int\",{\"1\":{\"165\":8}}],[\"inter\",{\"1\":{\"277\":2}}],[\"internet\",{\"1\":{\"264\":1}}],[\"interrupt\",{\"1\":{\"185\":1}}],[\"interface\",{\"1\":{\"147\":1,\"156\":1,\"161\":1}}],[\"interval=10\",{\"1\":{\"137\":1}}],[\"interval\",{\"1\":{\"137\":3}}],[\"introduction\",{\"1\":{\"73\":1}}],[\"ingress\",{\"1\":{\"91\":1}}],[\"include\",{\"1\":{\"70\":1,\"165\":2}}],[\"initreplicaset\",{\"1\":{\"137\":2}}],[\"initiate\",{\"1\":{\"137\":1}}],[\"initial\",{\"1\":{\"70\":1,\"137\":1}}],[\"initdb\",{\"1\":{\"137\":2}}],[\"init\",{\"1\":{\"57\":1,\"149\":1,\"165\":1}}],[\"in\",{\"1\":{\"49\":1,\"51\":1,\"57\":1,\"93\":1,\"143\":1}}],[\"inodesfree<5\",{\"1\":{\"46\":2}}],[\"ipu等专用加速器的兴起\",{\"1\":{\"303\":1}}],[\"iputils\",{\"1\":{\"171\":1}}],[\"ip协议进行路由选择\",{\"1\":{\"270\":1}}],[\"iptables\",{\"1\":{\"258\":1,\"259\":3,\"260\":2}}],[\"ipv4地址长度\",{\"1\":{\"232\":1}}],[\"ip地址\",{\"1\":{\"222\":1}}],[\"ipinfo\",{\"1\":{\"172\":1}}],[\"ip\",{\"0\":{\"222\":1},\"1\":{\"32\":1,\"33\":2,\"39\":1,\"40\":1,\"41\":4,\"42\":1,\"44\":2,\"45\":1,\"70\":1,\"172\":1,\"207\":3,\"209\":1,\"210\":2,\"211\":6,\"222\":1,\"223\":1,\"246\":1,\"247\":1,\"249\":3,\"250\":1,\"252\":2,\"253\":3,\"255\":1,\"256\":3,\"260\":8,\"264\":1}}],[\"iso\",{\"1\":{\"261\":1}}],[\"isinited\",{\"1\":{\"137\":2}}],[\"is\",{\"1\":{\"31\":1,\"57\":3}}],[\"iowait\",{\"1\":{\"185\":1}}],[\"io\",{\"1\":{\"31\":2,\"43\":1,\"49\":2,\"53\":1,\"93\":4,\"137\":4,\"162\":2,\"172\":1}}],[\"if29\",{\"1\":{\"211\":2}}],[\"ifconfig\",{\"1\":{\"208\":2,\"246\":1,\"247\":4,\"249\":1,\"260\":2}}],[\"ifconfig命令也可以用于查看网络接口\",{\"1\":{\"208\":1}}],[\"ifnotpresent\",{\"1\":{\"31\":1,\"93\":1}}],[\"if\",{\"1\":{\"0\":6,\"70\":1,\"90\":1,\"137\":1,\"149\":1,\"165\":2}}],[\"你会哪个就用哪个\",{\"1\":{\"274\":2}}],[\"你会看到进程871的系统调用输出\",{\"1\":{\"185\":1}}],[\"你很快就会知道你的想法是不是可以赚到钱\",{\"1\":{\"274\":2}}],[\"你需要重新创建一个新的分区\",{\"1\":{\"188\":1}}],[\"你需要确保\",{\"1\":{\"187\":1}}],[\"你需要执行以下步骤\",{\"1\":{\"186\":1}}],[\"你需要在节点的特定目录中\",{\"1\":{\"27\":1}}],[\"你旨在回答并解决人们的任何问题\",{\"1\":{\"143\":1}}],[\"你是chatgpt\",{\"1\":{\"143\":1}}],[\"你还可以指定最大并发运行数\",{\"1\":{\"90\":1}}],[\"你必须将传递给组件之间的数据序列化\",{\"1\":{\"88\":1}}],[\"你必须将组件打包为\",{\"1\":{\"88\":1}}],[\"你可以将新的空间分配给逻辑卷\",{\"1\":{\"190\":1}}],[\"你可以这样理解这个软中断\",{\"1\":{\"185\":1}}],[\"你可以看到进程\",{\"1\":{\"184\":1}}],[\"你可以查看跨管道运行的工件和执行之间的连接\",{\"1\":{\"90\":1}}],[\"你可以从\",{\"1\":{\"90\":1}}],[\"你可以在任何实验中启动定期运行\",{\"1\":{\"90\":1}}],[\"你可以在其中尝试管道的不同配置\",{\"1\":{\"90\":1}}],[\"你可以通过查看\",{\"1\":{\"90\":1}}],[\"你可以通过以下命令访问kong代理的服务\",{\"1\":{\"69\":1}}],[\"你可以使用实验将你的运行组织成逻辑组\",{\"1\":{\"90\":1}}],[\"你可以使用\",{\"1\":{\"84\":1}}],[\"你通过以下命令启动了一个nginx容器\",{\"1\":{\"61\":1}}],[\"你仍然可以使用\",{\"1\":{\"29\":1}}],[\"你都需要确保任意故障场景下\",{\"1\":{\"0\":1}}],[\"创建新的分区并标记为\",{\"0\":{\"188\":1}}],[\"创建runs\",{\"0\":{\"108\":1}}],[\"创建流水线只是把相关参数信息写入数据库\",{\"1\":{\"107\":1}}],[\"创建组件或指定管道\",{\"1\":{\"76\":1}}],[\"创建路由\",{\"0\":{\"66\":1}}],[\"创建服务\",{\"0\":{\"63\":1}}],[\"创建一个新的分区\",{\"1\":{\"188\":1}}],[\"创建一个张量\",{\"1\":{\"149\":1}}],[\"创建一个所有工具必须实现的标准\",{\"1\":{\"99\":1}}],[\"创建一个\",{\"1\":{\"33\":1}}],[\"创建一个包含\",{\"1\":{\"27\":1}}],[\"创建\",{\"0\":{\"27\":1}}],[\"创建了一个路由\",{\"1\":{\"66\":1}}],[\"创建了一个\",{\"1\":{\"0\":1}}],[\"保持动力等\",{\"1\":{\"274\":2}}],[\"保障系统的弹性伸缩和高可用性\",{\"1\":{\"123\":1}}],[\"保障系统的稳定性与可扩展性\",{\"1\":{\"122\":1}}],[\"保证这些关键组件的高可用性\",{\"1\":{\"26\":1}}],[\"保留数据\",{\"1\":{\"5\":1}}],[\"崩溃或被删除\",{\"1\":{\"26\":1}}],[\"自主运营并开发自己的在线业务以获得收入的人\",{\"1\":{\"274\":2}}],[\"自治系统\",{\"1\":{\"238\":1}}],[\"自愈能力\",{\"1\":{\"114\":1}}],[\"自动同步各个设备计算出的梯度\",{\"1\":{\"147\":1}}],[\"自动处理\",{\"1\":{\"116\":1}}],[\"自动化\",{\"1\":{\"116\":1}}],[\"自动化了许多日常的运维任务\",{\"1\":{\"115\":1}}],[\"自动化升级\",{\"1\":{\"114\":1}}],[\"自动修复出现的问题\",{\"1\":{\"114\":1}}],[\"自动执行\",{\"1\":{\"114\":1}}],[\"自动重启\",{\"1\":{\"26\":1}}],[\"自\",{\"1\":{\"91\":1}}],[\"自然就是具体的\",{\"1\":{\"56\":1}}],[\"自定义额外参数\",{\"1\":{\"136\":1}}],[\"自定义内容提取提示词\",{\"1\":{\"136\":1}}],[\"自定义文本分类提示词\",{\"1\":{\"136\":1}}],[\"自定义资源\",{\"1\":{\"112\":1}}],[\"自定义资源定义\",{\"1\":{\"95\":1,\"112\":1}}],[\"自定义调度策略文件\",{\"1\":{\"55\":1}}],[\"自定义调度器策略\",{\"0\":{\"54\":1}}],[\"自定义服务发现\",{\"1\":{\"34\":1}}],[\"自访问\",{\"1\":{\"41\":1}}],[\"自身来管理\",{\"1\":{\"28\":1}}],[\"自身的管理中\",{\"1\":{\"25\":1}}],[\"存储时的额外参数\",{\"1\":{\"136\":1}}],[\"存储工作流定义和执行状态\",{\"1\":{\"92\":1}}],[\"存储超参数调优任务的状态和结果\",{\"1\":{\"92\":1}}],[\"存储和对象数量等\",{\"1\":{\"16\":1}}],[\"存放在节点的文件系统中\",{\"1\":{\"26\":1}}],[\"格式的组件规范描述\",{\"1\":{\"87\":1}}],[\"格式\",{\"1\":{\"26\":1}}],[\"静态部分的任务是生成内存节省计划\",{\"1\":{\"289\":1}}],[\"静态arp表\",{\"1\":{\"235\":1}}],[\"静态配置\",{\"1\":{\"26\":1}}],[\"静态pod\",{\"0\":{\"25\":1}}],[\"滚动更新等高级特性\",{\"1\":{\"26\":1}}],[\"会话层\",{\"0\":{\"266\":1}}],[\"会话\",{\"1\":{\"238\":1}}],[\"会将设备b的ip地址和mac地址映射关系存储在本地的arp缓存中\",{\"1\":{\"231\":1}}],[\"会响应中断\",{\"1\":{\"185\":1}}],[\"会把这段时间标示成\",{\"1\":{\"185\":1}}],[\"会对被跟踪的进程产生一定的性能开销\",{\"1\":{\"185\":1}}],[\"会附加到这个进程\",{\"1\":{\"183\":1}}],[\"会优先使用\",{\"1\":{\"136\":1}}],[\"会自动去掉注释\",{\"1\":{\"136\":1}}],[\"会自动检测到文件的变化并重新创建\",{\"1\":{\"29\":1}}],[\"会自动检测到该文件并创建对应的\",{\"1\":{\"27\":1}}],[\"会启动\",{\"1\":{\"84\":1}}],[\"会以options方式发送预检请求\",{\"1\":{\"70\":1}}],[\"会在\",{\"1\":{\"56\":1}}],[\"会在创建容器网络接口时启用发夹规则\",{\"1\":{\"42\":1}}],[\"会保证只有当\",{\"1\":{\"46\":1}}],[\"会为每个\",{\"1\":{\"33\":1}}],[\"会被驱逐\",{\"1\":{\"31\":1}}],[\"会根据配置文件自动重新创建它们\",{\"1\":{\"26\":1}}],[\"会定期扫描特定的目录\",{\"1\":{\"26\":1}}],[\"会使用我们上面的介绍的\",{\"1\":{\"0\":1}}],[\"由网络管理员手动设置\",{\"1\":{\"238\":1}}],[\"由三个部分组成\",{\"1\":{\"31\":1}}],[\"由于gpu的空闲内存资源有限\",{\"1\":{\"291\":1}}],[\"由于gpu资源有限\",{\"1\":{\"288\":1}}],[\"由于pcie带宽有限\",{\"1\":{\"285\":1}}],[\"由于深度神经网络\",{\"1\":{\"282\":1}}],[\"由于是文本协议\",{\"1\":{\"203\":1}}],[\"由于我们的中断服务处理需要关闭中断\",{\"1\":{\"185\":1}}],[\"由于\",{\"1\":{\"29\":1,\"157\":1}}],[\"由于某种原因无法使用\",{\"1\":{\"10\":1}}],[\"由运行在节点上的\",{\"1\":{\"26\":1}}],[\"由\",{\"1\":{\"26\":1,\"29\":1}}],[\"直到我们拿出自己的产品\",{\"1\":{\"274\":2}}],[\"直到你停止\",{\"1\":{\"185\":1}}],[\"直到被释放\",{\"1\":{\"8\":1}}],[\"直接修改这个环境变量\",{\"1\":{\"137\":1}}],[\"直接与\",{\"1\":{\"91\":1}}],[\"直接与集群交互\",{\"1\":{\"91\":1}}],[\"直接相互访问\",{\"1\":{\"34\":1}}],[\"直接访问\",{\"1\":{\"33\":1}}],[\"直接管理\",{\"1\":{\"25\":1,\"26\":1,\"29\":1}}],[\"目标客户更愿意使用哪种产品\",{\"1\":{\"274\":2}}],[\"目标客户会经常出现在那里\",{\"1\":{\"274\":2}}],[\"目标设备的ip地址\",{\"1\":{\"232\":1}}],[\"目标设备的mac地址\",{\"1\":{\"232\":1}}],[\"目标协议地址\",{\"1\":{\"232\":1}}],[\"目标硬件地址\",{\"1\":{\"232\":1}}],[\"目标vtep解封装udp包\",{\"1\":{\"219\":1}}],[\"目标发现和告警管理\",{\"1\":{\"116\":1}}],[\"目标\",{\"0\":{\"98\":1}}],[\"目录包含所有运行时代码\",{\"1\":{\"86\":1}}],[\"目录中后\",{\"1\":{\"27\":1}}],[\"目前有能力提供哪种产品形态\",{\"1\":{\"274\":2}}],[\"目前必须小于1536维度\",{\"1\":{\"136\":1}}],[\"目前只有gpt支持\",{\"1\":{\"136\":1}}],[\"目前只有nfs和hostpath两种类型的pv支持recycle策略\",{\"1\":{\"5\":1}}],[\"目前\",{\"1\":{\"46\":1}}],[\"目的vtep接收到vxlan包后\",{\"1\":{\"220\":1}}],[\"目的\",{\"1\":{\"23\":2}}],[\"范围是1到4094\",{\"1\":{\"213\":1}}],[\"范围\",{\"1\":{\"23\":2}}],[\"比现有的系统支持更大规模的模型训练\",{\"1\":{\"304\":1}}],[\"比在dgx\",{\"1\":{\"297\":1}}],[\"比如说\",{\"1\":{\"185\":1}}],[\"比如挂起\",{\"1\":{\"184\":1}}],[\"比如上面例子里的\",{\"1\":{\"46\":1}}],[\"比如\",{\"1\":{\"46\":1,\"56\":2,\"136\":1,\"185\":1}}],[\"比较与总结\",{\"0\":{\"23\":1}}],[\"比自己小的\",{\"1\":{\"0\":2}}],[\"鼓励开发人员在部署\",{\"1\":{\"19\":1}}],[\"鼓励合理的资源分配\",{\"1\":{\"19\":1}}],[\"与这些系统不同\",{\"1\":{\"303\":1}}],[\"与mpress相同\",{\"1\":{\"297\":1}}],[\"与最先进的重计算系统相比\",{\"1\":{\"296\":1}}],[\"与gpu\",{\"1\":{\"296\":1}}],[\"与gpu内存之间的数据传输速度快于普通可分页内存\",{\"1\":{\"293\":1}}],[\"与重计算相比\",{\"1\":{\"291\":1}}],[\"与实际训练可能需要运行数百万次迭代以实现模型收敛不同\",{\"1\":{\"289\":1}}],[\"与此相反\",{\"1\":{\"283\":1}}],[\"与此不同\",{\"1\":{\"282\":1,\"297\":1}}],[\"与其他两种方法相比\",{\"1\":{\"282\":1}}],[\"与其他并行模型的比较\",{\"0\":{\"152\":1}}],[\"与vxlan\",{\"0\":{\"212\":1}}],[\"与多个程序相对应\",{\"1\":{\"156\":1}}],[\"与oneapi对应\",{\"1\":{\"136\":1}}],[\"与许多优化框架\",{\"1\":{\"101\":1}}],[\"与应用程序\",{\"1\":{\"98\":1}}],[\"与元数据\",{\"1\":{\"92\":1}}],[\"与执行或工件关联的自定义属性等\",{\"1\":{\"90\":1}}],[\"与端点通信以提交作业的代码\",{\"1\":{\"86\":1}}],[\"与它建立长连接\",{\"1\":{\"56\":1}}],[\"与普通的\",{\"1\":{\"33\":1}}],[\"与\",{\"0\":{\"36\":1,\"157\":1},\"1\":{\"18\":1,\"86\":1,\"92\":1,\"101\":2,\"152\":2,\"155\":1,\"156\":1}}],[\"与pv相连的后端存储完成volume的删除操作\",{\"1\":{\"5\":1}}],[\"成长与学习\",{\"1\":{\"274\":2}}],[\"成为一名独立开发者可以提供很多传统工作所无法提供的优点\",{\"1\":{\"274\":2}}],[\"成功\",{\"1\":{\"89\":1}}],[\"成功后\",{\"1\":{\"0\":1}}],[\"成本管理\",{\"1\":{\"17\":1}}],[\"之前方法难以低成本在单个\",{\"1\":{\"179\":1}}],[\"之前已经绑定的\",{\"1\":{\"9\":1}}],[\"之间交换路由信息\",{\"1\":{\"237\":1}}],[\"之间进行消息传递和协调\",{\"1\":{\"161\":1}}],[\"之间的互操作性\",{\"1\":{\"98\":1}}],[\"之间的资源使用\",{\"1\":{\"17\":1}}],[\"之间有一定的关联关系\",{\"1\":{\"92\":1}}],[\"之上安排\",{\"1\":{\"74\":1}}],[\"之上\",{\"1\":{\"73\":1}}],[\"之后\",{\"1\":{\"56\":1,\"239\":1}}],[\"控制数据包的流入\",{\"1\":{\"260\":1}}],[\"控制平面来实现和基准测试他们自己的优化算法\",{\"1\":{\"101\":1}}],[\"控制平面组件\",{\"1\":{\"25\":1,\"28\":2}}],[\"控制器的核心任务是不断将资源的实际状态调整为期望状态\",{\"1\":{\"113\":1}}],[\"控制器监控自定义资源的状态\",{\"1\":{\"113\":1}}],[\"控制器是\",{\"1\":{\"112\":1}}],[\"控制器管理器\",{\"1\":{\"92\":2}}],[\"控制器\",{\"1\":{\"28\":1,\"92\":1,\"112\":1}}],[\"控制命名空间内的资源使用上限\",{\"1\":{\"23\":1}}],[\"控制资源使用来管理和控制成本\",{\"1\":{\"17\":1}}],[\"控制资源分配\",{\"1\":{\"14\":1}}],[\"控制不同租户\",{\"1\":{\"17\":1}}],[\"多租户支持\",{\"1\":{\"218\":1}}],[\"多租户环境\",{\"1\":{\"17\":1,\"23\":1}}],[\"多路复用\",{\"0\":{\"198\":1},\"1\":{\"205\":2}}],[\"多物理场仿真\",{\"1\":{\"158\":1}}],[\"多个小的请求可能会因为串行化处理导致较高的延迟和低效的带宽利用\",{\"1\":{\"204\":1}}],[\"多个程序\",{\"1\":{\"156\":1}}],[\"多个处理单元\",{\"1\":{\"155\":1}}],[\"多个处理单元同时执行相同的程序代码\",{\"1\":{\"150\":1}}],[\"多数据流\",{\"1\":{\"151\":1,\"156\":1}}],[\"多gpu训练\",{\"1\":{\"148\":1}}],[\"多节点和多gpu分布式训练\",{\"1\":{\"101\":1}}],[\"多种访问模式不能同时生效\",{\"1\":{\"4\":1}}],[\"内核防火墙实现\",{\"1\":{\"258\":1}}],[\"内核态\",{\"1\":{\"185\":1}}],[\"内核中的延迟细分和稀疏模式\",{\"1\":{\"179\":1}}],[\"内核执行高效计算\",{\"1\":{\"179\":1}}],[\"内容提取\",{\"1\":{\"136\":2}}],[\"内部原理\",{\"0\":{\"287\":1}}],[\"内部bgp\",{\"1\":{\"238\":1}}],[\"内部的不同容器通过\",{\"1\":{\"44\":1}}],[\"内部通信\",{\"1\":{\"41\":1}}],[\"内的容器通信\",{\"1\":{\"44\":1}}],[\"内的容器是否能够通过\",{\"1\":{\"40\":1}}],[\"内的多个容器之间的通信\",{\"1\":{\"41\":1}}],[\"内的其他容器\",{\"1\":{\"41\":1,\"42\":1}}],[\"内存优化\",{\"1\":{\"303\":2}}],[\"内存优化及其局限性\",{\"0\":{\"285\":1}}],[\"内存不足\",{\"1\":{\"302\":1}}],[\"内存交换\",{\"1\":{\"293\":1}}],[\"内存交换需求与目标操作间并行训练任务中空闲gpu内存资源的多样性\",{\"1\":{\"290\":1}}],[\"内存管理\",{\"1\":{\"293\":1}}],[\"内存管理器和压缩库三个关键系统组件\",{\"1\":{\"289\":1}}],[\"内存压缩规划\",{\"0\":{\"291\":1}}],[\"内存平衡的分区策略能够解决gpu内存不平衡的问题\",{\"1\":{\"285\":1}}],[\"内存缓存\",{\"1\":{\"137\":1}}],[\"内存\",{\"1\":{\"16\":1}}],[\"内资源总量的机制\",{\"1\":{\"13\":1}}],[\"包括不要熬夜做产品\",{\"1\":{\"274\":2}}],[\"包括产品有什么核心功能和特点\",{\"1\":{\"274\":2}}],[\"包括想法\",{\"1\":{\"274\":2}}],[\"包括美工问题\",{\"1\":{\"274\":2}}],[\"包括人身自由\",{\"1\":{\"274\":2}}],[\"包括什么是独立开发者\",{\"1\":{\"274\":2}}],[\"包括数据加密\",{\"1\":{\"267\":1}}],[\"包括定义硬件设备的电气\",{\"1\":{\"262\":1}}],[\"包括定期运行\",{\"1\":{\"90\":1}}],[\"包括其ip地址和mac地址\",{\"1\":{\"222\":1}}],[\"包括veth设备对\",{\"1\":{\"207\":1}}],[\"包括工件在内的管道组件非常有用\",{\"1\":{\"90\":1}}],[\"包括工作流中的所有组件及其相互关系\",{\"1\":{\"84\":1}}],[\"包括\",{\"1\":{\"16\":1,\"246\":1,\"260\":1,\"279\":1}}],[\"包含了所有进程\",{\"1\":{\"162\":1}}],[\"包含\",{\"1\":{\"0\":1}}],[\"主页\",{\"1\":{\"95\":1}}],[\"主要包括执行器\",{\"1\":{\"289\":1}}],[\"主要有三种并行训练方法\",{\"1\":{\"282\":1}}],[\"主要负责流量控制\",{\"1\":{\"265\":1}}],[\"主要功能\",{\"0\":{\"147\":1}}],[\"主要集中在容器化应用程序上\",{\"1\":{\"95\":1}}],[\"主要的\",{\"0\":{\"91\":1}}],[\"主要依赖于从\",{\"1\":{\"46\":1}}],[\"主要用于以下几种场景\",{\"1\":{\"34\":1}}],[\"主要控制单个\",{\"1\":{\"18\":1}}],[\"主要字段\",{\"0\":{\"16\":1,\"21\":1}}],[\"主备异步复制可能导致丢数据的问题\",{\"1\":{\"0\":1}}],[\"5b的模型\",{\"1\":{\"297\":1}}],[\"5bbh9\",{\"1\":{\"92\":2}}],[\"5mb的数据\",{\"1\":{\"282\":1}}],[\"5e\",{\"1\":{\"225\":1}}],[\"58\",{\"1\":{\"222\":4}}],[\"507e\",{\"1\":{\"211\":1}}],[\"5000+\",{\"1\":{\"126\":1}}],[\"5000\",{\"1\":{\"31\":1,\"92\":1}}],[\"500m\",{\"1\":{\"20\":1,\"31\":1}}],[\"52\",{\"1\":{\"211\":2}}],[\"512gb\",{\"1\":{\"302\":1}}],[\"512\",{\"1\":{\"136\":2}}],[\"512mi\",{\"1\":{\"20\":1}}],[\"5499555669\",{\"1\":{\"92\":2}}],[\"57dbbdfd77\",{\"1\":{\"92\":2}}],[\"5\",{\"0\":{\"65\":1,\"191\":1,\"200\":1,\"266\":1},\"1\":{\"15\":1,\"136\":3,\"137\":4,\"143\":1,\"295\":1,\"296\":1,\"301\":1}}],[\"限制资源以确保测试环境不会占用过多的生产资源\",{\"1\":{\"17\":1}}],[\"限制内存使用总量\",{\"1\":{\"15\":1}}],[\"限制内存请求总量\",{\"1\":{\"15\":1}}],[\"限制\",{\"1\":{\"15\":4}}],[\"限制命名空间资源使用\",{\"1\":{\"14\":1}}],[\"hbm\",{\"1\":{\"302\":1}}],[\"hpack\",{\"1\":{\"199\":1}}],[\"hpc\",{\"1\":{\"161\":1}}],[\"h\",{\"1\":{\"192\":2}}],[\"hi\",{\"1\":{\"185\":3}}],[\"high\",{\"1\":{\"31\":2}}],[\"hqjiang\",{\"1\":{\"177\":1}}],[\"h>\",{\"1\":{\"165\":2}}],[\"hopper目前64gb\",{\"1\":{\"302\":1}}],[\"hopper架构已经为每个gpu支持专用的cpu侧内存\",{\"1\":{\"302\":1}}],[\"hot\",{\"1\":{\"143\":1}}],[\"host\",{\"1\":{\"70\":1,\"137\":1}}],[\"hostname\",{\"1\":{\"49\":2,\"53\":1}}],[\"hub\",{\"1\":{\"143\":1,\"262\":1}}],[\"hyperopt\",{\"1\":{\"101\":1}}],[\"hyperband\",{\"1\":{\"100\":1}}],[\"href=\",{\"1\":{\"70\":1}}],[\"h1>\",{\"1\":{\"70\":1}}],[\"h1\",{\"1\":{\"70\":1}}],[\"html>\",{\"1\":{\"70\":2}}],[\"html\",{\"1\":{\"63\":2,\"69\":1,\"70\":2,\"125\":1,\"177\":1},\"2\":{\"72\":1}}],[\"http头部是以纯文本格式传输的\",{\"1\":{\"199\":1}}],[\"http2与http1区别\",{\"1\":{\"195\":1}}],[\"https\",{\"1\":{\"70\":1,\"73\":1,\"93\":1,\"94\":1,\"134\":1,\"135\":1,\"136\":2,\"137\":1,\"141\":1,\"142\":1,\"176\":1,\"177\":1,\"205\":1,\"274\":1,\"277\":1}}],[\"http\",{\"1\":{\"31\":2,\"35\":1,\"37\":1,\"63\":2,\"64\":1,\"65\":1,\"66\":1,\"67\":1,\"68\":1,\"69\":1,\"70\":2,\"137\":4,\"139\":1,\"140\":1,\"143\":1,\"195\":4,\"196\":2,\"197\":4,\"198\":2,\"199\":2,\"200\":2,\"201\":3,\"202\":3,\"203\":3,\"204\":3,\"205\":3,\"268\":1},\"2\":{\"273\":1}}],[\"healthz\",{\"1\":{\"137\":1}}],[\"health\",{\"1\":{\"137\":2}}],[\"healthcheck\",{\"1\":{\"137\":3}}],[\"headers\",{\"1\":{\"70\":2}}],[\"header\",{\"1\":{\"70\":19}}],[\"head>\",{\"1\":{\"70\":1}}],[\"headless\",{\"0\":{\"32\":1,\"33\":1,\"35\":1,\"36\":1,\"37\":1},\"1\":{\"32\":2,\"33\":3,\"34\":3,\"35\":3,\"36\":1,\"38\":1,\"39\":2}}],[\"height\",{\"1\":{\"70\":1}}],[\"help\",{\"1\":{\"143\":1}}],[\"helpful\",{\"1\":{\"31\":1}}],[\"helm\",{\"1\":{\"97\":1}}],[\"hello\",{\"1\":{\"63\":1,\"64\":1,\"65\":1,\"66\":5,\"67\":2,\"68\":1,\"69\":1}}],[\"has\",{\"1\":{\"149\":1}}],[\"hangzhou\",{\"1\":{\"137\":4,\"143\":1}}],[\"hairpinmode\",{\"1\":{\"43\":1}}],[\"hairpin\",{\"0\":{\"41\":1},\"1\":{\"40\":3,\"42\":2,\"43\":3,\"45\":2}}],[\"had\",{\"1\":{\"31\":1}}],[\"hardware\",{\"1\":{\"185\":1,\"232\":4}}],[\"hard=imagefs\",{\"1\":{\"46\":1}}],[\"hard\",{\"1\":{\"15\":1,\"16\":1,\"46\":2}}],[\"hdr\",{\"1\":{\"0\":3}}],[\"和23\",{\"1\":{\"297\":1}}],[\"和通过层级分区\",{\"1\":{\"282\":1}}],[\"和vxlan\",{\"1\":{\"212\":1}}],[\"和聚集\",{\"1\":{\"162\":1}}],[\"和控制器的实现\",{\"1\":{\"113\":1}}],[\"和控制器旨在改变这种状况\",{\"1\":{\"95\":1}}],[\"和行为方式\",{\"1\":{\"113\":1}}],[\"和工具来自动管理复杂应用的生命周期\",{\"1\":{\"111\":1}}],[\"和用户界面进行紧密集成\",{\"1\":{\"92\":1}}],[\"和服务正常运行\",{\"1\":{\"92\":1}}],[\"和内存的默认值和最大\",{\"1\":{\"20\":1}}],[\"和内存总量\",{\"1\":{\"15\":1}}],[\"和\",{\"0\":{\"220\":1,\"244\":1},\"1\":{\"12\":1,\"15\":1,\"25\":1,\"28\":2,\"46\":1,\"92\":1,\"101\":2,\"106\":3,\"137\":1,\"158\":1,\"162\":1,\"260\":2,\"274\":2}}],[\"或撤销\",{\"1\":{\"239\":1}}],[\"或在解析管道代码中的\",{\"1\":{\"90\":1}}],[\"或在\",{\"1\":{\"90\":1}}],[\"或跳过\",{\"1\":{\"89\":1}}],[\"或者私有化的laf环境\",{\"1\":{\"136\":1}}],[\"或者宿主机本身正处于\",{\"1\":{\"46\":1}}],[\"或者在启动\",{\"1\":{\"43\":1}}],[\"或者\",{\"1\":{\"41\":1}}],[\"或其他控制器管理的\",{\"1\":{\"26\":1}}],[\"或容器的资源使用\",{\"1\":{\"23\":1}}],[\"或容器的资源使用范围\",{\"1\":{\"18\":1}}],[\"或容器没有指定资源请求和限制\",{\"1\":{\"19\":1}}],[\"或容器资源使用的机制\",{\"1\":{\"18\":1}}],[\"或\",{\"1\":{\"12\":1,\"26\":3,\"84\":1,\"100\":1}}],[\"删除规则\",{\"1\":{\"259\":1}}],[\"删除和查看路由规则\",{\"1\":{\"255\":1,\"260\":1}}],[\"删除路由\",{\"0\":{\"68\":1},\"1\":{\"256\":1}}],[\"删除服务和路由\",{\"1\":{\"70\":1}}],[\"删除服务\",{\"0\":{\"65\":1}}],[\"删除或再利用\",{\"1\":{\"12\":1}}],[\"删除\",{\"1\":{\"12\":1,\"187\":2}}],[\"vdnn和superneurons等系统在运行时根据内存使用情况\",{\"1\":{\"303\":1}}],[\"vpn\",{\"1\":{\"235\":2}}],[\"vni映射\",{\"1\":{\"219\":1}}],[\"vtep作为vxlan架构中的关键组件\",{\"1\":{\"221\":1}}],[\"vtep将该帧封装到一个udp包中\",{\"1\":{\"220\":1}}],[\"vtep通过监听网络流量和arp\",{\"1\":{\"219\":1}}],[\"vtep负责将二层网络中的vlan\",{\"1\":{\"219\":1}}],[\"vtep是vxlan隧道的起点和终点\",{\"1\":{\"219\":1}}],[\"vtep是vxlan架构中的关键组件\",{\"1\":{\"219\":1}}],[\"vtep\",{\"0\":{\"219\":1,\"220\":1},\"1\":{\"215\":1}}],[\"vxlan和vtep的结合\",{\"1\":{\"221\":1}}],[\"vxlan通过在现有的三层ip网络上创建虚拟二层网络\",{\"1\":{\"221\":1}}],[\"vxlan通过udp隧道封装将二层以太网帧封装在三层ip包中\",{\"1\":{\"218\":1}}],[\"vxlan通过udp隧道封装\",{\"1\":{\"214\":1}}],[\"vxlan包封装\",{\"1\":{\"220\":1}}],[\"vxlan可以在现有的ip网络上实现二层网络的扩展和弹性\",{\"1\":{\"218\":1}}],[\"vxlan可以在现有的ip网络基础上创建虚拟网络\",{\"1\":{\"214\":1}}],[\"vxlan允许在同一个物理网络基础设施上运行多个独立的虚拟网络\",{\"1\":{\"218\":1}}],[\"vxlan是一种用于扩展二层网络的技术\",{\"1\":{\"218\":1}}],[\"vxlan是一种用于在大规模数据中心和云环境中创建虚拟网络的技术\",{\"1\":{\"214\":1}}],[\"vxlan与vtep\",{\"0\":{\"217\":1}}],[\"vxlan适用于大规模的分布式数据中心环境\",{\"1\":{\"214\":1}}],[\"vxlan使用24位的vni\",{\"1\":{\"214\":1,\"218\":1}}],[\"vxlan\",{\"0\":{\"214\":1,\"218\":1,\"219\":1,\"220\":1},\"1\":{\"214\":1,\"215\":1,\"218\":1}}],[\"vlan适用于较小规模的网络分段和隔离\",{\"1\":{\"216\":1}}],[\"vlan的配置相对简单\",{\"1\":{\"213\":1}}],[\"vlan使用ieee\",{\"1\":{\"213\":1}}],[\"vlan是一种用于在同一物理网络上创建多个逻辑网络的技术\",{\"1\":{\"213\":1}}],[\"vlan\",{\"0\":{\"212\":1,\"213\":1},\"1\":{\"212\":1,\"213\":1,\"215\":1,\"225\":2,\"226\":2}}],[\"vgextend\",{\"1\":{\"189\":1}}],[\"v0\",{\"1\":{\"137\":2}}],[\"v4\",{\"1\":{\"137\":2}}],[\"volumes\",{\"1\":{\"137\":8}}],[\"voices\",{\"1\":{\"136\":1}}],[\"v3\",{\"1\":{\"136\":1,\"137\":1}}],[\"v2\",{\"1\":{\"137\":1}}],[\"v2ray\",{\"2\":{\"132\":1}}],[\"v2beta1\",{\"0\":{\"104\":1},\"1\":{\"106\":4}}],[\"vue\",{\"1\":{\"125\":1}}],[\"vii\",{\"0\":{\"304\":1}}],[\"vi\",{\"0\":{\"303\":1}}],[\"via\",{\"1\":{\"256\":1,\"277\":2}}],[\"virtual\",{\"0\":{\"213\":1,\"214\":1,\"218\":1},\"1\":{\"212\":2}}],[\"vision\",{\"1\":{\"136\":2}}],[\"visualizationserviceport\",{\"1\":{\"103\":1}}],[\"visualizationservicehost\",{\"1\":{\"103\":1}}],[\"visualizationservice\",{\"1\":{\"103\":1,\"106\":1}}],[\"visualizationserver\",{\"1\":{\"92\":3}}],[\"viewer\",{\"1\":{\"92\":3}}],[\"viewport\",{\"1\":{\"70\":1}}],[\"vertical\",{\"1\":{\"179\":2}}],[\"version\",{\"1\":{\"70\":1,\"137\":1,\"143\":1}}],[\"vectormodels\",{\"1\":{\"136\":1}}],[\"vectormaxprocess\",{\"1\":{\"136\":1}}],[\"veth1\",{\"1\":{\"210\":3,\"211\":3}}],[\"veth0\",{\"1\":{\"209\":1,\"210\":3}}],[\"veth\",{\"1\":{\"42\":1,\"43\":2,\"45\":1,\"207\":1,\"208\":1,\"210\":2}}],[\"valid\",{\"1\":{\"211\":2}}],[\"valuefrom\",{\"1\":{\"93\":1}}],[\"values\",{\"1\":{\"49\":1,\"51\":1}}],[\"value\",{\"1\":{\"31\":2,\"136\":6}}],[\"var\",{\"1\":{\"57\":3,\"137\":2}}],[\"v100\",{\"1\":{\"295\":1}}],[\"v1beta1\",{\"0\":{\"103\":1},\"1\":{\"43\":1,\"106\":8}}],[\"v1\",{\"1\":{\"15\":1,\"20\":1,\"27\":1,\"31\":1,\"35\":1,\"37\":1,\"38\":1,\"49\":1,\"51\":1,\"53\":1,\"55\":1,\"93\":1,\"137\":2,\"143\":2,\"295\":1}}],[\"v\",{\"0\":{\"302\":1},\"1\":{\"12\":3,\"61\":2,\"259\":1}}],[\"|\",{\"1\":{\"12\":6,\"137\":1,\"207\":1,\"208\":1,\"210\":1}}],[\"使bert模型变得更深\",{\"1\":{\"295\":1}}],[\"使设备能够通过ip地址找到目标设备的mac地址\",{\"1\":{\"236\":1}}],[\"使得网络设计和实现更加模块化和清晰\",{\"1\":{\"271\":1}}],[\"使得网络应用能够更高效地传输数据\",{\"1\":{\"205\":1}}],[\"使得设备能够通过ip地址找到目标设备的物理地址\",{\"1\":{\"230\":1}}],[\"使得跨越不同物理位置的虚拟机能够像在同一个二层网络中一样进行通信\",{\"1\":{\"221\":1}}],[\"使得虚拟机可以在不同的物理位置之间自由迁移\",{\"1\":{\"218\":1}}],[\"使得虚拟机和容器之间的通信更加灵活和高效\",{\"1\":{\"214\":1}}],[\"使得不同vlan之间的通信受到限制\",{\"1\":{\"213\":1}}],[\"使得程序能够在多处理单元环境中高效运行\",{\"1\":{\"166\":1}}],[\"使得创建复杂的应用管理变得更简单\",{\"1\":{\"117\":1}}],[\"使得\",{\"1\":{\"115\":1}}],[\"使得复杂应用的管理变得更一致和可靠\",{\"1\":{\"115\":1}}],[\"使得用户可以在\",{\"1\":{\"112\":1}}],[\"使得流量可以从容器发出后\",{\"1\":{\"40\":1}}],[\"使应用程序能够声明对另一个应用程序的依赖关系\",{\"1\":{\"98\":1}}],[\"使应用程序能够向\",{\"1\":{\"98\":1}}],[\"使其利用新增的空间\",{\"1\":{\"191\":1}}],[\"使其能够在众多支持工具之间实现互操作\",{\"1\":{\"95\":1}}],[\"使其可以绑定到新的\",{\"1\":{\"11\":1}}],[\"使主容器可以访问子容器的文件系统和进程\",{\"1\":{\"91\":1}}],[\"使\",{\"1\":{\"90\":1,\"99\":1}}],[\"使用不同规模的bert变体进行操作间并行训练时的性能\",{\"1\":{\"296\":1}}],[\"使用维基百科数据集训练gpt\",{\"1\":{\"295\":1}}],[\"使用异构内存优化技术来应对著名的gpu内存墙问题\",{\"1\":{\"288\":1}}],[\"使用什么样的编程语言\",{\"1\":{\"274\":4}}],[\"使用网络设备\",{\"1\":{\"235\":1}}],[\"使用示例\",{\"0\":{\"228\":1}}],[\"使用hpack算法进行压缩\",{\"1\":{\"205\":1}}],[\"使用流的概念\",{\"1\":{\"197\":1}}],[\"使用二进制帧传输数据\",{\"1\":{\"196\":1}}],[\"使用新行符分隔的文本消息进行通信\",{\"1\":{\"196\":1}}],[\"使用默认的开始和结束扇区\",{\"1\":{\"188\":1}}],[\"使用类型\",{\"1\":{\"185\":1}}],[\"使用没讲到\",{\"1\":{\"185\":1}}],[\"使用中的\",{\"1\":{\"185\":1}}],[\"使用优化的\",{\"1\":{\"179\":1}}],[\"使用fastgpt\",{\"1\":{\"143\":1}}],[\"使用大规模指标来调试管道运行或调查单个运行的性能\",{\"1\":{\"81\":1}}],[\"使用kubeflow\",{\"1\":{\"76\":1}}],[\"使用混杂模式的网桥\",{\"1\":{\"42\":1}}],[\"使用量\",{\"1\":{\"20\":2}}],[\"使用场景\",{\"0\":{\"17\":1,\"22\":1,\"28\":1,\"34\":1,\"44\":1,\"148\":1,\"164\":1,\"184\":1}}],[\"使用总量\",{\"1\":{\"15\":1}}],[\"使用\",{\"0\":{\"116\":1,\"207\":1,\"208\":1},\"1\":{\"6\":1,\"7\":1,\"8\":1,\"28\":1,\"90\":2,\"111\":1,\"154\":1,\"159\":1,\"185\":3,\"187\":1,\"191\":1,\"192\":1,\"199\":1,\"202\":1,\"260\":3}}],[\"如参数和梯度\",{\"1\":{\"296\":1}}],[\"如表ii所示\",{\"1\":{\"295\":1}}],[\"如gpipe\",{\"1\":{\"293\":1}}],[\"如pipedream\",{\"1\":{\"282\":1}}],[\"如dgx\",{\"1\":{\"280\":1,\"290\":1}}],[\"如双绞线\",{\"1\":{\"262\":1}}],[\"如交换机\",{\"1\":{\"235\":1}}],[\"如mac地址\",{\"1\":{\"230\":1}}],[\"如ens3或docker0\",{\"1\":{\"226\":1}}],[\"如33\",{\"1\":{\"226\":1}}],[\"如flannel\",{\"1\":{\"223\":1}}],[\"如广播\",{\"1\":{\"162\":1}}],[\"如计算集群\",{\"1\":{\"162\":1}}],[\"如在大规模数据处理或分析任务中\",{\"1\":{\"158\":1}}],[\"如流体动力学和热传导\",{\"1\":{\"158\":1}}],[\"如多个gpu或多台机器\",{\"1\":{\"146\":1}}],[\"如何面对压力\",{\"1\":{\"274\":2}}],[\"如何面对压力等\",{\"1\":{\"274\":2}}],[\"如何保持积极的心态\",{\"1\":{\"274\":4}}],[\"如何解决用户的问题\",{\"1\":{\"274\":4}}],[\"如何判断想法的是不是可以赚钱\",{\"1\":{\"274\":4}}],[\"如何无法访问\",{\"1\":{\"137\":1}}],[\"如何选择适合的执行器\",{\"0\":{\"92\":1}}],[\"如何能够让\",{\"0\":{\"47\":1}}],[\"如监控\",{\"1\":{\"90\":1}}],[\"如下图所示\",{\"1\":{\"101\":1}}],[\"如下所示\",{\"1\":{\"31\":1}}],[\"如下代码所示\",{\"1\":{\"0\":1}}],[\"如仅应用于某些特定的资源类型\",{\"1\":{\"16\":1}}],[\"如\",{\"1\":{\"15\":1,\"25\":2,\"28\":1,\"92\":1,\"101\":3,\"112\":1,\"147\":1,\"153\":1,\"155\":1,\"158\":1,\"161\":1}}],[\"如果有必要\",{\"1\":{\"299\":1}}],[\"如果新的配置比之前的配置性能更好\",{\"1\":{\"291\":1}}],[\"如果设备b的ip地址与请求中的ip地址匹配\",{\"1\":{\"231\":1}}],[\"如果在arp缓存中找不到设备b的mac地址\",{\"1\":{\"231\":1}}],[\"如果将veth设备移动到不同的命名空间\",{\"1\":{\"211\":1}}],[\"如果已经挂载\",{\"1\":{\"187\":1}}],[\"如果这些工作比较耗时那怎么办呢\",{\"1\":{\"185\":1}}],[\"如果这时这台机器在网络收到一个网络数据包\",{\"1\":{\"185\":1}}],[\"如果目标进程由另一个用户\",{\"1\":{\"185\":1}}],[\"如果某个进程表现异常\",{\"1\":{\"184\":1}}],[\"如果需要修改\",{\"1\":{\"137\":1}}],[\"如果需要删除路由\",{\"1\":{\"68\":1}}],[\"如果需要删除服务\",{\"1\":{\"65\":1}}],[\"如果修改了账号密码\",{\"1\":{\"137\":1}}],[\"如果希望使用\",{\"1\":{\"136\":1}}],[\"如果仍为\",{\"1\":{\"136\":1}}],[\"如果为false\",{\"1\":{\"136\":1}}],[\"如果使用\",{\"1\":{\"136\":1}}],[\"如果你正在寻找一位能够推动项目成功\",{\"1\":{\"126\":1}}],[\"如果你对开发\",{\"1\":{\"118\":1}}],[\"如果你更熟悉\",{\"1\":{\"92\":1}}],[\"如果你的工作流需要高效处理大量文件操作\",{\"1\":{\"92\":1}}],[\"如果你的工作流步骤之间需要共享文件或进程命名空间\",{\"1\":{\"92\":1}}],[\"如果你的工作流不需要特别的资源共享或文件处理\",{\"1\":{\"92\":1}}],[\"如果一个工件被多个不同运行中的执行使用\",{\"1\":{\"90\":1}}],[\"如果管道预计运行时间较长且触发频繁运行\",{\"1\":{\"90\":1}}],[\"如果pod不设置亲和性tolerations\",{\"1\":{\"31\":1}}],[\"如果\",{\"1\":{\"11\":1,\"19\":1,\"26\":1}}],[\"如果允许再利用\",{\"1\":{\"11\":1}}],[\"再往上则会出现gpu内存不足的错误\",{\"1\":{\"284\":1}}],[\"再利用或删除\",{\"1\":{\"11\":1}}],[\"再次使用\",{\"1\":{\"9\":1}}],[\"释放\",{\"1\":{\"11\":1}}],[\"释放锁的过程性能开销要尽量低\",{\"1\":{\"0\":1}}],[\"释放锁\",{\"1\":{\"0\":1}}],[\"后面跟随的是设备名\",{\"1\":{\"226\":1}}],[\"后续请求只需发送差异部分\",{\"1\":{\"199\":1}}],[\"后端将管道运行的运行时信息存储在元数据存储中\",{\"1\":{\"90\":1}}],[\"后端\",{\"1\":{\"90\":1}}],[\"后\",{\"1\":{\"11\":1,\"113\":1,\"189\":1}}],[\"被广泛应用于isp\",{\"1\":{\"237\":1}}],[\"被广泛应用于分布式深度学习训练中\",{\"1\":{\"148\":1}}],[\"被调度到带有特定标签的节点上\",{\"1\":{\"51\":1}}],[\"被认为不再需要\",{\"1\":{\"11\":1}}],[\"被删除后\",{\"1\":{\"11\":1}}],[\"被绑定到\",{\"1\":{\"11\":1}}],[\"被创建后\",{\"1\":{\"11\":1}}],[\"状态是stale\",{\"1\":{\"222\":1}}],[\"状态是reachable\",{\"1\":{\"222\":1}}],[\"状态检查\",{\"1\":{\"29\":1}}],[\"状态图示\",{\"0\":{\"12\":1}}],[\"状态重置为\",{\"1\":{\"11\":1}}],[\"状态变为\",{\"1\":{\"11\":2}}],[\"状态\",{\"1\":{\"11\":1,\"222\":1}}],[\"状态转换\",{\"0\":{\"11\":1}}],[\"状态时\",{\"1\":{\"7\":1,\"46\":1}}],[\"无法处理剩余的模型数据\",{\"1\":{\"296\":1}}],[\"无法承受重新计算或gpu\",{\"1\":{\"288\":1}}],[\"无法正常使用\",{\"1\":{\"10\":1}}],[\"无需手动去除\",{\"1\":{\"136\":1}}],[\"无头服务\",{\"0\":{\"32\":1}}],[\"无论是\",{\"1\":{\"185\":1}}],[\"无论是管理数据库\",{\"1\":{\"118\":1}}],[\"无论\",{\"1\":{\"0\":1}}],[\"通信机制\",{\"1\":{\"162\":1}}],[\"通信与同步\",{\"1\":{\"151\":1,\"156\":1}}],[\"通信后端\",{\"1\":{\"147\":1}}],[\"通信库是用于分布式计算的核心组件\",{\"1\":{\"146\":1}}],[\"通信以提交\",{\"1\":{\"86\":1}}],[\"通常为4\",{\"1\":{\"232\":1}}],[\"通常为6\",{\"1\":{\"232\":1}}],[\"通常为0x0800\",{\"1\":{\"232\":1}}],[\"通常为1\",{\"1\":{\"232\":1}}],[\"通常通过\",{\"1\":{\"185\":1}}],[\"通常需要同步操作来协调各个处理单元的执行\",{\"1\":{\"151\":1}}],[\"通常在集群中运行\",{\"1\":{\"86\":1}}],[\"通常用于有状态应用和自定义服务发现场景\",{\"1\":{\"39\":1}}],[\"通常用于部署有状态应用\",{\"1\":{\"34\":1}}],[\"通常用于以下场景\",{\"1\":{\"28\":1}}],[\"通常用于集群管理工具\",{\"1\":{\"25\":1}}],[\"通常是不同的cpu或gpu\",{\"1\":{\"151\":1}}],[\"通常是最合适的选择\",{\"1\":{\"92\":1}}],[\"通常是\",{\"1\":{\"26\":2,\"27\":1}}],[\"通常是因为与\",{\"1\":{\"10\":1}}],[\"通过综合运用这些技术\",{\"1\":{\"304\":1}}],[\"通过gpu\",{\"1\":{\"297\":1}}],[\"通过grep过滤出veth设备\",{\"1\":{\"207\":1}}],[\"通过优先使用更快的d2d交换和尽可能使用重计算\",{\"1\":{\"296\":1}}],[\"通过启用pipedream中的内存交换和重计算优化实现内存压缩\",{\"1\":{\"295\":1}}],[\"通过精心映射流水线阶段到gpu设备\",{\"1\":{\"288\":1}}],[\"通过nvlink将张量从高内存压力的gpu卸载到有空闲内存的gpu\",{\"1\":{\"286\":1}}],[\"通过网络结构分区\",{\"1\":{\"282\":1}}],[\"通过智能调度优化性能和内存使用\",{\"1\":{\"279\":1}}],[\"通过节省内存的操作间并行化民主化十亿规模模型训练\",{\"1\":{\"277\":1}}],[\"通过存储保存算子间并行性在多gpu服务器上实现十亿规模级模型训练的民主化\",{\"0\":{\"277\":1}}],[\"通过维护到达每个目标网络的路径信息来选择最佳路径\",{\"1\":{\"238\":1}}],[\"通过建立bgp会话来交换路由信息\",{\"1\":{\"238\":1}}],[\"通过虚拟专用网络\",{\"1\":{\"235\":1}}],[\"通过ip网络传输\",{\"1\":{\"220\":1}}],[\"通过减少广播流量和冲突域\",{\"1\":{\"213\":1}}],[\"通过分割网络减少广播域\",{\"1\":{\"213\":1}}],[\"通过vlan\",{\"1\":{\"213\":1}}],[\"通过这个命令\",{\"1\":{\"224\":1}}],[\"通过这个场景假设\",{\"1\":{\"185\":1}}],[\"通过这些命令\",{\"1\":{\"211\":1}}],[\"通过多路复用\",{\"1\":{\"204\":1}}],[\"通过https\",{\"1\":{\"202\":1}}],[\"通过http或https\",{\"1\":{\"202\":1}}],[\"通过四个基准测试评估\",{\"1\":{\"179\":1}}],[\"通过动态稀疏注意力加速长上下文\",{\"1\":{\"175\":1}}],[\"通过消息传递机制实现进程间的通信与同步\",{\"1\":{\"156\":1}}],[\"通过让多个处理单元执行相同的程序代码并处理不同的数据\",{\"1\":{\"155\":1}}],[\"通过提供灵活的通信后端和强大的同步机制\",{\"1\":{\"150\":1}}],[\"通过丰富的教学资源和优质的用户体验\",{\"1\":{\"126\":1}}],[\"通过定义自定义资源和控制器\",{\"1\":{\"118\":1}}],[\"通过创建工具可以实现的标准\",{\"1\":{\"98\":1}}],[\"通过共享的进程命名空间\",{\"1\":{\"91\":1}}],[\"通过kong路由访问\",{\"1\":{\"70\":1}}],[\"通过以下命令查询了路由是否成功创建\",{\"1\":{\"67\":1}}],[\"通过以下命令查询了服务是否成功创建\",{\"1\":{\"64\":1}}],[\"通过以下命令在kong中创建了一个名为\",{\"1\":{\"63\":1}}],[\"通过配置这些策略\",{\"1\":{\"55\":1}}],[\"通过标记节点来影响\",{\"1\":{\"31\":1}}],[\"通过限制单个容器或\",{\"1\":{\"19\":1}}],[\"通过设置资源限额\",{\"1\":{\"14\":1}}],[\"通过\",{\"1\":{\"0\":2,\"41\":1,\"70\":1,\"91\":1,\"92\":1,\"112\":1,\"115\":1,\"148\":1,\"164\":1,\"184\":1}}],[\"上进行训练\",{\"1\":{\"280\":1}}],[\"上没有重要数据\",{\"1\":{\"187\":1}}],[\"上也没有其他需要运行的进程了\",{\"1\":{\"185\":1}}],[\"上运行\",{\"1\":{\"162\":1}}],[\"上运行海洋模拟程序\",{\"1\":{\"159\":1}}],[\"上运行大气模拟程序\",{\"1\":{\"159\":1}}],[\"上的文件前\",{\"1\":{\"185\":1}}],[\"上的运行详情页面来跟踪运行的进度\",{\"1\":{\"90\":1}}],[\"上的部署变得简单\",{\"1\":{\"73\":1}}],[\"上传你的管道\",{\"1\":{\"84\":1}}],[\"上述fastgpt\",{\"1\":{\"137\":1}}],[\"上述描述来自\",{\"1\":{\"95\":1}}],[\"上述各个触发条件在\",{\"1\":{\"46\":1}}],[\"上述配置说明pod能够容忍节点设置taint的level=high\",{\"1\":{\"31\":1}}],[\"上\",{\"1\":{\"9\":1}}],[\"已超过单个gpu的容量\",{\"1\":{\"295\":1}}],[\"已使用\",{\"1\":{\"136\":1}}],[\"已从使用\",{\"1\":{\"90\":1}}],[\"已被删除\",{\"1\":{\"9\":1}}],[\"已经集成了该技术\",{\"1\":{\"282\":1}}],[\"已经运行在这个节点上的\",{\"1\":{\"31\":1}}],[\"已经被删除\",{\"1\":{\"9\":1}}],[\"已经被绑定到一个\",{\"1\":{\"8\":1}}],[\"已经与一个\",{\"1\":{\"8\":1}}],[\"本文参考了最近的alpa工作\",{\"1\":{\"282\":1}}],[\"本文主要介绍了独立开发者的相关内容\",{\"1\":{\"274\":2}}],[\"本质上是一个\",{\"1\":{\"113\":1}}],[\"本质是创建了一个\",{\"1\":{\"0\":1}}],[\"本项目中的应用程序\",{\"1\":{\"95\":1}}],[\"本身\",{\"1\":{\"25\":1,\"56\":1}}],[\"本身还没有被集群中的任何新\",{\"1\":{\"9\":1}}],[\"但要满足未来不断增长的模型需求仍然是一个挑战\",{\"1\":{\"302\":1}}],[\"但要注意其兼容性问题\",{\"1\":{\"92\":1}}],[\"但重计算不会消耗有限的gpu空闲内存\",{\"1\":{\"300\":1}}],[\"但其训练性能分别比mpress降低了30\",{\"1\":{\"297\":1}}],[\"但其性能比mpress低19\",{\"1\":{\"297\":1}}],[\"但需要牺牲训练速度\",{\"1\":{\"297\":1}}],[\"但拥有更大的cpu内存和额外的nvme\",{\"1\":{\"297\":1}}],[\"但mpress通过设备映射优化和三种优化策略的组合\",{\"1\":{\"296\":1}}],[\"但比mpress慢19\",{\"1\":{\"296\":1}}],[\"但也引入了不可忽视的跨gpu通信开销\",{\"1\":{\"285\":1}}],[\"但会带来额外的计算或通信开销\",{\"1\":{\"278\":1}}],[\"但一起使用时可以全面管理和配置网络接口\",{\"0\":{\"244\":1}}],[\"但通过适当的防御措施可以有效防止arp欺骗攻击\",{\"1\":{\"236\":1}}],[\"但通常也更复杂\",{\"1\":{\"152\":1}}],[\"但不知道设备b的mac地址\",{\"1\":{\"231\":1}}],[\"但非强制\",{\"1\":{\"205\":1}}],[\"但非加密的http请求仍然普遍存在\",{\"1\":{\"202\":1}}],[\"但它需要大量通信来收集和汇总部分结果\",{\"1\":{\"282\":1}}],[\"但它们仍可能需要在某些阶段进行通信和数据交换\",{\"1\":{\"156\":1}}],[\"但它还未被新的\",{\"1\":{\"9\":1}}],[\"但每个处理单元处理的输入数据是不同的\",{\"1\":{\"151\":1}}],[\"但每个处理单元处理不同的数据\",{\"1\":{\"150\":1}}],[\"但可以根据处理单元的id或索引来执行不同的操作\",{\"1\":{\"151\":1}}],[\"但\",{\"1\":{\"92\":1}}],[\"但在避免gpu\",{\"1\":{\"301\":1}}],[\"但在某些系统上仍然可用\",{\"1\":{\"260\":1}}],[\"但在某些网络插件或环境下可能是必要的\",{\"1\":{\"42\":1}}],[\"但在同一时刻只能处理一个请求\",{\"1\":{\"197\":1}}],[\"但在这一步\",{\"1\":{\"56\":1}}],[\"但如果没有其他合适的节点\",{\"1\":{\"31\":1}}],[\"但是速度越慢\",{\"1\":{\"136\":1}}],[\"但是\",{\"1\":{\"9\":1,\"185\":1}}],[\"但pv在挂载时只能使用一种访问模式\",{\"1\":{\"4\":1}}],[\"准备好用于新的\",{\"1\":{\"7\":1}}],[\"还通过进一步减少内存消耗来训练更大规模的模型\",{\"1\":{\"303\":1}}],[\"还展示了\",{\"1\":{\"179\":1}}],[\"还注重代码的可维护性和团队协作\",{\"1\":{\"121\":1}}],[\"还适用于想要将\",{\"1\":{\"73\":1}}],[\"还是\",{\"1\":{\"185\":1}}],[\"还是大数据处理集群\",{\"1\":{\"118\":1}}],[\"还是容器\",{\"1\":{\"21\":1}}],[\"还是遭遇网络分区\",{\"1\":{\"0\":1}}],[\"还未与任何\",{\"1\":{\"7\":1}}],[\"绑定\",{\"1\":{\"7\":3,\"8\":2,\"11\":1,\"12\":1}}],[\"可扩展性\",{\"1\":{\"241\":1}}],[\"可扩展性和可移植性\",{\"1\":{\"101\":1}}],[\"可达\",{\"1\":{\"222\":1}}],[\"可选\",{\"1\":{\"205\":1}}],[\"可选字段\",{\"1\":{\"16\":1}}],[\"可视化服务\",{\"1\":{\"103\":1}}],[\"可视化服务器\",{\"1\":{\"92\":1}}],[\"可微分架构搜索\",{\"1\":{\"100\":1}}],[\"可移植且可扩展\",{\"1\":{\"73\":1}}],[\"可用的运行触发器类型包括\",{\"1\":{\"90\":1}}],[\"可用的宿主机磁盘空间\",{\"1\":{\"46\":1}}],[\"可用内存\",{\"1\":{\"46\":1}}],[\"可能导致训练时间延长33\",{\"1\":{\"285\":1}}],[\"可能需要相应的权限\",{\"1\":{\"185\":1}}],[\"可能需要管理员干预以修复问题\",{\"1\":{\"10\":1}}],[\"可能涉及多个物理场\",{\"1\":{\"158\":1}}],[\"可能无法满足所有应用的需求\",{\"1\":{\"112\":1}}],[\"可能会使用\",{\"1\":{\"28\":1}}],[\"可能会被删除\",{\"1\":{\"11\":1}}],[\"可以应用于其他操作间并行训练系统\",{\"1\":{\"293\":1}}],[\"可以应用于节点\",{\"1\":{\"30\":1}}],[\"可以与\",{\"1\":{\"260\":1}}],[\"可以与任何\",{\"1\":{\"101\":1}}],[\"可以添加\",{\"1\":{\"260\":1}}],[\"可以查看和配置网络接口的状态和地址\",{\"1\":{\"260\":1}}],[\"可以查看桥接设备当前的mac地址表\",{\"1\":{\"224\":1}}],[\"可以查看它在调用哪些系统调用\",{\"1\":{\"184\":1}}],[\"可以方便地查看和管理系统中的veth设备对\",{\"1\":{\"211\":1}}],[\"可以执行不同的程序\",{\"1\":{\"155\":1}}],[\"可以通过\",{\"1\":{\"153\":1}}],[\"可以通过以下几种方式配置调度策略\",{\"1\":{\"47\":1}}],[\"可以用阿里云\",{\"1\":{\"137\":1}}],[\"可以传入\",{\"1\":{\"136\":1}}],[\"可以先从简单的示例开始\",{\"1\":{\"118\":1}}],[\"可以管理更复杂的工作负载\",{\"1\":{\"115\":1}}],[\"可以将一个物理网络分割成多个逻辑网络\",{\"1\":{\"213\":1}}],[\"可以将计算任务分布到多个节点\",{\"1\":{\"164\":1}}],[\"可以将多个进程组织成一个组\",{\"1\":{\"147\":1}}],[\"可以将最佳实践和操作流程编码成标准化的流程\",{\"1\":{\"115\":1}}],[\"可以将人类操作员\",{\"1\":{\"111\":1}}],[\"可以监控应用的健康状态\",{\"1\":{\"114\":1}}],[\"可以监控应用的新版本\",{\"1\":{\"114\":1}}],[\"可以定期备份应用的数据\",{\"1\":{\"114\":1}}],[\"可以自由对话\",{\"1\":{\"143\":1}}],[\"可以自动化和简化复杂应用的管理\",{\"1\":{\"118\":1}}],[\"可以自动化复杂应用的部署和管理过程\",{\"1\":{\"114\":1}}],[\"可以自定义变量$http\",{\"1\":{\"70\":1}}],[\"可以协调更高级的优化工作流\",{\"1\":{\"101\":1}}],[\"可以协调多节点和多gpu的分布式训练工作负载\",{\"1\":{\"101\":1}}],[\"可以考虑\",{\"1\":{\"92\":1}}],[\"可以选择\",{\"1\":{\"92\":1}}],[\"可以选择适当的发夹模式配置\",{\"1\":{\"45\":1}}],[\"可以看到\",{\"1\":{\"56\":1}}],[\"可以显著改善\",{\"1\":{\"55\":1}}],[\"可以设置防火墙规则\",{\"1\":{\"260\":1}}],[\"可以设置\",{\"1\":{\"54\":1}}],[\"可以防止某些\",{\"1\":{\"31\":1}}],[\"可以使用grep过滤出veth设备\",{\"1\":{\"208\":1}}],[\"可以使用以下几种方法\",{\"0\":{\"206\":1}}],[\"可以使用以下命令查看特定命名空间中的网络接口\",{\"1\":{\"211\":1}}],[\"可以使用以下命令查看\",{\"1\":{\"210\":1}}],[\"可以使用以下命令查看某个veth设备对的详细信息\",{\"1\":{\"209\":1}}],[\"可以使用以下命令\",{\"1\":{\"65\":1,\"68\":1}}],[\"可以使用\",{\"1\":{\"29\":1}}],[\"可以在ns1命名空间中看到它\",{\"1\":{\"211\":1}}],[\"可以在不同的处理单元上并行运行各自的程序\",{\"1\":{\"158\":1}}],[\"可以在不同的进程组之间进行广播\",{\"1\":{\"147\":1}}],[\"可以在\",{\"1\":{\"23\":1,\"43\":1}}],[\"可以提供默认值\",{\"1\":{\"19\":1}}],[\"可以供新的\",{\"1\":{\"7\":1}}],[\"可以被绑定到\",{\"1\":{\"7\":1}}],[\"可通过\",{\"1\":{\"0\":1}}],[\"描述应用程序元数据的能力\",{\"1\":{\"96\":1}}],[\"描述在给定组件输入参数值的情况下如何运行组件的规范\",{\"1\":{\"87\":1}}],[\"描述等\",{\"1\":{\"87\":1}}],[\"描述\",{\"1\":{\"7\":1,\"8\":1,\"9\":1,\"10\":1,\"87\":1}}],[\"以支持更大的模型\",{\"1\":{\"303\":1}}],[\"以智能地将不同模型张量分配到合适的内存层\",{\"1\":{\"302\":1}}],[\"以进一步降低成本\",{\"1\":{\"302\":1}}],[\"以此来测试我们的搜索算法\",{\"1\":{\"299\":1}}],[\"以探讨设备映射\",{\"1\":{\"298\":1}}],[\"以满足目标内存节省需求\",{\"1\":{\"291\":1}}],[\"以满足特定的网络需求\",{\"1\":{\"238\":1}}],[\"以最大限度地减少gpu\",{\"1\":{\"291\":1}}],[\"以最大化gpu内存节省的同时最小化训练过程中引入的额外延迟是一个非常具有挑战性的问题\",{\"1\":{\"291\":1}}],[\"以最大化这些gpu的交换带宽\",{\"1\":{\"290\":1}}],[\"以释放已使用的gpu内存\",{\"1\":{\"289\":1}}],[\"以确定当前的配置是否接近最佳配置\",{\"1\":{\"289\":1}}],[\"以确保\",{\"1\":{\"51\":1}}],[\"以符合操作的依赖关系\",{\"1\":{\"289\":1}}],[\"以选择对性能影响最小的优化方法\",{\"1\":{\"289\":1}}],[\"以启动第二阶段\",{\"1\":{\"283\":1}}],[\"以触发后续的计算\",{\"1\":{\"282\":1}}],[\"以充分利用闲置的gpu内存\",{\"1\":{\"279\":1}}],[\"以充分利用各自的计算优势\",{\"1\":{\"158\":1}}],[\"以太网\",{\"1\":{\"263\":1}}],[\"以通知其他对等体\",{\"1\":{\"239\":1}}],[\"以避免环路\",{\"1\":{\"238\":1}}],[\"以保证arp缓存的最新性\",{\"1\":{\"233\":1}}],[\"以实现负载均衡和计算资源的优化利用\",{\"1\":{\"156\":1}}],[\"以优化管道的执行效率和资源管理\",{\"1\":{\"92\":1}}],[\"以限制并行启动的运行数量\",{\"1\":{\"90\":1}}],[\"以便后续通信时可以直接使用\",{\"1\":{\"231\":1}}],[\"以便分析问题的根本原因\",{\"1\":{\"184\":1}}],[\"以便更灵活地管理和组织进程\",{\"1\":{\"162\":1}}],[\"以便它们之间进行通信\",{\"1\":{\"147\":1}}],[\"以便于重现\",{\"1\":{\"90\":1}}],[\"以便数据可以在分布式网络上传输\",{\"1\":{\"88\":1}}],[\"以图的形式呈现\",{\"1\":{\"84\":1}}],[\"以尽可能地将\",{\"1\":{\"47\":1}}],[\"以及内存压缩计划的选择\",{\"1\":{\"298\":1}}],[\"以及多种内存压缩优化技术的结合\",{\"1\":{\"297\":1}}],[\"以及三种方法各自的内存减少情况\",{\"1\":{\"295\":1}}],[\"以及948gb的cpu内存和6tb的nvme\",{\"1\":{\"295\":1}}],[\"以及768gb的cpu内存\",{\"1\":{\"295\":1}}],[\"以及调整合适的知识库参数\",{\"1\":{\"137\":1}}],[\"以及每个组件的输入和输出\",{\"1\":{\"84\":1}}],[\"以及使用\",{\"1\":{\"46\":1}}],[\"以及容器运行时镜像存储空间\",{\"1\":{\"46\":1}}],[\"以及对象数量\",{\"1\":{\"15\":1}}],[\"以及它是否能够被持久卷声明\",{\"1\":{\"6\":1}}],[\"以下是七层网络模型的详细介绍\",{\"1\":{\"261\":1}}],[\"以下是这些命令的功能及其关系的详细介绍\",{\"0\":{\"244\":1}}],[\"以下是对它们的解析\",{\"1\":{\"212\":1}}],[\"以下是对这两者的详细介绍\",{\"1\":{\"12\":1}}],[\"以下是它们之间的一些主要关联关系\",{\"1\":{\"92\":1}}],[\"以下是一个简单的\",{\"1\":{\"165\":1}}],[\"以下是一个简单的使用\",{\"1\":{\"149\":1}}],[\"以下是一个使用\",{\"1\":{\"36\":1}}],[\"以下是一个示例\",{\"1\":{\"27\":1}}],[\"以下是一个\",{\"1\":{\"15\":1,\"20\":1,\"35\":1}}],[\"以下是状态转换的示意图\",{\"1\":{\"12\":1}}],[\"以下是\",{\"1\":{\"6\":1,\"195\":1}}],[\"中等规模模型\",{\"1\":{\"296\":1}}],[\"中间加个具有号召性的按钮\",{\"1\":{\"274\":2}}],[\"中有一个软中断的概念\",{\"1\":{\"185\":1}}],[\"中实现高效分布式计算的关键组件\",{\"1\":{\"150\":1}}],[\"中一个不断循环检查资源实际状态并使其符合预期状态的逻辑组件\",{\"1\":{\"112\":1}}],[\"中引入新的资源类型\",{\"1\":{\"112\":1}}],[\"中创建\",{\"1\":{\"98\":1}}],[\"中创建和管理元数据\",{\"1\":{\"92\":1}}],[\"中称为作业\",{\"1\":{\"90\":1}}],[\"中的限制了\",{\"1\":{\"185\":1}}],[\"中的稀疏索引\",{\"1\":{\"179\":1}}],[\"中的进程可以组织成进程组\",{\"1\":{\"162\":1}}],[\"中的进程组是通信的基本单元\",{\"1\":{\"147\":1}}],[\"中的元数据管理\",{\"1\":{\"92\":1}}],[\"中的各个核心组件\",{\"1\":{\"92\":1}}],[\"中的各个步骤\",{\"1\":{\"84\":1}}],[\"中的自定义资源定义\",{\"1\":{\"92\":1}}],[\"中的定时任务\",{\"1\":{\"92\":1}}],[\"中的图形表示\",{\"1\":{\"89\":1}}],[\"中的某一步骤\",{\"1\":{\"85\":1}}],[\"中的其他容器的服务\",{\"1\":{\"40\":1}}],[\"中的数据库分片或有状态应用\",{\"1\":{\"33\":1}}],[\"中的一种特殊服务类型\",{\"1\":{\"39\":1}}],[\"中的一种特殊类型的\",{\"1\":{\"25\":1}}],[\"中的一种机制\",{\"1\":{\"30\":1}}],[\"中的\",{\"1\":{\"26\":1}}],[\"中用于限制命名空间内单个\",{\"1\":{\"18\":1}}],[\"中用来限制命名空间\",{\"1\":{\"13\":1}}],[\"中\",{\"1\":{\"6\":2,\"31\":1,\"32\":1,\"39\":1,\"47\":1,\"84\":1,\"85\":1,\"89\":1,\"95\":1}}],[\"在多个gpu之间分配模型参数\",{\"1\":{\"303\":1}}],[\"在多gpu训练中\",{\"1\":{\"147\":1}}],[\"在三种方法中\",{\"1\":{\"301\":1}}],[\"在bert模型中\",{\"1\":{\"300\":1}}],[\"在我们的所有评估案例中\",{\"1\":{\"299\":1}}],[\"在dgx\",{\"1\":{\"299\":1}}],[\"在大模型上\",{\"1\":{\"297\":1}}],[\"在大规模数据分析任务中\",{\"1\":{\"164\":1}}],[\"在主机内存请求方面\",{\"1\":{\"293\":1}}],[\"在每个步骤中\",{\"1\":{\"291\":1}}],[\"在不对称的拓扑结构中\",{\"1\":{\"290\":1}}],[\"在不同as之间的路由器之间运行\",{\"1\":{\"238\":1}}],[\"在不同模型和方法对比中性能良好\",{\"1\":{\"179\":1}}],[\"在不同环境中设置不同的限制\",{\"1\":{\"22\":1}}],[\"在对称nvlink拓扑结构中\",{\"1\":{\"290\":1}}],[\"在设计d2d交换技术时\",{\"1\":{\"290\":1}}],[\"在mpress的静态部分\",{\"1\":{\"289\":1}}],[\"在pipedream中对39\",{\"1\":{\"285\":1}}],[\"在相同的硬件配置下\",{\"1\":{\"284\":1}}],[\"在相邻的微批次之间有两种调度执行方式\",{\"1\":{\"283\":1}}],[\"在实践的过程中\",{\"1\":{\"274\":2}}],[\"在同一as内的路由器之间运行\",{\"1\":{\"238\":1}}],[\"在同一时间内\",{\"1\":{\"0\":1}}],[\"在使用flannel的kubernetes集群中\",{\"1\":{\"222\":1}}],[\"在以太网帧中添加一个4字节的标签\",{\"1\":{\"213\":1}}],[\"在一台aws\",{\"1\":{\"284\":1}}],[\"在一个连接上\",{\"1\":{\"198\":1}}],[\"在一些复杂的物理仿真中\",{\"1\":{\"158\":1}}],[\"在一些简化的集群管理方案中\",{\"1\":{\"28\":1}}],[\"在释放\",{\"1\":{\"188\":1}}],[\"在用户态得到文件数据\",{\"1\":{\"185\":1}}],[\"在问答\",{\"1\":{\"179\":1}}],[\"在成本效率和系统延迟方面表现出色\",{\"1\":{\"179\":1}}],[\"在推理中动态近似动态稀疏索引\",{\"1\":{\"179\":1}}],[\"在流体力学\",{\"1\":{\"164\":1}}],[\"在涉及多种计算架构\",{\"1\":{\"158\":1}}],[\"在需要并行处理不同任务的工作流中\",{\"1\":{\"158\":1}}],[\"在分布式训练中\",{\"1\":{\"154\":1}}],[\"在分布式数据并行训练中\",{\"1\":{\"147\":1}}],[\"在深度学习中\",{\"1\":{\"153\":1}}],[\"在这种情况下\",{\"1\":{\"296\":2,\"302\":1}}],[\"在这种模型中\",{\"1\":{\"150\":1}}],[\"在这里是flannel\",{\"1\":{\"222\":1}}],[\"在这个\",{\"1\":{\"106\":1}}],[\"在这个示例中\",{\"1\":{\"49\":1,\"53\":1}}],[\"在这个例子中\",{\"1\":{\"38\":1,\"222\":1}}],[\"在开发过程中\",{\"1\":{\"121\":1}}],[\"在配置\",{\"1\":{\"92\":1}}],[\"在某些\",{\"1\":{\"91\":1}}],[\"在某些情况下\",{\"1\":{\"34\":1}}],[\"在复杂的管道中\",{\"1\":{\"90\":1}}],[\"在那里你可以看到运行时的图表\",{\"1\":{\"90\":1}}],[\"在高层次上\",{\"1\":{\"75\":1}}],[\"在发送post跨域请求前\",{\"1\":{\"70\":1}}],[\"在发夹模式下\",{\"1\":{\"41\":1}}],[\"在拿到这个\",{\"1\":{\"56\":1}}],[\"在集群中的分布情况\",{\"1\":{\"55\":1}}],[\"在集群启动或恢复过程中\",{\"1\":{\"28\":1}}],[\"在节点上运行的条件\",{\"1\":{\"30\":2}}],[\"在命名空间内强制执行资源使用标准\",{\"1\":{\"22\":1}}],[\"在共享集群中\",{\"1\":{\"17\":1}}],[\"在操作过程中遇到错误\",{\"1\":{\"10\":1}}],[\"在生命周期中的位置\",{\"1\":{\"6\":1}}],[\"在\",{\"1\":{\"6\":1,\"12\":1,\"31\":1,\"32\":1,\"43\":1,\"46\":1,\"47\":1,\"84\":1,\"85\":1,\"89\":1,\"151\":2,\"152\":1,\"155\":1,\"156\":1,\"258\":1}}],[\"aws\",{\"1\":{\"302\":1}}],[\"awselasticblockstore\",{\"1\":{\"5\":1}}],[\"aka\",{\"1\":{\"274\":2}}],[\"a\",{\"0\":{\"288\":1,\"295\":1},\"1\":{\"211\":1,\"249\":1,\"250\":1,\"259\":1,\"260\":2}}],[\"a100\",{\"1\":{\"179\":1,\"295\":1,\"302\":1}}],[\"asn\",{\"1\":{\"238\":1}}],[\"as\",{\"1\":{\"149\":1,\"237\":1,\"238\":1}}],[\"aq0uogrk8ujsazfy3e986c5993bb4af3a9c3eb20708144f4\",{\"1\":{\"137\":1}}],[\"audiospeechmodels\",{\"1\":{\"136\":1}}],[\"authentication\",{\"1\":{\"137\":1}}],[\"authenticationdatabase\",{\"1\":{\"137\":2}}],[\"authsource=admin\",{\"1\":{\"137\":1}}],[\"authservice\",{\"1\":{\"103\":1,\"106\":1}}],[\"autonomous\",{\"1\":{\"237\":1}}],[\"auto\",{\"1\":{\"137\":2}}],[\"automl\",{\"1\":{\"100\":3,\"101\":1}}],[\"avatar\",{\"1\":{\"136\":5}}],[\"available=2m\",{\"1\":{\"46\":3}}],[\"available<30\",{\"1\":{\"46\":1}}],[\"available<5\",{\"1\":{\"46\":1}}],[\"available<500mi\",{\"1\":{\"46\":1}}],[\"available<15\",{\"1\":{\"46\":1}}],[\"available<10\",{\"1\":{\"46\":3}}],[\"available<100mi\",{\"1\":{\"46\":1}}],[\"available\",{\"1\":{\"7\":1,\"11\":2,\"12\":2,\"31\":2,\"46\":3,\"57\":1}}],[\"admin\",{\"1\":{\"137\":2}}],[\"advertise\",{\"1\":{\"137\":1}}],[\"ada\",{\"1\":{\"136\":1}}],[\"adaptation\",{\"1\":{\"100\":1}}],[\"add\",{\"1\":{\"70\":13,\"210\":1,\"256\":1}}],[\"address=http\",{\"1\":{\"137\":1}}],[\"address\",{\"1\":{\"137\":2,\"219\":1,\"230\":1,\"232\":6}}],[\"addr\",{\"1\":{\"70\":2}}],[\"amazon\",{\"1\":{\"100\":1}}],[\"azure\",{\"1\":{\"100\":1}}],[\"azuredisk和cinder类型的pv支持delete策略\",{\"1\":{\"5\":1}}],[\"aigc\",{\"2\":{\"144\":1}}],[\"ai助手百科全书\",{\"1\":{\"143\":1}}],[\"ai模型的api\",{\"1\":{\"137\":1}}],[\"ai模型的api地址哦\",{\"1\":{\"137\":1}}],[\"ai\",{\"1\":{\"100\":1,\"101\":1,\"135\":1,\"142\":1,\"143\":2}}],[\"ago\",{\"1\":{\"92\":1}}],[\"age\",{\"1\":{\"31\":1,\"70\":1,\"92\":1}}],[\"allreduce操作\",{\"1\":{\"147\":1}}],[\"alloy\",{\"1\":{\"136\":3}}],[\"allow\",{\"1\":{\"70\":4}}],[\"alive\",{\"1\":{\"197\":1}}],[\"aliyuncs\",{\"1\":{\"137\":4,\"143\":1}}],[\"align\",{\"1\":{\"70\":2}}],[\"always\",{\"1\":{\"70\":1,\"137\":5}}],[\"a><\",{\"1\":{\"70\":1}}],[\"absolute\",{\"1\":{\"70\":1}}],[\"affinity\",{\"0\":{\"48\":1,\"50\":1},\"1\":{\"49\":1,\"50\":1,\"51\":1}}],[\"anti\",{\"0\":{\"48\":1}}],[\"arp检测\",{\"1\":{\"235\":1}}],[\"arp欺骗的防御措施\",{\"0\":{\"235\":1}}],[\"arp的安全问题\",{\"0\":{\"234\":1}}],[\"arp缓存中的条目通常有一个生存时间\",{\"1\":{\"233\":1}}],[\"arp请求中该字段为空\",{\"1\":{\"232\":1}}],[\"arp请求和arp响应\",{\"1\":{\"232\":1}}],[\"arp报文包含两个主要部分\",{\"1\":{\"232\":1}}],[\"arp\",{\"0\":{\"231\":1,\"232\":1,\"233\":1},\"1\":{\"230\":1,\"231\":2,\"234\":1}}],[\"arp协议在ipv4网络中起到了关键的地址解析作用\",{\"1\":{\"236\":1}}],[\"arp协议本身没有安全机制\",{\"1\":{\"234\":1}}],[\"arp协议\",{\"0\":{\"230\":1}}],[\"architecture\",{\"1\":{\"100\":2}}],[\"argv\",{\"1\":{\"165\":2}}],[\"argc\",{\"1\":{\"165\":2}}],[\"argo\",{\"0\":{\"91\":1},\"1\":{\"90\":3,\"92\":2,\"101\":1}}],[\"args\",{\"1\":{\"31\":1}}],[\"artifact\",{\"1\":{\"90\":1}}],[\"artifacts\",{\"1\":{\"81\":1}}],[\"arial\",{\"1\":{\"70\":1}}],[\"area\",{\"0\":{\"213\":1},\"1\":{\"212\":1}}],[\"are\",{\"1\":{\"31\":2}}],[\"apt\",{\"1\":{\"171\":1}}],[\"application\",{\"0\":{\"268\":1},\"1\":{\"70\":1,\"93\":3,\"94\":1}}],[\"app=myapp\",{\"1\":{\"49\":1}}],[\"app\",{\"1\":{\"31\":2,\"35\":4,\"37\":2,\"38\":7,\"49\":1,\"53\":1,\"93\":1,\"137\":1,\"139\":1}}],[\"apps\",{\"1\":{\"31\":1,\"38\":1,\"93\":1}}],[\"apikey\",{\"1\":{\"143\":1}}],[\"apiv2beta1\",{\"1\":{\"104\":4}}],[\"apiv1beta1\",{\"1\":{\"103\":8}}],[\"apiversion\",{\"1\":{\"15\":1,\"20\":1,\"27\":1,\"31\":1,\"35\":1,\"37\":1,\"38\":1,\"43\":1,\"49\":1,\"51\":1,\"53\":1,\"55\":1,\"93\":1}}],[\"api服务器以创建运行管道所需的必要kubernetes资源\",{\"1\":{\"79\":1}}],[\"apiserver\",{\"1\":{\"25\":1,\"28\":1,\"92\":1}}],[\"api\",{\"0\":{\"103\":1,\"104\":1},\"1\":{\"25\":1,\"26\":2,\"28\":1,\"56\":10,\"86\":1,\"90\":1,\"91\":1,\"92\":2,\"98\":2,\"111\":1,\"113\":1,\"117\":1,\"137\":4,\"143\":4,\"161\":1}}],[\"accept\",{\"1\":{\"259\":2}}],[\"access\",{\"0\":{\"4\":1},\"1\":{\"70\":7,\"137\":1}}],[\"ac\",{\"1\":{\"225\":2}}],[\"acquired\",{\"1\":{\"0\":1}}],[\"acquire\",{\"1\":{\"0\":1}}],[\"回收策略\",{\"0\":{\"5\":1}}],[\"载\",{\"1\":{\"4\":1}}],[\"并被用于将早期阶段的张量\",{\"1\":{\"301\":1}}],[\"并优先选择重计算而不是d2d交换\",{\"1\":{\"300\":1}}],[\"并会延迟操作间并行训练\",{\"1\":{\"300\":1}}],[\"并估算相应的反向传播的flops为前向传播的两倍\",{\"1\":{\"295\":1}}],[\"并启用了高性能重计算的dapple+recomp\",{\"1\":{\"295\":1}}],[\"并启用其nccl库以使用nvlink在阶段之间传输数据\",{\"1\":{\"293\":1}}],[\"并监控每个设备的内存使用情况\",{\"1\":{\"293\":1}}],[\"并基于以下几个关键观察来进行简化\",{\"1\":{\"291\":1}}],[\"并让其总数量与目标接收gpu的数量一致\",{\"1\":{\"290\":1}}],[\"并触发启用了内存压缩的操作间并行训练\",{\"1\":{\"289\":1}}],[\"并与之前的运行结果进行比较\",{\"1\":{\"289\":1}}],[\"并收集gpu内存节省量及引入的开销\",{\"1\":{\"289\":1}}],[\"并引入额外的延迟\",{\"1\":{\"285\":1}}],[\"并已被许多主流系统采用\",{\"1\":{\"285\":1}}],[\"并设置了最大可持续的模型规模\",{\"1\":{\"284\":1}}],[\"并从工人3回流至工人1\",{\"1\":{\"283\":1}}],[\"并定期交换与模型参数等大小的梯度\",{\"1\":{\"282\":1}}],[\"并映射到单独的gpu上进行计算\",{\"1\":{\"282\":1}}],[\"并单播发送给设备a\",{\"1\":{\"231\":1}}],[\"并询问\",{\"1\":{\"231\":1}}],[\"并附加上对应的vni\",{\"1\":{\"220\":1}}],[\"并跟踪它的系统调用\",{\"1\":{\"183\":1}}],[\"并实时显示它的系统调用\",{\"1\":{\"182\":1}}],[\"并行计算\",{\"1\":{\"163\":1}}],[\"并行i\",{\"1\":{\"162\":1}}],[\"并行性\",{\"1\":{\"151\":1,\"156\":1}}],[\"并通过高带宽\",{\"1\":{\"302\":1}}],[\"并通过不同链路并行传输\",{\"1\":{\"290\":1}}],[\"并通过多种实验和测试展示了其效果\",{\"1\":{\"178\":1}}],[\"并通过\",{\"1\":{\"159\":1}}],[\"并处理不同的数据集\",{\"1\":{\"155\":1,\"161\":1}}],[\"并在dapple上运行mpress\",{\"1\":{\"295\":1}}],[\"并在训练过程中共享模型参数\",{\"1\":{\"153\":1}}],[\"并在出现故障时自动进行恢复\",{\"1\":{\"114\":1}}],[\"并重启即可\",{\"1\":{\"137\":1}}],[\"并自动执行无中断的滚动升级\",{\"1\":{\"114\":1}}],[\"并根据需要恢复状态\",{\"1\":{\"289\":1}}],[\"并根据策略决定是否将这些路由信息传播给其他对等体\",{\"1\":{\"239\":1}}],[\"并根据用户定义的逻辑执行相应的操作\",{\"1\":{\"113\":1}}],[\"并根据这些文件创建和管理\",{\"1\":{\"26\":1}}],[\"并进行相应的标注\",{\"1\":{\"89\":1}}],[\"并将计算传递给工人2\",{\"1\":{\"283\":1}}],[\"并将数据片段分配给gpu设备来训练共享的复制模型\",{\"1\":{\"282\":1}}],[\"并将结果分配给多个设备\",{\"1\":{\"282\":1}}],[\"并将以太网帧发送到其二层网络接口\",{\"1\":{\"219\":1}}],[\"并将其类型设置为\",{\"1\":{\"188\":1}}],[\"并将其添加到现有的\",{\"1\":{\"186\":1}}],[\"并将这些资源的状态持久化到ml元数据服务中\",{\"1\":{\"82\":1}}],[\"并将流量从服务的\",{\"1\":{\"35\":1}}],[\"并确保kong服务已正确启动\",{\"1\":{\"62\":1}}],[\"并不会直接去调用后端的容器项目\",{\"1\":{\"56\":1}}],[\"并为每个映射方案确定合适的内存分配策略\",{\"1\":{\"290\":1}}],[\"并为每个\",{\"1\":{\"39\":1}}],[\"并且无需对硬件进行额外的修改或优化\",{\"1\":{\"303\":1}}],[\"并且只在必要时使用gpu\",{\"1\":{\"303\":1}}],[\"并且只能被单个node挂\",{\"1\":{\"4\":1}}],[\"并且吸收了来自深度学习社区的各种优化\",{\"1\":{\"297\":1}}],[\"并且需要额外的具有高i\",{\"1\":{\"297\":1}}],[\"并且比重计算更快\",{\"1\":{\"296\":1}}],[\"并且能够与gpu上的前向和后向计算并行运行\",{\"1\":{\"291\":1}}],[\"并且能够训练比基线更大的模型\",{\"1\":{\"280\":1}}],[\"并且允许d2d交换更好地与dnn计算重叠\",{\"1\":{\"288\":1}}],[\"并且允许直接访问每个\",{\"1\":{\"32\":1}}],[\"并且它未被挂载\",{\"1\":{\"187\":1}}],[\"并且我们可以进一步假设\",{\"1\":{\"185\":1}}],[\"并且每个处理单元处理不同的数据\",{\"1\":{\"152\":1}}],[\"并且可以使用多种语言与人交流\",{\"1\":{\"143\":1}}],[\"并且支持不同版本的api\",{\"1\":{\"106\":1}}],[\"并且本身支持许多\",{\"1\":{\"100\":1}}],[\"并且希望与其他工具\",{\"1\":{\"97\":1}}],[\"并且你的集群配置支持\",{\"1\":{\"92\":1}}],[\"并且\",{\"1\":{\"56\":1}}],[\"并指定一个键值对\",{\"1\":{\"30\":1}}],[\"并获取到\",{\"1\":{\"0\":1}}],[\"kv\",{\"1\":{\"179\":1}}],[\"kudo\",{\"1\":{\"117\":1}}],[\"kubebuilder\",{\"1\":{\"117\":1}}],[\"kubeflow\",{\"0\":{\"73\":1},\"1\":{\"73\":7,\"74\":2,\"81\":2,\"84\":3,\"85\":1,\"87\":1,\"89\":2,\"90\":9,\"91\":2,\"92\":18,\"101\":2,\"124\":1},\"2\":{\"110\":1}}],[\"kubeadm\",{\"1\":{\"57\":2}}],[\"kubectl\",{\"1\":{\"29\":2,\"31\":2,\"56\":1,\"92\":1,\"98\":1,\"113\":1}}],[\"kube\",{\"1\":{\"25\":3,\"27\":1,\"28\":3,\"29\":1,\"55\":1,\"93\":1}}],[\"kubelet如何实现\",{\"0\":{\"56\":1}}],[\"kubeletconfiguration\",{\"1\":{\"43\":1}}],[\"kubelet的\",{\"0\":{\"40\":1}}],[\"kubelet\",{\"1\":{\"25\":1,\"26\":4,\"27\":1,\"29\":2,\"40\":1,\"42\":2,\"43\":5,\"45\":1,\"46\":4,\"56\":5,\"57\":12}}],[\"kubernetes\",{\"0\":{\"47\":1,\"95\":1},\"1\":{\"6\":2,\"12\":1,\"13\":1,\"18\":1,\"23\":1,\"25\":4,\"26\":1,\"27\":3,\"28\":5,\"29\":1,\"30\":1,\"31\":3,\"32\":2,\"33\":1,\"34\":1,\"39\":1,\"46\":5,\"47\":1,\"49\":2,\"52\":1,\"53\":1,\"54\":1,\"57\":1,\"73\":3,\"74\":2,\"84\":1,\"91\":2,\"92\":4,\"93\":1,\"94\":1,\"95\":3,\"98\":2,\"100\":1,\"101\":1,\"111\":4,\"112\":4,\"113\":1,\"115\":3,\"117\":2,\"118\":3,\"123\":1}}],[\"kubernetes支持的回收策略如下\",{\"1\":{\"5\":1}}],[\"kubernetes支持的访问模式如下\",{\"1\":{\"4\":1}}],[\"k8r6z\",{\"1\":{\"92\":2}}],[\"k8sapiexecutor\",{\"1\":{\"91\":1,\"92\":2}}],[\"k8s技能图谱\",{\"0\":{\"24\":1}}],[\"k8s\",{\"0\":{\"111\":1},\"1\":{\"3\":1,\"12\":1,\"43\":1,\"73\":1,\"93\":3,\"123\":1},\"2\":{\"58\":1}}],[\"k8s知识点\",{\"0\":{\"3\":1}}],[\"katib\",{\"0\":{\"100\":1,\"101\":1},\"1\":{\"92\":19,\"100\":5,\"101\":10}}],[\"keep\",{\"1\":{\"197\":1}}],[\"keepalive\",{\"1\":{\"70\":1}}],[\"kernel\",{\"1\":{\"179\":1}}],[\"key=filetoken\",{\"1\":{\"137\":1}}],[\"key=root\",{\"1\":{\"137\":1}}],[\"key=any\",{\"1\":{\"137\":1}}],[\"key=sk\",{\"1\":{\"137\":1}}],[\"keyfile\",{\"1\":{\"137\":1}}],[\"key\",{\"1\":{\"0\":8,\"31\":2,\"49\":1,\"51\":1,\"57\":1,\"137\":9,\"143\":2}}],[\"kong路由\",{\"1\":{\"70\":1}}],[\"kong服务\",{\"1\":{\"70\":1}}],[\"kong\",{\"1\":{\"61\":1},\"2\":{\"71\":1,\"72\":1}}],[\"kong和nginx创建服务和路由\",{\"1\":{\"60\":1}}],[\"kong和nginx部署服务\",{\"0\":{\"60\":1}}],[\"kind\",{\"1\":{\"15\":1,\"20\":1,\"27\":1,\"31\":1,\"35\":1,\"37\":1,\"38\":1,\"43\":1,\"49\":1,\"51\":1,\"53\":1,\"55\":1,\"93\":1}}],[\"高带宽内存\",{\"1\":{\"302\":1}}],[\"高扩展性\",{\"1\":{\"215\":1}}],[\"高效的消息传递\",{\"1\":{\"163\":1}}],[\"高效神经架构搜索\",{\"1\":{\"100\":1}}],[\"高性能的后端服务\",{\"1\":{\"122\":1}}],[\"高性能\",{\"1\":{\"0\":1}}],[\"高可用\",{\"1\":{\"0\":1}}],[\"活性\",{\"1\":{\"0\":1}}],[\"不可避免的额外重计算延迟会扩大早期层的生命周期\",{\"1\":{\"291\":1}}],[\"不幸的是\",{\"1\":{\"282\":1}}],[\"不积极才是常态\",{\"1\":{\"274\":2}}],[\"不做完美的产品\",{\"1\":{\"274\":2}}],[\"不做免费的产品\",{\"1\":{\"274\":2}}],[\"不支持\",{\"1\":{\"205\":4}}],[\"不支持工具和函数调用的模型\",{\"1\":{\"136\":1}}],[\"不过\",{\"1\":{\"185\":1}}],[\"不仅仅是基础设施视图\",{\"1\":{\"97\":1}}],[\"不应该被调度到相同的节点上\",{\"1\":{\"49\":1}}],[\"不应该与其他特定\",{\"1\":{\"48\":1}}],[\"不足的阈值达到\",{\"1\":{\"46\":1}}],[\"不同gpu之间的带宽和连接链路数量可能存在硬件异构性\",{\"1\":{\"290\":1}}],[\"不同的流可以独立处理\",{\"1\":{\"198\":1}}],[\"不同的处理单元可以负责不同的任务或数据集\",{\"1\":{\"158\":1}}],[\"不同\",{\"1\":{\"33\":1,\"152\":1}}],[\"不会相互阻塞\",{\"1\":{\"198\":1}}],[\"不会为服务分配一个\",{\"1\":{\"33\":1}}],[\"不会分配集群\",{\"1\":{\"32\":1}}],[\"不会被调度到这个节点上\",{\"1\":{\"31\":1}}],[\"不会出现\",{\"1\":{\"0\":1}}],[\"不能依赖于\",{\"1\":{\"28\":1}}],[\"不是通过\",{\"1\":{\"26\":1}}],[\"不需要\",{\"1\":{\"26\":1}}],[\"不允许多个\",{\"1\":{\"0\":1}}],[\"它不仅能够利用现有的流水线并行\",{\"1\":{\"303\":1}}],[\"它不能再被其他\",{\"1\":{\"8\":1}}],[\"它能够支持训练参数最多为6亿的bert模型\",{\"1\":{\"284\":1}}],[\"它能够在大多数场景下提供良好的性能和功能支持\",{\"1\":{\"45\":1}}],[\"它结合了多种内存优化技术\",{\"1\":{\"279\":1}}],[\"它还提供同步和对话控制\",{\"1\":{\"266\":1}}],[\"它将模型的不同层分配给不同的设备\",{\"1\":{\"303\":1}}],[\"它将网络通信过程划分为七个层次\",{\"1\":{\"261\":1}}],[\"它将帧封装在udp包中\",{\"1\":{\"219\":1}}],[\"它用于管理入站\",{\"1\":{\"258\":1}}],[\"它知道设备b的ip地址\",{\"1\":{\"231\":1}}],[\"它在以太网等局域网环境中起着关键作用\",{\"1\":{\"230\":1}}],[\"它可以添加\",{\"1\":{\"255\":1}}],[\"它可以查看和修改接口配置\",{\"1\":{\"246\":1}}],[\"它可以完成这些耗时比较长的工作\",{\"1\":{\"185\":1}}],[\"它可以帮助你诊断程序的行为或调试程序\",{\"1\":{\"182\":1}}],[\"它可以调优用任何用户选择的语言编写的应用程序的超参数\",{\"1\":{\"100\":1}}],[\"它的路径向量机制\",{\"1\":{\"243\":1}}],[\"它的主要特点和用途如下\",{\"1\":{\"213\":1,\"214\":1}}],[\"它的灵活性使其非常适合处理复杂的并行任务\",{\"1\":{\"161\":1}}],[\"它的简洁性和高效性使其成为许多并行和分布式计算任务的首选模型\",{\"1\":{\"155\":1}}],[\"它包括了\",{\"1\":{\"113\":1}}],[\"它提供了\",{\"0\":{\"96\":1}}],[\"它会检查其中的ip地址\",{\"1\":{\"231\":1}}],[\"它会定期启动运行配置的新副本\",{\"1\":{\"90\":1}}],[\"它会创建一个\",{\"1\":{\"0\":1}}],[\"它执行机器学习\",{\"1\":{\"85\":1}}],[\"它编排基于任务的工作流\",{\"1\":{\"80\":1}}],[\"它决定了\",{\"1\":{\"40\":1}}],[\"它通过结合多种内存优化技术\",{\"1\":{\"303\":1}}],[\"它通过丢弃中间激活值并在反向传播中重新计算它们\",{\"1\":{\"303\":1}}],[\"它通过不分配\",{\"1\":{\"39\":1}}],[\"它通过将模型的层分成多个阶段\",{\"1\":{\"303\":1}}],[\"它通过将\",{\"1\":{\"33\":1}}],[\"它与\",{\"1\":{\"38\":1}}],[\"它选择了带有标签\",{\"1\":{\"35\":1}}],[\"它由\",{\"1\":{\"25\":1}}],[\"它为容器设置了\",{\"1\":{\"20\":1}}],[\"它限制了某个命名空间内的\",{\"1\":{\"15\":1}}],[\"它们通过自定义的内存架构和高效的并行计算\",{\"1\":{\"303\":1}}],[\"它们可以通过数据并行进行大规模模型训练\",{\"1\":{\"295\":1}}],[\"它们都来自自然语言处理领域\",{\"1\":{\"295\":1}}],[\"它们各自有不同的功能\",{\"0\":{\"244\":1}}],[\"它们各自有不同的优缺点和应用场景\",{\"1\":{\"216\":1}}],[\"它们各自有不同的应用场景和特点\",{\"1\":{\"212\":1}}],[\"它们的\",{\"1\":{\"185\":1}}],[\"它们在不同的计算环境中均能有效运行\",{\"1\":{\"163\":1}}],[\"它们将其软件包发布集中在应用程序安装上\",{\"1\":{\"97\":1}}],[\"它们共同组成了\",{\"1\":{\"92\":1}}],[\"它们帮助管理员公平分配集群资源\",{\"1\":{\"14\":1}}],[\"它们帮助管理员确保资源的公平分配和高效利用\",{\"1\":{\"12\":1}}],[\"它们用于防止某个命名空间消耗过多的集群资源\",{\"1\":{\"13\":1}}],[\"它未被任何\",{\"1\":{\"7\":1}}],[\"它反映了存储卷的当前状态\",{\"1\":{\"6\":1}}],[\"它一定是持久化到了集群多数节点上\",{\"1\":{\"0\":1}}],[\"因为hbm成本昂贵\",{\"1\":{\"302\":1}}],[\"因为在三种方法中\",{\"1\":{\"300\":1}}],[\"因为在高内存压力下\",{\"1\":{\"296\":1}}],[\"因为其时间成本过高\",{\"1\":{\"301\":1}}],[\"因为其生命周期较长\",{\"1\":{\"300\":1}}],[\"因为其最大每gpu内存需求超过了32gb\",{\"1\":{\"297\":1}}],[\"因为前者的时间成本超过了t2的生命周期\",{\"1\":{\"300\":1}}],[\"因为对称的全互联nvlink连接使得每个gpu拥有相同数量的nvlink连接\",{\"1\":{\"299\":1}}],[\"因为对于大规模的自然语言处理模型\",{\"1\":{\"282\":1}}],[\"因为dapple默认启用了fp16低精度训练功能\",{\"1\":{\"297\":1}}],[\"因为a100\",{\"1\":{\"297\":1}}],[\"因为aws\",{\"1\":{\"295\":1}}],[\"因为zero\",{\"1\":{\"297\":1}}],[\"因为它过于缓慢\",{\"1\":{\"300\":1}}],[\"因为它的性能比gpu\",{\"1\":{\"300\":1}}],[\"因为它的时间成本只有3毫秒\",{\"1\":{\"300\":1}}],[\"因为它的成本可以被隐藏起来\",{\"1\":{\"300\":1}}],[\"因为它可以应用于所有类型的模型数据\",{\"1\":{\"296\":1}}],[\"因为它们可以用于性能评估\",{\"1\":{\"90\":1}}],[\"因为重计算只能减少前向传播生成的激活值的内存消耗\",{\"1\":{\"296\":1}}],[\"因为重新计算丢弃激活值的前向传播引入的延迟通常远低于gpu\",{\"1\":{\"296\":1}}],[\"因为pcie带宽的限制导致交换操作非常慢\",{\"1\":{\"296\":1}}],[\"因为第一层操作符的输出是前一层的输入\",{\"1\":{\"291\":1}}],[\"因为每个gpu都会复制相同数量的模型数据\",{\"1\":{\"282\":1}}],[\"因为每个处理单元可以执行不同的程序\",{\"1\":{\"157\":1}}],[\"因为只有\",{\"1\":{\"0\":1}}],[\"因此mpress没有使用其他两种优化\",{\"1\":{\"296\":1}}],[\"因此不需要触发任何内存压缩优化\",{\"1\":{\"296\":1}}],[\"因此不会带来运行时开销\",{\"1\":{\"289\":1}}],[\"因此我们引入了数据分条技术\",{\"1\":{\"290\":1}}],[\"因此容易受到arp欺骗\",{\"1\":{\"234\":1}}],[\"因此需要通过通信机制进行数据交换\",{\"1\":{\"159\":1}}],[\"因此任务协调和进程管理可能更加复杂\",{\"1\":{\"157\":1}}],[\"因此\",{\"1\":{\"90\":1,\"282\":2,\"293\":1,\"299\":1,\"300\":2,\"302\":3}}],[\"因此它们的一些管理和监控操作与普通\",{\"1\":{\"29\":1}}],[\"因此它们没有自动伸缩\",{\"1\":{\"26\":1}}],[\"因此非常适合用于管理集群的核心组件\",{\"1\":{\"26\":1}}],[\"因此一旦分布式锁申请返回给\",{\"1\":{\"0\":1}}],[\"rpc\",{\"1\":{\"266\":1}}],[\"rs\",{\"1\":{\"137\":2}}],[\"rs0\",{\"1\":{\"137\":2}}],[\"rsa+3des\",{\"1\":{\"70\":1}}],[\"rsa+aes256\",{\"1\":{\"70\":1}}],[\"rsa+aes128\",{\"1\":{\"70\":1}}],[\"rgmgf\",{\"1\":{\"92\":2}}],[\"rank\",{\"1\":{\"149\":5,\"165\":5}}],[\"rand\",{\"1\":{\"137\":1}}],[\"random\",{\"1\":{\"100\":1}}],[\"range\",{\"1\":{\"70\":1}}],[\"raft\",{\"1\":{\"0\":1}}],[\"right\",{\"1\":{\"70\":1}}],[\"router\",{\"1\":{\"264\":1}}],[\"routes\",{\"1\":{\"66\":1,\"67\":1,\"68\":1}}],[\"route\",{\"1\":{\"66\":2,\"67\":1,\"68\":1,\"255\":1,\"256\":3,\"260\":2}}],[\"root的密钥\",{\"1\":{\"137\":1}}],[\"root\",{\"1\":{\"57\":1,\"70\":1,\"92\":1,\"137\":10,\"139\":1,\"140\":1,\"185\":1,\"186\":1,\"190\":2,\"191\":1,\"192\":1}}],[\"rotation\",{\"1\":{\"57\":1}}],[\"rox\",{\"1\":{\"4\":1}}],[\"runs创建过程是\",{\"1\":{\"108\":1}}],[\"runservice\",{\"1\":{\"103\":1,\"104\":1,\"106\":1}}],[\"running\",{\"1\":{\"57\":1,\"89\":1,\"92\":13}}],[\"run\",{\"1\":{\"57\":4,\"61\":1,\"90\":2,\"136\":1,\"137\":1}}],[\"rwx\",{\"1\":{\"4\":1}}],[\"rwo\",{\"1\":{\"4\":1}}],[\"reduction\",{\"1\":{\"162\":1}}],[\"redirect\",{\"1\":{\"56\":1,\"70\":1}}],[\"redis\",{\"1\":{\"0\":2,\"123\":1}}],[\"reload\",{\"1\":{\"143\":1}}],[\"release\",{\"1\":{\"0\":1,\"137\":1}}],[\"released\",{\"1\":{\"0\":1,\"11\":1,\"12\":1}}],[\"rerankmodels\",{\"1\":{\"136\":1}}],[\"reflection\",{\"1\":{\"105\":1}}],[\"reflectionservice\",{\"1\":{\"105\":1,\"106\":1}}],[\"reply\",{\"1\":{\"143\":1}}],[\"replset\",{\"1\":{\"137\":1}}],[\"replicas\",{\"1\":{\"31\":1,\"38\":1}}],[\"replicaset\",{\"1\":{\"26\":2,\"92\":1}}],[\"reportservice\",{\"1\":{\"103\":1,\"106\":1}}],[\"register\",{\"1\":{\"105\":1}}],[\"registerauthserviceserver\",{\"1\":{\"103\":1}}],[\"registervisualizationserviceserver\",{\"1\":{\"103\":1}}],[\"registerrecurringrunserviceserver\",{\"1\":{\"104\":1}}],[\"registerreportserviceserver\",{\"1\":{\"103\":1}}],[\"registerrunserviceserver\",{\"1\":{\"103\":1,\"104\":1}}],[\"registertaskserviceserver\",{\"1\":{\"103\":1}}],[\"registerjobserviceserver\",{\"1\":{\"103\":1}}],[\"registerpipelineserviceserver\",{\"1\":{\"103\":1,\"104\":1}}],[\"registerexperimentserviceserver\",{\"1\":{\"103\":1,\"104\":1}}],[\"registry\",{\"1\":{\"31\":1,\"92\":1,\"137\":4,\"143\":1}}],[\"retention=1000\",{\"1\":{\"137\":1}}],[\"retries\",{\"1\":{\"137\":3}}],[\"return\",{\"1\":{\"70\":1,\"165\":1}}],[\"retain\",{\"1\":{\"5\":1}}],[\"resolution\",{\"1\":{\"219\":1,\"230\":1}}],[\"resource\",{\"1\":{\"112\":2}}],[\"resourcemanager\",{\"1\":{\"103\":4}}],[\"resources\",{\"1\":{\"31\":1,\"93\":1}}],[\"resourcequota\",{\"1\":{\"15\":2,\"16\":1}}],[\"resourcequotas\",{\"0\":{\"13\":1},\"1\":{\"12\":1,\"13\":1,\"14\":1,\"18\":1,\"23\":1}}],[\"restart\",{\"1\":{\"137\":5}}],[\"restarts\",{\"1\":{\"92\":1}}],[\"restart=always\",{\"1\":{\"61\":1}}],[\"result\",{\"1\":{\"57\":1}}],[\"reset\",{\"1\":{\"57\":1}}],[\"request\",{\"1\":{\"185\":1}}],[\"requests\",{\"1\":{\"15\":2,\"31\":1,\"93\":1}}],[\"requiredduringschedulingignoredduringexecution\",{\"1\":{\"49\":1,\"51\":1}}],[\"reachable\",{\"1\":{\"222\":1}}],[\"real\",{\"1\":{\"70\":1}}],[\"reason\",{\"1\":{\"31\":1}}],[\"read\",{\"1\":{\"70\":1,\"185\":3}}],[\"ready\",{\"1\":{\"31\":1,\"92\":1}}],[\"readwritemany\",{\"1\":{\"4\":1}}],[\"readwriteonce\",{\"1\":{\"4\":1}}],[\"readonlymany\",{\"1\":{\"4\":1}}],[\"recomputation\",{\"1\":{\"303\":1}}],[\"recognition\",{\"1\":{\"143\":1}}],[\"received\",{\"1\":{\"165\":1}}],[\"recv\",{\"1\":{\"162\":1,\"165\":1}}],[\"recurringrunservice\",{\"1\":{\"104\":1,\"106\":1}}],[\"recurring\",{\"1\":{\"90\":1}}],[\"recycle\",{\"1\":{\"5\":1}}],[\"reclaim\",{\"0\":{\"5\":1}}],[\"revisions\",{\"1\":{\"0\":1}}],[\"revision\",{\"1\":{\"0\":3}}],[\"是最常见的技术\",{\"1\":{\"303\":1}}],[\"是最常用的实现\",{\"1\":{\"160\":1}}],[\"是grace\",{\"1\":{\"302\":1}}],[\"是这四个训练任务中d2d交换节省内存最多的一次\",{\"1\":{\"301\":1}}],[\"是pcie\",{\"1\":{\"286\":1}}],[\"是用户与网络交互的界面\",{\"1\":{\"268\":1}}],[\"是用于节点管理的机制\",{\"1\":{\"31\":1}}],[\"是由国际标准化组织\",{\"1\":{\"261\":1}}],[\"是由管道组件发出的输出\",{\"1\":{\"90\":1}}],[\"是现代的\",{\"1\":{\"260\":1}}],[\"是网络管理中常用的命令\",{\"0\":{\"244\":1}}],[\"是互联网核心路由协议\",{\"1\":{\"237\":1}}],[\"是另一个邻居节点的ip地址\",{\"1\":{\"222\":1}}],[\"是其mac地址\",{\"1\":{\"222\":2}}],[\"是两种用于网络分段和虚拟化的技术\",{\"1\":{\"212\":1}}],[\"是两种用于资源管理和控制的机制\",{\"1\":{\"12\":1}}],[\"是对\",{\"1\":{\"195\":1}}],[\"是对管道的单次执行\",{\"1\":{\"90\":1}}],[\"是在虚拟机里用的一个\",{\"1\":{\"185\":1}}],[\"是在所有处理单元上执行相同的指令\",{\"1\":{\"152\":1}}],[\"是指\",{\"1\":{\"185\":1}}],[\"是并行计算领域的重要工具\",{\"1\":{\"166\":1}}],[\"是所有\",{\"1\":{\"162\":1}}],[\"是否支持函数调用\",{\"1\":{\"136\":1}}],[\"是否支持工具选择\",{\"1\":{\"136\":1}}],[\"是否支持图片输入\",{\"1\":{\"136\":1}}],[\"是否用于问题优化\",{\"1\":{\"136\":1}}],[\"是否用于问题分类\",{\"1\":{\"136\":1}}],[\"是否用于工具调用\",{\"1\":{\"136\":1}}],[\"是否用于内容提取\",{\"1\":{\"136\":1}}],[\"是否设置为知识库处理模型\",{\"1\":{\"136\":1}}],[\"是否开启敏感校验\",{\"1\":{\"136\":1}}],[\"是可扩展和可移植的\",{\"1\":{\"101\":1}}],[\"是管道中某个组件的执行\",{\"1\":{\"90\":1}}],[\"是管道的可重复运行\",{\"1\":{\"90\":1}}],[\"是管道运行时在\",{\"1\":{\"89\":1}}],[\"是需要通过使用\",{\"1\":{\"56\":1}}],[\"是当宿主机资源紧张的时候\",{\"1\":{\"46\":1}}],[\"是应用在节点上的属性\",{\"1\":{\"31\":1}}],[\"是集群稳定运行的关键保障之一\",{\"1\":{\"29\":1}}],[\"是\",{\"1\":{\"25\":1,\"29\":1,\"30\":1,\"39\":1,\"45\":1,\"74\":1,\"92\":3,\"112\":1,\"150\":1,\"162\":1,\"185\":8,\"249\":1,\"252\":1}}],[\"是一款专注于在线教育的产品\",{\"1\":{\"126\":1}}],[\"是一个较老的工具\",{\"1\":{\"260\":1}}],[\"是一个用户空间实用程序\",{\"1\":{\"258\":1}}],[\"是一个用于跟踪系统调用和信号的工具\",{\"1\":{\"182\":1}}],[\"是一个传统的工具\",{\"1\":{\"246\":1}}],[\"是一个邻居节点的ip地址\",{\"1\":{\"222\":1}}],[\"是一个与机器学习\",{\"1\":{\"100\":1}}],[\"是一个原生于\",{\"1\":{\"100\":1}}],[\"是一个开源系统\",{\"1\":{\"95\":1}}],[\"是一个好的选择\",{\"1\":{\"92\":1}}],[\"是一个面向想要构建和试验\",{\"1\":{\"73\":1}}],[\"是一个配置选项\",{\"1\":{\"40\":1}}],[\"是一个\",{\"1\":{\"38\":1}}],[\"是一个集群级别的资源\",{\"1\":{\"6\":1}}],[\"是一种用于在ipv4网络中将ip地址解析为物理地址\",{\"1\":{\"230\":1}}],[\"是一种用于并行计算的标准接口\",{\"1\":{\"161\":1}}],[\"是一种标准接口\",{\"1\":{\"163\":1}}],[\"是一种并行计算模型\",{\"1\":{\"155\":1}}],[\"是一种强大的工具\",{\"1\":{\"118\":1}}],[\"是一种软件扩展\",{\"1\":{\"111\":1}}],[\"是一种特殊类型的\",{\"1\":{\"32\":1}}],[\"是一种在\",{\"1\":{\"13\":1,\"18\":1}}],[\"是基于\",{\"1\":{\"0\":1}}],[\"是如何等待的呢\",{\"1\":{\"0\":1}}],[\"相关工作\",{\"0\":{\"303\":1}}],[\"相关的存储设备出现了错误或问题\",{\"1\":{\"10\":1}}],[\"相反\",{\"1\":{\"301\":1}}],[\"相对于\",{\"1\":{\"195\":1}}],[\"相应地\",{\"1\":{\"185\":1}}],[\"相比之下\",{\"1\":{\"157\":1,\"282\":1,\"296\":1,\"297\":1,\"299\":1,\"302\":1,\"303\":1}}],[\"相比\",{\"1\":{\"0\":1,\"152\":1,\"249\":1}}],[\"相同\",{\"1\":{\"0\":1}}],[\"p3dn\",{\"1\":{\"284\":1,\"295\":1}}],[\"purl\",{\"1\":{\"277\":1}}],[\"put\",{\"1\":{\"70\":2}}],[\"physical\",{\"0\":{\"262\":1}}],[\"pinned\",{\"1\":{\"293\":1}}],[\"ping\",{\"0\":{\"171\":1},\"1\":{\"171\":1}}],[\"pipedream\",{\"1\":{\"303\":1}}],[\"pipedream出现了gpu内存不足的错误\",{\"1\":{\"296\":1}}],[\"pipedream使用异步调度\",{\"1\":{\"284\":1}}],[\"pipedream可以支持2亿参数的bert模型\",{\"1\":{\"284\":1}}],[\"pipedream中使用的异步模式允许第二个微批次的前向传播与第一个微批次的反向传播并行进行\",{\"1\":{\"283\":1}}],[\"pipedream和dapple之间的模型规模和性能差距较大\",{\"1\":{\"297\":1}}],[\"pipedream和dapple之间的结果差异\",{\"1\":{\"297\":1}}],[\"pipedream和dapple之间可支持模型规模的差异在于\",{\"1\":{\"284\":1}}],[\"pipedream和dapple\",{\"1\":{\"280\":1}}],[\"pipeline创建流程\",{\"0\":{\"107\":1}}],[\"pipeline服务注册流程\",{\"0\":{\"102\":1}}],[\"pipelineservice\",{\"1\":{\"103\":1,\"104\":1,\"106\":1}}],[\"pipelines\",{\"1\":{\"84\":3,\"85\":1,\"87\":1,\"89\":2,\"90\":8,\"91\":2,\"92\":15,\"101\":1}}],[\"pipelines将工件存储在像minio服务器或cloud\",{\"1\":{\"81\":1}}],[\"pipelines将元数据存储在mysql数据库中\",{\"1\":{\"81\":1}}],[\"pipelines特定领域语言\",{\"1\":{\"76\":1}}],[\"pipeline\",{\"0\":{\"75\":1,\"84\":1},\"1\":{\"92\":24,\"93\":1}}],[\"pid\",{\"1\":{\"183\":1}}],[\"psw=1234\",{\"1\":{\"137\":1}}],[\"pghnswefsearch\",{\"1\":{\"136\":1}}],[\"pnsexecutor\",{\"1\":{\"91\":1,\"92\":2}}],[\"pytorchjob\",{\"1\":{\"101\":1}}],[\"pytorch\",{\"0\":{\"146\":1},\"1\":{\"100\":1,\"146\":2,\"150\":1,\"295\":1},\"2\":{\"168\":1}}],[\"python\",{\"0\":{\"76\":1},\"1\":{\"31\":1,\"122\":1}}],[\"python3\",{\"1\":{\"31\":1}}],[\"py\",{\"1\":{\"86\":1}}],[\"plugin\",{\"1\":{\"143\":1}}],[\"plugin=mysql\",{\"1\":{\"137\":1}}],[\"plane\",{\"1\":{\"93\":3}}],[\"plain\",{\"1\":{\"70\":1}}],[\"please\",{\"1\":{\"57\":1}}],[\"p>\",{\"1\":{\"70\":1}}],[\"p\",{\"1\":{\"61\":1,\"136\":1,\"137\":2,\"182\":1,\"183\":2,\"259\":2}}],[\"pageable\",{\"1\":{\"293\":1}}],[\"passing\",{\"1\":{\"147\":1,\"156\":1,\"161\":1}}],[\"password\",{\"1\":{\"137\":2}}],[\"password=mypassword\",{\"1\":{\"137\":1}}],[\"par\",{\"1\":{\"277\":1}}],[\"parallelism\",{\"1\":{\"277\":2}}],[\"parallel\",{\"1\":{\"146\":1}}],[\"parzen\",{\"1\":{\"100\":1}}],[\"partition\",{\"1\":{\"57\":1}}],[\"paths\",{\"1\":{\"66\":1}}],[\"pair\",{\"1\":{\"57\":1}}],[\"peer\",{\"1\":{\"210\":1}}],[\"pem\",{\"1\":{\"57\":1}}],[\"permanent\",{\"1\":{\"225\":2,\"226\":1}}],[\"persistenceagent\",{\"1\":{\"92\":3}}],[\"persistentvolumeclaim\",{\"1\":{\"6\":1}}],[\"persistentvolume\",{\"1\":{\"6\":1}}],[\"period\",{\"1\":{\"137\":1}}],[\"periodic\",{\"1\":{\"90\":1}}],[\"period=600\",{\"1\":{\"46\":1}}],[\"period=imagefs\",{\"1\":{\"46\":1}}],[\"per\",{\"1\":{\"57\":1}}],[\"pki\",{\"1\":{\"57\":2}}],[\"p54eaf3\",{\"1\":{\"57\":9}}],[\"po\",{\"1\":{\"92\":1}}],[\"position\",{\"1\":{\"70\":1}}],[\"post\",{\"1\":{\"63\":1,\"66\":1,\"70\":2}}],[\"policies\",{\"0\":{\"54\":1}}],[\"policy\",{\"0\":{\"5\":1},\"1\":{\"55\":4}}],[\"port\",{\"1\":{\"35\":1,\"37\":1,\"70\":2}}],[\"ports\",{\"1\":{\"27\":1,\"31\":1,\"35\":1,\"37\":1,\"38\":1,\"137\":5}}],[\"pod存储两种类型的数据\",{\"1\":{\"81\":1}}],[\"pod中执行\",{\"1\":{\"80\":1}}],[\"podantiaffinity\",{\"1\":{\"49\":2}}],[\"pod设置toleration\",{\"1\":{\"31\":1}}],[\"pods\",{\"1\":{\"15\":1}}],[\"pod\",{\"0\":{\"26\":1,\"27\":1,\"47\":1,\"48\":2},\"1\":{\"15\":2,\"18\":2,\"19\":3,\"21\":1,\"23\":1,\"25\":3,\"26\":6,\"27\":6,\"28\":3,\"29\":9,\"30\":2,\"31\":8,\"32\":2,\"33\":6,\"34\":1,\"35\":2,\"38\":1,\"39\":2,\"40\":3,\"41\":5,\"42\":2,\"44\":4,\"45\":1,\"46\":5,\"47\":1,\"48\":3,\"49\":3,\"50\":1,\"51\":3,\"52\":1,\"53\":4,\"55\":1,\"84\":3,\"90\":1,\"92\":18,\"112\":1}}],[\"pvcreate\",{\"1\":{\"189\":1}}],[\"pvc\",{\"1\":{\"6\":1,\"7\":5,\"8\":4,\"9\":4,\"11\":4,\"12\":2}}],[\"pv\",{\"0\":{\"6\":1},\"1\":{\"6\":4,\"7\":3,\"8\":2,\"9\":3,\"10\":3,\"11\":7}}],[\"pfx\",{\"1\":{\"0\":1}}],[\"probe\",{\"1\":{\"222\":1}}],[\"program\",{\"1\":{\"150\":1,\"155\":2,\"161\":1}}],[\"prometheus\",{\"1\":{\"116\":3}}],[\"promiscuous\",{\"1\":{\"42\":1}}],[\"proto\",{\"1\":{\"70\":1}}],[\"protocols\",{\"1\":{\"70\":1}}],[\"protocol\",{\"1\":{\"31\":1,\"219\":1,\"230\":1,\"232\":4,\"237\":1,\"264\":1}}],[\"proxy=http\",{\"1\":{\"137\":2}}],[\"proxy\",{\"1\":{\"70\":11,\"143\":1}}],[\"project\",{\"1\":{\"61\":2,\"70\":1}}],[\"processes\",{\"1\":{\"70\":1}}],[\"process\",{\"1\":{\"57\":1,\"91\":1,\"147\":1,\"149\":1,\"165\":4}}],[\"proc\",{\"1\":{\"57\":1}}],[\"providing\",{\"1\":{\"57\":1}}],[\"presentation\",{\"0\":{\"267\":1}}],[\"pressure\",{\"1\":{\"46\":1}}],[\"preemption\",{\"1\":{\"31\":2}}],[\"preference\",{\"1\":{\"238\":1}}],[\"preferred\",{\"1\":{\"211\":2}}],[\"prefer\",{\"1\":{\"70\":1}}],[\"prefernoschedule\",{\"1\":{\"31\":1}}],[\"prefix\",{\"1\":{\"0\":4,\"143\":5}}],[\"printf\",{\"1\":{\"165\":2}}],[\"print\",{\"1\":{\"137\":1,\"149\":1}}],[\"println\",{\"1\":{\"0\":2}}],[\"privileged\",{\"1\":{\"61\":1}}],[\"priorities\",{\"1\":{\"55\":1}}],[\"prior\",{\"1\":{\"0\":1}}],[\"w\",{\"1\":{\"187\":1,\"188\":1}}],[\"wx\",{\"1\":{\"143\":1}}],[\"writer\",{\"1\":{\"92\":4}}],[\"www\",{\"1\":{\"73\":1}}],[\"wordpress\",{\"1\":{\"96\":1}}],[\"workflow\",{\"1\":{\"92\":3}}],[\"workflows\",{\"1\":{\"90\":1,\"92\":1,\"101\":1}}],[\"workflow控制器\",{\"1\":{\"80\":1}}],[\"worker\",{\"1\":{\"70\":2}}],[\"world\",{\"1\":{\"70\":1,\"162\":1,\"165\":10}}],[\"world<\",{\"1\":{\"70\":1}}],[\"whisper1\",{\"1\":{\"136\":1}}],[\"whisper\",{\"1\":{\"136\":1}}],[\"whispermodel\",{\"1\":{\"136\":1}}],[\"white\",{\"1\":{\"70\":2,\"143\":1}}],[\"whenunsatisfiable\",{\"1\":{\"53\":1}}],[\"w0729\",{\"1\":{\"57\":1}}],[\"wi\",{\"1\":{\"263\":1}}],[\"width\",{\"1\":{\"70\":2}}],[\"width=device\",{\"1\":{\"70\":1}}],[\"withdraw\",{\"1\":{\"239\":1}}],[\"with\",{\"1\":{\"57\":2}}],[\"withttl\",{\"1\":{\"0\":1}}],[\"will\",{\"1\":{\"57\":1}}],[\"wechat\",{\"1\":{\"141\":1,\"143\":3}}],[\"web\",{\"0\":{\"133\":1},\"1\":{\"92\":4},\"2\":{\"145\":1}}],[\"weight\",{\"1\":{\"55\":1,\"136\":3}}],[\"werr\",{\"1\":{\"0\":2}}],[\"wa\",{\"1\":{\"185\":2}}],[\"warn\",{\"1\":{\"137\":1}}],[\"warning\",{\"1\":{\"31\":1}}],[\"was\",{\"1\":{\"57\":1}}],[\"wangshi\",{\"1\":{\"31\":1}}],[\"watch\",{\"1\":{\"0\":2}}],[\"waiting\",{\"1\":{\"137\":1}}],[\"waited\",{\"1\":{\"137\":1}}],[\"waitdelete\",{\"1\":{\"0\":1}}],[\"waitdeletes\",{\"1\":{\"0\":1}}],[\"wait\",{\"1\":{\"0\":2,\"137\":1}}],[\"未获得锁的\",{\"1\":{\"0\":1}}],[\"最快的内存层存储的是计算立即需要的数据\",{\"1\":{\"302\":1}}],[\"最新的gpu只有80gb的hbm\",{\"1\":{\"302\":1}}],[\"最好有以下几方面准备\",{\"1\":{\"274\":2}}],[\"最稳定的路径\",{\"1\":{\"238\":1}}],[\"最短的as路径\",{\"1\":{\"238\":1}}],[\"最多1600万个\",{\"1\":{\"215\":1}}],[\"最多4094个vlan\",{\"1\":{\"215\":1}}],[\"最多4094个\",{\"1\":{\"215\":1}}],[\"最后做数据分析\",{\"1\":{\"274\":2}}],[\"最后\",{\"1\":{\"191\":1,\"291\":1,\"295\":2,\"296\":1,\"300\":2,\"301\":1,\"302\":1}}],[\"最后使用结束\",{\"1\":{\"0\":1}}],[\"最大化了计算资源的利用率\",{\"1\":{\"156\":1}}],[\"最大\",{\"1\":{\"136\":1}}],[\"最大温度\",{\"1\":{\"136\":1}}],[\"最大引用内容\",{\"1\":{\"136\":1}}],[\"最大回复\",{\"1\":{\"136\":1}}],[\"最大上下文\",{\"1\":{\"136\":1}}],[\"最终选择时间成本最小的映射方案\",{\"1\":{\"290\":1}}],[\"最终将网页内容展示给用户\",{\"1\":{\"270\":1}}],[\"最终\",{\"1\":{\"69\":1,\"289\":1}}],[\"最小的路由器id\",{\"1\":{\"238\":1}}],[\"最小的多出口判别器\",{\"1\":{\"238\":1}}],[\"最小限制\",{\"1\":{\"23\":1}}],[\"最小值\",{\"1\":{\"20\":1}}],[\"最小\",{\"1\":{\"0\":1}}],[\"4毫秒\",{\"1\":{\"300\":1}}],[\"44\",{\"1\":{\"297\":1}}],[\"404\",{\"1\":{\"307\":1}}],[\"40\",{\"1\":{\"297\":1}}],[\"400\",{\"1\":{\"137\":1}}],[\"4000\",{\"1\":{\"136\":1}}],[\"4b的表现则有所不同\",{\"1\":{\"301\":1}}],[\"4b\",{\"1\":{\"297\":1,\"301\":1}}],[\"4b不等规模的所有训练任务\",{\"1\":{\"297\":1}}],[\"4b及以上模型中失败了\",{\"1\":{\"296\":1}}],[\"42\",{\"1\":{\"225\":2,\"301\":1}}],[\"47d2\",{\"1\":{\"211\":1}}],[\"47\",{\"1\":{\"211\":2}}],[\"48px\",{\"1\":{\"70\":1}}],[\"469\",{\"1\":{\"57\":1}}],[\"4\",{\"0\":{\"10\":1,\"54\":1,\"64\":1,\"190\":1,\"199\":1,\"265\":1},\"1\":{\"0\":1,\"15\":1,\"137\":1,\"295\":2,\"296\":2,\"297\":1,\"299\":1,\"301\":2}}],[\"其复杂性远高于图7和图8中的所有实验\",{\"1\":{\"299\":1}}],[\"其总内存需求是服务器gpu内存供应量的5倍\",{\"1\":{\"295\":1}}],[\"其总gpu内存需求为108\",{\"1\":{\"295\":1}}],[\"其最大和最小阶段内存需求分别高于和低于每个gpu的内存容量\",{\"1\":{\"295\":1}}],[\"其后端引擎是pytorch\",{\"1\":{\"293\":1}}],[\"其次\",{\"1\":{\"291\":1,\"293\":1,\"300\":1,\"301\":1}}],[\"其次得到\",{\"1\":{\"0\":1}}],[\"其报文格式如下\",{\"1\":{\"232\":1}}],[\"其主要功能包括\",{\"1\":{\"219\":1}}],[\"其主要特性包括\",{\"1\":{\"218\":1}}],[\"其中阶段按dapple的建议映射到设备\",{\"1\":{\"299\":1}}],[\"其中一种仅使用d2d交换\",{\"1\":{\"295\":1}}],[\"其中包括我们提出的d2d交换\",{\"1\":{\"289\":1}}],[\"其中\",{\"1\":{\"0\":1,\"46\":1}}],[\"其他四个gpt配置的每阶段最大gpu内存需求为56\",{\"1\":{\"295\":1}}],[\"其他服务注册在\",{\"1\":{\"102\":1}}],[\"其他\",{\"0\":{\"105\":1},\"1\":{\"0\":1}}],[\"+100\",{\"1\":{\"190\":1}}],[\"+=\",{\"1\":{\"149\":1}}],[\"+精度\",{\"1\":{\"136\":1}}],[\"+\",{\"1\":{\"0\":1,\"302\":1}}],[\"时间\",{\"1\":{\"185\":1}}],[\"时间都不会计入进程的\",{\"1\":{\"185\":1}}],[\"时间序列\",{\"1\":{\"81\":1}}],[\"时需要用到的\",{\"1\":{\"46\":1}}],[\"时通过命令行参数\",{\"1\":{\"43\":1}}],[\"时合理设置资源请求和限制\",{\"1\":{\"19\":1}}],[\"时\",{\"1\":{\"0\":1,\"92\":1}}],[\"0等软件\",{\"1\":{\"295\":1}}],[\"04\",{\"1\":{\"295\":1}}],[\"01\",{\"1\":{\"222\":2,\"225\":3,\"226\":1}}],[\"02\",{\"1\":{\"222\":6,\"225\":3}}],[\"0a\",{\"1\":{\"222\":8}}],[\"00\",{\"1\":{\"211\":24,\"225\":8,\"226\":3}}],[\"002\",{\"1\":{\"136\":1}}],[\"0的张量值广播到所有进程\",{\"1\":{\"149\":1}}],[\"03\",{\"1\":{\"137\":1,\"225\":1}}],[\"07\",{\"1\":{\"57\":16}}],[\"0\",{\"1\":{\"0\":1,\"31\":2,\"38\":1,\"70\":4,\"92\":12,\"93\":3,\"136\":7,\"137\":9,\"143\":1,\"149\":2,\"165\":7,\"197\":1,\"211\":2,\"247\":1,\"256\":2,\"282\":1,\"295\":2,\"296\":2,\"297\":2,\"299\":1}}],[\"当模型规模超过单个设备的内存容量时\",{\"1\":{\"303\":1}}],[\"当模型扩大到1\",{\"1\":{\"296\":1}}],[\"当模型从bert\",{\"1\":{\"296\":1}}],[\"当被适当地应用时\",{\"1\":{\"291\":1}}],[\"当微批次大小缩小到2时\",{\"1\":{\"284\":1}}],[\"当工人3完成第一个微批次的前向传播计算后\",{\"1\":{\"283\":1}}],[\"当你的产品完成了最小\",{\"1\":{\"274\":2}}],[\"当你运行一个管道时\",{\"1\":{\"84\":1}}],[\"当数据从发送端传输到接收端时\",{\"1\":{\"269\":1}}],[\"当网络拓扑发生变化时\",{\"1\":{\"239\":1}}],[\"当设备b接收到这个arp请求时\",{\"1\":{\"231\":1}}],[\"当设备a需要向设备b发送数据时\",{\"1\":{\"231\":1}}],[\"当主机a发送一个以太网帧给主机b时\",{\"1\":{\"220\":1}}],[\"当vtep接收到来自二层网络的以太网帧时\",{\"1\":{\"219\":1}}],[\"当客户端请求html页面时\",{\"1\":{\"200\":1}}],[\"当磁盘返回数据时\",{\"1\":{\"185\":1}}],[\"当这个用户程序代码中调用了系统调用\",{\"1\":{\"185\":1}}],[\"当节点的父节点包含条件语句时\",{\"1\":{\"89\":1}}],[\"当前运行的管道列表\",{\"1\":{\"83\":1}}],[\"当然\",{\"1\":{\"56\":1}}],[\"当我们对一个容器执行\",{\"1\":{\"56\":1}}],[\"当\",{\"1\":{\"0\":1,\"46\":1}}],[\"方法释放锁\",{\"1\":{\"0\":1}}],[\"方法尝试获取锁\",{\"1\":{\"0\":1}}],[\"方法创建\",{\"1\":{\"0\":1}}],[\"3模型依然会遇到oom\",{\"1\":{\"302\":1}}],[\"3b\",{\"1\":{\"301\":1}}],[\"3b到20\",{\"1\":{\"297\":1}}],[\"3b参数的模型\",{\"1\":{\"297\":1}}],[\"3b参数规模的模型\",{\"1\":{\"297\":1}}],[\"3b是最小的模型\",{\"1\":{\"295\":1}}],[\"35b扩大到bert\",{\"1\":{\"296\":1}}],[\"35b的最小bert模型\",{\"1\":{\"296\":1}}],[\"35b表示最小的bert模型\",{\"1\":{\"295\":1}}],[\"33\",{\"1\":{\"225\":2,\"226\":1}}],[\"3306\",{\"1\":{\"137\":2}}],[\"3307\",{\"1\":{\"137\":1}}],[\"3600\",{\"1\":{\"143\":1}}],[\"3600s\",{\"1\":{\"70\":1}}],[\"36\",{\"1\":{\"137\":1}}],[\"30s\",{\"1\":{\"137\":3}}],[\"3001\",{\"1\":{\"137\":1,\"140\":1}}],[\"3000\",{\"1\":{\"136\":3,\"137\":5,\"139\":1,\"143\":1}}],[\"300s\",{\"1\":{\"31\":2}}],[\"30mi\",{\"1\":{\"93\":1}}],[\"30m\",{\"1\":{\"70\":1}}],[\"3437386\",{\"1\":{\"57\":14}}],[\"31\",{\"1\":{\"57\":16}}],[\"3m57s\",{\"1\":{\"31\":1}}],[\"3\",{\"0\":{\"9\":1,\"52\":1,\"63\":1,\"189\":1,\"198\":1,\"264\":1},\"1\":{\"0\":1,\"31\":1,\"38\":1,\"70\":1,\"136\":6,\"137\":6,\"143\":1,\"299\":1,\"301\":1}}],[\"2上a100\",{\"1\":{\"297\":1}}],[\"23\",{\"1\":{\"297\":1,\"301\":1}}],[\"2379\",{\"1\":{\"137\":3}}],[\"2b\",{\"1\":{\"301\":1}}],[\"2b的bert模型\",{\"1\":{\"296\":1}}],[\"2b是一个超大模型\",{\"1\":{\"295\":1}}],[\"2服务器上\",{\"1\":{\"299\":1}}],[\"2服务器的ssd存储带宽显著低于dgx\",{\"1\":{\"297\":1}}],[\"2服务器有164个虚拟cpu\",{\"1\":{\"295\":1}}],[\"2服务器\",{\"1\":{\"295\":1}}],[\"22\",{\"1\":{\"259\":2}}],[\"2表示arp响应\",{\"1\":{\"232\":1}}],[\"24xlarge实例\",{\"1\":{\"295\":1}}],[\"24xlarge\",{\"1\":{\"284\":1}}],[\"244\",{\"1\":{\"222\":4}}],[\"24位vni\",{\"1\":{\"215\":1}}],[\"24\",{\"1\":{\"211\":1,\"256\":2}}],[\"28\",{\"1\":{\"211\":2}}],[\"2>\",{\"1\":{\"137\":1}}],[\"27017\",{\"1\":{\"137\":4}}],[\"20\",{\"1\":{\"301\":2}}],[\"2016年\",{\"1\":{\"286\":1}}],[\"20s\",{\"1\":{\"137\":3}}],[\"20t20\",{\"1\":{\"137\":1}}],[\"20mi\",{\"1\":{\"93\":1}}],[\"2023\",{\"1\":{\"137\":1}}],[\"20231101\",{\"1\":{\"93\":1}}],[\"2022\",{\"1\":{\"91\":1}}],[\"204\",{\"1\":{\"70\":1}}],[\"203\",{\"1\":{\"57\":1}}],[\"2gb\",{\"1\":{\"61\":1}}],[\"29\",{\"1\":{\"57\":9}}],[\"255\",{\"1\":{\"247\":3}}],[\"256mi\",{\"1\":{\"20\":1,\"31\":1}}],[\"250m\",{\"1\":{\"20\":1}}],[\"2\",{\"0\":{\"8\":1,\"50\":1,\"62\":1,\"188\":1,\"197\":1,\"263\":1},\"1\":{\"0\":1,\"46\":1,\"57\":1,\"70\":1,\"91\":1,\"136\":3,\"137\":1,\"143\":1,\"195\":2,\"196\":1,\"197\":1,\"198\":1,\"199\":1,\"200\":1,\"201\":2,\"202\":2,\"203\":2,\"204\":2,\"205\":2,\"211\":1,\"222\":6,\"256\":2,\"280\":1,\"290\":1,\"293\":1,\"295\":3,\"297\":4,\"301\":4,\"302\":1}}],[\"lm\",{\"1\":{\"282\":1,\"303\":1}}],[\"lladdr\",{\"1\":{\"222\":2}}],[\"llm\",{\"1\":{\"175\":1,\"178\":1,\"179\":2}}],[\"llmmodels\",{\"1\":{\"136\":1}}],[\"lft\",{\"1\":{\"211\":4}}],[\"lvextend\",{\"1\":{\"190\":1}}],[\"lvm\",{\"0\":{\"188\":1,\"189\":1},\"1\":{\"186\":1,\"188\":2,\"189\":2}}],[\"list\",{\"1\":{\"139\":1,\"143\":1}}],[\"listen\",{\"1\":{\"70\":1,\"137\":1}}],[\"linux\",{\"1\":{\"185\":5,\"188\":2,\"258\":1}}],[\"linkai\",{\"1\":{\"143\":2}}],[\"link\",{\"0\":{\"263\":1},\"1\":{\"142\":1,\"207\":2,\"209\":1,\"210\":2,\"211\":9,\"252\":1,\"253\":3,\"260\":2}}],[\"link=30\",{\"1\":{\"137\":1}}],[\"lineage\",{\"1\":{\"90\":1}}],[\"linear\",{\"1\":{\"70\":1}}],[\"live\",{\"1\":{\"137\":1}}],[\"lib\",{\"1\":{\"57\":1,\"137\":2}}],[\"limitrange\",{\"1\":{\"20\":2}}],[\"limitranges\",{\"0\":{\"18\":1},\"1\":{\"12\":1,\"18\":2,\"19\":1,\"23\":1}}],[\"limits\",{\"1\":{\"15\":2,\"20\":2,\"31\":1,\"46\":1,\"93\":1}}],[\"l\",{\"1\":{\"57\":1,\"190\":1,\"259\":1}}],[\"lan\",{\"0\":{\"214\":1,\"218\":1},\"1\":{\"212\":1}}],[\"lang=\",{\"1\":{\"70\":1}}],[\"layer\",{\"0\":{\"262\":1,\"263\":1,\"264\":1,\"265\":1,\"266\":1,\"267\":1,\"268\":1},\"1\":{\"185\":1}}],[\"large\",{\"1\":{\"136\":3}}],[\"laf环境\",{\"1\":{\"136\":1}}],[\"laf\",{\"1\":{\"136\":4}}],[\"lafenv\",{\"1\":{\"136\":1}}],[\"label\",{\"1\":{\"136\":6}}],[\"labelselector\",{\"1\":{\"49\":1,\"53\":1}}],[\"labels\",{\"1\":{\"31\":1,\"38\":1,\"93\":2}}],[\"labring\",{\"1\":{\"134\":1,\"137\":2}}],[\"latest\",{\"1\":{\"27\":1,\"61\":1,\"137\":2}}],[\"length\",{\"1\":{\"70\":2,\"232\":2}}],[\"levelsio\",{\"1\":{\"274\":2}}],[\"level=warn\",{\"1\":{\"137\":1}}],[\"level=info\",{\"1\":{\"137\":1}}],[\"level=high\",{\"1\":{\"31\":2}}],[\"level\",{\"1\":{\"31\":2}}],[\"leaseid\",{\"1\":{\"0\":1}}],[\"lease\",{\"1\":{\"0\":2}}],[\"loopback\",{\"1\":{\"211\":2}}],[\"lo\",{\"1\":{\"211\":2}}],[\"lower\",{\"1\":{\"210\":2,\"211\":2}}],[\"loading\",{\"1\":{\"57\":1}}],[\"location\",{\"1\":{\"70\":1}}],[\"localhost\",{\"1\":{\"63\":1,\"64\":1,\"65\":1,\"66\":1,\"67\":1,\"68\":1,\"69\":1,\"70\":1,\"137\":2,\"139\":1,\"140\":1}}],[\"local\",{\"0\":{\"213\":1},\"1\":{\"38\":1,\"212\":1,\"238\":1}}],[\"lock\",{\"1\":{\"0\":11}}],[\"logo\",{\"1\":{\"136\":1}}],[\"logs\",{\"0\":{\"56\":1},\"1\":{\"29\":1}}],[\"log\",{\"1\":{\"0\":4,\"70\":2,\"137\":2}}],[\"的训练时间延长\",{\"1\":{\"302\":1}}],[\"的训练操作\",{\"1\":{\"101\":1}}],[\"的资源\",{\"1\":{\"302\":1}}],[\"的资源使用量超过了其\",{\"1\":{\"46\":1}}],[\"的资源使用\",{\"1\":{\"19\":1}}],[\"的设备内存\",{\"1\":{\"302\":1}}],[\"的速度\",{\"1\":{\"301\":1}}],[\"的内存节省\",{\"1\":{\"301\":1}}],[\"的内存\",{\"1\":{\"301\":1}}],[\"的内置资源\",{\"1\":{\"112\":1}}],[\"的gpu内存占用\",{\"1\":{\"301\":1}}],[\"的gpu内存\",{\"1\":{\"301\":1}}],[\"的开销比较\",{\"1\":{\"298\":1}}],[\"的开发过程\",{\"1\":{\"117\":1}}],[\"的性能\",{\"1\":{\"296\":1}}],[\"的bert数据应用gpu\",{\"1\":{\"285\":1}}],[\"的时候\",{\"1\":{\"274\":2}}],[\"的时间\",{\"1\":{\"185\":1}}],[\"的网络协议\",{\"1\":{\"230\":1}}],[\"的网络接口实现内循环\",{\"1\":{\"41\":1}}],[\"的邻居节点信息\",{\"1\":{\"223\":1}}],[\"的邻居表项\",{\"1\":{\"222\":1}}],[\"的一些关键区别和改进\",{\"1\":{\"195\":1}}],[\"的一个子集\",{\"1\":{\"162\":1}}],[\"的一个重要配置选项\",{\"1\":{\"45\":1}}],[\"的物理卷中\",{\"1\":{\"189\":1}}],[\"的空间已经成功分配给\",{\"1\":{\"192\":1}}],[\"的空间后\",{\"1\":{\"188\":1}}],[\"的空间扩展到\",{\"1\":{\"186\":1}}],[\"的用户态\",{\"1\":{\"185\":1}}],[\"的缩写\",{\"1\":{\"185\":8}}],[\"的进程\",{\"1\":{\"183\":1}}],[\"的微基准测试结果\",{\"1\":{\"179\":1}}],[\"的主要特性和工作原理\",{\"0\":{\"238\":1}}],[\"的主要贡献\",{\"1\":{\"179\":1}}],[\"的主要功能\",{\"0\":{\"163\":1}}],[\"的提出背景\",{\"1\":{\"179\":1}}],[\"的动态稀疏注意力方法\",{\"1\":{\"178\":1}}],[\"的预填充阶段多达\",{\"1\":{\"179\":1}}],[\"的预填充\",{\"1\":{\"175\":1}}],[\"的标准化设计和广泛支持使其成为高性能计算\",{\"1\":{\"166\":1}}],[\"的核心概念\",{\"0\":{\"162\":1}}],[\"的核心组件之一\",{\"1\":{\"92\":1}}],[\"的框架\",{\"0\":{\"160\":1}}],[\"的应用中\",{\"1\":{\"158\":1}}],[\"的应用场景\",{\"0\":{\"114\":1}}],[\"的计算\",{\"1\":{\"158\":1}}],[\"的比较\",{\"0\":{\"157\":1}}],[\"的梯度进行合并并同步模型参数\",{\"1\":{\"154\":1}}],[\"的数据\",{\"1\":{\"154\":1}}],[\"的数据库\",{\"1\":{\"92\":1}}],[\"的底层实现\",{\"1\":{\"146\":1}}],[\"的话\",{\"1\":{\"136\":1}}],[\"的管理能力\",{\"1\":{\"118\":1}}],[\"的管理能力扩展到了自定义应用领域\",{\"1\":{\"115\":1}}],[\"的工作过程\",{\"0\":{\"239\":1}}],[\"的工作流程\",{\"0\":{\"220\":1}}],[\"的工作原理\",{\"0\":{\"41\":1,\"113\":1},\"1\":{\"179\":1}}],[\"的工具\",{\"0\":{\"117\":1}}],[\"的示例\",{\"0\":{\"116\":1}}],[\"的能力\",{\"1\":{\"115\":1}}],[\"的优势和挑战\",{\"0\":{\"240\":1}}],[\"的优势\",{\"0\":{\"115\":1}}],[\"的基本概念\",{\"0\":{\"112\":1}}],[\"的操作自动化\",{\"1\":{\"111\":1}}],[\"的自动化机器学习\",{\"1\":{\"100\":1}}],[\"的根对象\",{\"1\":{\"96\":1}}],[\"的元数据\",{\"1\":{\"95\":1}}],[\"的各个组件通过数据库和控制器进行通信和协调\",{\"1\":{\"92\":1}}],[\"的可视化服务\",{\"1\":{\"92\":1}}],[\"的展示\",{\"1\":{\"92\":1}}],[\"的持久化存储\",{\"1\":{\"92\":1}}],[\"的控制器组件之一\",{\"1\":{\"92\":1}}],[\"的控制器组件\",{\"1\":{\"92\":1}}],[\"的功能简介\",{\"1\":{\"92\":1}}],[\"的默认执行器\",{\"1\":{\"91\":1}}],[\"的默认阈值如下所示\",{\"1\":{\"46\":1}}],[\"的任务\",{\"1\":{\"86\":1}}],[\"的定义\",{\"1\":{\"84\":1}}],[\"的定义示例\",{\"0\":{\"35\":1}}],[\"的维护者自行决定\",{\"1\":{\"56\":1}}],[\"的方式返回给\",{\"1\":{\"56\":1}}],[\"的地址和端口\",{\"1\":{\"56\":1}}],[\"的实现\",{\"1\":{\"56\":1}}],[\"的限制\",{\"1\":{\"46\":1}}],[\"的过程\",{\"1\":{\"46\":1}}],[\"的启动参数中设置\",{\"1\":{\"43\":1}}],[\"的作用是在容器网络接口上设置发夹规则\",{\"1\":{\"40\":1}}],[\"的作用方式\",{\"1\":{\"31\":1}}],[\"的场景\",{\"1\":{\"39\":1}}],[\"的结合\",{\"0\":{\"36\":1}}],[\"的服务\",{\"1\":{\"35\":1,\"63\":1}}],[\"的详细介绍\",{\"1\":{\"32\":1}}],[\"的每个\",{\"1\":{\"32\":1}}],[\"的调度器尽可能地将\",{\"0\":{\"47\":1}}],[\"的调度\",{\"1\":{\"31\":1}}],[\"的具体值\",{\"1\":{\"31\":1}}],[\"的名称\",{\"1\":{\"31\":1}}],[\"的日志\",{\"1\":{\"29\":1}}],[\"的故障而丢失\",{\"1\":{\"26\":1}}],[\"的配置是静态文件\",{\"1\":{\"26\":1}}],[\"的参与\",{\"1\":{\"26\":1}}],[\"的特点\",{\"0\":{\"26\":1,\"33\":1}}],[\"的部署和管理\",{\"1\":{\"25\":1}}],[\"的整体限制不同\",{\"1\":{\"18\":1}}],[\"的总数量\",{\"1\":{\"15\":2}}],[\"的状态\",{\"1\":{\"29\":1}}],[\"的状态转换通常遵循以下过程\",{\"1\":{\"11\":1}}],[\"的状态由其\",{\"1\":{\"6\":1}}],[\"的几种可能的状态\",{\"1\":{\"6\":1}}],[\"的\",{\"1\":{\"0\":3,\"15\":1,\"20\":1,\"35\":3,\"36\":1,\"40\":2,\"46\":2,\"49\":1,\"56\":3,\"74\":1,\"92\":3,\"97\":1,\"136\":1,\"146\":1,\"185\":1}}],[\"为操作间并行训练和gpu内存优化提供了新的方向\",{\"1\":{\"304\":1}}],[\"为四个操作间并行训练任务\",{\"1\":{\"301\":1}}],[\"为此\",{\"1\":{\"290\":1}}],[\"为了应对gpu内存的限制\",{\"1\":{\"303\":1}}],[\"为了完全隐藏gpu\",{\"1\":{\"302\":1}}],[\"为了理解mpress在这种新架构下的优势\",{\"1\":{\"302\":1}}],[\"为了更好地理解mpress相较于基线系统的优势\",{\"1\":{\"298\":1}}],[\"为了避免频繁分配和释放固定内存的高成本\",{\"1\":{\"293\":1}}],[\"为了展示其在操作间并行训练中优化gpu内存使用的通用性\",{\"1\":{\"293\":1}}],[\"为了发挥其全部潜力\",{\"1\":{\"291\":1}}],[\"为了解决这一问题\",{\"1\":{\"291\":1}}],[\"为了反映这种差异\",{\"1\":{\"290\":1}}],[\"为了克服gpu总体交换空间有限的局限\",{\"1\":{\"288\":1}}],[\"为了探索操作间并行训练中gpu内存的利用情况\",{\"1\":{\"284\":1}}],[\"为了便于理解模型并行和流水线并行的区别\",{\"1\":{\"282\":1}}],[\"为了提高效率\",{\"1\":{\"233\":1}}],[\"为了确保数据的一致性\",{\"1\":{\"151\":1}}],[\"为并行计算中的数据管理提供了高效的解决方案\",{\"1\":{\"162\":1}}],[\"为什么要做独立开发者\",{\"1\":{\"274\":4}}],[\"为什么选择\",{\"0\":{\"101\":1}}],[\"为什么使用etcd分布式锁比redis分布式锁更好\",{\"1\":{\"0\":1}}],[\"为支持应用程序提供信息\",{\"1\":{\"96\":1}}],[\"为你维护的\",{\"1\":{\"56\":1}}],[\"为你设置的\",{\"1\":{\"46\":1}}],[\"为\",{\"1\":{\"0\":3,\"49\":1,\"66\":1,\"183\":1}}],[\"1上支持的规模更大\",{\"1\":{\"297\":1}}],[\"1上的v100\",{\"1\":{\"297\":1}}],[\"1服务器\",{\"1\":{\"299\":1}}],[\"1服务器翻了一倍多\",{\"1\":{\"297\":1}}],[\"1服务器是aws\",{\"1\":{\"295\":1}}],[\"1倍\",{\"1\":{\"296\":1}}],[\"140\",{\"1\":{\"295\":1}}],[\"14px\",{\"1\":{\"70\":1}}],[\"1数据集训练bert\",{\"1\":{\"295\":1}}],[\"1升级到1\",{\"1\":{\"293\":1}}],[\"1架构\",{\"1\":{\"290\":1}}],[\"1和dgx\",{\"1\":{\"280\":1,\"295\":1,\"297\":1}}],[\"1表示arp请求\",{\"1\":{\"232\":1}}],[\"1命令用于查看指定设备\",{\"1\":{\"223\":1}}],[\"1命令用于显示指定网络设备\",{\"1\":{\"222\":1}}],[\"1可能得到以下输出\",{\"1\":{\"222\":1}}],[\"1通常是用于overlay网络的设备接口\",{\"1\":{\"222\":1}}],[\"1q\",{\"1\":{\"215\":1}}],[\"1q标准\",{\"1\":{\"213\":1}}],[\"11\",{\"1\":{\"210\":1,\"225\":2,\"263\":1,\"295\":1}}],[\"19\",{\"1\":{\"185\":1}}],[\"192\",{\"1\":{\"137\":2,\"211\":1,\"247\":1,\"256\":3}}],[\"19530\",{\"1\":{\"137\":1}}],[\"1k\",{\"1\":{\"136\":2}}],[\"168\",{\"1\":{\"137\":2,\"211\":1,\"247\":1,\"256\":3}}],[\"16\",{\"1\":{\"137\":2}}],[\"16000\",{\"1\":{\"136\":1}}],[\"16gi\",{\"1\":{\"15\":1}}],[\"12位vlan\",{\"1\":{\"215\":1}}],[\"12345678\",{\"1\":{\"140\":1}}],[\"1234\",{\"1\":{\"139\":1}}],[\"128\",{\"1\":{\"137\":1}}],[\"128mi\",{\"1\":{\"20\":1,\"31\":1}}],[\"127\",{\"1\":{\"137\":1}}],[\"120000\",{\"1\":{\"136\":2}}],[\"125000\",{\"1\":{\"136\":2}}],[\"1gb\",{\"1\":{\"295\":1}}],[\"1gb+\",{\"1\":{\"126\":1}}],[\"1gi\",{\"1\":{\"20\":1}}],[\"13\",{\"1\":{\"106\":1}}],[\"130\",{\"1\":{\"57\":1}}],[\"17h\",{\"1\":{\"92\":14}}],[\"1728000\",{\"1\":{\"70\":1}}],[\"1m\",{\"1\":{\"70\":1}}],[\"1500\",{\"1\":{\"210\":2,\"211\":2}}],[\"157\",{\"1\":{\"57\":1}}],[\"15\",{\"1\":{\"57\":16,\"136\":2}}],[\"18z\",{\"1\":{\"137\":1}}],[\"18\",{\"1\":{\"52\":1,\"137\":1,\"295\":1}}],[\"1\",{\"0\":{\"7\":1,\"48\":1,\"61\":1,\"187\":1,\"196\":1,\"262\":1},\"1\":{\"0\":2,\"20\":1,\"31\":5,\"52\":1,\"53\":1,\"55\":1,\"57\":2,\"70\":4,\"91\":1,\"92\":27,\"93\":3,\"136\":4,\"137\":3,\"149\":2,\"165\":6,\"185\":1,\"187\":1,\"195\":2,\"196\":1,\"197\":4,\"198\":1,\"199\":1,\"200\":1,\"201\":1,\"202\":1,\"203\":1,\"204\":1,\"205\":1,\"211\":3,\"222\":5,\"223\":1,\"225\":2,\"247\":1,\"256\":2,\"290\":1,\"295\":1,\"297\":2,\"301\":2}}],[\"10410479\",{\"1\":{\"277\":1}}],[\"101\",{\"1\":{\"92\":1}}],[\"1024\",{\"1\":{\"70\":1,\"136\":2}}],[\"10px\",{\"1\":{\"70\":1}}],[\"1000\",{\"1\":{\"143\":1,\"210\":2,\"211\":4}}],[\"100\",{\"1\":{\"70\":1,\"136\":4,\"165\":1,\"247\":1}}],[\"100vh\",{\"1\":{\"70\":1}}],[\"100m\",{\"1\":{\"20\":1,\"31\":1,\"93\":2}}],[\"10\",{\"1\":{\"0\":2,\"15\":2,\"31\":1,\"137\":2,\"179\":1,\"210\":1,\"222\":4,\"301\":1}}],[\"tpu和graphcore\",{\"1\":{\"303\":1}}],[\"tpriority\",{\"1\":{\"57\":1}}],[\"tls\",{\"1\":{\"202\":1,\"267\":1}}],[\"tlsv1\",{\"1\":{\"70\":3}}],[\"tunnel\",{\"0\":{\"219\":1}}],[\"turbo\",{\"1\":{\"136\":2,\"143\":1}}],[\"tused\",{\"1\":{\"57\":1}}],[\"ts\",{\"1\":{\"125\":1}}],[\"tsize\",{\"1\":{\"57\":1}}],[\"transport\",{\"0\":{\"265\":1}}],[\"training\",{\"1\":{\"101\":1,\"277\":2}}],[\"trigger\",{\"1\":{\"143\":1}}],[\"tryfastgpt\",{\"1\":{\"135\":1}}],[\"tree\",{\"1\":{\"100\":1}}],[\"true\",{\"1\":{\"70\":1,\"136\":13,\"143\":2}}],[\"the\",{\"1\":{\"93\":2}}],[\"thcd8\",{\"1\":{\"92\":2}}],[\"tqtgh\",{\"1\":{\"92\":2}}],[\"timeout\",{\"1\":{\"70\":3,\"137\":3}}],[\"title>\",{\"1\":{\"70\":1}}],[\"tesseract进一步结合了流水线并行和gpu\",{\"1\":{\"303\":1}}],[\"tesla\",{\"1\":{\"295\":2}}],[\"test\",{\"1\":{\"137\":3}}],[\"tensor\",{\"1\":{\"149\":5}}],[\"tensorflow\",{\"1\":{\"100\":1}}],[\"tech\",{\"1\":{\"142\":1}}],[\"tekton\",{\"1\":{\"101\":1}}],[\"text\",{\"1\":{\"70\":2,\"136\":5}}],[\"template\",{\"1\":{\"31\":1,\"38\":1,\"93\":1}}],[\"t8580\",{\"1\":{\"57\":1}}],[\"t4194304\",{\"1\":{\"57\":1}}],[\"tts1\",{\"1\":{\"136\":1}}],[\"tts\",{\"1\":{\"136\":1}}],[\"ttype\",{\"1\":{\"57\":1}}],[\"ttl\",{\"1\":{\"0\":1,\"233\":1}}],[\"t\",{\"1\":{\"57\":9,\"188\":1}}],[\"task\",{\"1\":{\"185\":1}}],[\"taskservice\",{\"1\":{\"103\":1,\"106\":1}}],[\"tag\",{\"1\":{\"93\":1}}],[\"target\",{\"1\":{\"232\":2}}],[\"target=\",{\"1\":{\"70\":1}}],[\"targetport\",{\"1\":{\"35\":1,\"37\":1}}],[\"taints\",{\"1\":{\"31\":1}}],[\"taint\",{\"0\":{\"30\":1,\"31\":1},\"1\":{\"30\":2,\"31\":10}}],[\"tcp将数据包分段并传递到网络层的ip协议\",{\"1\":{\"270\":1}}],[\"tcp\",{\"1\":{\"31\":1,\"137\":1,\"259\":2,\"265\":1}}],[\"typescript\",{\"1\":{\"125\":1}}],[\"types\",{\"1\":{\"70\":1}}],[\"type\",{\"1\":{\"20\":1,\"21\":1,\"31\":1,\"70\":2,\"143\":1,\"210\":1,\"232\":2}}],[\"torch\",{\"1\":{\"149\":3}}],[\"top命令解释\",{\"1\":{\"185\":1}}],[\"top\",{\"1\":{\"136\":1}}],[\"topology\",{\"1\":{\"57\":2}}],[\"topologyspreadconstraints\",{\"1\":{\"52\":1,\"53\":2}}],[\"topologykey\",{\"1\":{\"49\":2,\"53\":1}}],[\"toolchoice\",{\"1\":{\"136\":3}}],[\"tools\",{\"1\":{\"93\":3}}],[\"tokens\",{\"1\":{\"143\":1}}],[\"token=fastgpt\",{\"1\":{\"137\":1}}],[\"token=none\",{\"1\":{\"137\":1}}],[\"token\",{\"1\":{\"136\":4,\"137\":2}}],[\"toleration\",{\"1\":{\"31\":1}}],[\"tolerations\",{\"1\":{\"31\":2}}],[\"to\",{\"1\":{\"0\":1,\"57\":3,\"70\":1,\"137\":1,\"165\":1}}],[\"todo\",{\"1\":{\"0\":2}}],[\"two\",{\"1\":{\"0\":1}}],[\"mvp\",{\"1\":{\"274\":6}}],[\"mtu\",{\"1\":{\"210\":2,\"211\":4}}],[\"mpress展示了在现有硬件约束下突破模型训练规模限制的潜力\",{\"1\":{\"304\":1}}],[\"mpress展示了此类架构的潜在优势及其在低硬件成本下解决内存墙问题的示例应用\",{\"1\":{\"302\":1}}],[\"mpress为未来高带宽异构计算环境中的大规模模型训练提供了设计思路\",{\"1\":{\"304\":1}}],[\"mpress为重新思考内存架构提供了帮助\",{\"1\":{\"302\":1}}],[\"mpress显著提高了训练吞吐量\",{\"1\":{\"304\":1}}],[\"mpress显著提升了多gpu服务器上十亿规模dnn模型的训练效率\",{\"1\":{\"281\":1}}],[\"mpress能够高效地减少gpu内存消耗\",{\"1\":{\"304\":1}}],[\"mpress能够在现有的gpu硬件上运行\",{\"1\":{\"303\":1}}],[\"mpress结合了三种内存优化技术\",{\"1\":{\"304\":1}}],[\"mpress结合了三种优化策略\",{\"1\":{\"296\":1}}],[\"mpress与上述工作不同\",{\"1\":{\"303\":1}}],[\"mpress与这些工作是互补的\",{\"1\":{\"303\":1}}],[\"mpress通过优先使用nvlink进行d2d交换\",{\"1\":{\"303\":1}}],[\"mpress通过d2d交换减少了gpu内存需求\",{\"1\":{\"303\":1}}],[\"mpress通过进一步利用空闲的gpu内存资源\",{\"1\":{\"297\":1}}],[\"mpress不局限于特定的调度策略\",{\"1\":{\"303\":1}}],[\"mpress可以部分弥补当前硬件的局限性\",{\"1\":{\"302\":1}}],[\"mpress可以解决这个问题\",{\"1\":{\"302\":1}}],[\"mpress中的d2d交换技术在这种情况下仍然有效\",{\"1\":{\"302\":1}}],[\"mpress选择对阶段0\",{\"1\":{\"301\":1}}],[\"mpress选择重计算\",{\"1\":{\"300\":1}}],[\"mpress没有使用gpu\",{\"1\":{\"301\":1}}],[\"mpress优先选择d2d交换\",{\"1\":{\"300\":1}}],[\"mpress会分配gpu\",{\"1\":{\"300\":1}}],[\"mpress会舍弃gpu\",{\"1\":{\"300\":1}}],[\"mpress会选择d2d交换\",{\"1\":{\"300\":1}}],[\"mpress会优先选择gpu\",{\"1\":{\"300\":1}}],[\"mpress也能在47秒内找到最优映射\",{\"1\":{\"299\":1}}],[\"mpress比zero\",{\"1\":{\"297\":1}}],[\"mpress支持的模型规模提高了2\",{\"1\":{\"296\":1}}],[\"mpress相比gpu\",{\"1\":{\"296\":1}}],[\"mpress在模型规模上始终能够保持稳定的训练性能\",{\"1\":{\"297\":1}}],[\"mpress在dapple上的性能\",{\"0\":{\"297\":1}}],[\"mpress在pipedream上的性能\",{\"0\":{\"296\":1}}],[\"mpress在相同内存优化下训练速度大幅提升\",{\"1\":{\"280\":1}}],[\"mpress变体采用我们之前算法生成的设备映射和内存节省计划\",{\"1\":{\"295\":1}}],[\"mpress是否能有效缓解gpu内存限制\",{\"1\":{\"294\":1}}],[\"mpress是通用的\",{\"1\":{\"293\":1}}],[\"mpress运行时部分与操作间并行训练框架的运行时部分共同工作\",{\"1\":{\"289\":1}}],[\"mpress静态部分是离线运行的\",{\"1\":{\"289\":1}}],[\"mpress的规划算法可以扩展\",{\"1\":{\"302\":1}}],[\"mpress的逻辑横跨静态和运行时部分\",{\"1\":{\"289\":1}}],[\"mpress的总体概述及工作流程\",{\"0\":{\"289\":1}}],[\"mpress还采用了重新计算和gpu\",{\"1\":{\"288\":1}}],[\"mpress采用了一种新的设备间\",{\"1\":{\"288\":1}}],[\"mpress被集成到现有的两种操作间并行训练系统中\",{\"1\":{\"280\":1}}],[\"mpress提出了一种新的单服务器多gpu系统\",{\"1\":{\"279\":1}}],[\"mpress\",{\"0\":{\"277\":1,\"287\":1},\"1\":{\"277\":3},\"2\":{\"305\":1,\"306\":1}}],[\"mpeg\",{\"1\":{\"267\":1}}],[\"mpmd\",{\"0\":{\"156\":1,\"157\":1,\"160\":1},\"1\":{\"155\":3,\"156\":3,\"157\":3,\"158\":1,\"159\":1,\"160\":1,\"161\":2}}],[\"mpich\",{\"1\":{\"163\":1}}],[\"mpi\",{\"0\":{\"162\":1,\"163\":1},\"1\":{\"147\":1,\"156\":1,\"159\":1,\"160\":2,\"161\":4,\"162\":12,\"163\":4,\"164\":4,\"165\":15,\"166\":2}}],[\"multi\",{\"1\":{\"238\":1,\"277\":2}}],[\"multicast\",{\"1\":{\"210\":2,\"211\":2}}],[\"multiple\",{\"1\":{\"150\":1,\"152\":3,\"155\":3,\"161\":2}}],[\"mutex\",{\"1\":{\"0\":3}}],[\"msg\",{\"1\":{\"143\":1}}],[\"mongodb\",{\"1\":{\"137\":7}}],[\"mongod\",{\"1\":{\"137\":1}}],[\"mongo\",{\"1\":{\"137\":12}}],[\"mode=revision\",{\"1\":{\"137\":1}}],[\"mode=hairpin\",{\"1\":{\"43\":1}}],[\"model\",{\"1\":{\"136\":12,\"143\":1,\"277\":2}}],[\"mode\",{\"0\":{\"41\":1},\"1\":{\"40\":3,\"42\":1,\"43\":1,\"45\":1,\"210\":2,\"211\":2}}],[\"modes\",{\"0\":{\"4\":1}}],[\"mxnet\",{\"1\":{\"100\":1}}],[\"mlops\",{\"0\":{\"124\":1}}],[\"ml\",{\"1\":{\"73\":6,\"74\":2,\"84\":1,\"85\":1,\"90\":2,\"92\":24,\"93\":1,\"100\":2,\"101\":2}}],[\"md5\",{\"1\":{\"70\":1}}],[\"mimd\",{\"1\":{\"152\":3}}],[\"mime\",{\"1\":{\"70\":1}}],[\"milvusdb\",{\"1\":{\"137\":1}}],[\"milvusstandalone\",{\"1\":{\"137\":4}}],[\"milvusetcd\",{\"1\":{\"137\":4}}],[\"milvus\",{\"1\":{\"137\":8}}],[\"microsoft\",{\"1\":{\"100\":1,\"176\":1}}],[\"miit\",{\"1\":{\"70\":1}}],[\"minference\",{\"1\":{\"175\":1,\"176\":1,\"177\":1,\"178\":1,\"179\":5}}],[\"mini\",{\"1\":{\"154\":1}}],[\"minioadmin\",{\"1\":{\"137\":2}}],[\"minio\",{\"1\":{\"137\":14}}],[\"minikube\",{\"1\":{\"31\":2}}],[\"min\",{\"1\":{\"20\":1,\"21\":1}}],[\"mnt\",{\"1\":{\"61\":2}}],[\"mac地址长度\",{\"1\":{\"232\":1}}],[\"mac地址\",{\"1\":{\"222\":1,\"226\":1}}],[\"mac地址学习\",{\"1\":{\"219\":1}}],[\"mapper\",{\"1\":{\"186\":1,\"190\":1,\"191\":1,\"192\":1}}],[\"matrix\",{\"1\":{\"100\":1}}],[\"matchexpressions\",{\"1\":{\"49\":1,\"51\":1}}],[\"matchlabels\",{\"1\":{\"31\":1,\"38\":1,\"53\":1,\"93\":1}}],[\"master\",{\"1\":{\"93\":1,\"225\":2,\"226\":1}}],[\"margin\",{\"1\":{\"70\":2}}],[\"main\",{\"1\":{\"57\":1,\"165\":1}}],[\"manifests\",{\"1\":{\"26\":1,\"27\":3}}],[\"manager\",{\"0\":{\"93\":1},\"1\":{\"25\":1,\"28\":1,\"92\":6,\"93\":6}}],[\"maxtoken\",{\"1\":{\"136\":3}}],[\"maxtemperature\",{\"1\":{\"136\":2}}],[\"maxresponse\",{\"1\":{\"136\":2}}],[\"maxcontext\",{\"1\":{\"136\":2}}],[\"maxskew\",{\"1\":{\"53\":2}}],[\"max\",{\"1\":{\"20\":1,\"21\":1,\"46\":1,\"70\":1,\"137\":1,\"143\":1}}],[\"megatron\",{\"1\":{\"303\":1}}],[\"med\",{\"1\":{\"238\":1}}],[\"members\",{\"1\":{\"137\":1}}],[\"memory\",{\"1\":{\"15\":2,\"20\":4,\"31\":2,\"46\":4,\"93\":2,\"137\":1,\"277\":2,\"293\":2}}],[\"method\",{\"1\":{\"70\":1}}],[\"methods\",{\"1\":{\"70\":1}}],[\"metadata\",{\"1\":{\"15\":1,\"20\":1,\"27\":1,\"31\":2,\"35\":1,\"37\":1,\"38\":2,\"49\":1,\"51\":1,\"53\":1,\"81\":1,\"90\":3,\"92\":8,\"93\":3}}],[\"message\",{\"1\":{\"31\":1,\"156\":1,\"161\":1,\"264\":1}}],[\"m\",{\"1\":{\"0\":4,\"31\":1,\"61\":1}}],[\"mypassword\",{\"1\":{\"137\":3}}],[\"myusername\",{\"1\":{\"137\":3}}],[\"mysql\",{\"1\":{\"116\":2,\"123\":1,\"137\":11}}],[\"mysql数据库和minio服务器都由kubernetes持久卷子系统支持\",{\"1\":{\"81\":1}}],[\"mytask\",{\"1\":{\"86\":3}}],[\"myapp\",{\"1\":{\"49\":1,\"53\":1}}],[\"myrev\",{\"1\":{\"0\":1}}],[\"mykey\",{\"1\":{\"0\":1}}],[\"my\",{\"1\":{\"0\":4,\"35\":2,\"37\":2,\"38\":10,\"53\":2}}],[\"m1\",{\"1\":{\"0\":3}}],[\"s带宽的两倍多\",{\"1\":{\"302\":1}}],[\"s的双向数据传输带宽\",{\"1\":{\"286\":1}}],[\"smtp\",{\"1\":{\"268\":1}}],[\"small\",{\"1\":{\"136\":2}}],[\"switch\",{\"1\":{\"263\":1}}],[\"swaps\",{\"1\":{\"57\":1}}],[\"swap\",{\"1\":{\"57\":3}}],[\"sy\",{\"1\":{\"185\":3}}],[\"sysinfo\",{\"1\":{\"57\":1}}],[\"systems\",{\"1\":{\"237\":1}}],[\"systemenv\",{\"1\":{\"136\":1}}],[\"systemd\",{\"1\":{\"57\":2}}],[\"system\",{\"1\":{\"27\":1,\"29\":1,\"185\":2}}],[\"slash\",{\"1\":{\"179\":2}}],[\"sleep\",{\"1\":{\"137\":1}}],[\"skill\",{\"2\":{\"174\":1}}],[\"skipped\",{\"1\":{\"89\":1}}],[\"sb\",{\"1\":{\"172\":1}}],[\"sql\",{\"1\":{\"137\":1}}],[\"snapshot\",{\"1\":{\"137\":1}}],[\"svg\",{\"1\":{\"136\":5}}],[\"svc\",{\"1\":{\"38\":1}}],[\"src=0\",{\"1\":{\"149\":1}}],[\"src\",{\"1\":{\"92\":1}}],[\"sudo\",{\"1\":{\"185\":1,\"187\":2,\"188\":1,\"189\":2,\"190\":1,\"191\":1,\"247\":3,\"253\":2,\"256\":2,\"259\":3}}],[\"subscribe\",{\"1\":{\"143\":1}}],[\"succeeded\",{\"1\":{\"89\":1}}],[\"supported\",{\"1\":{\"57\":1}}],[\"sdk\",{\"0\":{\"76\":1},\"1\":{\"84\":1,\"117\":1}}],[\"sdb\",{\"1\":{\"57\":1}}],[\"saving\",{\"1\":{\"277\":2}}],[\"sandbox\",{\"1\":{\"137\":8}}],[\"sans\",{\"1\":{\"70\":1}}],[\"sagemaker\",{\"1\":{\"100\":1}}],[\"sameorigin\",{\"1\":{\"70\":1}}],[\"show命令用于查看linux桥接设备的前向数据库\",{\"1\":{\"229\":1}}],[\"show命令用于显示linux桥接设备的前向数据库\",{\"1\":{\"224\":1}}],[\"show命令的示例输出可能如下所示\",{\"1\":{\"225\":1}}],[\"show\",{\"0\":{\"222\":1,\"224\":1},\"1\":{\"207\":2,\"209\":1,\"210\":1,\"211\":2,\"222\":2,\"223\":1,\"227\":3,\"228\":3,\"253\":1,\"256\":1}}],[\"sh脚本执行的mongodb服务进程\",{\"1\":{\"137\":1}}],[\"sh\",{\"1\":{\"137\":1}}],[\"sharing\",{\"1\":{\"91\":1}}],[\"sharedrunserver\",{\"1\":{\"103\":1,\"104\":1}}],[\"sharedjobserver\",{\"1\":{\"103\":1,\"104\":1}}],[\"sharedpipelineserver\",{\"1\":{\"103\":1,\"104\":1}}],[\"sharedexperimentserver\",{\"1\":{\"103\":1,\"104\":1}}],[\"shared\",{\"1\":{\"70\":1}}],[\"shimmer\",{\"1\":{\"136\":3}}],[\"shim\",{\"1\":{\"56\":6}}],[\"ssl\",{\"1\":{\"70\":6,\"267\":1}}],[\"ssd存储空间\",{\"1\":{\"297\":1}}],[\"ssd\",{\"1\":{\"51\":1,\"295\":1}}],[\"si\",{\"1\":{\"185\":3}}],[\"simd\",{\"1\":{\"152\":3}}],[\"single\",{\"1\":{\"143\":2,\"150\":1,\"152\":1,\"155\":1}}],[\"size\",{\"1\":{\"70\":2,\"165\":3}}],[\"sigs\",{\"1\":{\"93\":1,\"94\":1}}],[\"sig\",{\"1\":{\"56\":1}}],[\"songquanpeng\",{\"1\":{\"137\":1}}],[\"sock\",{\"1\":{\"57\":2}}],[\"socket\",{\"1\":{\"57\":2}}],[\"softirq\",{\"1\":{\"185\":2}}],[\"software\",{\"1\":{\"143\":1}}],[\"soft\",{\"1\":{\"46\":3}}],[\"soft=imagefs\",{\"1\":{\"46\":1}}],[\"steal\",{\"1\":{\"185\":1}}],[\"step\",{\"1\":{\"90\":1}}],[\"st\",{\"1\":{\"185\":2}}],[\"strace\",{\"1\":{\"182\":1,\"183\":4,\"184\":1,\"185\":3}}],[\"strace命令\",{\"1\":{\"182\":1}}],[\"strategy\",{\"1\":{\"100\":1}}],[\"streams\",{\"1\":{\"293\":1}}],[\"stream\",{\"1\":{\"56\":1,\"70\":1}}],[\"streaming\",{\"1\":{\"56\":8}}],[\"stg\",{\"1\":{\"92\":1}}],[\"storage之类的工件存储中\",{\"1\":{\"81\":1}}],[\"store\",{\"1\":{\"57\":1,\"70\":1,\"137\":1}}],[\"style=\",{\"1\":{\"70\":1}}],[\"style>\",{\"1\":{\"70\":1}}],[\"stale\",{\"1\":{\"222\":2}}],[\"standalone\",{\"1\":{\"137\":1}}],[\"start\",{\"1\":{\"137\":2,\"142\":1}}],[\"startrpcserver\",{\"1\":{\"102\":1,\"106\":1}}],[\"started\",{\"1\":{\"73\":1}}],[\"starting\",{\"1\":{\"57\":1}}],[\"state\",{\"1\":{\"210\":2,\"211\":4}}],[\"stateful\",{\"1\":{\"37\":2,\"38\":8}}],[\"statefulset\",{\"0\":{\"36\":1,\"38\":1},\"1\":{\"32\":1,\"33\":2,\"34\":2,\"36\":1,\"38\":3,\"39\":1}}],[\"static\",{\"0\":{\"26\":1,\"27\":1},\"1\":{\"25\":2,\"26\":4,\"27\":3,\"28\":3,\"29\":5}}],[\"status=1\",{\"1\":{\"57\":1}}],[\"status\",{\"0\":{\"6\":1},\"1\":{\"6\":1,\"70\":1,\"92\":1,\"137\":1,\"165\":1}}],[\"spoofing\",{\"1\":{\"234\":1}}],[\"spmd\",{\"0\":{\"151\":1,\"152\":1,\"157\":1},\"1\":{\"150\":2,\"151\":3,\"152\":2,\"153\":4,\"154\":1,\"155\":2,\"156\":1,\"157\":1}}],[\"speech\",{\"1\":{\"143\":1}}],[\"specified\",{\"1\":{\"57\":1,\"93\":1}}],[\"spec\",{\"1\":{\"15\":1,\"20\":1,\"27\":1,\"31\":2,\"35\":1,\"37\":1,\"38\":2,\"49\":1,\"51\":1,\"53\":1,\"93\":2}}],[\"spring\",{\"1\":{\"123\":1}}],[\"spread\",{\"0\":{\"52\":1}}],[\"sparkdesk\",{\"1\":{\"136\":1}}],[\"spark\",{\"1\":{\"86\":2}}],[\"s\",{\"1\":{\"31\":1,\"63\":1,\"65\":1,\"68\":1,\"103\":8,\"104\":4,\"105\":1,\"302\":1}}],[\"scope\",{\"1\":{\"211\":2}}],[\"scopes\",{\"1\":{\"16\":1}}],[\"scale\",{\"1\":{\"277\":2}}],[\"scale=1\",{\"1\":{\"70\":1}}],[\"scatter\",{\"1\":{\"162\":1}}],[\"scheduledworkflow\",{\"1\":{\"92\":3}}],[\"scheduler\",{\"0\":{\"54\":1},\"1\":{\"25\":1,\"28\":1,\"31\":1,\"55\":2}}],[\"scheduling\",{\"1\":{\"31\":1}}],[\"s1\",{\"1\":{\"0\":6}}],[\"self\",{\"1\":{\"225\":2,\"226\":1}}],[\"selector\",{\"1\":{\"31\":1,\"35\":1,\"37\":1,\"38\":1,\"93\":1}}],[\"sent\",{\"1\":{\"165\":1}}],[\"sender\",{\"1\":{\"232\":2}}],[\"send\",{\"1\":{\"162\":1,\"165\":1}}],[\"sendfile\",{\"1\":{\"70\":1}}],[\"seconds\",{\"1\":{\"143\":1}}],[\"seccomp\",{\"1\":{\"137\":1,\"143\":1}}],[\"security\",{\"1\":{\"137\":1,\"143\":1}}],[\"secret=oneapikey\",{\"1\":{\"137\":1}}],[\"secret\",{\"1\":{\"137\":1}}],[\"search\",{\"1\":{\"100\":3}}],[\"serif\",{\"1\":{\"70\":1}}],[\"servlets\",{\"1\":{\"277\":1}}],[\"servers\",{\"1\":{\"277\":2}}],[\"server\",{\"1\":{\"25\":1,\"26\":2,\"28\":1,\"31\":1,\"56\":10,\"57\":3,\"70\":3,\"92\":1,\"103\":4,\"137\":1}}],[\"serviceaccountname\",{\"1\":{\"93\":1}}],[\"servicename\",{\"1\":{\"38\":1}}],[\"services\",{\"0\":{\"32\":1},\"1\":{\"15\":1,\"63\":1,\"64\":1,\"65\":1,\"66\":1,\"67\":1,\"137\":1,\"143\":1}}],[\"service\",{\"0\":{\"33\":1,\"35\":1,\"36\":1,\"37\":1},\"1\":{\"15\":2,\"32\":3,\"33\":4,\"34\":3,\"35\":4,\"36\":1,\"37\":2,\"38\":4,\"39\":2,\"57\":2,\"63\":2,\"64\":1,\"65\":1,\"66\":2,\"67\":1,\"112\":1}}],[\"set\",{\"1\":{\"57\":1,\"70\":7,\"253\":2}}],[\"settings\",{\"1\":{\"57\":1}}],[\"session\",{\"0\":{\"266\":1},\"1\":{\"0\":2,\"70\":2,\"137\":1}}],[\"sessions\",{\"1\":{\"0\":1}}],[\"separate\",{\"1\":{\"0\":1}}],[\"ftp\",{\"1\":{\"268\":1}}],[\"fdb记录了mac地址与网络接口的映射关系\",{\"1\":{\"224\":1}}],[\"fdb\",{\"0\":{\"224\":1},\"1\":{\"224\":2,\"225\":1,\"227\":3,\"228\":3,\"229\":1}}],[\"fdisk\",{\"1\":{\"187\":4,\"188\":4}}],[\"f4\",{\"1\":{\"222\":4}}],[\"f\",{\"1\":{\"137\":2,\"149\":1}}],[\"functioncall\",{\"1\":{\"136\":3}}],[\"feb6\",{\"1\":{\"211\":1}}],[\"feb47b\",{\"1\":{\"70\":1}}],[\"fe80\",{\"1\":{\"211\":1}}],[\"feconfigs\",{\"1\":{\"136\":1}}],[\"fi\",{\"1\":{\"263\":1}}],[\"finalize\",{\"1\":{\"165\":1}}],[\"fieldpath\",{\"1\":{\"93\":1}}],[\"fieldref\",{\"1\":{\"93\":1}}],[\"file\",{\"1\":{\"137\":1}}],[\"filename\",{\"1\":{\"57\":1}}],[\"file=scheduler\",{\"1\":{\"55\":1}}],[\"fsgks\",{\"1\":{\"92\":2}}],[\"free\",{\"1\":{\"190\":1}}],[\"frame\",{\"1\":{\"70\":1}}],[\"from\",{\"1\":{\"31\":1,\"57\":1,\"93\":1,\"165\":1}}],[\"ff\",{\"1\":{\"211\":12}}],[\"ffffff\",{\"1\":{\"70\":1}}],[\"ff7e5f\",{\"1\":{\"70\":1}}],[\"found\",{\"1\":{\"307\":1}}],[\"footer>\",{\"1\":{\"70\":1}}],[\"footer\",{\"1\":{\"70\":1}}],[\"font\",{\"1\":{\"70\":3}}],[\"forwarding\",{\"1\":{\"224\":1}}],[\"forwarded\",{\"1\":{\"70\":4}}],[\"forever\",{\"1\":{\"211\":4}}],[\"for\",{\"1\":{\"0\":5,\"31\":3,\"70\":2,\"137\":2}}],[\"flops\",{\"1\":{\"295\":1}}],[\"flannel\",{\"1\":{\"222\":5,\"223\":1}}],[\"flashattention\",{\"1\":{\"179\":1}}],[\"flag\",{\"1\":{\"57\":1}}],[\"flex\",{\"1\":{\"70\":1}}],[\"fatgpt\",{\"1\":{\"143\":1}}],[\"fatal\",{\"1\":{\"0\":4}}],[\"fable\",{\"1\":{\"136\":3}}],[\"fastgpt\",{\"0\":{\"139\":1},\"1\":{\"133\":1,\"134\":1,\"137\":21,\"143\":5},\"2\":{\"145\":1}}],[\"fastgpt+chatgpt\",{\"0\":{\"133\":1}}],[\"fast\",{\"1\":{\"100\":1}}],[\"family\",{\"1\":{\"70\":1}}],[\"false\",{\"1\":{\"57\":1,\"136\":6,\"143\":3}}],[\"failure\",{\"1\":{\"57\":1}}],[\"fail\",{\"1\":{\"57\":1}}],[\"failedscheduling\",{\"1\":{\"31\":1}}],[\"failed\",{\"1\":{\"0\":1,\"12\":1,\"57\":3,\"89\":1}}],[\"fmt\",{\"1\":{\"0\":2}}],[\"nsf\",{\"1\":{\"277\":1}}],[\"ns1\",{\"1\":{\"211\":3}}],[\"nvlink\",{\"1\":{\"302\":1}}],[\"nvidia的grace\",{\"1\":{\"302\":1}}],[\"nvidia的p100\",{\"1\":{\"286\":1}}],[\"nvme0n1\",{\"1\":{\"187\":1,\"188\":1}}],[\"nvme0n1p1\",{\"1\":{\"186\":2,\"187\":4,\"188\":2,\"189\":2,\"192\":1}}],[\"nv8km\",{\"1\":{\"92\":2}}],[\"nice\",{\"1\":{\"185\":2}}],[\"ni\",{\"1\":{\"185\":1}}],[\"nil\",{\"1\":{\"0\":5}}],[\"nccl\",{\"1\":{\"147\":1,\"295\":1}}],[\"n输入\",{\"1\":{\"143\":1}}],[\"n支持tool\",{\"1\":{\"143\":1}}],[\"n支持图片输出\",{\"1\":{\"143\":1}}],[\"n支持图片输入\",{\"1\":{\"143\":1}}],[\"n支持语音对话\",{\"1\":{\"143\":1}}],[\"n这里是chatgpt\",{\"1\":{\"143\":1}}],[\"n积分\",{\"1\":{\"136\":2}}],[\"native\",{\"1\":{\"137\":1}}],[\"nacos\",{\"1\":{\"123\":1}}],[\"nas\",{\"1\":{\"100\":1}}],[\"name=hello\",{\"1\":{\"63\":1,\"66\":1}}],[\"name=\",{\"1\":{\"57\":1,\"70\":1}}],[\"name\",{\"1\":{\"15\":1,\"20\":1,\"27\":2,\"31\":3,\"35\":2,\"37\":2,\"38\":2,\"49\":1,\"51\":1,\"53\":2,\"55\":1,\"61\":1,\"70\":1,\"92\":1,\"93\":3,\"136\":7,\"137\":8,\"143\":3,\"210\":1}}],[\"namespace\",{\"1\":{\"13\":1,\"15\":2,\"20\":2,\"27\":1,\"35\":1,\"37\":1,\"38\":1,\"91\":1,\"93\":2}}],[\"null\",{\"1\":{\"70\":1,\"137\":1}}],[\"neigh\",{\"0\":{\"222\":1},\"1\":{\"222\":2,\"223\":1}}],[\"neural\",{\"1\":{\"100\":1}}],[\"netbios\",{\"1\":{\"266\":1}}],[\"netfilter\",{\"1\":{\"258\":1}}],[\"netmask\",{\"1\":{\"247\":1}}],[\"netnsid\",{\"1\":{\"211\":2}}],[\"netns\",{\"1\":{\"211\":3}}],[\"network\",{\"0\":{\"213\":1,\"264\":1},\"1\":{\"212\":1,\"214\":1,\"218\":1}}],[\"networks\",{\"1\":{\"137\":9,\"143\":2}}],[\"network=kong\",{\"1\":{\"61\":1}}],[\"net\",{\"1\":{\"61\":2}}],[\"newauthserver\",{\"1\":{\"103\":1}}],[\"newvisualizationserver\",{\"1\":{\"103\":1}}],[\"newreportserver\",{\"1\":{\"103\":1}}],[\"newtaskserver\",{\"1\":{\"103\":1}}],[\"newmutex\",{\"1\":{\"0\":2}}],[\"newsession\",{\"1\":{\"0\":2}}],[\"new\",{\"1\":{\"0\":1}}],[\"noop\",{\"1\":{\"211\":2}}],[\"noqueue\",{\"1\":{\"210\":2,\"211\":2}}],[\"nova\",{\"1\":{\"136\":3}}],[\"none\",{\"1\":{\"33\":1,\"35\":1,\"37\":1,\"42\":1}}],[\"not\",{\"1\":{\"31\":2,\"57\":3,\"307\":1}}],[\"nodeaffinity\",{\"1\":{\"51\":1}}],[\"nodefs\",{\"1\":{\"46\":7}}],[\"nodeselectorterms\",{\"1\":{\"51\":1}}],[\"nodes\",{\"1\":{\"31\":2,\"57\":1}}],[\"node\",{\"0\":{\"50\":1},\"1\":{\"31\":3,\"50\":1,\"56\":1}}],[\"no\",{\"1\":{\"31\":2,\"70\":2}}],[\"noexecute\",{\"1\":{\"31\":3}}],[\"noschedule\",{\"1\":{\"31\":5}}],[\"n\",{\"1\":{\"29\":1,\"92\":1,\"165\":2,\"188\":1,\"259\":1}}],[\"nginx容器\",{\"1\":{\"70\":1}}],[\"nginx容器启动\",{\"0\":{\"61\":1}}],[\"nginx\",{\"1\":{\"27\":2,\"31\":4,\"61\":8,\"63\":1,\"70\":1},\"2\":{\"72\":1}}],[\"c2c\",{\"1\":{\"302\":1}}],[\"ctrl+c\",{\"1\":{\"185\":1}}],[\"ctx\",{\"1\":{\"0\":2}}],[\"c10d\",{\"1\":{\"146\":3,\"147\":5,\"148\":2,\"149\":1,\"150\":1},\"2\":{\"168\":1}}],[\"char\",{\"1\":{\"165\":1}}],[\"character\",{\"1\":{\"143\":1}}],[\"charspointsprice\",{\"1\":{\"136\":7}}],[\"charset=utf\",{\"1\":{\"70\":1}}],[\"charset=\",{\"1\":{\"70\":1}}],[\"channel\",{\"1\":{\"143\":1}}],[\"chatgpt测试群2\",{\"1\":{\"143\":1}}],[\"chatgpt测试群\",{\"1\":{\"143\":1}}],[\"chatgpt\",{\"1\":{\"141\":1,\"143\":3},\"2\":{\"145\":1}}],[\"chat\",{\"1\":{\"137\":1,\"143\":3}}],[\"chown\",{\"1\":{\"137\":1}}],[\"chmod\",{\"1\":{\"137\":1}}],[\"c\",{\"0\":{\"290\":1,\"297\":1},\"1\":{\"122\":1,\"137\":1}}],[\"c++\",{\"1\":{\"122\":1}}],[\"cmd\",{\"1\":{\"137\":3}}],[\"cm\",{\"1\":{\"103\":2}}],[\"ciphers\",{\"1\":{\"70\":2}}],[\"cn\",{\"1\":{\"70\":1,\"137\":4,\"143\":1}}],[\"cnbita\",{\"1\":{\"31\":1,\"92\":1}}],[\"centos\",{\"1\":{\"186\":1,\"189\":1,\"190\":2,\"191\":1,\"192\":1}}],[\"center\",{\"1\":{\"70\":3}}],[\"censor\",{\"1\":{\"136\":2}}],[\"cert\",{\"1\":{\"57\":1}}],[\"certificate\",{\"1\":{\"57\":1}}],[\"cgroup\",{\"1\":{\"57\":1,\"185\":1}}],[\"cgroups\",{\"1\":{\"46\":1,\"57\":1}}],[\"call\",{\"1\":{\"185\":1}}],[\"cache\",{\"1\":{\"70\":5,\"137\":1}}],[\"ca\",{\"1\":{\"57\":2}}],[\"cafile\",{\"1\":{\"57\":1}}],[\"cadvisor\",{\"1\":{\"46\":1}}],[\"cuda\",{\"1\":{\"295\":1}}],[\"curl\",{\"1\":{\"63\":1,\"64\":1,\"65\":1,\"66\":1,\"67\":1,\"68\":1,\"69\":1,\"70\":1,\"137\":2,\"172\":2}}],[\"current\",{\"1\":{\"57\":1}}],[\"customextractprompt\",{\"1\":{\"136\":2}}],[\"customcqprompt\",{\"1\":{\"136\":2}}],[\"custom\",{\"0\":{\"54\":1},\"1\":{\"112\":2}}],[\"cpu内存\",{\"1\":{\"302\":1}}],[\"cpu内存更便宜\",{\"1\":{\"302\":1}}],[\"cpu内存空间\",{\"1\":{\"293\":1}}],[\"cpu交换对内存节省的贡献为0\",{\"1\":{\"301\":1}}],[\"cpu交换快了7\",{\"1\":{\"300\":1}}],[\"cpu交换快了143\",{\"1\":{\"296\":1}}],[\"cpu交换取而代之\",{\"1\":{\"297\":1}}],[\"cpu交换并进一步扩展到nvme设备\",{\"1\":{\"297\":1}}],[\"cpu交换可以支持相同的超大模型\",{\"1\":{\"296\":1}}],[\"cpu交换实现了1\",{\"1\":{\"296\":1}}],[\"cpu交换依然可行\",{\"1\":{\"296\":1}}],[\"cpu交换相比\",{\"1\":{\"296\":1}}],[\"cpu交换分配给剩余的张量\",{\"1\":{\"291\":1}}],[\"cpu交换分配给生命周期特别长的张量\",{\"1\":{\"291\":1}}],[\"cpu交换的高延迟\",{\"1\":{\"303\":1}}],[\"cpu交换的方案可能可以支持非常大规模的模型训练\",{\"1\":{\"297\":1}}],[\"cpu交换的性能最差\",{\"1\":{\"296\":1}}],[\"cpu交换的系统和启用重计算的系统\",{\"1\":{\"295\":1}}],[\"cpu交换的成本\",{\"1\":{\"291\":1,\"302\":1}}],[\"cpu交换的延迟\",{\"1\":{\"288\":1}}],[\"cpu交换要快得多\",{\"1\":{\"291\":1}}],[\"cpu交换腾出更多空间\",{\"1\":{\"291\":1}}],[\"cpu交换和我们新提出的d2d交换\",{\"1\":{\"304\":1}}],[\"cpu交换和深度学习加速器\",{\"1\":{\"303\":1}}],[\"cpu交换和d2d交换的时间成本\",{\"1\":{\"300\":1}}],[\"cpu交换和d2d交换的优势\",{\"1\":{\"279\":1}}],[\"cpu交换和mpress能够成功执行训练任务\",{\"1\":{\"296\":1}}],[\"cpu交换和重计算相结合\",{\"1\":{\"303\":1}}],[\"cpu交换和重计算带来的额外开销或gpu资源争用方面起到了关键作用\",{\"1\":{\"301\":1}}],[\"cpu交换和重计算带来的额外延迟\",{\"1\":{\"291\":1}}],[\"cpu交换和重计算都会带来额外开销\",{\"1\":{\"300\":1}}],[\"cpu交换和重计算为d2d交换腾出了更多空间\",{\"1\":{\"296\":1}}],[\"cpu交换和重计算的时间成本\",{\"1\":{\"295\":1}}],[\"cpu交换和重计算替换为d2d交换来优化配置\",{\"1\":{\"291\":1}}],[\"cpu交换和重计算优化\",{\"1\":{\"291\":1}}],[\"cpu交换和重计算结合起来的最佳配置\",{\"1\":{\"291\":1}}],[\"cpu交换技术来进一步减少gpu内存消耗\",{\"1\":{\"288\":1}}],[\"cpu交换所带来的高额性能损失至关重要\",{\"1\":{\"288\":1}}],[\"cpu交换后\",{\"1\":{\"285\":1}}],[\"cpu交换会大幅降低训练吞吐量\",{\"1\":{\"285\":1}}],[\"cpu交换利用了cpu内存的大容量来扩展gpu内存空间\",{\"1\":{\"285\":1}}],[\"cpu交换\",{\"1\":{\"278\":1,\"296\":1,\"298\":1,\"300\":3,\"301\":3,\"303\":3}}],[\"cpu\",{\"1\":{\"15\":5,\"16\":1,\"20\":9,\"31\":2,\"57\":1,\"93\":2,\"155\":1,\"158\":1,\"159\":1,\"161\":1,\"185\":18}}],[\"cr\",{\"1\":{\"112\":3}}],[\"cron\",{\"1\":{\"90\":2}}],[\"crd\",{\"1\":{\"79\":1,\"92\":6,\"93\":1,\"95\":1,\"112\":3,\"113\":4}}],[\"credentials\",{\"1\":{\"70\":1}}],[\"createrevision\",{\"1\":{\"0\":1}}],[\"create\",{\"1\":{\"0\":1,\"143\":1}}],[\"crt\",{\"1\":{\"57\":1}}],[\"crit\",{\"1\":{\"70\":1}}],[\"cri\",{\"1\":{\"56\":7,\"57\":4}}],[\"crash\",{\"1\":{\"0\":1}}],[\"cow\",{\"1\":{\"142\":1}}],[\"count=50000\",{\"1\":{\"137\":1}}],[\"coreos\",{\"1\":{\"137\":1}}],[\"covariance\",{\"1\":{\"100\":1}}],[\"color\",{\"1\":{\"70\":3}}],[\"code\",{\"1\":{\"57\":1,\"232\":1}}],[\"code=exited\",{\"1\":{\"57\":1}}],[\"comm\",{\"1\":{\"162\":1,\"165\":6}}],[\"communicator\",{\"1\":{\"162\":1}}],[\"common\",{\"1\":{\"103\":2}}],[\"command\",{\"1\":{\"31\":1,\"57\":1,\"93\":1,\"137\":5}}],[\"compaction\",{\"1\":{\"137\":2}}],[\"compose\",{\"0\":{\"137\":1,\"143\":1}}],[\"component\",{\"0\":{\"85\":1}}],[\"competition\",{\"1\":{\"0\":1}}],[\"com\",{\"1\":{\"31\":1,\"92\":1,\"93\":1,\"94\":1,\"134\":1,\"137\":4,\"141\":1,\"143\":1,\"176\":1,\"177\":1}}],[\"conversation\",{\"1\":{\"143\":1}}],[\"const\",{\"1\":{\"137\":1}}],[\"constraints\",{\"0\":{\"52\":1}}],[\"console\",{\"1\":{\"137\":1}}],[\"connection\",{\"1\":{\"70\":1,\"137\":1}}],[\"connections\",{\"1\":{\"70\":1}}],[\"conf\",{\"1\":{\"61\":3,\"70\":1}}],[\"config\",{\"1\":{\"0\":1,\"43\":1,\"55\":3,\"137\":2,\"143\":1}}],[\"control\",{\"1\":{\"70\":8,\"93\":3,\"264\":1}}],[\"controller\",{\"0\":{\"93\":1},\"1\":{\"25\":1,\"28\":1,\"57\":1,\"92\":9,\"93\":8,\"112\":1}}],[\"contained\",{\"1\":{\"57\":1}}],[\"containerport\",{\"1\":{\"27\":1,\"31\":1,\"38\":1}}],[\"containers\",{\"1\":{\"27\":1,\"31\":1,\"38\":1,\"53\":1,\"93\":1}}],[\"container\",{\"1\":{\"20\":1,\"38\":1,\"53\":1,\"137\":8,\"143\":1}}],[\"content=\",{\"1\":{\"70\":1}}],[\"content\",{\"1\":{\"57\":1,\"70\":5}}],[\"context\",{\"1\":{\"0\":2}}],[\"concurrency\",{\"1\":{\"0\":5}}],[\"clash\",{\"2\":{\"132\":1}}],[\"clash节点转为v2ray\",{\"0\":{\"130\":1}}],[\"cloud\",{\"1\":{\"100\":1}}],[\"close\",{\"1\":{\"0\":2}}],[\"cluster\",{\"1\":{\"33\":2,\"38\":1,\"39\":1}}],[\"clusterip\",{\"1\":{\"32\":1,\"33\":1,\"35\":2,\"37\":1}}],[\"client\",{\"1\":{\"0\":8,\"57\":3,\"137\":2}}],[\"clientv3\",{\"1\":{\"0\":2}}],[\"cli\",{\"1\":{\"0\":3,\"98\":1}}],[\"==\",{\"1\":{\"149\":1,\"165\":2}}],[\"===\",{\"1\":{\"137\":1}}],[\"=\",{\"1\":{\"0\":12,\"66\":1,\"70\":1,\"137\":1,\"149\":2,\"165\":1}}],[\"e\",{\"0\":{\"292\":1,\"293\":1}}],[\"ec2上最新的gpu实例仍然使用dgx\",{\"1\":{\"302\":1}}],[\"ec2上这种高端gpu服务器的配额非常有限\",{\"1\":{\"295\":1}}],[\"ec2实例上进行这组实验\",{\"1\":{\"297\":1}}],[\"ec2\",{\"1\":{\"284\":1,\"295\":1}}],[\"echo\",{\"1\":{\"136\":3,\"137\":2}}],[\"ebgp\",{\"1\":{\"238\":1}}],[\"e0ff\",{\"1\":{\"211\":1}}],[\"e0\",{\"1\":{\"211\":2}}],[\"e0729\",{\"1\":{\"57\":1}}],[\"eth0\",{\"1\":{\"247\":3,\"253\":2,\"256\":1}}],[\"ethernet\",{\"1\":{\"263\":1}}],[\"ether\",{\"1\":{\"211\":2}}],[\"etc\",{\"1\":{\"26\":1,\"27\":3,\"57\":1,\"61\":1}}],[\"etcdctl\",{\"1\":{\"137\":1}}],[\"etcd获取分布式锁\",{\"1\":{\"0\":1}}],[\"etcd\",{\"0\":{\"0\":1},\"1\":{\"0\":1,\"25\":1,\"26\":1,\"28\":2,\"137\":10},\"2\":{\"1\":1}}],[\"embedding3\",{\"1\":{\"136\":1}}],[\"embedding\",{\"1\":{\"136\":6}}],[\"emissary\",{\"1\":{\"91\":2,\"92\":1}}],[\"emissaryexecutor\",{\"1\":{\"91\":1,\"92\":2}}],[\"element\",{\"1\":{\"125\":1}}],[\"elasticsearch\",{\"1\":{\"116\":2}}],[\"else\",{\"1\":{\"0\":1,\"90\":1,\"165\":1}}],[\"efficient\",{\"1\":{\"100\":1}}],[\"effect\",{\"1\":{\"31\":2}}],[\"estimators\",{\"1\":{\"100\":1}}],[\"eecdh+3des\",{\"1\":{\"70\":1}}],[\"eecdh+aes256\",{\"1\":{\"70\":1}}],[\"eecdh+aes128\",{\"1\":{\"70\":1}}],[\"eecdh+chacha20\",{\"1\":{\"70\":2}}],[\"ens3\",{\"1\":{\"225\":2}}],[\"entrypoint\",{\"1\":{\"137\":3}}],[\"endpoint\",{\"0\":{\"219\":1},\"1\":{\"137\":1}}],[\"endpoints\",{\"1\":{\"0\":2,\"137\":1}}],[\"environment\",{\"1\":{\"137\":7,\"143\":1}}],[\"env\",{\"1\":{\"93\":1}}],[\"en\",{\"1\":{\"70\":1}}],[\"enabled=true\",{\"1\":{\"137\":2}}],[\"enabled\",{\"1\":{\"57\":1}}],[\"extensible\",{\"0\":{\"214\":1,\"218\":1},\"1\":{\"212\":1}}],[\"external\",{\"1\":{\"143\":1}}],[\"expires\",{\"1\":{\"143\":1}}],[\"experimentservice\",{\"1\":{\"103\":1,\"104\":1,\"106\":1}}],[\"experiment\",{\"0\":{\"90\":1}}],[\"expose\",{\"1\":{\"70\":1}}],[\"exit\",{\"1\":{\"57\":1,\"238\":1}}],[\"exited\",{\"1\":{\"57\":1}}],[\"exec\",{\"0\":{\"56\":1},\"1\":{\"56\":5,\"137\":1,\"211\":3}}],[\"example\",{\"1\":{\"15\":2,\"20\":2,\"27\":2,\"49\":1,\"51\":1,\"53\":1}}],[\"eval\",{\"1\":{\"137\":1}}],[\"evolution\",{\"1\":{\"100\":1}}],[\"evenpodsspreadpriority\",{\"1\":{\"54\":1,\"55\":1}}],[\"events\",{\"1\":{\"31\":1,\"70\":1}}],[\"eviction\",{\"1\":{\"46\":15}}],[\"equal\",{\"1\":{\"31\":1}}],[\"error\",{\"1\":{\"70\":1,\"137\":1}}],[\"err=\",{\"1\":{\"57\":1}}],[\"err\",{\"1\":{\"0\":12}}]],\"serializationVersion\":2}}")).map(([e,t])=>[e,zt(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:s,options:n,id:o}})=>{const u=bt[s];e==="suggest"?self.postMessage([e,o,tt(t,u,n)]):e==="search"?self.postMessage([e,o,Z(t,u,n)]):self.postMessage({suggestions:[e,o,tt(t,u,n)],results:[e,o,Z(t,u,n)]})};
//# sourceMappingURL=index.js.map
