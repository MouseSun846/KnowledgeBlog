import {
  Hook,
  UrlBuilder,
  buildCSSItem,
  buildJSItem,
  loadJS,
  noop,
  walkTree,
  wrapFunction
} from "./chunk-Q463VRAJ.js";
import {
  __commonJS,
  __export,
  __toESM
} from "./chunk-ZS7NZCD4.js";

// node_modules/.pnpm/boolbase@1.0.0/node_modules/boolbase/index.js
var require_boolbase = __commonJS({
  "node_modules/.pnpm/boolbase@1.0.0/node_modules/boolbase/index.js"(exports, module) {
    module.exports = {
      trueFunc: function trueFunc2() {
        return true;
      },
      falseFunc: function falseFunc() {
        return false;
      }
    };
  }
});

// node_modules/.pnpm/katex@0.12.0/node_modules/katex/dist/katex.js
var require_katex = __commonJS({
  "node_modules/.pnpm/katex@0.12.0/node_modules/katex/dist/katex.js"(exports, module) {
    (function webpackUniversalModuleDefinition(root3, factory) {
      if (typeof exports === "object" && typeof module === "object")
        module.exports = factory();
      else if (typeof define === "function" && define.amd)
        define([], factory);
      else if (typeof exports === "object")
        exports["katex"] = factory();
      else
        root3["katex"] = factory();
    })(typeof self !== "undefined" ? self : exports, function() {
      return (
        /******/
        function(modules) {
          var installedModules = {};
          function __webpack_require__(moduleId) {
            if (installedModules[moduleId]) {
              return installedModules[moduleId].exports;
            }
            var module2 = installedModules[moduleId] = {
              /******/
              i: moduleId,
              /******/
              l: false,
              /******/
              exports: {}
              /******/
            };
            modules[moduleId].call(module2.exports, module2, module2.exports, __webpack_require__);
            module2.l = true;
            return module2.exports;
          }
          __webpack_require__.m = modules;
          __webpack_require__.c = installedModules;
          __webpack_require__.d = function(exports2, name2, getter) {
            if (!__webpack_require__.o(exports2, name2)) {
              Object.defineProperty(exports2, name2, { enumerable: true, get: getter });
            }
          };
          __webpack_require__.r = function(exports2) {
            if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
              Object.defineProperty(exports2, Symbol.toStringTag, { value: "Module" });
            }
            Object.defineProperty(exports2, "__esModule", { value: true });
          };
          __webpack_require__.t = function(value, mode) {
            if (mode & 1)
              value = __webpack_require__(value);
            if (mode & 8)
              return value;
            if (mode & 4 && typeof value === "object" && value && value.__esModule)
              return value;
            var ns = /* @__PURE__ */ Object.create(null);
            __webpack_require__.r(ns);
            Object.defineProperty(ns, "default", { enumerable: true, value });
            if (mode & 2 && typeof value != "string")
              for (var key in value)
                __webpack_require__.d(ns, key, (function(key2) {
                  return value[key2];
                }).bind(null, key));
            return ns;
          };
          __webpack_require__.n = function(module2) {
            var getter = module2 && module2.__esModule ? (
              /******/
              function getDefault() {
                return module2["default"];
              }
            ) : (
              /******/
              function getModuleExports() {
                return module2;
              }
            );
            __webpack_require__.d(getter, "a", getter);
            return getter;
          };
          __webpack_require__.o = function(object, property) {
            return Object.prototype.hasOwnProperty.call(object, property);
          };
          __webpack_require__.p = "";
          return __webpack_require__(__webpack_require__.s = 1);
        }([
          /* 0 */
          /***/
          function(module2, exports2, __webpack_require__) {
          },
          /* 1 */
          /***/
          function(module2, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            var katex = __webpack_require__(0);
            var SourceLocation = function() {
              function SourceLocation2(lexer, start, end2) {
                this.lexer = void 0;
                this.start = void 0;
                this.end = void 0;
                this.lexer = lexer;
                this.start = start;
                this.end = end2;
              }
              SourceLocation2.range = function range(first2, second) {
                if (!second) {
                  return first2 && first2.loc;
                } else if (!first2 || !first2.loc || !second.loc || first2.loc.lexer !== second.loc.lexer) {
                  return null;
                } else {
                  return new SourceLocation2(first2.loc.lexer, first2.loc.start, second.loc.end);
                }
              };
              return SourceLocation2;
            }();
            var Token_Token = function() {
              function Token2(text4, loc) {
                this.text = void 0;
                this.loc = void 0;
                this.noexpand = void 0;
                this.treatAsRelax = void 0;
                this.text = text4;
                this.loc = loc;
              }
              var _proto = Token2.prototype;
              _proto.range = function range(endToken, text4) {
                return new Token2(text4, SourceLocation.range(this, endToken));
              };
              return Token2;
            }();
            var ParseError = (
              // Error position based on passed-in Token or ParseNode.
              function ParseError2(message, token) {
                this.position = void 0;
                var error2 = "KaTeX parse error: " + message;
                var start;
                var loc = token && token.loc;
                if (loc && loc.start <= loc.end) {
                  var input = loc.lexer.input;
                  start = loc.start;
                  var end2 = loc.end;
                  if (start === input.length) {
                    error2 += " at end of input: ";
                  } else {
                    error2 += " at position " + (start + 1) + ": ";
                  }
                  var underlined = input.slice(start, end2).replace(/[^]/g, "$&̲");
                  var left;
                  if (start > 15) {
                    left = "…" + input.slice(start - 15, start);
                  } else {
                    left = input.slice(0, start);
                  }
                  var right;
                  if (end2 + 15 < input.length) {
                    right = input.slice(end2, end2 + 15) + "…";
                  } else {
                    right = input.slice(end2);
                  }
                  error2 += left + underlined + right;
                }
                var self2 = new Error(error2);
                self2.name = "ParseError";
                self2.__proto__ = ParseError2.prototype;
                self2.position = start;
                return self2;
              }
            );
            ParseError.prototype.__proto__ = Error.prototype;
            var src_ParseError = ParseError;
            var contains3 = function contains4(list2, elem) {
              return list2.indexOf(elem) !== -1;
            };
            var deflt = function deflt2(setting, defaultIfUndefined) {
              return setting === void 0 ? defaultIfUndefined : setting;
            };
            var uppercase = /([A-Z])/g;
            var hyphenate = function hyphenate2(str2) {
              return str2.replace(uppercase, "-$1").toLowerCase();
            };
            var ESCAPE_LOOKUP = {
              "&": "&amp;",
              ">": "&gt;",
              "<": "&lt;",
              '"': "&quot;",
              "'": "&#x27;"
            };
            var ESCAPE_REGEX = /[&><"']/g;
            function utils_escape(text4) {
              return String(text4).replace(ESCAPE_REGEX, function(match2) {
                return ESCAPE_LOOKUP[match2];
              });
            }
            var getBaseElem = function getBaseElem2(group) {
              if (group.type === "ordgroup") {
                if (group.body.length === 1) {
                  return getBaseElem2(group.body[0]);
                } else {
                  return group;
                }
              } else if (group.type === "color") {
                if (group.body.length === 1) {
                  return getBaseElem2(group.body[0]);
                } else {
                  return group;
                }
              } else if (group.type === "font") {
                return getBaseElem2(group.body);
              } else {
                return group;
              }
            };
            var utils_isCharacterBox = function isCharacterBox(group) {
              var baseElem = getBaseElem(group);
              return baseElem.type === "mathord" || baseElem.type === "textord" || baseElem.type === "atom";
            };
            var assert = function assert2(value) {
              if (!value) {
                throw new Error("Expected non-null, but got " + String(value));
              }
              return value;
            };
            var protocolFromUrl = function protocolFromUrl2(url) {
              var protocol = /^\s*([^\\/#]*?)(?::|&#0*58|&#x0*3a)/i.exec(url);
              return protocol != null ? protocol[1] : "_relative";
            };
            var utils = {
              contains: contains3,
              deflt,
              escape: utils_escape,
              hyphenate,
              getBaseElem,
              isCharacterBox: utils_isCharacterBox,
              protocolFromUrl
            };
            var Settings_Settings = function() {
              function Settings(options) {
                this.displayMode = void 0;
                this.output = void 0;
                this.leqno = void 0;
                this.fleqn = void 0;
                this.throwOnError = void 0;
                this.errorColor = void 0;
                this.macros = void 0;
                this.minRuleThickness = void 0;
                this.colorIsTextColor = void 0;
                this.strict = void 0;
                this.trust = void 0;
                this.maxSize = void 0;
                this.maxExpand = void 0;
                this.globalGroup = void 0;
                options = options || {};
                this.displayMode = utils.deflt(options.displayMode, false);
                this.output = utils.deflt(options.output, "htmlAndMathml");
                this.leqno = utils.deflt(options.leqno, false);
                this.fleqn = utils.deflt(options.fleqn, false);
                this.throwOnError = utils.deflt(options.throwOnError, true);
                this.errorColor = utils.deflt(options.errorColor, "#cc0000");
                this.macros = options.macros || {};
                this.minRuleThickness = Math.max(0, utils.deflt(options.minRuleThickness, 0));
                this.colorIsTextColor = utils.deflt(options.colorIsTextColor, false);
                this.strict = utils.deflt(options.strict, "warn");
                this.trust = utils.deflt(options.trust, false);
                this.maxSize = Math.max(0, utils.deflt(options.maxSize, Infinity));
                this.maxExpand = Math.max(0, utils.deflt(options.maxExpand, 1e3));
                this.globalGroup = utils.deflt(options.globalGroup, false);
              }
              var _proto = Settings.prototype;
              _proto.reportNonstrict = function reportNonstrict(errorCode, errorMsg, token) {
                var strict = this.strict;
                if (typeof strict === "function") {
                  strict = strict(errorCode, errorMsg, token);
                }
                if (!strict || strict === "ignore") {
                  return;
                } else if (strict === true || strict === "error") {
                  throw new src_ParseError("LaTeX-incompatible input and strict mode is set to 'error': " + (errorMsg + " [" + errorCode + "]"), token);
                } else if (strict === "warn") {
                  typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to 'warn': " + (errorMsg + " [" + errorCode + "]"));
                } else {
                  typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to " + ("unrecognized '" + strict + "': " + errorMsg + " [" + errorCode + "]"));
                }
              };
              _proto.useStrictBehavior = function useStrictBehavior(errorCode, errorMsg, token) {
                var strict = this.strict;
                if (typeof strict === "function") {
                  try {
                    strict = strict(errorCode, errorMsg, token);
                  } catch (error2) {
                    strict = "error";
                  }
                }
                if (!strict || strict === "ignore") {
                  return false;
                } else if (strict === true || strict === "error") {
                  return true;
                } else if (strict === "warn") {
                  typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to 'warn': " + (errorMsg + " [" + errorCode + "]"));
                  return false;
                } else {
                  typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to " + ("unrecognized '" + strict + "': " + errorMsg + " [" + errorCode + "]"));
                  return false;
                }
              };
              _proto.isTrusted = function isTrusted(context) {
                if (context.url && !context.protocol) {
                  context.protocol = utils.protocolFromUrl(context.url);
                }
                var trust = typeof this.trust === "function" ? this.trust(context) : this.trust;
                return Boolean(trust);
              };
              return Settings;
            }();
            var Style2 = function() {
              function Style3(id, size, cramped) {
                this.id = void 0;
                this.size = void 0;
                this.cramped = void 0;
                this.id = id;
                this.size = size;
                this.cramped = cramped;
              }
              var _proto = Style3.prototype;
              _proto.sup = function sup() {
                return Style_styles[_sup[this.id]];
              };
              _proto.sub = function sub() {
                return Style_styles[_sub[this.id]];
              };
              _proto.fracNum = function fracNum() {
                return Style_styles[_fracNum[this.id]];
              };
              _proto.fracDen = function fracDen() {
                return Style_styles[_fracDen[this.id]];
              };
              _proto.cramp = function cramp() {
                return Style_styles[_cramp[this.id]];
              };
              _proto.text = function text4() {
                return Style_styles[_text[this.id]];
              };
              _proto.isTight = function isTight() {
                return this.size >= 2;
              };
              return Style3;
            }();
            var D = 0;
            var Dc = 1;
            var T = 2;
            var Tc = 3;
            var S = 4;
            var Sc = 5;
            var SS = 6;
            var SSc = 7;
            var Style_styles = [new Style2(D, 0, false), new Style2(Dc, 0, true), new Style2(T, 1, false), new Style2(Tc, 1, true), new Style2(S, 2, false), new Style2(Sc, 2, true), new Style2(SS, 3, false), new Style2(SSc, 3, true)];
            var _sup = [S, Sc, S, Sc, SS, SSc, SS, SSc];
            var _sub = [Sc, Sc, Sc, Sc, SSc, SSc, SSc, SSc];
            var _fracNum = [T, Tc, S, Sc, SS, SSc, SS, SSc];
            var _fracDen = [Tc, Tc, Sc, Sc, SSc, SSc, SSc, SSc];
            var _cramp = [Dc, Dc, Tc, Tc, Sc, Sc, SSc, SSc];
            var _text = [D, Dc, T, Tc, T, Tc, T, Tc];
            var src_Style = {
              DISPLAY: Style_styles[D],
              TEXT: Style_styles[T],
              SCRIPT: Style_styles[S],
              SCRIPTSCRIPT: Style_styles[SS]
            };
            var scriptData = [{
              // Latin characters beyond the Latin-1 characters we have metrics for.
              // Needed for Czech, Hungarian and Turkish text, for example.
              name: "latin",
              blocks: [
                [256, 591],
                // Latin Extended-A and Latin Extended-B
                [768, 879]
              ]
            }, {
              // The Cyrillic script used by Russian and related languages.
              // A Cyrillic subset used to be supported as explicitly defined
              // symbols in symbols.js
              name: "cyrillic",
              blocks: [[1024, 1279]]
            }, {
              // The Brahmic scripts of South and Southeast Asia
              // Devanagari (0900–097F)
              // Bengali (0980–09FF)
              // Gurmukhi (0A00–0A7F)
              // Gujarati (0A80–0AFF)
              // Oriya (0B00–0B7F)
              // Tamil (0B80–0BFF)
              // Telugu (0C00–0C7F)
              // Kannada (0C80–0CFF)
              // Malayalam (0D00–0D7F)
              // Sinhala (0D80–0DFF)
              // Thai (0E00–0E7F)
              // Lao (0E80–0EFF)
              // Tibetan (0F00–0FFF)
              // Myanmar (1000–109F)
              name: "brahmic",
              blocks: [[2304, 4255]]
            }, {
              name: "georgian",
              blocks: [[4256, 4351]]
            }, {
              // Chinese and Japanese.
              // The "k" in cjk is for Korean, but we've separated Korean out
              name: "cjk",
              blocks: [
                [12288, 12543],
                // CJK symbols and punctuation, Hiragana, Katakana
                [19968, 40879],
                // CJK ideograms
                [65280, 65376]
              ]
            }, {
              // Korean
              name: "hangul",
              blocks: [[44032, 55215]]
            }];
            function scriptFromCodepoint(codepoint) {
              for (var i = 0; i < scriptData.length; i++) {
                var script = scriptData[i];
                for (var _i = 0; _i < script.blocks.length; _i++) {
                  var block2 = script.blocks[_i];
                  if (codepoint >= block2[0] && codepoint <= block2[1]) {
                    return script.name;
                  }
                }
              }
              return null;
            }
            var allBlocks = [];
            scriptData.forEach(function(s) {
              return s.blocks.forEach(function(b) {
                return allBlocks.push.apply(allBlocks, b);
              });
            });
            function supportedCodepoint(codepoint) {
              for (var i = 0; i < allBlocks.length; i += 2) {
                if (codepoint >= allBlocks[i] && codepoint <= allBlocks[i + 1]) {
                  return true;
                }
              }
              return false;
            }
            var hLinePad = 80;
            var sqrtMain = function sqrtMain2(extraViniculum, hLinePad2) {
              return "M95," + (622 + extraViniculum + hLinePad2) + "\nc-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14\nc0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54\nc44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10\ns173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429\nc69,-144,104.5,-217.7,106.5,-221\nl" + extraViniculum / 2.075 + " -" + extraViniculum + "\nc5.3,-9.3,12,-14,20,-14\nH400000v" + (40 + extraViniculum) + "H845.2724\ns-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7\nc-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z\nM" + (834 + extraViniculum) + " " + hLinePad2 + "h400000v" + (40 + extraViniculum) + "h-400000z";
            };
            var sqrtSize1 = function sqrtSize12(extraViniculum, hLinePad2) {
              return "M263," + (601 + extraViniculum + hLinePad2) + "c0.7,0,18,39.7,52,119\nc34,79.3,68.167,158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120\nc340,-704.7,510.7,-1060.3,512,-1067\nl" + extraViniculum / 2.084 + " -" + extraViniculum + "\nc4.7,-7.3,11,-11,19,-11\nH40000v" + (40 + extraViniculum) + "H1012.3\ns-271.3,567,-271.3,567c-38.7,80.7,-84,175,-136,283c-52,108,-89.167,185.3,-111.5,232\nc-22.3,46.7,-33.8,70.3,-34.5,71c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1\ns-109,-253,-109,-253c-72.7,-168,-109.3,-252,-110,-252c-10.7,8,-22,16.7,-34,26\nc-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26s76,-59,76,-59s76,-60,76,-60z\nM" + (1001 + extraViniculum) + " " + hLinePad2 + "h400000v" + (40 + extraViniculum) + "h-400000z";
            };
            var sqrtSize2 = function sqrtSize22(extraViniculum, hLinePad2) {
              return "M983 " + (10 + extraViniculum + hLinePad2) + "\nl" + extraViniculum / 3.13 + " -" + extraViniculum + "\nc4,-6.7,10,-10,18,-10 H400000v" + (40 + extraViniculum) + "\nH1013.1s-83.4,268,-264.1,840c-180.7,572,-277,876.3,-289,913c-4.7,4.7,-12.7,7,-24,7\ns-12,0,-12,0c-1.3,-3.3,-3.7,-11.7,-7,-25c-35.3,-125.3,-106.7,-373.3,-214,-744\nc-10,12,-21,25,-33,39s-32,39,-32,39c-6,-5.3,-15,-14,-27,-26s25,-30,25,-30\nc26.7,-32.7,52,-63,76,-91s52,-60,52,-60s208,722,208,722\nc56,-175.3,126.3,-397.3,211,-666c84.7,-268.7,153.8,-488.2,207.5,-658.5\nc53.7,-170.3,84.5,-266.8,92.5,-289.5z\nM" + (1001 + extraViniculum) + " " + hLinePad2 + "h400000v" + (40 + extraViniculum) + "h-400000z";
            };
            var sqrtSize3 = function sqrtSize32(extraViniculum, hLinePad2) {
              return "M424," + (2398 + extraViniculum + hLinePad2) + "\nc-1.3,-0.7,-38.5,-172,-111.5,-514c-73,-342,-109.8,-513.3,-110.5,-514\nc0,-2,-10.7,14.3,-32,49c-4.7,7.3,-9.8,15.7,-15.5,25c-5.7,9.3,-9.8,16,-12.5,20\ns-5,7,-5,7c-4,-3.3,-8.3,-7.7,-13,-13s-13,-13,-13,-13s76,-122,76,-122s77,-121,77,-121\ns209,968,209,968c0,-2,84.7,-361.7,254,-1079c169.3,-717.3,254.7,-1077.7,256,-1081\nl" + extraViniculum / 4.223 + " -" + extraViniculum + "c4,-6.7,10,-10,18,-10 H400000\nv" + (40 + extraViniculum) + "H1014.6\ns-87.3,378.7,-272.6,1166c-185.3,787.3,-279.3,1182.3,-282,1185\nc-2,6,-10,9,-24,9\nc-8,0,-12,-0.7,-12,-2z M" + (1001 + extraViniculum) + " " + hLinePad2 + "\nh400000v" + (40 + extraViniculum) + "h-400000z";
            };
            var sqrtSize4 = function sqrtSize42(extraViniculum, hLinePad2) {
              return "M473," + (2713 + extraViniculum + hLinePad2) + "\nc339.3,-1799.3,509.3,-2700,510,-2702 l" + extraViniculum / 5.298 + " -" + extraViniculum + "\nc3.3,-7.3,9.3,-11,18,-11 H400000v" + (40 + extraViniculum) + "H1017.7\ns-90.5,478,-276.2,1466c-185.7,988,-279.5,1483,-281.5,1485c-2,6,-10,9,-24,9\nc-8,0,-12,-0.7,-12,-2c0,-1.3,-5.3,-32,-16,-92c-50.7,-293.3,-119.7,-693.3,-207,-1200\nc0,-1.3,-5.3,8.7,-16,30c-10.7,21.3,-21.3,42.7,-32,64s-16,33,-16,33s-26,-26,-26,-26\ns76,-153,76,-153s77,-151,77,-151c0.7,0.7,35.7,202,105,604c67.3,400.7,102,602.7,104,\n606zM" + (1001 + extraViniculum) + " " + hLinePad2 + "h400000v" + (40 + extraViniculum) + "H1017.7z";
            };
            var sqrtTall = function sqrtTall2(extraViniculum, hLinePad2, viewBoxHeight) {
              var vertSegment = viewBoxHeight - 54 - hLinePad2 - extraViniculum;
              return "M702 " + (extraViniculum + hLinePad2) + "H400000" + (40 + extraViniculum) + "\nH742v" + vertSegment + "l-4 4-4 4c-.667.7 -2 1.5-4 2.5s-4.167 1.833-6.5 2.5-5.5 1-9.5 1\nh-12l-28-84c-16.667-52-96.667 -294.333-240-727l-212 -643 -85 170\nc-4-3.333-8.333-7.667-13 -13l-13-13l77-155 77-156c66 199.333 139 419.667\n219 661 l218 661zM702 " + hLinePad2 + "H400000v" + (40 + extraViniculum) + "H742z";
            };
            var sqrtPath = function sqrtPath2(size, extraViniculum, viewBoxHeight) {
              extraViniculum = 1e3 * extraViniculum;
              var path = "";
              switch (size) {
                case "sqrtMain":
                  path = sqrtMain(extraViniculum, hLinePad);
                  break;
                case "sqrtSize1":
                  path = sqrtSize1(extraViniculum, hLinePad);
                  break;
                case "sqrtSize2":
                  path = sqrtSize2(extraViniculum, hLinePad);
                  break;
                case "sqrtSize3":
                  path = sqrtSize3(extraViniculum, hLinePad);
                  break;
                case "sqrtSize4":
                  path = sqrtSize4(extraViniculum, hLinePad);
                  break;
                case "sqrtTall":
                  path = sqrtTall(extraViniculum, hLinePad, viewBoxHeight);
              }
              return path;
            };
            var svgGeometry_path = {
              // Two paths that cover gaps in built-up parentheses.
              leftParenInner: "M291 0 H417 V300 H291 z",
              rightParenInner: "M457 0 H583 V300 H457 z",
              // The doubleleftarrow geometry is from glyph U+21D0 in the font KaTeX Main
              doubleleftarrow: "M262 157\nl10-10c34-36 62.7-77 86-123 3.3-8 5-13.3 5-16 0-5.3-6.7-8-20-8-7.3\n 0-12.2.5-14.5 1.5-2.3 1-4.8 4.5-7.5 10.5-49.3 97.3-121.7 169.3-217 216-28\n 14-57.3 25-88 33-6.7 2-11 3.8-13 5.5-2 1.7-3 4.2-3 7.5s1 5.8 3 7.5\nc2 1.7 6.3 3.5 13 5.5 68 17.3 128.2 47.8 180.5 91.5 52.3 43.7 93.8 96.2 124.5\n 157.5 9.3 8 15.3 12.3 18 13h6c12-.7 18-4 18-10 0-2-1.7-7-5-15-23.3-46-52-87\n-86-123l-10-10h399738v-40H218c328 0 0 0 0 0l-10-8c-26.7-20-65.7-43-117-69 2.7\n-2 6-3.7 10-5 36.7-16 72.3-37.3 107-64l10-8h399782v-40z\nm8 0v40h399730v-40zm0 194v40h399730v-40z",
              // doublerightarrow is from glyph U+21D2 in font KaTeX Main
              doublerightarrow: "M399738 392l\n-10 10c-34 36-62.7 77-86 123-3.3 8-5 13.3-5 16 0 5.3 6.7 8 20 8 7.3 0 12.2-.5\n 14.5-1.5 2.3-1 4.8-4.5 7.5-10.5 49.3-97.3 121.7-169.3 217-216 28-14 57.3-25 88\n-33 6.7-2 11-3.8 13-5.5 2-1.7 3-4.2 3-7.5s-1-5.8-3-7.5c-2-1.7-6.3-3.5-13-5.5-68\n-17.3-128.2-47.8-180.5-91.5-52.3-43.7-93.8-96.2-124.5-157.5-9.3-8-15.3-12.3-18\n-13h-6c-12 .7-18 4-18 10 0 2 1.7 7 5 15 23.3 46 52 87 86 123l10 10H0v40h399782\nc-328 0 0 0 0 0l10 8c26.7 20 65.7 43 117 69-2.7 2-6 3.7-10 5-36.7 16-72.3 37.3\n-107 64l-10 8H0v40zM0 157v40h399730v-40zm0 194v40h399730v-40z",
              // leftarrow is from glyph U+2190 in font KaTeX Main
              leftarrow: "M400000 241H110l3-3c68.7-52.7 113.7-120\n 135-202 4-14.7 6-23 6-25 0-7.3-7-11-21-11-8 0-13.2.8-15.5 2.5-2.3 1.7-4.2 5.8\n-5.5 12.5-1.3 4.7-2.7 10.3-4 17-12 48.7-34.8 92-68.5 130S65.3 228.3 18 247\nc-10 4-16 7.7-18 11 0 8.7 6 14.3 18 17 47.3 18.7 87.8 47 121.5 85S196 441.3 208\n 490c.7 2 1.3 5 2 9s1.2 6.7 1.5 8c.3 1.3 1 3.3 2 6s2.2 4.5 3.5 5.5c1.3 1 3.3\n 1.8 6 2.5s6 1 10 1c14 0 21-3.7 21-11 0-2-2-10.3-6-25-20-79.3-65-146.7-135-202\n l-3-3h399890zM100 241v40h399900v-40z",
              // overbrace is from glyphs U+23A9/23A8/23A7 in font KaTeX_Size4-Regular
              leftbrace: "M6 548l-6-6v-35l6-11c56-104 135.3-181.3 238-232 57.3-28.7 117\n-45 179-50h399577v120H403c-43.3 7-81 15-113 26-100.7 33-179.7 91-237 174-2.7\n 5-6 9-10 13-.7 1-7.3 1-20 1H6z",
              leftbraceunder: "M0 6l6-6h17c12.688 0 19.313.3 20 1 4 4 7.313 8.3 10 13\n 35.313 51.3 80.813 93.8 136.5 127.5 55.688 33.7 117.188 55.8 184.5 66.5.688\n 0 2 .3 4 1 18.688 2.7 76 4.3 172 5h399450v120H429l-6-1c-124.688-8-235-61.7\n-331-161C60.687 138.7 32.312 99.3 7 54L0 41V6z",
              // overgroup is from the MnSymbol package (public domain)
              leftgroup: "M400000 80\nH435C64 80 168.3 229.4 21 260c-5.9 1.2-18 0-18 0-2 0-3-1-3-3v-38C76 61 257 0\n 435 0h399565z",
              leftgroupunder: "M400000 262\nH435C64 262 168.3 112.6 21 82c-5.9-1.2-18 0-18 0-2 0-3 1-3 3v38c76 158 257 219\n 435 219h399565z",
              // Harpoons are from glyph U+21BD in font KaTeX Main
              leftharpoon: "M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3\n-3.3 10.2-9.5 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5\n-18.3 3-21-1.3-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7\n-196 228-6.7 4.7-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40z",
              leftharpoonplus: "M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3-3.3 10.2-9.5\n 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5-18.3 3-21-1.3\n-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7-196 228-6.7 4.7\n-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40zM0 435v40h400000v-40z\nm0 0v40h400000v-40z",
              leftharpoondown: "M7 241c-4 4-6.333 8.667-7 14 0 5.333.667 9 2 11s5.333\n 5.333 12 10c90.667 54 156 130 196 228 3.333 10.667 6.333 16.333 9 17 2 .667 5\n 1 9 1h5c10.667 0 16.667-2 18-6 2-2.667 1-9.667-3-21-32-87.333-82.667-157.667\n-152-211l-3-3h399907v-40zM93 281 H400000 v-40L7 241z",
              leftharpoondownplus: "M7 435c-4 4-6.3 8.7-7 14 0 5.3.7 9 2 11s5.3 5.3 12\n 10c90.7 54 156 130 196 228 3.3 10.7 6.3 16.3 9 17 2 .7 5 1 9 1h5c10.7 0 16.7\n-2 18-6 2-2.7 1-9.7-3-21-32-87.3-82.7-157.7-152-211l-3-3h399907v-40H7zm93 0\nv40h399900v-40zM0 241v40h399900v-40zm0 0v40h399900v-40z",
              // hook is from glyph U+21A9 in font KaTeX Main
              lefthook: "M400000 281 H103s-33-11.2-61-33.5S0 197.3 0 164s14.2-61.2 42.5\n-83.5C70.8 58.2 104 47 142 47 c16.7 0 25 6.7 25 20 0 12-8.7 18.7-26 20-40 3.3\n-68.7 15.7-86 37-10 12-15 25.3-15 40 0 22.7 9.8 40.7 29.5 54 19.7 13.3 43.5 21\n 71.5 23h399859zM103 281v-40h399897v40z",
              leftlinesegment: "M40 281 V428 H0 V94 H40 V241 H400000 v40z\nM40 281 V428 H0 V94 H40 V241 H400000 v40z",
              leftmapsto: "M40 281 V448H0V74H40V241H400000v40z\nM40 281 V448H0V74H40V241H400000v40z",
              // tofrom is from glyph U+21C4 in font KaTeX AMS Regular
              leftToFrom: "M0 147h400000v40H0zm0 214c68 40 115.7 95.7 143 167h22c15.3 0 23\n-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69-70-101l-7-8h399905v-40H95l7-8\nc28.7-32 52-65.7 70-101 10.7-23.3 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 265.3\n 68 321 0 361zm0-174v-40h399900v40zm100 154v40h399900v-40z",
              longequal: "M0 50 h400000 v40H0z m0 194h40000v40H0z\nM0 50 h400000 v40H0z m0 194h40000v40H0z",
              midbrace: "M200428 334\nc-100.7-8.3-195.3-44-280-108-55.3-42-101.7-93-139-153l-9-14c-2.7 4-5.7 8.7-9 14\n-53.3 86.7-123.7 153-211 199-66.7 36-137.3 56.3-212 62H0V214h199568c178.3-11.7\n 311.7-78.3 403-201 6-8 9.7-12 11-12 .7-.7 6.7-1 18-1s17.3.3 18 1c1.3 0 5 4 11\n 12 44.7 59.3 101.3 106.3 170 141s145.3 54.3 229 60h199572v120z",
              midbraceunder: "M199572 214\nc100.7 8.3 195.3 44 280 108 55.3 42 101.7 93 139 153l9 14c2.7-4 5.7-8.7 9-14\n 53.3-86.7 123.7-153 211-199 66.7-36 137.3-56.3 212-62h199568v120H200432c-178.3\n 11.7-311.7 78.3-403 201-6 8-9.7 12-11 12-.7.7-6.7 1-18 1s-17.3-.3-18-1c-1.3 0\n-5-4-11-12-44.7-59.3-101.3-106.3-170-141s-145.3-54.3-229-60H0V214z",
              oiintSize1: "M512.6 71.6c272.6 0 320.3 106.8 320.3 178.2 0 70.8-47.7 177.6\n-320.3 177.6S193.1 320.6 193.1 249.8c0-71.4 46.9-178.2 319.5-178.2z\nm368.1 178.2c0-86.4-60.9-215.4-368.1-215.4-306.4 0-367.3 129-367.3 215.4 0 85.8\n60.9 214.8 367.3 214.8 307.2 0 368.1-129 368.1-214.8z",
              oiintSize2: "M757.8 100.1c384.7 0 451.1 137.6 451.1 230 0 91.3-66.4 228.8\n-451.1 228.8-386.3 0-452.7-137.5-452.7-228.8 0-92.4 66.4-230 452.7-230z\nm502.4 230c0-111.2-82.4-277.2-502.4-277.2s-504 166-504 277.2\nc0 110 84 276 504 276s502.4-166 502.4-276z",
              oiiintSize1: "M681.4 71.6c408.9 0 480.5 106.8 480.5 178.2 0 70.8-71.6 177.6\n-480.5 177.6S202.1 320.6 202.1 249.8c0-71.4 70.5-178.2 479.3-178.2z\nm525.8 178.2c0-86.4-86.8-215.4-525.7-215.4-437.9 0-524.7 129-524.7 215.4 0\n85.8 86.8 214.8 524.7 214.8 438.9 0 525.7-129 525.7-214.8z",
              oiiintSize2: "M1021.2 53c603.6 0 707.8 165.8 707.8 277.2 0 110-104.2 275.8\n-707.8 275.8-606 0-710.2-165.8-710.2-275.8C311 218.8 415.2 53 1021.2 53z\nm770.4 277.1c0-131.2-126.4-327.6-770.5-327.6S248.4 198.9 248.4 330.1\nc0 130 128.8 326.4 772.7 326.4s770.5-196.4 770.5-326.4z",
              rightarrow: "M0 241v40h399891c-47.3 35.3-84 78-110 128\n-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20\n 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7\n 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85\n-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5\n-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67\n 151.7 139 205zm0 0v40h399900v-40z",
              rightbrace: "M400000 542l\n-6 6h-17c-12.7 0-19.3-.3-20-1-4-4-7.3-8.3-10-13-35.3-51.3-80.8-93.8-136.5-127.5\ns-117.2-55.8-184.5-66.5c-.7 0-2-.3-4-1-18.7-2.7-76-4.3-172-5H0V214h399571l6 1\nc124.7 8 235 61.7 331 161 31.3 33.3 59.7 72.7 85 118l7 13v35z",
              rightbraceunder: "M399994 0l6 6v35l-6 11c-56 104-135.3 181.3-238 232-57.3\n 28.7-117 45-179 50H-300V214h399897c43.3-7 81-15 113-26 100.7-33 179.7-91 237\n-174 2.7-5 6-9 10-13 .7-1 7.3-1 20-1h17z",
              rightgroup: "M0 80h399565c371 0 266.7 149.4 414 180 5.9 1.2 18 0 18 0 2 0\n 3-1 3-3v-38c-76-158-257-219-435-219H0z",
              rightgroupunder: "M0 262h399565c371 0 266.7-149.4 414-180 5.9-1.2 18 0 18\n 0 2 0 3 1 3 3v38c-76 158-257 219-435 219H0z",
              rightharpoon: "M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3\n-3.7-15.3-11-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2\n-10.7 0-16.7 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58\n 69.2 92 94.5zm0 0v40h399900v-40z",
              rightharpoonplus: "M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3-3.7-15.3-11\n-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2-10.7 0-16.7\n 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58 69.2 92 94.5z\nm0 0v40h399900v-40z m100 194v40h399900v-40zm0 0v40h399900v-40z",
              rightharpoondown: "M399747 511c0 7.3 6.7 11 20 11 8 0 13-.8 15-2.5s4.7-6.8\n 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3 8.5-5.8 9.5\n-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3-64.7 57-92 95\n-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 241v40h399900v-40z",
              rightharpoondownplus: "M399747 705c0 7.3 6.7 11 20 11 8 0 13-.8\n 15-2.5s4.7-6.8 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3\n 8.5-5.8 9.5-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3\n-64.7 57-92 95-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 435v40h399900v-40z\nm0-194v40h400000v-40zm0 0v40h400000v-40z",
              righthook: "M399859 241c-764 0 0 0 0 0 40-3.3 68.7-15.7 86-37 10-12 15-25.3\n 15-40 0-22.7-9.8-40.7-29.5-54-19.7-13.3-43.5-21-71.5-23-17.3-1.3-26-8-26-20 0\n-13.3 8.7-20 26-20 38 0 71 11.2 99 33.5 0 0 7 5.6 21 16.7 14 11.2 21 33.5 21\n 66.8s-14 61.2-42 83.5c-28 22.3-61 33.5-99 33.5L0 241z M0 281v-40h399859v40z",
              rightlinesegment: "M399960 241 V94 h40 V428 h-40 V281 H0 v-40z\nM399960 241 V94 h40 V428 h-40 V281 H0 v-40z",
              rightToFrom: "M400000 167c-70.7-42-118-97.7-142-167h-23c-15.3 0-23 .3-23\n 1 0 1.3 5.3 13.7 16 37 18 35.3 41.3 69 70 101l7 8H0v40h399905l-7 8c-28.7 32\n-52 65.7-70 101-10.7 23.3-16 35.7-16 37 0 .7 7.7 1 23 1h23c24-69.3 71.3-125 142\n-167z M100 147v40h399900v-40zM0 341v40h399900v-40z",
              // twoheadleftarrow is from glyph U+219E in font KaTeX AMS Regular
              twoheadleftarrow: "M0 167c68 40\n 115.7 95.7 143 167h22c15.3 0 23-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69\n-70-101l-7-8h125l9 7c50.7 39.3 85 86 103 140h46c0-4.7-6.3-18.7-19-42-18-35.3\n-40-67.3-66-96l-9-9h399716v-40H284l9-9c26-28.7 48-60.7 66-96 12.7-23.333 19\n-37.333 19-42h-46c-18 54-52.3 100.7-103 140l-9 7H95l7-8c28.7-32 52-65.7 70-101\n 10.7-23.333 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 71.3 68 127 0 167z",
              twoheadrightarrow: "M400000 167\nc-68-40-115.7-95.7-143-167h-22c-15.3 0-23 .3-23 1 0 1.3 5.3 13.7 16 37 18 35.3\n 41.3 69 70 101l7 8h-125l-9-7c-50.7-39.3-85-86-103-140h-46c0 4.7 6.3 18.7 19 42\n 18 35.3 40 67.3 66 96l9 9H0v40h399716l-9 9c-26 28.7-48 60.7-66 96-12.7 23.333\n-19 37.333-19 42h46c18-54 52.3-100.7 103-140l9-7h125l-7 8c-28.7 32-52 65.7-70\n 101-10.7 23.333-16 35.7-16 37 0 .7 7.7 1 23 1h22c27.3-71.3 75-127 143-167z",
              // tilde1 is a modified version of a glyph from the MnSymbol package
              tilde1: "M200 55.538c-77 0-168 73.953-177 73.953-3 0-7\n-2.175-9-5.437L2 97c-1-2-2-4-2-6 0-4 2-7 5-9l20-12C116 12 171 0 207 0c86 0\n 114 68 191 68 78 0 168-68 177-68 4 0 7 2 9 5l12 19c1 2.175 2 4.35 2 6.525 0\n 4.35-2 7.613-5 9.788l-19 13.05c-92 63.077-116.937 75.308-183 76.128\n-68.267.847-113-73.952-191-73.952z",
              // ditto tilde2, tilde3, & tilde4
              tilde2: "M344 55.266c-142 0-300.638 81.316-311.5 86.418\n-8.01 3.762-22.5 10.91-23.5 5.562L1 120c-1-2-1-3-1-4 0-5 3-9 8-10l18.4-9C160.9\n 31.9 283 0 358 0c148 0 188 122 331 122s314-97 326-97c4 0 8 2 10 7l7 21.114\nc1 2.14 1 3.21 1 4.28 0 5.347-3 9.626-7 10.696l-22.3 12.622C852.6 158.372 751\n 181.476 676 181.476c-149 0-189-126.21-332-126.21z",
              tilde3: "M786 59C457 59 32 175.242 13 175.242c-6 0-10-3.457\n-11-10.37L.15 138c-1-7 3-12 10-13l19.2-6.4C378.4 40.7 634.3 0 804.3 0c337 0\n 411.8 157 746.8 157 328 0 754-112 773-112 5 0 10 3 11 9l1 14.075c1 8.066-.697\n 16.595-6.697 17.492l-21.052 7.31c-367.9 98.146-609.15 122.696-778.15 122.696\n -338 0-409-156.573-744-156.573z",
              tilde4: "M786 58C457 58 32 177.487 13 177.487c-6 0-10-3.345\n-11-10.035L.15 143c-1-7 3-12 10-13l22-6.7C381.2 35 637.15 0 807.15 0c337 0 409\n 177 744 177 328 0 754-127 773-127 5 0 10 3 11 9l1 14.794c1 7.805-3 13.38-9\n 14.495l-20.7 5.574c-366.85 99.79-607.3 139.372-776.3 139.372-338 0-409\n -175.236-744-175.236z",
              // vec is from glyph U+20D7 in font KaTeX Main
              vec: "M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5\n3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11\n10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63\n-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1\n-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59\nH213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359\nc-16-25.333-24-45-24-59z",
              // widehat1 is a modified version of a glyph from the MnSymbol package
              widehat1: "M529 0h5l519 115c5 1 9 5 9 10 0 1-1 2-1 3l-4 22\nc-1 5-5 9-11 9h-2L532 67 19 159h-2c-5 0-9-4-11-9l-5-22c-1-6 2-12 8-13z",
              // ditto widehat2, widehat3, & widehat4
              widehat2: "M1181 0h2l1171 176c6 0 10 5 10 11l-2 23c-1 6-5 10\n-11 10h-1L1182 67 15 220h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z",
              widehat3: "M1181 0h2l1171 236c6 0 10 5 10 11l-2 23c-1 6-5 10\n-11 10h-1L1182 67 15 280h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z",
              widehat4: "M1181 0h2l1171 296c6 0 10 5 10 11l-2 23c-1 6-5 10\n-11 10h-1L1182 67 15 340h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z",
              // widecheck paths are all inverted versions of widehat
              widecheck1: "M529,159h5l519,-115c5,-1,9,-5,9,-10c0,-1,-1,-2,-1,-3l-4,-22c-1,\n-5,-5,-9,-11,-9h-2l-512,92l-513,-92h-2c-5,0,-9,4,-11,9l-5,22c-1,6,2,12,8,13z",
              widecheck2: "M1181,220h2l1171,-176c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,\n-11,-10h-1l-1168,153l-1167,-153h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z",
              widecheck3: "M1181,280h2l1171,-236c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,\n-11,-10h-1l-1168,213l-1167,-213h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z",
              widecheck4: "M1181,340h2l1171,-296c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,\n-11,-10h-1l-1168,273l-1167,-273h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z",
              // The next ten paths support reaction arrows from the mhchem package.
              // Arrows for \ce{<-->} are offset from xAxis by 0.22ex, per mhchem in LaTeX
              // baraboveleftarrow is mostly from from glyph U+2190 in font KaTeX Main
              baraboveleftarrow: "M400000 620h-399890l3 -3c68.7 -52.7 113.7 -120 135 -202\nc4 -14.7 6 -23 6 -25c0 -7.3 -7 -11 -21 -11c-8 0 -13.2 0.8 -15.5 2.5\nc-2.3 1.7 -4.2 5.8 -5.5 12.5c-1.3 4.7 -2.7 10.3 -4 17c-12 48.7 -34.8 92 -68.5 130\ns-74.2 66.3 -121.5 85c-10 4 -16 7.7 -18 11c0 8.7 6 14.3 18 17c47.3 18.7 87.8 47\n121.5 85s56.5 81.3 68.5 130c0.7 2 1.3 5 2 9s1.2 6.7 1.5 8c0.3 1.3 1 3.3 2 6\ns2.2 4.5 3.5 5.5c1.3 1 3.3 1.8 6 2.5s6 1 10 1c14 0 21 -3.7 21 -11\nc0 -2 -2 -10.3 -6 -25c-20 -79.3 -65 -146.7 -135 -202l-3 -3h399890z\nM100 620v40h399900v-40z M0 241v40h399900v-40zM0 241v40h399900v-40z",
              // rightarrowabovebar is mostly from glyph U+2192, KaTeX Main
              rightarrowabovebar: "M0 241v40h399891c-47.3 35.3-84 78-110 128-16.7 32\n-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20 11 8 0\n13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7 39\n-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85-40.5\n-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5\n-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67\n151.7 139 205zm96 379h399894v40H0zm0 0h399904v40H0z",
              // The short left harpoon has 0.5em (i.e. 500 units) kern on the left end.
              // Ref from mhchem.sty: \rlap{\raisebox{-.22ex}{$\kern0.5em
              baraboveshortleftharpoon: "M507,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11\nc1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17\nc2,0.7,5,1,9,1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21\nc-32,-87.3,-82.7,-157.7,-152,-211c0,0,-3,-3,-3,-3l399351,0l0,-40\nc-398570,0,-399437,0,-399437,0z M593 435 v40 H399500 v-40z\nM0 281 v-40 H399908 v40z M0 281 v-40 H399908 v40z",
              rightharpoonaboveshortbar: "M0,241 l0,40c399126,0,399993,0,399993,0\nc4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,\n-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6\nc-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z\nM0 241 v40 H399908 v-40z M0 475 v-40 H399500 v40z M0 475 v-40 H399500 v40z",
              shortbaraboveleftharpoon: "M7,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11\nc1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17c2,0.7,5,1,9,\n1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21c-32,-87.3,-82.7,-157.7,\n-152,-211c0,0,-3,-3,-3,-3l399907,0l0,-40c-399126,0,-399993,0,-399993,0z\nM93 435 v40 H400000 v-40z M500 241 v40 H400000 v-40z M500 241 v40 H400000 v-40z",
              shortrightharpoonabovebar: "M53,241l0,40c398570,0,399437,0,399437,0\nc4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,\n-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6\nc-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z\nM500 241 v40 H399408 v-40z M500 435 v40 H400000 v-40z"
            };
            var tree_DocumentFragment = function() {
              function DocumentFragment(children2) {
                this.children = void 0;
                this.classes = void 0;
                this.height = void 0;
                this.depth = void 0;
                this.maxFontSize = void 0;
                this.style = void 0;
                this.children = children2;
                this.classes = [];
                this.height = 0;
                this.depth = 0;
                this.maxFontSize = 0;
                this.style = {};
              }
              var _proto = DocumentFragment.prototype;
              _proto.hasClass = function hasClass2(className) {
                return utils.contains(this.classes, className);
              };
              _proto.toNode = function toNode() {
                var frag = document.createDocumentFragment();
                for (var i = 0; i < this.children.length; i++) {
                  frag.appendChild(this.children[i].toNode());
                }
                return frag;
              };
              _proto.toMarkup = function toMarkup() {
                var markup = "";
                for (var i = 0; i < this.children.length; i++) {
                  markup += this.children[i].toMarkup();
                }
                return markup;
              };
              _proto.toText = function toText() {
                var toText2 = function toText3(child) {
                  return child.toText();
                };
                return this.children.map(toText2).join("");
              };
              return DocumentFragment;
            }();
            var createClass = function createClass2(classes) {
              return classes.filter(function(cls) {
                return cls;
              }).join(" ");
            };
            var initNode = function initNode2(classes, options, style) {
              this.classes = classes || [];
              this.attributes = {};
              this.height = 0;
              this.depth = 0;
              this.maxFontSize = 0;
              this.style = style || {};
              if (options) {
                if (options.style.isTight()) {
                  this.classes.push("mtight");
                }
                var color = options.getColor();
                if (color) {
                  this.style.color = color;
                }
              }
            };
            var _toNode = function toNode(tagName) {
              var node = document.createElement(tagName);
              node.className = createClass(this.classes);
              for (var style in this.style) {
                if (this.style.hasOwnProperty(style)) {
                  node.style[style] = this.style[style];
                }
              }
              for (var attr2 in this.attributes) {
                if (this.attributes.hasOwnProperty(attr2)) {
                  node.setAttribute(attr2, this.attributes[attr2]);
                }
              }
              for (var i = 0; i < this.children.length; i++) {
                node.appendChild(this.children[i].toNode());
              }
              return node;
            };
            var _toMarkup = function toMarkup(tagName) {
              var markup = "<" + tagName;
              if (this.classes.length) {
                markup += ' class="' + utils.escape(createClass(this.classes)) + '"';
              }
              var styles2 = "";
              for (var style in this.style) {
                if (this.style.hasOwnProperty(style)) {
                  styles2 += utils.hyphenate(style) + ":" + this.style[style] + ";";
                }
              }
              if (styles2) {
                markup += ' style="' + utils.escape(styles2) + '"';
              }
              for (var attr2 in this.attributes) {
                if (this.attributes.hasOwnProperty(attr2)) {
                  markup += " " + attr2 + '="' + utils.escape(this.attributes[attr2]) + '"';
                }
              }
              markup += ">";
              for (var i = 0; i < this.children.length; i++) {
                markup += this.children[i].toMarkup();
              }
              markup += "</" + tagName + ">";
              return markup;
            };
            var domTree_Span = function() {
              function Span(classes, children2, options, style) {
                this.children = void 0;
                this.attributes = void 0;
                this.classes = void 0;
                this.height = void 0;
                this.depth = void 0;
                this.width = void 0;
                this.maxFontSize = void 0;
                this.style = void 0;
                initNode.call(this, classes, options, style);
                this.children = children2 || [];
              }
              var _proto = Span.prototype;
              _proto.setAttribute = function setAttribute(attribute2, value) {
                this.attributes[attribute2] = value;
              };
              _proto.hasClass = function hasClass2(className) {
                return utils.contains(this.classes, className);
              };
              _proto.toNode = function toNode() {
                return _toNode.call(this, "span");
              };
              _proto.toMarkup = function toMarkup() {
                return _toMarkup.call(this, "span");
              };
              return Span;
            }();
            var domTree_Anchor = function() {
              function Anchor(href, classes, children2, options) {
                this.children = void 0;
                this.attributes = void 0;
                this.classes = void 0;
                this.height = void 0;
                this.depth = void 0;
                this.maxFontSize = void 0;
                this.style = void 0;
                initNode.call(this, classes, options);
                this.children = children2 || [];
                this.setAttribute("href", href);
              }
              var _proto2 = Anchor.prototype;
              _proto2.setAttribute = function setAttribute(attribute2, value) {
                this.attributes[attribute2] = value;
              };
              _proto2.hasClass = function hasClass2(className) {
                return utils.contains(this.classes, className);
              };
              _proto2.toNode = function toNode() {
                return _toNode.call(this, "a");
              };
              _proto2.toMarkup = function toMarkup() {
                return _toMarkup.call(this, "a");
              };
              return Anchor;
            }();
            var domTree_Img = function() {
              function Img(src, alt, style) {
                this.src = void 0;
                this.alt = void 0;
                this.classes = void 0;
                this.height = void 0;
                this.depth = void 0;
                this.maxFontSize = void 0;
                this.style = void 0;
                this.alt = alt;
                this.src = src;
                this.classes = ["mord"];
                this.style = style;
              }
              var _proto3 = Img.prototype;
              _proto3.hasClass = function hasClass2(className) {
                return utils.contains(this.classes, className);
              };
              _proto3.toNode = function toNode() {
                var node = document.createElement("img");
                node.src = this.src;
                node.alt = this.alt;
                node.className = "mord";
                for (var style in this.style) {
                  if (this.style.hasOwnProperty(style)) {
                    node.style[style] = this.style[style];
                  }
                }
                return node;
              };
              _proto3.toMarkup = function toMarkup() {
                var markup = "<img  src='" + this.src + " 'alt='" + this.alt + "' ";
                var styles2 = "";
                for (var style in this.style) {
                  if (this.style.hasOwnProperty(style)) {
                    styles2 += utils.hyphenate(style) + ":" + this.style[style] + ";";
                  }
                }
                if (styles2) {
                  markup += ' style="' + utils.escape(styles2) + '"';
                }
                markup += "'/>";
                return markup;
              };
              return Img;
            }();
            var iCombinations = {
              "î": "ı̂",
              "ï": "ı̈",
              "í": "ı́",
              // 'ī': '\u0131\u0304', // enable when we add Extended Latin
              "ì": "ı̀"
            };
            var domTree_SymbolNode = function() {
              function SymbolNode(text4, height, depth, italic, skew2, width, classes, style) {
                this.text = void 0;
                this.height = void 0;
                this.depth = void 0;
                this.italic = void 0;
                this.skew = void 0;
                this.width = void 0;
                this.maxFontSize = void 0;
                this.classes = void 0;
                this.style = void 0;
                this.text = text4;
                this.height = height || 0;
                this.depth = depth || 0;
                this.italic = italic || 0;
                this.skew = skew2 || 0;
                this.width = width || 0;
                this.classes = classes || [];
                this.style = style || {};
                this.maxFontSize = 0;
                var script = scriptFromCodepoint(this.text.charCodeAt(0));
                if (script) {
                  this.classes.push(script + "_fallback");
                }
                if (/[îïíì]/.test(this.text)) {
                  this.text = iCombinations[this.text];
                }
              }
              var _proto4 = SymbolNode.prototype;
              _proto4.hasClass = function hasClass2(className) {
                return utils.contains(this.classes, className);
              };
              _proto4.toNode = function toNode() {
                var node = document.createTextNode(this.text);
                var span = null;
                if (this.italic > 0) {
                  span = document.createElement("span");
                  span.style.marginRight = this.italic + "em";
                }
                if (this.classes.length > 0) {
                  span = span || document.createElement("span");
                  span.className = createClass(this.classes);
                }
                for (var style in this.style) {
                  if (this.style.hasOwnProperty(style)) {
                    span = span || document.createElement("span");
                    span.style[style] = this.style[style];
                  }
                }
                if (span) {
                  span.appendChild(node);
                  return span;
                } else {
                  return node;
                }
              };
              _proto4.toMarkup = function toMarkup() {
                var needsSpan = false;
                var markup = "<span";
                if (this.classes.length) {
                  needsSpan = true;
                  markup += ' class="';
                  markup += utils.escape(createClass(this.classes));
                  markup += '"';
                }
                var styles2 = "";
                if (this.italic > 0) {
                  styles2 += "margin-right:" + this.italic + "em;";
                }
                for (var style in this.style) {
                  if (this.style.hasOwnProperty(style)) {
                    styles2 += utils.hyphenate(style) + ":" + this.style[style] + ";";
                  }
                }
                if (styles2) {
                  needsSpan = true;
                  markup += ' style="' + utils.escape(styles2) + '"';
                }
                var escaped = utils.escape(this.text);
                if (needsSpan) {
                  markup += ">";
                  markup += escaped;
                  markup += "</span>";
                  return markup;
                } else {
                  return escaped;
                }
              };
              return SymbolNode;
            }();
            var SvgNode = function() {
              function SvgNode2(children2, attributes2) {
                this.children = void 0;
                this.attributes = void 0;
                this.children = children2 || [];
                this.attributes = attributes2 || {};
              }
              var _proto5 = SvgNode2.prototype;
              _proto5.toNode = function toNode() {
                var svgNS = "http://www.w3.org/2000/svg";
                var node = document.createElementNS(svgNS, "svg");
                for (var attr2 in this.attributes) {
                  if (Object.prototype.hasOwnProperty.call(this.attributes, attr2)) {
                    node.setAttribute(attr2, this.attributes[attr2]);
                  }
                }
                for (var i = 0; i < this.children.length; i++) {
                  node.appendChild(this.children[i].toNode());
                }
                return node;
              };
              _proto5.toMarkup = function toMarkup() {
                var markup = "<svg";
                for (var attr2 in this.attributes) {
                  if (Object.prototype.hasOwnProperty.call(this.attributes, attr2)) {
                    markup += " " + attr2 + "='" + this.attributes[attr2] + "'";
                  }
                }
                markup += ">";
                for (var i = 0; i < this.children.length; i++) {
                  markup += this.children[i].toMarkup();
                }
                markup += "</svg>";
                return markup;
              };
              return SvgNode2;
            }();
            var domTree_PathNode = function() {
              function PathNode(pathName, alternate) {
                this.pathName = void 0;
                this.alternate = void 0;
                this.pathName = pathName;
                this.alternate = alternate;
              }
              var _proto6 = PathNode.prototype;
              _proto6.toNode = function toNode() {
                var svgNS = "http://www.w3.org/2000/svg";
                var node = document.createElementNS(svgNS, "path");
                if (this.alternate) {
                  node.setAttribute("d", this.alternate);
                } else {
                  node.setAttribute("d", svgGeometry_path[this.pathName]);
                }
                return node;
              };
              _proto6.toMarkup = function toMarkup() {
                if (this.alternate) {
                  return "<path d='" + this.alternate + "'/>";
                } else {
                  return "<path d='" + svgGeometry_path[this.pathName] + "'/>";
                }
              };
              return PathNode;
            }();
            var LineNode = function() {
              function LineNode2(attributes2) {
                this.attributes = void 0;
                this.attributes = attributes2 || {};
              }
              var _proto7 = LineNode2.prototype;
              _proto7.toNode = function toNode() {
                var svgNS = "http://www.w3.org/2000/svg";
                var node = document.createElementNS(svgNS, "line");
                for (var attr2 in this.attributes) {
                  if (Object.prototype.hasOwnProperty.call(this.attributes, attr2)) {
                    node.setAttribute(attr2, this.attributes[attr2]);
                  }
                }
                return node;
              };
              _proto7.toMarkup = function toMarkup() {
                var markup = "<line";
                for (var attr2 in this.attributes) {
                  if (Object.prototype.hasOwnProperty.call(this.attributes, attr2)) {
                    markup += " " + attr2 + "='" + this.attributes[attr2] + "'";
                  }
                }
                markup += "/>";
                return markup;
              };
              return LineNode2;
            }();
            function assertSymbolDomNode(group) {
              if (group instanceof domTree_SymbolNode) {
                return group;
              } else {
                throw new Error("Expected symbolNode but got " + String(group) + ".");
              }
            }
            function assertSpan(group) {
              if (group instanceof domTree_Span) {
                return group;
              } else {
                throw new Error("Expected span<HtmlDomNode> but got " + String(group) + ".");
              }
            }
            var fontMetricsData = {
              "AMS-Regular": {
                "32": [0, 0, 0, 0, 0.25],
                "65": [0, 0.68889, 0, 0, 0.72222],
                "66": [0, 0.68889, 0, 0, 0.66667],
                "67": [0, 0.68889, 0, 0, 0.72222],
                "68": [0, 0.68889, 0, 0, 0.72222],
                "69": [0, 0.68889, 0, 0, 0.66667],
                "70": [0, 0.68889, 0, 0, 0.61111],
                "71": [0, 0.68889, 0, 0, 0.77778],
                "72": [0, 0.68889, 0, 0, 0.77778],
                "73": [0, 0.68889, 0, 0, 0.38889],
                "74": [0.16667, 0.68889, 0, 0, 0.5],
                "75": [0, 0.68889, 0, 0, 0.77778],
                "76": [0, 0.68889, 0, 0, 0.66667],
                "77": [0, 0.68889, 0, 0, 0.94445],
                "78": [0, 0.68889, 0, 0, 0.72222],
                "79": [0.16667, 0.68889, 0, 0, 0.77778],
                "80": [0, 0.68889, 0, 0, 0.61111],
                "81": [0.16667, 0.68889, 0, 0, 0.77778],
                "82": [0, 0.68889, 0, 0, 0.72222],
                "83": [0, 0.68889, 0, 0, 0.55556],
                "84": [0, 0.68889, 0, 0, 0.66667],
                "85": [0, 0.68889, 0, 0, 0.72222],
                "86": [0, 0.68889, 0, 0, 0.72222],
                "87": [0, 0.68889, 0, 0, 1],
                "88": [0, 0.68889, 0, 0, 0.72222],
                "89": [0, 0.68889, 0, 0, 0.72222],
                "90": [0, 0.68889, 0, 0, 0.66667],
                "107": [0, 0.68889, 0, 0, 0.55556],
                "160": [0, 0, 0, 0, 0.25],
                "165": [0, 0.675, 0.025, 0, 0.75],
                "174": [0.15559, 0.69224, 0, 0, 0.94666],
                "240": [0, 0.68889, 0, 0, 0.55556],
                "295": [0, 0.68889, 0, 0, 0.54028],
                "710": [0, 0.825, 0, 0, 2.33334],
                "732": [0, 0.9, 0, 0, 2.33334],
                "770": [0, 0.825, 0, 0, 2.33334],
                "771": [0, 0.9, 0, 0, 2.33334],
                "989": [0.08167, 0.58167, 0, 0, 0.77778],
                "1008": [0, 0.43056, 0.04028, 0, 0.66667],
                "8245": [0, 0.54986, 0, 0, 0.275],
                "8463": [0, 0.68889, 0, 0, 0.54028],
                "8487": [0, 0.68889, 0, 0, 0.72222],
                "8498": [0, 0.68889, 0, 0, 0.55556],
                "8502": [0, 0.68889, 0, 0, 0.66667],
                "8503": [0, 0.68889, 0, 0, 0.44445],
                "8504": [0, 0.68889, 0, 0, 0.66667],
                "8513": [0, 0.68889, 0, 0, 0.63889],
                "8592": [-0.03598, 0.46402, 0, 0, 0.5],
                "8594": [-0.03598, 0.46402, 0, 0, 0.5],
                "8602": [-0.13313, 0.36687, 0, 0, 1],
                "8603": [-0.13313, 0.36687, 0, 0, 1],
                "8606": [0.01354, 0.52239, 0, 0, 1],
                "8608": [0.01354, 0.52239, 0, 0, 1],
                "8610": [0.01354, 0.52239, 0, 0, 1.11111],
                "8611": [0.01354, 0.52239, 0, 0, 1.11111],
                "8619": [0, 0.54986, 0, 0, 1],
                "8620": [0, 0.54986, 0, 0, 1],
                "8621": [-0.13313, 0.37788, 0, 0, 1.38889],
                "8622": [-0.13313, 0.36687, 0, 0, 1],
                "8624": [0, 0.69224, 0, 0, 0.5],
                "8625": [0, 0.69224, 0, 0, 0.5],
                "8630": [0, 0.43056, 0, 0, 1],
                "8631": [0, 0.43056, 0, 0, 1],
                "8634": [0.08198, 0.58198, 0, 0, 0.77778],
                "8635": [0.08198, 0.58198, 0, 0, 0.77778],
                "8638": [0.19444, 0.69224, 0, 0, 0.41667],
                "8639": [0.19444, 0.69224, 0, 0, 0.41667],
                "8642": [0.19444, 0.69224, 0, 0, 0.41667],
                "8643": [0.19444, 0.69224, 0, 0, 0.41667],
                "8644": [0.1808, 0.675, 0, 0, 1],
                "8646": [0.1808, 0.675, 0, 0, 1],
                "8647": [0.1808, 0.675, 0, 0, 1],
                "8648": [0.19444, 0.69224, 0, 0, 0.83334],
                "8649": [0.1808, 0.675, 0, 0, 1],
                "8650": [0.19444, 0.69224, 0, 0, 0.83334],
                "8651": [0.01354, 0.52239, 0, 0, 1],
                "8652": [0.01354, 0.52239, 0, 0, 1],
                "8653": [-0.13313, 0.36687, 0, 0, 1],
                "8654": [-0.13313, 0.36687, 0, 0, 1],
                "8655": [-0.13313, 0.36687, 0, 0, 1],
                "8666": [0.13667, 0.63667, 0, 0, 1],
                "8667": [0.13667, 0.63667, 0, 0, 1],
                "8669": [-0.13313, 0.37788, 0, 0, 1],
                "8672": [-0.064, 0.437, 0, 0, 1.334],
                "8674": [-0.064, 0.437, 0, 0, 1.334],
                "8705": [0, 0.825, 0, 0, 0.5],
                "8708": [0, 0.68889, 0, 0, 0.55556],
                "8709": [0.08167, 0.58167, 0, 0, 0.77778],
                "8717": [0, 0.43056, 0, 0, 0.42917],
                "8722": [-0.03598, 0.46402, 0, 0, 0.5],
                "8724": [0.08198, 0.69224, 0, 0, 0.77778],
                "8726": [0.08167, 0.58167, 0, 0, 0.77778],
                "8733": [0, 0.69224, 0, 0, 0.77778],
                "8736": [0, 0.69224, 0, 0, 0.72222],
                "8737": [0, 0.69224, 0, 0, 0.72222],
                "8738": [0.03517, 0.52239, 0, 0, 0.72222],
                "8739": [0.08167, 0.58167, 0, 0, 0.22222],
                "8740": [0.25142, 0.74111, 0, 0, 0.27778],
                "8741": [0.08167, 0.58167, 0, 0, 0.38889],
                "8742": [0.25142, 0.74111, 0, 0, 0.5],
                "8756": [0, 0.69224, 0, 0, 0.66667],
                "8757": [0, 0.69224, 0, 0, 0.66667],
                "8764": [-0.13313, 0.36687, 0, 0, 0.77778],
                "8765": [-0.13313, 0.37788, 0, 0, 0.77778],
                "8769": [-0.13313, 0.36687, 0, 0, 0.77778],
                "8770": [-0.03625, 0.46375, 0, 0, 0.77778],
                "8774": [0.30274, 0.79383, 0, 0, 0.77778],
                "8776": [-0.01688, 0.48312, 0, 0, 0.77778],
                "8778": [0.08167, 0.58167, 0, 0, 0.77778],
                "8782": [0.06062, 0.54986, 0, 0, 0.77778],
                "8783": [0.06062, 0.54986, 0, 0, 0.77778],
                "8785": [0.08198, 0.58198, 0, 0, 0.77778],
                "8786": [0.08198, 0.58198, 0, 0, 0.77778],
                "8787": [0.08198, 0.58198, 0, 0, 0.77778],
                "8790": [0, 0.69224, 0, 0, 0.77778],
                "8791": [0.22958, 0.72958, 0, 0, 0.77778],
                "8796": [0.08198, 0.91667, 0, 0, 0.77778],
                "8806": [0.25583, 0.75583, 0, 0, 0.77778],
                "8807": [0.25583, 0.75583, 0, 0, 0.77778],
                "8808": [0.25142, 0.75726, 0, 0, 0.77778],
                "8809": [0.25142, 0.75726, 0, 0, 0.77778],
                "8812": [0.25583, 0.75583, 0, 0, 0.5],
                "8814": [0.20576, 0.70576, 0, 0, 0.77778],
                "8815": [0.20576, 0.70576, 0, 0, 0.77778],
                "8816": [0.30274, 0.79383, 0, 0, 0.77778],
                "8817": [0.30274, 0.79383, 0, 0, 0.77778],
                "8818": [0.22958, 0.72958, 0, 0, 0.77778],
                "8819": [0.22958, 0.72958, 0, 0, 0.77778],
                "8822": [0.1808, 0.675, 0, 0, 0.77778],
                "8823": [0.1808, 0.675, 0, 0, 0.77778],
                "8828": [0.13667, 0.63667, 0, 0, 0.77778],
                "8829": [0.13667, 0.63667, 0, 0, 0.77778],
                "8830": [0.22958, 0.72958, 0, 0, 0.77778],
                "8831": [0.22958, 0.72958, 0, 0, 0.77778],
                "8832": [0.20576, 0.70576, 0, 0, 0.77778],
                "8833": [0.20576, 0.70576, 0, 0, 0.77778],
                "8840": [0.30274, 0.79383, 0, 0, 0.77778],
                "8841": [0.30274, 0.79383, 0, 0, 0.77778],
                "8842": [0.13597, 0.63597, 0, 0, 0.77778],
                "8843": [0.13597, 0.63597, 0, 0, 0.77778],
                "8847": [0.03517, 0.54986, 0, 0, 0.77778],
                "8848": [0.03517, 0.54986, 0, 0, 0.77778],
                "8858": [0.08198, 0.58198, 0, 0, 0.77778],
                "8859": [0.08198, 0.58198, 0, 0, 0.77778],
                "8861": [0.08198, 0.58198, 0, 0, 0.77778],
                "8862": [0, 0.675, 0, 0, 0.77778],
                "8863": [0, 0.675, 0, 0, 0.77778],
                "8864": [0, 0.675, 0, 0, 0.77778],
                "8865": [0, 0.675, 0, 0, 0.77778],
                "8872": [0, 0.69224, 0, 0, 0.61111],
                "8873": [0, 0.69224, 0, 0, 0.72222],
                "8874": [0, 0.69224, 0, 0, 0.88889],
                "8876": [0, 0.68889, 0, 0, 0.61111],
                "8877": [0, 0.68889, 0, 0, 0.61111],
                "8878": [0, 0.68889, 0, 0, 0.72222],
                "8879": [0, 0.68889, 0, 0, 0.72222],
                "8882": [0.03517, 0.54986, 0, 0, 0.77778],
                "8883": [0.03517, 0.54986, 0, 0, 0.77778],
                "8884": [0.13667, 0.63667, 0, 0, 0.77778],
                "8885": [0.13667, 0.63667, 0, 0, 0.77778],
                "8888": [0, 0.54986, 0, 0, 1.11111],
                "8890": [0.19444, 0.43056, 0, 0, 0.55556],
                "8891": [0.19444, 0.69224, 0, 0, 0.61111],
                "8892": [0.19444, 0.69224, 0, 0, 0.61111],
                "8901": [0, 0.54986, 0, 0, 0.27778],
                "8903": [0.08167, 0.58167, 0, 0, 0.77778],
                "8905": [0.08167, 0.58167, 0, 0, 0.77778],
                "8906": [0.08167, 0.58167, 0, 0, 0.77778],
                "8907": [0, 0.69224, 0, 0, 0.77778],
                "8908": [0, 0.69224, 0, 0, 0.77778],
                "8909": [-0.03598, 0.46402, 0, 0, 0.77778],
                "8910": [0, 0.54986, 0, 0, 0.76042],
                "8911": [0, 0.54986, 0, 0, 0.76042],
                "8912": [0.03517, 0.54986, 0, 0, 0.77778],
                "8913": [0.03517, 0.54986, 0, 0, 0.77778],
                "8914": [0, 0.54986, 0, 0, 0.66667],
                "8915": [0, 0.54986, 0, 0, 0.66667],
                "8916": [0, 0.69224, 0, 0, 0.66667],
                "8918": [0.0391, 0.5391, 0, 0, 0.77778],
                "8919": [0.0391, 0.5391, 0, 0, 0.77778],
                "8920": [0.03517, 0.54986, 0, 0, 1.33334],
                "8921": [0.03517, 0.54986, 0, 0, 1.33334],
                "8922": [0.38569, 0.88569, 0, 0, 0.77778],
                "8923": [0.38569, 0.88569, 0, 0, 0.77778],
                "8926": [0.13667, 0.63667, 0, 0, 0.77778],
                "8927": [0.13667, 0.63667, 0, 0, 0.77778],
                "8928": [0.30274, 0.79383, 0, 0, 0.77778],
                "8929": [0.30274, 0.79383, 0, 0, 0.77778],
                "8934": [0.23222, 0.74111, 0, 0, 0.77778],
                "8935": [0.23222, 0.74111, 0, 0, 0.77778],
                "8936": [0.23222, 0.74111, 0, 0, 0.77778],
                "8937": [0.23222, 0.74111, 0, 0, 0.77778],
                "8938": [0.20576, 0.70576, 0, 0, 0.77778],
                "8939": [0.20576, 0.70576, 0, 0, 0.77778],
                "8940": [0.30274, 0.79383, 0, 0, 0.77778],
                "8941": [0.30274, 0.79383, 0, 0, 0.77778],
                "8994": [0.19444, 0.69224, 0, 0, 0.77778],
                "8995": [0.19444, 0.69224, 0, 0, 0.77778],
                "9416": [0.15559, 0.69224, 0, 0, 0.90222],
                "9484": [0, 0.69224, 0, 0, 0.5],
                "9488": [0, 0.69224, 0, 0, 0.5],
                "9492": [0, 0.37788, 0, 0, 0.5],
                "9496": [0, 0.37788, 0, 0, 0.5],
                "9585": [0.19444, 0.68889, 0, 0, 0.88889],
                "9586": [0.19444, 0.74111, 0, 0, 0.88889],
                "9632": [0, 0.675, 0, 0, 0.77778],
                "9633": [0, 0.675, 0, 0, 0.77778],
                "9650": [0, 0.54986, 0, 0, 0.72222],
                "9651": [0, 0.54986, 0, 0, 0.72222],
                "9654": [0.03517, 0.54986, 0, 0, 0.77778],
                "9660": [0, 0.54986, 0, 0, 0.72222],
                "9661": [0, 0.54986, 0, 0, 0.72222],
                "9664": [0.03517, 0.54986, 0, 0, 0.77778],
                "9674": [0.11111, 0.69224, 0, 0, 0.66667],
                "9733": [0.19444, 0.69224, 0, 0, 0.94445],
                "10003": [0, 0.69224, 0, 0, 0.83334],
                "10016": [0, 0.69224, 0, 0, 0.83334],
                "10731": [0.11111, 0.69224, 0, 0, 0.66667],
                "10846": [0.19444, 0.75583, 0, 0, 0.61111],
                "10877": [0.13667, 0.63667, 0, 0, 0.77778],
                "10878": [0.13667, 0.63667, 0, 0, 0.77778],
                "10885": [0.25583, 0.75583, 0, 0, 0.77778],
                "10886": [0.25583, 0.75583, 0, 0, 0.77778],
                "10887": [0.13597, 0.63597, 0, 0, 0.77778],
                "10888": [0.13597, 0.63597, 0, 0, 0.77778],
                "10889": [0.26167, 0.75726, 0, 0, 0.77778],
                "10890": [0.26167, 0.75726, 0, 0, 0.77778],
                "10891": [0.48256, 0.98256, 0, 0, 0.77778],
                "10892": [0.48256, 0.98256, 0, 0, 0.77778],
                "10901": [0.13667, 0.63667, 0, 0, 0.77778],
                "10902": [0.13667, 0.63667, 0, 0, 0.77778],
                "10933": [0.25142, 0.75726, 0, 0, 0.77778],
                "10934": [0.25142, 0.75726, 0, 0, 0.77778],
                "10935": [0.26167, 0.75726, 0, 0, 0.77778],
                "10936": [0.26167, 0.75726, 0, 0, 0.77778],
                "10937": [0.26167, 0.75726, 0, 0, 0.77778],
                "10938": [0.26167, 0.75726, 0, 0, 0.77778],
                "10949": [0.25583, 0.75583, 0, 0, 0.77778],
                "10950": [0.25583, 0.75583, 0, 0, 0.77778],
                "10955": [0.28481, 0.79383, 0, 0, 0.77778],
                "10956": [0.28481, 0.79383, 0, 0, 0.77778],
                "57350": [0.08167, 0.58167, 0, 0, 0.22222],
                "57351": [0.08167, 0.58167, 0, 0, 0.38889],
                "57352": [0.08167, 0.58167, 0, 0, 0.77778],
                "57353": [0, 0.43056, 0.04028, 0, 0.66667],
                "57356": [0.25142, 0.75726, 0, 0, 0.77778],
                "57357": [0.25142, 0.75726, 0, 0, 0.77778],
                "57358": [0.41951, 0.91951, 0, 0, 0.77778],
                "57359": [0.30274, 0.79383, 0, 0, 0.77778],
                "57360": [0.30274, 0.79383, 0, 0, 0.77778],
                "57361": [0.41951, 0.91951, 0, 0, 0.77778],
                "57366": [0.25142, 0.75726, 0, 0, 0.77778],
                "57367": [0.25142, 0.75726, 0, 0, 0.77778],
                "57368": [0.25142, 0.75726, 0, 0, 0.77778],
                "57369": [0.25142, 0.75726, 0, 0, 0.77778],
                "57370": [0.13597, 0.63597, 0, 0, 0.77778],
                "57371": [0.13597, 0.63597, 0, 0, 0.77778]
              },
              "Caligraphic-Regular": {
                "32": [0, 0, 0, 0, 0.25],
                "65": [0, 0.68333, 0, 0.19445, 0.79847],
                "66": [0, 0.68333, 0.03041, 0.13889, 0.65681],
                "67": [0, 0.68333, 0.05834, 0.13889, 0.52653],
                "68": [0, 0.68333, 0.02778, 0.08334, 0.77139],
                "69": [0, 0.68333, 0.08944, 0.11111, 0.52778],
                "70": [0, 0.68333, 0.09931, 0.11111, 0.71875],
                "71": [0.09722, 0.68333, 0.0593, 0.11111, 0.59487],
                "72": [0, 0.68333, 965e-5, 0.11111, 0.84452],
                "73": [0, 0.68333, 0.07382, 0, 0.54452],
                "74": [0.09722, 0.68333, 0.18472, 0.16667, 0.67778],
                "75": [0, 0.68333, 0.01445, 0.05556, 0.76195],
                "76": [0, 0.68333, 0, 0.13889, 0.68972],
                "77": [0, 0.68333, 0, 0.13889, 1.2009],
                "78": [0, 0.68333, 0.14736, 0.08334, 0.82049],
                "79": [0, 0.68333, 0.02778, 0.11111, 0.79611],
                "80": [0, 0.68333, 0.08222, 0.08334, 0.69556],
                "81": [0.09722, 0.68333, 0, 0.11111, 0.81667],
                "82": [0, 0.68333, 0, 0.08334, 0.8475],
                "83": [0, 0.68333, 0.075, 0.13889, 0.60556],
                "84": [0, 0.68333, 0.25417, 0, 0.54464],
                "85": [0, 0.68333, 0.09931, 0.08334, 0.62583],
                "86": [0, 0.68333, 0.08222, 0, 0.61278],
                "87": [0, 0.68333, 0.08222, 0.08334, 0.98778],
                "88": [0, 0.68333, 0.14643, 0.13889, 0.7133],
                "89": [0.09722, 0.68333, 0.08222, 0.08334, 0.66834],
                "90": [0, 0.68333, 0.07944, 0.13889, 0.72473],
                "160": [0, 0, 0, 0, 0.25]
              },
              "Fraktur-Regular": {
                "32": [0, 0, 0, 0, 0.25],
                "33": [0, 0.69141, 0, 0, 0.29574],
                "34": [0, 0.69141, 0, 0, 0.21471],
                "38": [0, 0.69141, 0, 0, 0.73786],
                "39": [0, 0.69141, 0, 0, 0.21201],
                "40": [0.24982, 0.74947, 0, 0, 0.38865],
                "41": [0.24982, 0.74947, 0, 0, 0.38865],
                "42": [0, 0.62119, 0, 0, 0.27764],
                "43": [0.08319, 0.58283, 0, 0, 0.75623],
                "44": [0, 0.10803, 0, 0, 0.27764],
                "45": [0.08319, 0.58283, 0, 0, 0.75623],
                "46": [0, 0.10803, 0, 0, 0.27764],
                "47": [0.24982, 0.74947, 0, 0, 0.50181],
                "48": [0, 0.47534, 0, 0, 0.50181],
                "49": [0, 0.47534, 0, 0, 0.50181],
                "50": [0, 0.47534, 0, 0, 0.50181],
                "51": [0.18906, 0.47534, 0, 0, 0.50181],
                "52": [0.18906, 0.47534, 0, 0, 0.50181],
                "53": [0.18906, 0.47534, 0, 0, 0.50181],
                "54": [0, 0.69141, 0, 0, 0.50181],
                "55": [0.18906, 0.47534, 0, 0, 0.50181],
                "56": [0, 0.69141, 0, 0, 0.50181],
                "57": [0.18906, 0.47534, 0, 0, 0.50181],
                "58": [0, 0.47534, 0, 0, 0.21606],
                "59": [0.12604, 0.47534, 0, 0, 0.21606],
                "61": [-0.13099, 0.36866, 0, 0, 0.75623],
                "63": [0, 0.69141, 0, 0, 0.36245],
                "65": [0, 0.69141, 0, 0, 0.7176],
                "66": [0, 0.69141, 0, 0, 0.88397],
                "67": [0, 0.69141, 0, 0, 0.61254],
                "68": [0, 0.69141, 0, 0, 0.83158],
                "69": [0, 0.69141, 0, 0, 0.66278],
                "70": [0.12604, 0.69141, 0, 0, 0.61119],
                "71": [0, 0.69141, 0, 0, 0.78539],
                "72": [0.06302, 0.69141, 0, 0, 0.7203],
                "73": [0, 0.69141, 0, 0, 0.55448],
                "74": [0.12604, 0.69141, 0, 0, 0.55231],
                "75": [0, 0.69141, 0, 0, 0.66845],
                "76": [0, 0.69141, 0, 0, 0.66602],
                "77": [0, 0.69141, 0, 0, 1.04953],
                "78": [0, 0.69141, 0, 0, 0.83212],
                "79": [0, 0.69141, 0, 0, 0.82699],
                "80": [0.18906, 0.69141, 0, 0, 0.82753],
                "81": [0.03781, 0.69141, 0, 0, 0.82699],
                "82": [0, 0.69141, 0, 0, 0.82807],
                "83": [0, 0.69141, 0, 0, 0.82861],
                "84": [0, 0.69141, 0, 0, 0.66899],
                "85": [0, 0.69141, 0, 0, 0.64576],
                "86": [0, 0.69141, 0, 0, 0.83131],
                "87": [0, 0.69141, 0, 0, 1.04602],
                "88": [0, 0.69141, 0, 0, 0.71922],
                "89": [0.18906, 0.69141, 0, 0, 0.83293],
                "90": [0.12604, 0.69141, 0, 0, 0.60201],
                "91": [0.24982, 0.74947, 0, 0, 0.27764],
                "93": [0.24982, 0.74947, 0, 0, 0.27764],
                "94": [0, 0.69141, 0, 0, 0.49965],
                "97": [0, 0.47534, 0, 0, 0.50046],
                "98": [0, 0.69141, 0, 0, 0.51315],
                "99": [0, 0.47534, 0, 0, 0.38946],
                "100": [0, 0.62119, 0, 0, 0.49857],
                "101": [0, 0.47534, 0, 0, 0.40053],
                "102": [0.18906, 0.69141, 0, 0, 0.32626],
                "103": [0.18906, 0.47534, 0, 0, 0.5037],
                "104": [0.18906, 0.69141, 0, 0, 0.52126],
                "105": [0, 0.69141, 0, 0, 0.27899],
                "106": [0, 0.69141, 0, 0, 0.28088],
                "107": [0, 0.69141, 0, 0, 0.38946],
                "108": [0, 0.69141, 0, 0, 0.27953],
                "109": [0, 0.47534, 0, 0, 0.76676],
                "110": [0, 0.47534, 0, 0, 0.52666],
                "111": [0, 0.47534, 0, 0, 0.48885],
                "112": [0.18906, 0.52396, 0, 0, 0.50046],
                "113": [0.18906, 0.47534, 0, 0, 0.48912],
                "114": [0, 0.47534, 0, 0, 0.38919],
                "115": [0, 0.47534, 0, 0, 0.44266],
                "116": [0, 0.62119, 0, 0, 0.33301],
                "117": [0, 0.47534, 0, 0, 0.5172],
                "118": [0, 0.52396, 0, 0, 0.5118],
                "119": [0, 0.52396, 0, 0, 0.77351],
                "120": [0.18906, 0.47534, 0, 0, 0.38865],
                "121": [0.18906, 0.47534, 0, 0, 0.49884],
                "122": [0.18906, 0.47534, 0, 0, 0.39054],
                "160": [0, 0, 0, 0, 0.25],
                "8216": [0, 0.69141, 0, 0, 0.21471],
                "8217": [0, 0.69141, 0, 0, 0.21471],
                "58112": [0, 0.62119, 0, 0, 0.49749],
                "58113": [0, 0.62119, 0, 0, 0.4983],
                "58114": [0.18906, 0.69141, 0, 0, 0.33328],
                "58115": [0.18906, 0.69141, 0, 0, 0.32923],
                "58116": [0.18906, 0.47534, 0, 0, 0.50343],
                "58117": [0, 0.69141, 0, 0, 0.33301],
                "58118": [0, 0.62119, 0, 0, 0.33409],
                "58119": [0, 0.47534, 0, 0, 0.50073]
              },
              "Main-Bold": {
                "32": [0, 0, 0, 0, 0.25],
                "33": [0, 0.69444, 0, 0, 0.35],
                "34": [0, 0.69444, 0, 0, 0.60278],
                "35": [0.19444, 0.69444, 0, 0, 0.95833],
                "36": [0.05556, 0.75, 0, 0, 0.575],
                "37": [0.05556, 0.75, 0, 0, 0.95833],
                "38": [0, 0.69444, 0, 0, 0.89444],
                "39": [0, 0.69444, 0, 0, 0.31944],
                "40": [0.25, 0.75, 0, 0, 0.44722],
                "41": [0.25, 0.75, 0, 0, 0.44722],
                "42": [0, 0.75, 0, 0, 0.575],
                "43": [0.13333, 0.63333, 0, 0, 0.89444],
                "44": [0.19444, 0.15556, 0, 0, 0.31944],
                "45": [0, 0.44444, 0, 0, 0.38333],
                "46": [0, 0.15556, 0, 0, 0.31944],
                "47": [0.25, 0.75, 0, 0, 0.575],
                "48": [0, 0.64444, 0, 0, 0.575],
                "49": [0, 0.64444, 0, 0, 0.575],
                "50": [0, 0.64444, 0, 0, 0.575],
                "51": [0, 0.64444, 0, 0, 0.575],
                "52": [0, 0.64444, 0, 0, 0.575],
                "53": [0, 0.64444, 0, 0, 0.575],
                "54": [0, 0.64444, 0, 0, 0.575],
                "55": [0, 0.64444, 0, 0, 0.575],
                "56": [0, 0.64444, 0, 0, 0.575],
                "57": [0, 0.64444, 0, 0, 0.575],
                "58": [0, 0.44444, 0, 0, 0.31944],
                "59": [0.19444, 0.44444, 0, 0, 0.31944],
                "60": [0.08556, 0.58556, 0, 0, 0.89444],
                "61": [-0.10889, 0.39111, 0, 0, 0.89444],
                "62": [0.08556, 0.58556, 0, 0, 0.89444],
                "63": [0, 0.69444, 0, 0, 0.54305],
                "64": [0, 0.69444, 0, 0, 0.89444],
                "65": [0, 0.68611, 0, 0, 0.86944],
                "66": [0, 0.68611, 0, 0, 0.81805],
                "67": [0, 0.68611, 0, 0, 0.83055],
                "68": [0, 0.68611, 0, 0, 0.88194],
                "69": [0, 0.68611, 0, 0, 0.75555],
                "70": [0, 0.68611, 0, 0, 0.72361],
                "71": [0, 0.68611, 0, 0, 0.90416],
                "72": [0, 0.68611, 0, 0, 0.9],
                "73": [0, 0.68611, 0, 0, 0.43611],
                "74": [0, 0.68611, 0, 0, 0.59444],
                "75": [0, 0.68611, 0, 0, 0.90138],
                "76": [0, 0.68611, 0, 0, 0.69166],
                "77": [0, 0.68611, 0, 0, 1.09166],
                "78": [0, 0.68611, 0, 0, 0.9],
                "79": [0, 0.68611, 0, 0, 0.86388],
                "80": [0, 0.68611, 0, 0, 0.78611],
                "81": [0.19444, 0.68611, 0, 0, 0.86388],
                "82": [0, 0.68611, 0, 0, 0.8625],
                "83": [0, 0.68611, 0, 0, 0.63889],
                "84": [0, 0.68611, 0, 0, 0.8],
                "85": [0, 0.68611, 0, 0, 0.88472],
                "86": [0, 0.68611, 0.01597, 0, 0.86944],
                "87": [0, 0.68611, 0.01597, 0, 1.18888],
                "88": [0, 0.68611, 0, 0, 0.86944],
                "89": [0, 0.68611, 0.02875, 0, 0.86944],
                "90": [0, 0.68611, 0, 0, 0.70277],
                "91": [0.25, 0.75, 0, 0, 0.31944],
                "92": [0.25, 0.75, 0, 0, 0.575],
                "93": [0.25, 0.75, 0, 0, 0.31944],
                "94": [0, 0.69444, 0, 0, 0.575],
                "95": [0.31, 0.13444, 0.03194, 0, 0.575],
                "97": [0, 0.44444, 0, 0, 0.55902],
                "98": [0, 0.69444, 0, 0, 0.63889],
                "99": [0, 0.44444, 0, 0, 0.51111],
                "100": [0, 0.69444, 0, 0, 0.63889],
                "101": [0, 0.44444, 0, 0, 0.52708],
                "102": [0, 0.69444, 0.10903, 0, 0.35139],
                "103": [0.19444, 0.44444, 0.01597, 0, 0.575],
                "104": [0, 0.69444, 0, 0, 0.63889],
                "105": [0, 0.69444, 0, 0, 0.31944],
                "106": [0.19444, 0.69444, 0, 0, 0.35139],
                "107": [0, 0.69444, 0, 0, 0.60694],
                "108": [0, 0.69444, 0, 0, 0.31944],
                "109": [0, 0.44444, 0, 0, 0.95833],
                "110": [0, 0.44444, 0, 0, 0.63889],
                "111": [0, 0.44444, 0, 0, 0.575],
                "112": [0.19444, 0.44444, 0, 0, 0.63889],
                "113": [0.19444, 0.44444, 0, 0, 0.60694],
                "114": [0, 0.44444, 0, 0, 0.47361],
                "115": [0, 0.44444, 0, 0, 0.45361],
                "116": [0, 0.63492, 0, 0, 0.44722],
                "117": [0, 0.44444, 0, 0, 0.63889],
                "118": [0, 0.44444, 0.01597, 0, 0.60694],
                "119": [0, 0.44444, 0.01597, 0, 0.83055],
                "120": [0, 0.44444, 0, 0, 0.60694],
                "121": [0.19444, 0.44444, 0.01597, 0, 0.60694],
                "122": [0, 0.44444, 0, 0, 0.51111],
                "123": [0.25, 0.75, 0, 0, 0.575],
                "124": [0.25, 0.75, 0, 0, 0.31944],
                "125": [0.25, 0.75, 0, 0, 0.575],
                "126": [0.35, 0.34444, 0, 0, 0.575],
                "160": [0, 0, 0, 0, 0.25],
                "163": [0, 0.69444, 0, 0, 0.86853],
                "168": [0, 0.69444, 0, 0, 0.575],
                "172": [0, 0.44444, 0, 0, 0.76666],
                "176": [0, 0.69444, 0, 0, 0.86944],
                "177": [0.13333, 0.63333, 0, 0, 0.89444],
                "184": [0.17014, 0, 0, 0, 0.51111],
                "198": [0, 0.68611, 0, 0, 1.04166],
                "215": [0.13333, 0.63333, 0, 0, 0.89444],
                "216": [0.04861, 0.73472, 0, 0, 0.89444],
                "223": [0, 0.69444, 0, 0, 0.59722],
                "230": [0, 0.44444, 0, 0, 0.83055],
                "247": [0.13333, 0.63333, 0, 0, 0.89444],
                "248": [0.09722, 0.54167, 0, 0, 0.575],
                "305": [0, 0.44444, 0, 0, 0.31944],
                "338": [0, 0.68611, 0, 0, 1.16944],
                "339": [0, 0.44444, 0, 0, 0.89444],
                "567": [0.19444, 0.44444, 0, 0, 0.35139],
                "710": [0, 0.69444, 0, 0, 0.575],
                "711": [0, 0.63194, 0, 0, 0.575],
                "713": [0, 0.59611, 0, 0, 0.575],
                "714": [0, 0.69444, 0, 0, 0.575],
                "715": [0, 0.69444, 0, 0, 0.575],
                "728": [0, 0.69444, 0, 0, 0.575],
                "729": [0, 0.69444, 0, 0, 0.31944],
                "730": [0, 0.69444, 0, 0, 0.86944],
                "732": [0, 0.69444, 0, 0, 0.575],
                "733": [0, 0.69444, 0, 0, 0.575],
                "915": [0, 0.68611, 0, 0, 0.69166],
                "916": [0, 0.68611, 0, 0, 0.95833],
                "920": [0, 0.68611, 0, 0, 0.89444],
                "923": [0, 0.68611, 0, 0, 0.80555],
                "926": [0, 0.68611, 0, 0, 0.76666],
                "928": [0, 0.68611, 0, 0, 0.9],
                "931": [0, 0.68611, 0, 0, 0.83055],
                "933": [0, 0.68611, 0, 0, 0.89444],
                "934": [0, 0.68611, 0, 0, 0.83055],
                "936": [0, 0.68611, 0, 0, 0.89444],
                "937": [0, 0.68611, 0, 0, 0.83055],
                "8211": [0, 0.44444, 0.03194, 0, 0.575],
                "8212": [0, 0.44444, 0.03194, 0, 1.14999],
                "8216": [0, 0.69444, 0, 0, 0.31944],
                "8217": [0, 0.69444, 0, 0, 0.31944],
                "8220": [0, 0.69444, 0, 0, 0.60278],
                "8221": [0, 0.69444, 0, 0, 0.60278],
                "8224": [0.19444, 0.69444, 0, 0, 0.51111],
                "8225": [0.19444, 0.69444, 0, 0, 0.51111],
                "8242": [0, 0.55556, 0, 0, 0.34444],
                "8407": [0, 0.72444, 0.15486, 0, 0.575],
                "8463": [0, 0.69444, 0, 0, 0.66759],
                "8465": [0, 0.69444, 0, 0, 0.83055],
                "8467": [0, 0.69444, 0, 0, 0.47361],
                "8472": [0.19444, 0.44444, 0, 0, 0.74027],
                "8476": [0, 0.69444, 0, 0, 0.83055],
                "8501": [0, 0.69444, 0, 0, 0.70277],
                "8592": [-0.10889, 0.39111, 0, 0, 1.14999],
                "8593": [0.19444, 0.69444, 0, 0, 0.575],
                "8594": [-0.10889, 0.39111, 0, 0, 1.14999],
                "8595": [0.19444, 0.69444, 0, 0, 0.575],
                "8596": [-0.10889, 0.39111, 0, 0, 1.14999],
                "8597": [0.25, 0.75, 0, 0, 0.575],
                "8598": [0.19444, 0.69444, 0, 0, 1.14999],
                "8599": [0.19444, 0.69444, 0, 0, 1.14999],
                "8600": [0.19444, 0.69444, 0, 0, 1.14999],
                "8601": [0.19444, 0.69444, 0, 0, 1.14999],
                "8636": [-0.10889, 0.39111, 0, 0, 1.14999],
                "8637": [-0.10889, 0.39111, 0, 0, 1.14999],
                "8640": [-0.10889, 0.39111, 0, 0, 1.14999],
                "8641": [-0.10889, 0.39111, 0, 0, 1.14999],
                "8656": [-0.10889, 0.39111, 0, 0, 1.14999],
                "8657": [0.19444, 0.69444, 0, 0, 0.70277],
                "8658": [-0.10889, 0.39111, 0, 0, 1.14999],
                "8659": [0.19444, 0.69444, 0, 0, 0.70277],
                "8660": [-0.10889, 0.39111, 0, 0, 1.14999],
                "8661": [0.25, 0.75, 0, 0, 0.70277],
                "8704": [0, 0.69444, 0, 0, 0.63889],
                "8706": [0, 0.69444, 0.06389, 0, 0.62847],
                "8707": [0, 0.69444, 0, 0, 0.63889],
                "8709": [0.05556, 0.75, 0, 0, 0.575],
                "8711": [0, 0.68611, 0, 0, 0.95833],
                "8712": [0.08556, 0.58556, 0, 0, 0.76666],
                "8715": [0.08556, 0.58556, 0, 0, 0.76666],
                "8722": [0.13333, 0.63333, 0, 0, 0.89444],
                "8723": [0.13333, 0.63333, 0, 0, 0.89444],
                "8725": [0.25, 0.75, 0, 0, 0.575],
                "8726": [0.25, 0.75, 0, 0, 0.575],
                "8727": [-0.02778, 0.47222, 0, 0, 0.575],
                "8728": [-0.02639, 0.47361, 0, 0, 0.575],
                "8729": [-0.02639, 0.47361, 0, 0, 0.575],
                "8730": [0.18, 0.82, 0, 0, 0.95833],
                "8733": [0, 0.44444, 0, 0, 0.89444],
                "8734": [0, 0.44444, 0, 0, 1.14999],
                "8736": [0, 0.69224, 0, 0, 0.72222],
                "8739": [0.25, 0.75, 0, 0, 0.31944],
                "8741": [0.25, 0.75, 0, 0, 0.575],
                "8743": [0, 0.55556, 0, 0, 0.76666],
                "8744": [0, 0.55556, 0, 0, 0.76666],
                "8745": [0, 0.55556, 0, 0, 0.76666],
                "8746": [0, 0.55556, 0, 0, 0.76666],
                "8747": [0.19444, 0.69444, 0.12778, 0, 0.56875],
                "8764": [-0.10889, 0.39111, 0, 0, 0.89444],
                "8768": [0.19444, 0.69444, 0, 0, 0.31944],
                "8771": [222e-5, 0.50222, 0, 0, 0.89444],
                "8776": [0.02444, 0.52444, 0, 0, 0.89444],
                "8781": [222e-5, 0.50222, 0, 0, 0.89444],
                "8801": [222e-5, 0.50222, 0, 0, 0.89444],
                "8804": [0.19667, 0.69667, 0, 0, 0.89444],
                "8805": [0.19667, 0.69667, 0, 0, 0.89444],
                "8810": [0.08556, 0.58556, 0, 0, 1.14999],
                "8811": [0.08556, 0.58556, 0, 0, 1.14999],
                "8826": [0.08556, 0.58556, 0, 0, 0.89444],
                "8827": [0.08556, 0.58556, 0, 0, 0.89444],
                "8834": [0.08556, 0.58556, 0, 0, 0.89444],
                "8835": [0.08556, 0.58556, 0, 0, 0.89444],
                "8838": [0.19667, 0.69667, 0, 0, 0.89444],
                "8839": [0.19667, 0.69667, 0, 0, 0.89444],
                "8846": [0, 0.55556, 0, 0, 0.76666],
                "8849": [0.19667, 0.69667, 0, 0, 0.89444],
                "8850": [0.19667, 0.69667, 0, 0, 0.89444],
                "8851": [0, 0.55556, 0, 0, 0.76666],
                "8852": [0, 0.55556, 0, 0, 0.76666],
                "8853": [0.13333, 0.63333, 0, 0, 0.89444],
                "8854": [0.13333, 0.63333, 0, 0, 0.89444],
                "8855": [0.13333, 0.63333, 0, 0, 0.89444],
                "8856": [0.13333, 0.63333, 0, 0, 0.89444],
                "8857": [0.13333, 0.63333, 0, 0, 0.89444],
                "8866": [0, 0.69444, 0, 0, 0.70277],
                "8867": [0, 0.69444, 0, 0, 0.70277],
                "8868": [0, 0.69444, 0, 0, 0.89444],
                "8869": [0, 0.69444, 0, 0, 0.89444],
                "8900": [-0.02639, 0.47361, 0, 0, 0.575],
                "8901": [-0.02639, 0.47361, 0, 0, 0.31944],
                "8902": [-0.02778, 0.47222, 0, 0, 0.575],
                "8968": [0.25, 0.75, 0, 0, 0.51111],
                "8969": [0.25, 0.75, 0, 0, 0.51111],
                "8970": [0.25, 0.75, 0, 0, 0.51111],
                "8971": [0.25, 0.75, 0, 0, 0.51111],
                "8994": [-0.13889, 0.36111, 0, 0, 1.14999],
                "8995": [-0.13889, 0.36111, 0, 0, 1.14999],
                "9651": [0.19444, 0.69444, 0, 0, 1.02222],
                "9657": [-0.02778, 0.47222, 0, 0, 0.575],
                "9661": [0.19444, 0.69444, 0, 0, 1.02222],
                "9667": [-0.02778, 0.47222, 0, 0, 0.575],
                "9711": [0.19444, 0.69444, 0, 0, 1.14999],
                "9824": [0.12963, 0.69444, 0, 0, 0.89444],
                "9825": [0.12963, 0.69444, 0, 0, 0.89444],
                "9826": [0.12963, 0.69444, 0, 0, 0.89444],
                "9827": [0.12963, 0.69444, 0, 0, 0.89444],
                "9837": [0, 0.75, 0, 0, 0.44722],
                "9838": [0.19444, 0.69444, 0, 0, 0.44722],
                "9839": [0.19444, 0.69444, 0, 0, 0.44722],
                "10216": [0.25, 0.75, 0, 0, 0.44722],
                "10217": [0.25, 0.75, 0, 0, 0.44722],
                "10815": [0, 0.68611, 0, 0, 0.9],
                "10927": [0.19667, 0.69667, 0, 0, 0.89444],
                "10928": [0.19667, 0.69667, 0, 0, 0.89444],
                "57376": [0.19444, 0.69444, 0, 0, 0]
              },
              "Main-BoldItalic": {
                "32": [0, 0, 0, 0, 0.25],
                "33": [0, 0.69444, 0.11417, 0, 0.38611],
                "34": [0, 0.69444, 0.07939, 0, 0.62055],
                "35": [0.19444, 0.69444, 0.06833, 0, 0.94444],
                "37": [0.05556, 0.75, 0.12861, 0, 0.94444],
                "38": [0, 0.69444, 0.08528, 0, 0.88555],
                "39": [0, 0.69444, 0.12945, 0, 0.35555],
                "40": [0.25, 0.75, 0.15806, 0, 0.47333],
                "41": [0.25, 0.75, 0.03306, 0, 0.47333],
                "42": [0, 0.75, 0.14333, 0, 0.59111],
                "43": [0.10333, 0.60333, 0.03306, 0, 0.88555],
                "44": [0.19444, 0.14722, 0, 0, 0.35555],
                "45": [0, 0.44444, 0.02611, 0, 0.41444],
                "46": [0, 0.14722, 0, 0, 0.35555],
                "47": [0.25, 0.75, 0.15806, 0, 0.59111],
                "48": [0, 0.64444, 0.13167, 0, 0.59111],
                "49": [0, 0.64444, 0.13167, 0, 0.59111],
                "50": [0, 0.64444, 0.13167, 0, 0.59111],
                "51": [0, 0.64444, 0.13167, 0, 0.59111],
                "52": [0.19444, 0.64444, 0.13167, 0, 0.59111],
                "53": [0, 0.64444, 0.13167, 0, 0.59111],
                "54": [0, 0.64444, 0.13167, 0, 0.59111],
                "55": [0.19444, 0.64444, 0.13167, 0, 0.59111],
                "56": [0, 0.64444, 0.13167, 0, 0.59111],
                "57": [0, 0.64444, 0.13167, 0, 0.59111],
                "58": [0, 0.44444, 0.06695, 0, 0.35555],
                "59": [0.19444, 0.44444, 0.06695, 0, 0.35555],
                "61": [-0.10889, 0.39111, 0.06833, 0, 0.88555],
                "63": [0, 0.69444, 0.11472, 0, 0.59111],
                "64": [0, 0.69444, 0.09208, 0, 0.88555],
                "65": [0, 0.68611, 0, 0, 0.86555],
                "66": [0, 0.68611, 0.0992, 0, 0.81666],
                "67": [0, 0.68611, 0.14208, 0, 0.82666],
                "68": [0, 0.68611, 0.09062, 0, 0.87555],
                "69": [0, 0.68611, 0.11431, 0, 0.75666],
                "70": [0, 0.68611, 0.12903, 0, 0.72722],
                "71": [0, 0.68611, 0.07347, 0, 0.89527],
                "72": [0, 0.68611, 0.17208, 0, 0.8961],
                "73": [0, 0.68611, 0.15681, 0, 0.47166],
                "74": [0, 0.68611, 0.145, 0, 0.61055],
                "75": [0, 0.68611, 0.14208, 0, 0.89499],
                "76": [0, 0.68611, 0, 0, 0.69777],
                "77": [0, 0.68611, 0.17208, 0, 1.07277],
                "78": [0, 0.68611, 0.17208, 0, 0.8961],
                "79": [0, 0.68611, 0.09062, 0, 0.85499],
                "80": [0, 0.68611, 0.0992, 0, 0.78721],
                "81": [0.19444, 0.68611, 0.09062, 0, 0.85499],
                "82": [0, 0.68611, 0.02559, 0, 0.85944],
                "83": [0, 0.68611, 0.11264, 0, 0.64999],
                "84": [0, 0.68611, 0.12903, 0, 0.7961],
                "85": [0, 0.68611, 0.17208, 0, 0.88083],
                "86": [0, 0.68611, 0.18625, 0, 0.86555],
                "87": [0, 0.68611, 0.18625, 0, 1.15999],
                "88": [0, 0.68611, 0.15681, 0, 0.86555],
                "89": [0, 0.68611, 0.19803, 0, 0.86555],
                "90": [0, 0.68611, 0.14208, 0, 0.70888],
                "91": [0.25, 0.75, 0.1875, 0, 0.35611],
                "93": [0.25, 0.75, 0.09972, 0, 0.35611],
                "94": [0, 0.69444, 0.06709, 0, 0.59111],
                "95": [0.31, 0.13444, 0.09811, 0, 0.59111],
                "97": [0, 0.44444, 0.09426, 0, 0.59111],
                "98": [0, 0.69444, 0.07861, 0, 0.53222],
                "99": [0, 0.44444, 0.05222, 0, 0.53222],
                "100": [0, 0.69444, 0.10861, 0, 0.59111],
                "101": [0, 0.44444, 0.085, 0, 0.53222],
                "102": [0.19444, 0.69444, 0.21778, 0, 0.4],
                "103": [0.19444, 0.44444, 0.105, 0, 0.53222],
                "104": [0, 0.69444, 0.09426, 0, 0.59111],
                "105": [0, 0.69326, 0.11387, 0, 0.35555],
                "106": [0.19444, 0.69326, 0.1672, 0, 0.35555],
                "107": [0, 0.69444, 0.11111, 0, 0.53222],
                "108": [0, 0.69444, 0.10861, 0, 0.29666],
                "109": [0, 0.44444, 0.09426, 0, 0.94444],
                "110": [0, 0.44444, 0.09426, 0, 0.64999],
                "111": [0, 0.44444, 0.07861, 0, 0.59111],
                "112": [0.19444, 0.44444, 0.07861, 0, 0.59111],
                "113": [0.19444, 0.44444, 0.105, 0, 0.53222],
                "114": [0, 0.44444, 0.11111, 0, 0.50167],
                "115": [0, 0.44444, 0.08167, 0, 0.48694],
                "116": [0, 0.63492, 0.09639, 0, 0.385],
                "117": [0, 0.44444, 0.09426, 0, 0.62055],
                "118": [0, 0.44444, 0.11111, 0, 0.53222],
                "119": [0, 0.44444, 0.11111, 0, 0.76777],
                "120": [0, 0.44444, 0.12583, 0, 0.56055],
                "121": [0.19444, 0.44444, 0.105, 0, 0.56166],
                "122": [0, 0.44444, 0.13889, 0, 0.49055],
                "126": [0.35, 0.34444, 0.11472, 0, 0.59111],
                "160": [0, 0, 0, 0, 0.25],
                "168": [0, 0.69444, 0.11473, 0, 0.59111],
                "176": [0, 0.69444, 0, 0, 0.94888],
                "184": [0.17014, 0, 0, 0, 0.53222],
                "198": [0, 0.68611, 0.11431, 0, 1.02277],
                "216": [0.04861, 0.73472, 0.09062, 0, 0.88555],
                "223": [0.19444, 0.69444, 0.09736, 0, 0.665],
                "230": [0, 0.44444, 0.085, 0, 0.82666],
                "248": [0.09722, 0.54167, 0.09458, 0, 0.59111],
                "305": [0, 0.44444, 0.09426, 0, 0.35555],
                "338": [0, 0.68611, 0.11431, 0, 1.14054],
                "339": [0, 0.44444, 0.085, 0, 0.82666],
                "567": [0.19444, 0.44444, 0.04611, 0, 0.385],
                "710": [0, 0.69444, 0.06709, 0, 0.59111],
                "711": [0, 0.63194, 0.08271, 0, 0.59111],
                "713": [0, 0.59444, 0.10444, 0, 0.59111],
                "714": [0, 0.69444, 0.08528, 0, 0.59111],
                "715": [0, 0.69444, 0, 0, 0.59111],
                "728": [0, 0.69444, 0.10333, 0, 0.59111],
                "729": [0, 0.69444, 0.12945, 0, 0.35555],
                "730": [0, 0.69444, 0, 0, 0.94888],
                "732": [0, 0.69444, 0.11472, 0, 0.59111],
                "733": [0, 0.69444, 0.11472, 0, 0.59111],
                "915": [0, 0.68611, 0.12903, 0, 0.69777],
                "916": [0, 0.68611, 0, 0, 0.94444],
                "920": [0, 0.68611, 0.09062, 0, 0.88555],
                "923": [0, 0.68611, 0, 0, 0.80666],
                "926": [0, 0.68611, 0.15092, 0, 0.76777],
                "928": [0, 0.68611, 0.17208, 0, 0.8961],
                "931": [0, 0.68611, 0.11431, 0, 0.82666],
                "933": [0, 0.68611, 0.10778, 0, 0.88555],
                "934": [0, 0.68611, 0.05632, 0, 0.82666],
                "936": [0, 0.68611, 0.10778, 0, 0.88555],
                "937": [0, 0.68611, 0.0992, 0, 0.82666],
                "8211": [0, 0.44444, 0.09811, 0, 0.59111],
                "8212": [0, 0.44444, 0.09811, 0, 1.18221],
                "8216": [0, 0.69444, 0.12945, 0, 0.35555],
                "8217": [0, 0.69444, 0.12945, 0, 0.35555],
                "8220": [0, 0.69444, 0.16772, 0, 0.62055],
                "8221": [0, 0.69444, 0.07939, 0, 0.62055]
              },
              "Main-Italic": {
                "32": [0, 0, 0, 0, 0.25],
                "33": [0, 0.69444, 0.12417, 0, 0.30667],
                "34": [0, 0.69444, 0.06961, 0, 0.51444],
                "35": [0.19444, 0.69444, 0.06616, 0, 0.81777],
                "37": [0.05556, 0.75, 0.13639, 0, 0.81777],
                "38": [0, 0.69444, 0.09694, 0, 0.76666],
                "39": [0, 0.69444, 0.12417, 0, 0.30667],
                "40": [0.25, 0.75, 0.16194, 0, 0.40889],
                "41": [0.25, 0.75, 0.03694, 0, 0.40889],
                "42": [0, 0.75, 0.14917, 0, 0.51111],
                "43": [0.05667, 0.56167, 0.03694, 0, 0.76666],
                "44": [0.19444, 0.10556, 0, 0, 0.30667],
                "45": [0, 0.43056, 0.02826, 0, 0.35778],
                "46": [0, 0.10556, 0, 0, 0.30667],
                "47": [0.25, 0.75, 0.16194, 0, 0.51111],
                "48": [0, 0.64444, 0.13556, 0, 0.51111],
                "49": [0, 0.64444, 0.13556, 0, 0.51111],
                "50": [0, 0.64444, 0.13556, 0, 0.51111],
                "51": [0, 0.64444, 0.13556, 0, 0.51111],
                "52": [0.19444, 0.64444, 0.13556, 0, 0.51111],
                "53": [0, 0.64444, 0.13556, 0, 0.51111],
                "54": [0, 0.64444, 0.13556, 0, 0.51111],
                "55": [0.19444, 0.64444, 0.13556, 0, 0.51111],
                "56": [0, 0.64444, 0.13556, 0, 0.51111],
                "57": [0, 0.64444, 0.13556, 0, 0.51111],
                "58": [0, 0.43056, 0.0582, 0, 0.30667],
                "59": [0.19444, 0.43056, 0.0582, 0, 0.30667],
                "61": [-0.13313, 0.36687, 0.06616, 0, 0.76666],
                "63": [0, 0.69444, 0.1225, 0, 0.51111],
                "64": [0, 0.69444, 0.09597, 0, 0.76666],
                "65": [0, 0.68333, 0, 0, 0.74333],
                "66": [0, 0.68333, 0.10257, 0, 0.70389],
                "67": [0, 0.68333, 0.14528, 0, 0.71555],
                "68": [0, 0.68333, 0.09403, 0, 0.755],
                "69": [0, 0.68333, 0.12028, 0, 0.67833],
                "70": [0, 0.68333, 0.13305, 0, 0.65277],
                "71": [0, 0.68333, 0.08722, 0, 0.77361],
                "72": [0, 0.68333, 0.16389, 0, 0.74333],
                "73": [0, 0.68333, 0.15806, 0, 0.38555],
                "74": [0, 0.68333, 0.14028, 0, 0.525],
                "75": [0, 0.68333, 0.14528, 0, 0.76888],
                "76": [0, 0.68333, 0, 0, 0.62722],
                "77": [0, 0.68333, 0.16389, 0, 0.89666],
                "78": [0, 0.68333, 0.16389, 0, 0.74333],
                "79": [0, 0.68333, 0.09403, 0, 0.76666],
                "80": [0, 0.68333, 0.10257, 0, 0.67833],
                "81": [0.19444, 0.68333, 0.09403, 0, 0.76666],
                "82": [0, 0.68333, 0.03868, 0, 0.72944],
                "83": [0, 0.68333, 0.11972, 0, 0.56222],
                "84": [0, 0.68333, 0.13305, 0, 0.71555],
                "85": [0, 0.68333, 0.16389, 0, 0.74333],
                "86": [0, 0.68333, 0.18361, 0, 0.74333],
                "87": [0, 0.68333, 0.18361, 0, 0.99888],
                "88": [0, 0.68333, 0.15806, 0, 0.74333],
                "89": [0, 0.68333, 0.19383, 0, 0.74333],
                "90": [0, 0.68333, 0.14528, 0, 0.61333],
                "91": [0.25, 0.75, 0.1875, 0, 0.30667],
                "93": [0.25, 0.75, 0.10528, 0, 0.30667],
                "94": [0, 0.69444, 0.06646, 0, 0.51111],
                "95": [0.31, 0.12056, 0.09208, 0, 0.51111],
                "97": [0, 0.43056, 0.07671, 0, 0.51111],
                "98": [0, 0.69444, 0.06312, 0, 0.46],
                "99": [0, 0.43056, 0.05653, 0, 0.46],
                "100": [0, 0.69444, 0.10333, 0, 0.51111],
                "101": [0, 0.43056, 0.07514, 0, 0.46],
                "102": [0.19444, 0.69444, 0.21194, 0, 0.30667],
                "103": [0.19444, 0.43056, 0.08847, 0, 0.46],
                "104": [0, 0.69444, 0.07671, 0, 0.51111],
                "105": [0, 0.65536, 0.1019, 0, 0.30667],
                "106": [0.19444, 0.65536, 0.14467, 0, 0.30667],
                "107": [0, 0.69444, 0.10764, 0, 0.46],
                "108": [0, 0.69444, 0.10333, 0, 0.25555],
                "109": [0, 0.43056, 0.07671, 0, 0.81777],
                "110": [0, 0.43056, 0.07671, 0, 0.56222],
                "111": [0, 0.43056, 0.06312, 0, 0.51111],
                "112": [0.19444, 0.43056, 0.06312, 0, 0.51111],
                "113": [0.19444, 0.43056, 0.08847, 0, 0.46],
                "114": [0, 0.43056, 0.10764, 0, 0.42166],
                "115": [0, 0.43056, 0.08208, 0, 0.40889],
                "116": [0, 0.61508, 0.09486, 0, 0.33222],
                "117": [0, 0.43056, 0.07671, 0, 0.53666],
                "118": [0, 0.43056, 0.10764, 0, 0.46],
                "119": [0, 0.43056, 0.10764, 0, 0.66444],
                "120": [0, 0.43056, 0.12042, 0, 0.46389],
                "121": [0.19444, 0.43056, 0.08847, 0, 0.48555],
                "122": [0, 0.43056, 0.12292, 0, 0.40889],
                "126": [0.35, 0.31786, 0.11585, 0, 0.51111],
                "160": [0, 0, 0, 0, 0.25],
                "168": [0, 0.66786, 0.10474, 0, 0.51111],
                "176": [0, 0.69444, 0, 0, 0.83129],
                "184": [0.17014, 0, 0, 0, 0.46],
                "198": [0, 0.68333, 0.12028, 0, 0.88277],
                "216": [0.04861, 0.73194, 0.09403, 0, 0.76666],
                "223": [0.19444, 0.69444, 0.10514, 0, 0.53666],
                "230": [0, 0.43056, 0.07514, 0, 0.71555],
                "248": [0.09722, 0.52778, 0.09194, 0, 0.51111],
                "338": [0, 0.68333, 0.12028, 0, 0.98499],
                "339": [0, 0.43056, 0.07514, 0, 0.71555],
                "710": [0, 0.69444, 0.06646, 0, 0.51111],
                "711": [0, 0.62847, 0.08295, 0, 0.51111],
                "713": [0, 0.56167, 0.10333, 0, 0.51111],
                "714": [0, 0.69444, 0.09694, 0, 0.51111],
                "715": [0, 0.69444, 0, 0, 0.51111],
                "728": [0, 0.69444, 0.10806, 0, 0.51111],
                "729": [0, 0.66786, 0.11752, 0, 0.30667],
                "730": [0, 0.69444, 0, 0, 0.83129],
                "732": [0, 0.66786, 0.11585, 0, 0.51111],
                "733": [0, 0.69444, 0.1225, 0, 0.51111],
                "915": [0, 0.68333, 0.13305, 0, 0.62722],
                "916": [0, 0.68333, 0, 0, 0.81777],
                "920": [0, 0.68333, 0.09403, 0, 0.76666],
                "923": [0, 0.68333, 0, 0, 0.69222],
                "926": [0, 0.68333, 0.15294, 0, 0.66444],
                "928": [0, 0.68333, 0.16389, 0, 0.74333],
                "931": [0, 0.68333, 0.12028, 0, 0.71555],
                "933": [0, 0.68333, 0.11111, 0, 0.76666],
                "934": [0, 0.68333, 0.05986, 0, 0.71555],
                "936": [0, 0.68333, 0.11111, 0, 0.76666],
                "937": [0, 0.68333, 0.10257, 0, 0.71555],
                "8211": [0, 0.43056, 0.09208, 0, 0.51111],
                "8212": [0, 0.43056, 0.09208, 0, 1.02222],
                "8216": [0, 0.69444, 0.12417, 0, 0.30667],
                "8217": [0, 0.69444, 0.12417, 0, 0.30667],
                "8220": [0, 0.69444, 0.1685, 0, 0.51444],
                "8221": [0, 0.69444, 0.06961, 0, 0.51444],
                "8463": [0, 0.68889, 0, 0, 0.54028]
              },
              "Main-Regular": {
                "32": [0, 0, 0, 0, 0.25],
                "33": [0, 0.69444, 0, 0, 0.27778],
                "34": [0, 0.69444, 0, 0, 0.5],
                "35": [0.19444, 0.69444, 0, 0, 0.83334],
                "36": [0.05556, 0.75, 0, 0, 0.5],
                "37": [0.05556, 0.75, 0, 0, 0.83334],
                "38": [0, 0.69444, 0, 0, 0.77778],
                "39": [0, 0.69444, 0, 0, 0.27778],
                "40": [0.25, 0.75, 0, 0, 0.38889],
                "41": [0.25, 0.75, 0, 0, 0.38889],
                "42": [0, 0.75, 0, 0, 0.5],
                "43": [0.08333, 0.58333, 0, 0, 0.77778],
                "44": [0.19444, 0.10556, 0, 0, 0.27778],
                "45": [0, 0.43056, 0, 0, 0.33333],
                "46": [0, 0.10556, 0, 0, 0.27778],
                "47": [0.25, 0.75, 0, 0, 0.5],
                "48": [0, 0.64444, 0, 0, 0.5],
                "49": [0, 0.64444, 0, 0, 0.5],
                "50": [0, 0.64444, 0, 0, 0.5],
                "51": [0, 0.64444, 0, 0, 0.5],
                "52": [0, 0.64444, 0, 0, 0.5],
                "53": [0, 0.64444, 0, 0, 0.5],
                "54": [0, 0.64444, 0, 0, 0.5],
                "55": [0, 0.64444, 0, 0, 0.5],
                "56": [0, 0.64444, 0, 0, 0.5],
                "57": [0, 0.64444, 0, 0, 0.5],
                "58": [0, 0.43056, 0, 0, 0.27778],
                "59": [0.19444, 0.43056, 0, 0, 0.27778],
                "60": [0.0391, 0.5391, 0, 0, 0.77778],
                "61": [-0.13313, 0.36687, 0, 0, 0.77778],
                "62": [0.0391, 0.5391, 0, 0, 0.77778],
                "63": [0, 0.69444, 0, 0, 0.47222],
                "64": [0, 0.69444, 0, 0, 0.77778],
                "65": [0, 0.68333, 0, 0, 0.75],
                "66": [0, 0.68333, 0, 0, 0.70834],
                "67": [0, 0.68333, 0, 0, 0.72222],
                "68": [0, 0.68333, 0, 0, 0.76389],
                "69": [0, 0.68333, 0, 0, 0.68056],
                "70": [0, 0.68333, 0, 0, 0.65278],
                "71": [0, 0.68333, 0, 0, 0.78472],
                "72": [0, 0.68333, 0, 0, 0.75],
                "73": [0, 0.68333, 0, 0, 0.36111],
                "74": [0, 0.68333, 0, 0, 0.51389],
                "75": [0, 0.68333, 0, 0, 0.77778],
                "76": [0, 0.68333, 0, 0, 0.625],
                "77": [0, 0.68333, 0, 0, 0.91667],
                "78": [0, 0.68333, 0, 0, 0.75],
                "79": [0, 0.68333, 0, 0, 0.77778],
                "80": [0, 0.68333, 0, 0, 0.68056],
                "81": [0.19444, 0.68333, 0, 0, 0.77778],
                "82": [0, 0.68333, 0, 0, 0.73611],
                "83": [0, 0.68333, 0, 0, 0.55556],
                "84": [0, 0.68333, 0, 0, 0.72222],
                "85": [0, 0.68333, 0, 0, 0.75],
                "86": [0, 0.68333, 0.01389, 0, 0.75],
                "87": [0, 0.68333, 0.01389, 0, 1.02778],
                "88": [0, 0.68333, 0, 0, 0.75],
                "89": [0, 0.68333, 0.025, 0, 0.75],
                "90": [0, 0.68333, 0, 0, 0.61111],
                "91": [0.25, 0.75, 0, 0, 0.27778],
                "92": [0.25, 0.75, 0, 0, 0.5],
                "93": [0.25, 0.75, 0, 0, 0.27778],
                "94": [0, 0.69444, 0, 0, 0.5],
                "95": [0.31, 0.12056, 0.02778, 0, 0.5],
                "97": [0, 0.43056, 0, 0, 0.5],
                "98": [0, 0.69444, 0, 0, 0.55556],
                "99": [0, 0.43056, 0, 0, 0.44445],
                "100": [0, 0.69444, 0, 0, 0.55556],
                "101": [0, 0.43056, 0, 0, 0.44445],
                "102": [0, 0.69444, 0.07778, 0, 0.30556],
                "103": [0.19444, 0.43056, 0.01389, 0, 0.5],
                "104": [0, 0.69444, 0, 0, 0.55556],
                "105": [0, 0.66786, 0, 0, 0.27778],
                "106": [0.19444, 0.66786, 0, 0, 0.30556],
                "107": [0, 0.69444, 0, 0, 0.52778],
                "108": [0, 0.69444, 0, 0, 0.27778],
                "109": [0, 0.43056, 0, 0, 0.83334],
                "110": [0, 0.43056, 0, 0, 0.55556],
                "111": [0, 0.43056, 0, 0, 0.5],
                "112": [0.19444, 0.43056, 0, 0, 0.55556],
                "113": [0.19444, 0.43056, 0, 0, 0.52778],
                "114": [0, 0.43056, 0, 0, 0.39167],
                "115": [0, 0.43056, 0, 0, 0.39445],
                "116": [0, 0.61508, 0, 0, 0.38889],
                "117": [0, 0.43056, 0, 0, 0.55556],
                "118": [0, 0.43056, 0.01389, 0, 0.52778],
                "119": [0, 0.43056, 0.01389, 0, 0.72222],
                "120": [0, 0.43056, 0, 0, 0.52778],
                "121": [0.19444, 0.43056, 0.01389, 0, 0.52778],
                "122": [0, 0.43056, 0, 0, 0.44445],
                "123": [0.25, 0.75, 0, 0, 0.5],
                "124": [0.25, 0.75, 0, 0, 0.27778],
                "125": [0.25, 0.75, 0, 0, 0.5],
                "126": [0.35, 0.31786, 0, 0, 0.5],
                "160": [0, 0, 0, 0, 0.25],
                "163": [0, 0.69444, 0, 0, 0.76909],
                "167": [0.19444, 0.69444, 0, 0, 0.44445],
                "168": [0, 0.66786, 0, 0, 0.5],
                "172": [0, 0.43056, 0, 0, 0.66667],
                "176": [0, 0.69444, 0, 0, 0.75],
                "177": [0.08333, 0.58333, 0, 0, 0.77778],
                "182": [0.19444, 0.69444, 0, 0, 0.61111],
                "184": [0.17014, 0, 0, 0, 0.44445],
                "198": [0, 0.68333, 0, 0, 0.90278],
                "215": [0.08333, 0.58333, 0, 0, 0.77778],
                "216": [0.04861, 0.73194, 0, 0, 0.77778],
                "223": [0, 0.69444, 0, 0, 0.5],
                "230": [0, 0.43056, 0, 0, 0.72222],
                "247": [0.08333, 0.58333, 0, 0, 0.77778],
                "248": [0.09722, 0.52778, 0, 0, 0.5],
                "305": [0, 0.43056, 0, 0, 0.27778],
                "338": [0, 0.68333, 0, 0, 1.01389],
                "339": [0, 0.43056, 0, 0, 0.77778],
                "567": [0.19444, 0.43056, 0, 0, 0.30556],
                "710": [0, 0.69444, 0, 0, 0.5],
                "711": [0, 0.62847, 0, 0, 0.5],
                "713": [0, 0.56778, 0, 0, 0.5],
                "714": [0, 0.69444, 0, 0, 0.5],
                "715": [0, 0.69444, 0, 0, 0.5],
                "728": [0, 0.69444, 0, 0, 0.5],
                "729": [0, 0.66786, 0, 0, 0.27778],
                "730": [0, 0.69444, 0, 0, 0.75],
                "732": [0, 0.66786, 0, 0, 0.5],
                "733": [0, 0.69444, 0, 0, 0.5],
                "915": [0, 0.68333, 0, 0, 0.625],
                "916": [0, 0.68333, 0, 0, 0.83334],
                "920": [0, 0.68333, 0, 0, 0.77778],
                "923": [0, 0.68333, 0, 0, 0.69445],
                "926": [0, 0.68333, 0, 0, 0.66667],
                "928": [0, 0.68333, 0, 0, 0.75],
                "931": [0, 0.68333, 0, 0, 0.72222],
                "933": [0, 0.68333, 0, 0, 0.77778],
                "934": [0, 0.68333, 0, 0, 0.72222],
                "936": [0, 0.68333, 0, 0, 0.77778],
                "937": [0, 0.68333, 0, 0, 0.72222],
                "8211": [0, 0.43056, 0.02778, 0, 0.5],
                "8212": [0, 0.43056, 0.02778, 0, 1],
                "8216": [0, 0.69444, 0, 0, 0.27778],
                "8217": [0, 0.69444, 0, 0, 0.27778],
                "8220": [0, 0.69444, 0, 0, 0.5],
                "8221": [0, 0.69444, 0, 0, 0.5],
                "8224": [0.19444, 0.69444, 0, 0, 0.44445],
                "8225": [0.19444, 0.69444, 0, 0, 0.44445],
                "8230": [0, 0.12, 0, 0, 1.172],
                "8242": [0, 0.55556, 0, 0, 0.275],
                "8407": [0, 0.71444, 0.15382, 0, 0.5],
                "8463": [0, 0.68889, 0, 0, 0.54028],
                "8465": [0, 0.69444, 0, 0, 0.72222],
                "8467": [0, 0.69444, 0, 0.11111, 0.41667],
                "8472": [0.19444, 0.43056, 0, 0.11111, 0.63646],
                "8476": [0, 0.69444, 0, 0, 0.72222],
                "8501": [0, 0.69444, 0, 0, 0.61111],
                "8592": [-0.13313, 0.36687, 0, 0, 1],
                "8593": [0.19444, 0.69444, 0, 0, 0.5],
                "8594": [-0.13313, 0.36687, 0, 0, 1],
                "8595": [0.19444, 0.69444, 0, 0, 0.5],
                "8596": [-0.13313, 0.36687, 0, 0, 1],
                "8597": [0.25, 0.75, 0, 0, 0.5],
                "8598": [0.19444, 0.69444, 0, 0, 1],
                "8599": [0.19444, 0.69444, 0, 0, 1],
                "8600": [0.19444, 0.69444, 0, 0, 1],
                "8601": [0.19444, 0.69444, 0, 0, 1],
                "8614": [0.011, 0.511, 0, 0, 1],
                "8617": [0.011, 0.511, 0, 0, 1.126],
                "8618": [0.011, 0.511, 0, 0, 1.126],
                "8636": [-0.13313, 0.36687, 0, 0, 1],
                "8637": [-0.13313, 0.36687, 0, 0, 1],
                "8640": [-0.13313, 0.36687, 0, 0, 1],
                "8641": [-0.13313, 0.36687, 0, 0, 1],
                "8652": [0.011, 0.671, 0, 0, 1],
                "8656": [-0.13313, 0.36687, 0, 0, 1],
                "8657": [0.19444, 0.69444, 0, 0, 0.61111],
                "8658": [-0.13313, 0.36687, 0, 0, 1],
                "8659": [0.19444, 0.69444, 0, 0, 0.61111],
                "8660": [-0.13313, 0.36687, 0, 0, 1],
                "8661": [0.25, 0.75, 0, 0, 0.61111],
                "8704": [0, 0.69444, 0, 0, 0.55556],
                "8706": [0, 0.69444, 0.05556, 0.08334, 0.5309],
                "8707": [0, 0.69444, 0, 0, 0.55556],
                "8709": [0.05556, 0.75, 0, 0, 0.5],
                "8711": [0, 0.68333, 0, 0, 0.83334],
                "8712": [0.0391, 0.5391, 0, 0, 0.66667],
                "8715": [0.0391, 0.5391, 0, 0, 0.66667],
                "8722": [0.08333, 0.58333, 0, 0, 0.77778],
                "8723": [0.08333, 0.58333, 0, 0, 0.77778],
                "8725": [0.25, 0.75, 0, 0, 0.5],
                "8726": [0.25, 0.75, 0, 0, 0.5],
                "8727": [-0.03472, 0.46528, 0, 0, 0.5],
                "8728": [-0.05555, 0.44445, 0, 0, 0.5],
                "8729": [-0.05555, 0.44445, 0, 0, 0.5],
                "8730": [0.2, 0.8, 0, 0, 0.83334],
                "8733": [0, 0.43056, 0, 0, 0.77778],
                "8734": [0, 0.43056, 0, 0, 1],
                "8736": [0, 0.69224, 0, 0, 0.72222],
                "8739": [0.25, 0.75, 0, 0, 0.27778],
                "8741": [0.25, 0.75, 0, 0, 0.5],
                "8743": [0, 0.55556, 0, 0, 0.66667],
                "8744": [0, 0.55556, 0, 0, 0.66667],
                "8745": [0, 0.55556, 0, 0, 0.66667],
                "8746": [0, 0.55556, 0, 0, 0.66667],
                "8747": [0.19444, 0.69444, 0.11111, 0, 0.41667],
                "8764": [-0.13313, 0.36687, 0, 0, 0.77778],
                "8768": [0.19444, 0.69444, 0, 0, 0.27778],
                "8771": [-0.03625, 0.46375, 0, 0, 0.77778],
                "8773": [-0.022, 0.589, 0, 0, 1],
                "8776": [-0.01688, 0.48312, 0, 0, 0.77778],
                "8781": [-0.03625, 0.46375, 0, 0, 0.77778],
                "8784": [-0.133, 0.67, 0, 0, 0.778],
                "8801": [-0.03625, 0.46375, 0, 0, 0.77778],
                "8804": [0.13597, 0.63597, 0, 0, 0.77778],
                "8805": [0.13597, 0.63597, 0, 0, 0.77778],
                "8810": [0.0391, 0.5391, 0, 0, 1],
                "8811": [0.0391, 0.5391, 0, 0, 1],
                "8826": [0.0391, 0.5391, 0, 0, 0.77778],
                "8827": [0.0391, 0.5391, 0, 0, 0.77778],
                "8834": [0.0391, 0.5391, 0, 0, 0.77778],
                "8835": [0.0391, 0.5391, 0, 0, 0.77778],
                "8838": [0.13597, 0.63597, 0, 0, 0.77778],
                "8839": [0.13597, 0.63597, 0, 0, 0.77778],
                "8846": [0, 0.55556, 0, 0, 0.66667],
                "8849": [0.13597, 0.63597, 0, 0, 0.77778],
                "8850": [0.13597, 0.63597, 0, 0, 0.77778],
                "8851": [0, 0.55556, 0, 0, 0.66667],
                "8852": [0, 0.55556, 0, 0, 0.66667],
                "8853": [0.08333, 0.58333, 0, 0, 0.77778],
                "8854": [0.08333, 0.58333, 0, 0, 0.77778],
                "8855": [0.08333, 0.58333, 0, 0, 0.77778],
                "8856": [0.08333, 0.58333, 0, 0, 0.77778],
                "8857": [0.08333, 0.58333, 0, 0, 0.77778],
                "8866": [0, 0.69444, 0, 0, 0.61111],
                "8867": [0, 0.69444, 0, 0, 0.61111],
                "8868": [0, 0.69444, 0, 0, 0.77778],
                "8869": [0, 0.69444, 0, 0, 0.77778],
                "8872": [0.249, 0.75, 0, 0, 0.867],
                "8900": [-0.05555, 0.44445, 0, 0, 0.5],
                "8901": [-0.05555, 0.44445, 0, 0, 0.27778],
                "8902": [-0.03472, 0.46528, 0, 0, 0.5],
                "8904": [5e-3, 0.505, 0, 0, 0.9],
                "8942": [0.03, 0.9, 0, 0, 0.278],
                "8943": [-0.19, 0.31, 0, 0, 1.172],
                "8945": [-0.1, 0.82, 0, 0, 1.282],
                "8968": [0.25, 0.75, 0, 0, 0.44445],
                "8969": [0.25, 0.75, 0, 0, 0.44445],
                "8970": [0.25, 0.75, 0, 0, 0.44445],
                "8971": [0.25, 0.75, 0, 0, 0.44445],
                "8994": [-0.14236, 0.35764, 0, 0, 1],
                "8995": [-0.14236, 0.35764, 0, 0, 1],
                "9136": [0.244, 0.744, 0, 0, 0.412],
                "9137": [0.244, 0.744, 0, 0, 0.412],
                "9651": [0.19444, 0.69444, 0, 0, 0.88889],
                "9657": [-0.03472, 0.46528, 0, 0, 0.5],
                "9661": [0.19444, 0.69444, 0, 0, 0.88889],
                "9667": [-0.03472, 0.46528, 0, 0, 0.5],
                "9711": [0.19444, 0.69444, 0, 0, 1],
                "9824": [0.12963, 0.69444, 0, 0, 0.77778],
                "9825": [0.12963, 0.69444, 0, 0, 0.77778],
                "9826": [0.12963, 0.69444, 0, 0, 0.77778],
                "9827": [0.12963, 0.69444, 0, 0, 0.77778],
                "9837": [0, 0.75, 0, 0, 0.38889],
                "9838": [0.19444, 0.69444, 0, 0, 0.38889],
                "9839": [0.19444, 0.69444, 0, 0, 0.38889],
                "10216": [0.25, 0.75, 0, 0, 0.38889],
                "10217": [0.25, 0.75, 0, 0, 0.38889],
                "10222": [0.244, 0.744, 0, 0, 0.412],
                "10223": [0.244, 0.744, 0, 0, 0.412],
                "10229": [0.011, 0.511, 0, 0, 1.609],
                "10230": [0.011, 0.511, 0, 0, 1.638],
                "10231": [0.011, 0.511, 0, 0, 1.859],
                "10232": [0.024, 0.525, 0, 0, 1.609],
                "10233": [0.024, 0.525, 0, 0, 1.638],
                "10234": [0.024, 0.525, 0, 0, 1.858],
                "10236": [0.011, 0.511, 0, 0, 1.638],
                "10815": [0, 0.68333, 0, 0, 0.75],
                "10927": [0.13597, 0.63597, 0, 0, 0.77778],
                "10928": [0.13597, 0.63597, 0, 0, 0.77778],
                "57376": [0.19444, 0.69444, 0, 0, 0]
              },
              "Math-BoldItalic": {
                "32": [0, 0, 0, 0, 0.25],
                "48": [0, 0.44444, 0, 0, 0.575],
                "49": [0, 0.44444, 0, 0, 0.575],
                "50": [0, 0.44444, 0, 0, 0.575],
                "51": [0.19444, 0.44444, 0, 0, 0.575],
                "52": [0.19444, 0.44444, 0, 0, 0.575],
                "53": [0.19444, 0.44444, 0, 0, 0.575],
                "54": [0, 0.64444, 0, 0, 0.575],
                "55": [0.19444, 0.44444, 0, 0, 0.575],
                "56": [0, 0.64444, 0, 0, 0.575],
                "57": [0.19444, 0.44444, 0, 0, 0.575],
                "65": [0, 0.68611, 0, 0, 0.86944],
                "66": [0, 0.68611, 0.04835, 0, 0.8664],
                "67": [0, 0.68611, 0.06979, 0, 0.81694],
                "68": [0, 0.68611, 0.03194, 0, 0.93812],
                "69": [0, 0.68611, 0.05451, 0, 0.81007],
                "70": [0, 0.68611, 0.15972, 0, 0.68889],
                "71": [0, 0.68611, 0, 0, 0.88673],
                "72": [0, 0.68611, 0.08229, 0, 0.98229],
                "73": [0, 0.68611, 0.07778, 0, 0.51111],
                "74": [0, 0.68611, 0.10069, 0, 0.63125],
                "75": [0, 0.68611, 0.06979, 0, 0.97118],
                "76": [0, 0.68611, 0, 0, 0.75555],
                "77": [0, 0.68611, 0.11424, 0, 1.14201],
                "78": [0, 0.68611, 0.11424, 0, 0.95034],
                "79": [0, 0.68611, 0.03194, 0, 0.83666],
                "80": [0, 0.68611, 0.15972, 0, 0.72309],
                "81": [0.19444, 0.68611, 0, 0, 0.86861],
                "82": [0, 0.68611, 421e-5, 0, 0.87235],
                "83": [0, 0.68611, 0.05382, 0, 0.69271],
                "84": [0, 0.68611, 0.15972, 0, 0.63663],
                "85": [0, 0.68611, 0.11424, 0, 0.80027],
                "86": [0, 0.68611, 0.25555, 0, 0.67778],
                "87": [0, 0.68611, 0.15972, 0, 1.09305],
                "88": [0, 0.68611, 0.07778, 0, 0.94722],
                "89": [0, 0.68611, 0.25555, 0, 0.67458],
                "90": [0, 0.68611, 0.06979, 0, 0.77257],
                "97": [0, 0.44444, 0, 0, 0.63287],
                "98": [0, 0.69444, 0, 0, 0.52083],
                "99": [0, 0.44444, 0, 0, 0.51342],
                "100": [0, 0.69444, 0, 0, 0.60972],
                "101": [0, 0.44444, 0, 0, 0.55361],
                "102": [0.19444, 0.69444, 0.11042, 0, 0.56806],
                "103": [0.19444, 0.44444, 0.03704, 0, 0.5449],
                "104": [0, 0.69444, 0, 0, 0.66759],
                "105": [0, 0.69326, 0, 0, 0.4048],
                "106": [0.19444, 0.69326, 0.0622, 0, 0.47083],
                "107": [0, 0.69444, 0.01852, 0, 0.6037],
                "108": [0, 0.69444, 88e-4, 0, 0.34815],
                "109": [0, 0.44444, 0, 0, 1.0324],
                "110": [0, 0.44444, 0, 0, 0.71296],
                "111": [0, 0.44444, 0, 0, 0.58472],
                "112": [0.19444, 0.44444, 0, 0, 0.60092],
                "113": [0.19444, 0.44444, 0.03704, 0, 0.54213],
                "114": [0, 0.44444, 0.03194, 0, 0.5287],
                "115": [0, 0.44444, 0, 0, 0.53125],
                "116": [0, 0.63492, 0, 0, 0.41528],
                "117": [0, 0.44444, 0, 0, 0.68102],
                "118": [0, 0.44444, 0.03704, 0, 0.56666],
                "119": [0, 0.44444, 0.02778, 0, 0.83148],
                "120": [0, 0.44444, 0, 0, 0.65903],
                "121": [0.19444, 0.44444, 0.03704, 0, 0.59028],
                "122": [0, 0.44444, 0.04213, 0, 0.55509],
                "160": [0, 0, 0, 0, 0.25],
                "915": [0, 0.68611, 0.15972, 0, 0.65694],
                "916": [0, 0.68611, 0, 0, 0.95833],
                "920": [0, 0.68611, 0.03194, 0, 0.86722],
                "923": [0, 0.68611, 0, 0, 0.80555],
                "926": [0, 0.68611, 0.07458, 0, 0.84125],
                "928": [0, 0.68611, 0.08229, 0, 0.98229],
                "931": [0, 0.68611, 0.05451, 0, 0.88507],
                "933": [0, 0.68611, 0.15972, 0, 0.67083],
                "934": [0, 0.68611, 0, 0, 0.76666],
                "936": [0, 0.68611, 0.11653, 0, 0.71402],
                "937": [0, 0.68611, 0.04835, 0, 0.8789],
                "945": [0, 0.44444, 0, 0, 0.76064],
                "946": [0.19444, 0.69444, 0.03403, 0, 0.65972],
                "947": [0.19444, 0.44444, 0.06389, 0, 0.59003],
                "948": [0, 0.69444, 0.03819, 0, 0.52222],
                "949": [0, 0.44444, 0, 0, 0.52882],
                "950": [0.19444, 0.69444, 0.06215, 0, 0.50833],
                "951": [0.19444, 0.44444, 0.03704, 0, 0.6],
                "952": [0, 0.69444, 0.03194, 0, 0.5618],
                "953": [0, 0.44444, 0, 0, 0.41204],
                "954": [0, 0.44444, 0, 0, 0.66759],
                "955": [0, 0.69444, 0, 0, 0.67083],
                "956": [0.19444, 0.44444, 0, 0, 0.70787],
                "957": [0, 0.44444, 0.06898, 0, 0.57685],
                "958": [0.19444, 0.69444, 0.03021, 0, 0.50833],
                "959": [0, 0.44444, 0, 0, 0.58472],
                "960": [0, 0.44444, 0.03704, 0, 0.68241],
                "961": [0.19444, 0.44444, 0, 0, 0.6118],
                "962": [0.09722, 0.44444, 0.07917, 0, 0.42361],
                "963": [0, 0.44444, 0.03704, 0, 0.68588],
                "964": [0, 0.44444, 0.13472, 0, 0.52083],
                "965": [0, 0.44444, 0.03704, 0, 0.63055],
                "966": [0.19444, 0.44444, 0, 0, 0.74722],
                "967": [0.19444, 0.44444, 0, 0, 0.71805],
                "968": [0.19444, 0.69444, 0.03704, 0, 0.75833],
                "969": [0, 0.44444, 0.03704, 0, 0.71782],
                "977": [0, 0.69444, 0, 0, 0.69155],
                "981": [0.19444, 0.69444, 0, 0, 0.7125],
                "982": [0, 0.44444, 0.03194, 0, 0.975],
                "1009": [0.19444, 0.44444, 0, 0, 0.6118],
                "1013": [0, 0.44444, 0, 0, 0.48333],
                "57649": [0, 0.44444, 0, 0, 0.39352],
                "57911": [0.19444, 0.44444, 0, 0, 0.43889]
              },
              "Math-Italic": {
                "32": [0, 0, 0, 0, 0.25],
                "48": [0, 0.43056, 0, 0, 0.5],
                "49": [0, 0.43056, 0, 0, 0.5],
                "50": [0, 0.43056, 0, 0, 0.5],
                "51": [0.19444, 0.43056, 0, 0, 0.5],
                "52": [0.19444, 0.43056, 0, 0, 0.5],
                "53": [0.19444, 0.43056, 0, 0, 0.5],
                "54": [0, 0.64444, 0, 0, 0.5],
                "55": [0.19444, 0.43056, 0, 0, 0.5],
                "56": [0, 0.64444, 0, 0, 0.5],
                "57": [0.19444, 0.43056, 0, 0, 0.5],
                "65": [0, 0.68333, 0, 0.13889, 0.75],
                "66": [0, 0.68333, 0.05017, 0.08334, 0.75851],
                "67": [0, 0.68333, 0.07153, 0.08334, 0.71472],
                "68": [0, 0.68333, 0.02778, 0.05556, 0.82792],
                "69": [0, 0.68333, 0.05764, 0.08334, 0.7382],
                "70": [0, 0.68333, 0.13889, 0.08334, 0.64306],
                "71": [0, 0.68333, 0, 0.08334, 0.78625],
                "72": [0, 0.68333, 0.08125, 0.05556, 0.83125],
                "73": [0, 0.68333, 0.07847, 0.11111, 0.43958],
                "74": [0, 0.68333, 0.09618, 0.16667, 0.55451],
                "75": [0, 0.68333, 0.07153, 0.05556, 0.84931],
                "76": [0, 0.68333, 0, 0.02778, 0.68056],
                "77": [0, 0.68333, 0.10903, 0.08334, 0.97014],
                "78": [0, 0.68333, 0.10903, 0.08334, 0.80347],
                "79": [0, 0.68333, 0.02778, 0.08334, 0.76278],
                "80": [0, 0.68333, 0.13889, 0.08334, 0.64201],
                "81": [0.19444, 0.68333, 0, 0.08334, 0.79056],
                "82": [0, 0.68333, 773e-5, 0.08334, 0.75929],
                "83": [0, 0.68333, 0.05764, 0.08334, 0.6132],
                "84": [0, 0.68333, 0.13889, 0.08334, 0.58438],
                "85": [0, 0.68333, 0.10903, 0.02778, 0.68278],
                "86": [0, 0.68333, 0.22222, 0, 0.58333],
                "87": [0, 0.68333, 0.13889, 0, 0.94445],
                "88": [0, 0.68333, 0.07847, 0.08334, 0.82847],
                "89": [0, 0.68333, 0.22222, 0, 0.58056],
                "90": [0, 0.68333, 0.07153, 0.08334, 0.68264],
                "97": [0, 0.43056, 0, 0, 0.52859],
                "98": [0, 0.69444, 0, 0, 0.42917],
                "99": [0, 0.43056, 0, 0.05556, 0.43276],
                "100": [0, 0.69444, 0, 0.16667, 0.52049],
                "101": [0, 0.43056, 0, 0.05556, 0.46563],
                "102": [0.19444, 0.69444, 0.10764, 0.16667, 0.48959],
                "103": [0.19444, 0.43056, 0.03588, 0.02778, 0.47697],
                "104": [0, 0.69444, 0, 0, 0.57616],
                "105": [0, 0.65952, 0, 0, 0.34451],
                "106": [0.19444, 0.65952, 0.05724, 0, 0.41181],
                "107": [0, 0.69444, 0.03148, 0, 0.5206],
                "108": [0, 0.69444, 0.01968, 0.08334, 0.29838],
                "109": [0, 0.43056, 0, 0, 0.87801],
                "110": [0, 0.43056, 0, 0, 0.60023],
                "111": [0, 0.43056, 0, 0.05556, 0.48472],
                "112": [0.19444, 0.43056, 0, 0.08334, 0.50313],
                "113": [0.19444, 0.43056, 0.03588, 0.08334, 0.44641],
                "114": [0, 0.43056, 0.02778, 0.05556, 0.45116],
                "115": [0, 0.43056, 0, 0.05556, 0.46875],
                "116": [0, 0.61508, 0, 0.08334, 0.36111],
                "117": [0, 0.43056, 0, 0.02778, 0.57246],
                "118": [0, 0.43056, 0.03588, 0.02778, 0.48472],
                "119": [0, 0.43056, 0.02691, 0.08334, 0.71592],
                "120": [0, 0.43056, 0, 0.02778, 0.57153],
                "121": [0.19444, 0.43056, 0.03588, 0.05556, 0.49028],
                "122": [0, 0.43056, 0.04398, 0.05556, 0.46505],
                "160": [0, 0, 0, 0, 0.25],
                "915": [0, 0.68333, 0.13889, 0.08334, 0.61528],
                "916": [0, 0.68333, 0, 0.16667, 0.83334],
                "920": [0, 0.68333, 0.02778, 0.08334, 0.76278],
                "923": [0, 0.68333, 0, 0.16667, 0.69445],
                "926": [0, 0.68333, 0.07569, 0.08334, 0.74236],
                "928": [0, 0.68333, 0.08125, 0.05556, 0.83125],
                "931": [0, 0.68333, 0.05764, 0.08334, 0.77986],
                "933": [0, 0.68333, 0.13889, 0.05556, 0.58333],
                "934": [0, 0.68333, 0, 0.08334, 0.66667],
                "936": [0, 0.68333, 0.11, 0.05556, 0.61222],
                "937": [0, 0.68333, 0.05017, 0.08334, 0.7724],
                "945": [0, 0.43056, 37e-4, 0.02778, 0.6397],
                "946": [0.19444, 0.69444, 0.05278, 0.08334, 0.56563],
                "947": [0.19444, 0.43056, 0.05556, 0, 0.51773],
                "948": [0, 0.69444, 0.03785, 0.05556, 0.44444],
                "949": [0, 0.43056, 0, 0.08334, 0.46632],
                "950": [0.19444, 0.69444, 0.07378, 0.08334, 0.4375],
                "951": [0.19444, 0.43056, 0.03588, 0.05556, 0.49653],
                "952": [0, 0.69444, 0.02778, 0.08334, 0.46944],
                "953": [0, 0.43056, 0, 0.05556, 0.35394],
                "954": [0, 0.43056, 0, 0, 0.57616],
                "955": [0, 0.69444, 0, 0, 0.58334],
                "956": [0.19444, 0.43056, 0, 0.02778, 0.60255],
                "957": [0, 0.43056, 0.06366, 0.02778, 0.49398],
                "958": [0.19444, 0.69444, 0.04601, 0.11111, 0.4375],
                "959": [0, 0.43056, 0, 0.05556, 0.48472],
                "960": [0, 0.43056, 0.03588, 0, 0.57003],
                "961": [0.19444, 0.43056, 0, 0.08334, 0.51702],
                "962": [0.09722, 0.43056, 0.07986, 0.08334, 0.36285],
                "963": [0, 0.43056, 0.03588, 0, 0.57141],
                "964": [0, 0.43056, 0.1132, 0.02778, 0.43715],
                "965": [0, 0.43056, 0.03588, 0.02778, 0.54028],
                "966": [0.19444, 0.43056, 0, 0.08334, 0.65417],
                "967": [0.19444, 0.43056, 0, 0.05556, 0.62569],
                "968": [0.19444, 0.69444, 0.03588, 0.11111, 0.65139],
                "969": [0, 0.43056, 0.03588, 0, 0.62245],
                "977": [0, 0.69444, 0, 0.08334, 0.59144],
                "981": [0.19444, 0.69444, 0, 0.08334, 0.59583],
                "982": [0, 0.43056, 0.02778, 0, 0.82813],
                "1009": [0.19444, 0.43056, 0, 0.08334, 0.51702],
                "1013": [0, 0.43056, 0, 0.05556, 0.4059],
                "57649": [0, 0.43056, 0, 0.02778, 0.32246],
                "57911": [0.19444, 0.43056, 0, 0.08334, 0.38403]
              },
              "SansSerif-Bold": {
                "32": [0, 0, 0, 0, 0.25],
                "33": [0, 0.69444, 0, 0, 0.36667],
                "34": [0, 0.69444, 0, 0, 0.55834],
                "35": [0.19444, 0.69444, 0, 0, 0.91667],
                "36": [0.05556, 0.75, 0, 0, 0.55],
                "37": [0.05556, 0.75, 0, 0, 1.02912],
                "38": [0, 0.69444, 0, 0, 0.83056],
                "39": [0, 0.69444, 0, 0, 0.30556],
                "40": [0.25, 0.75, 0, 0, 0.42778],
                "41": [0.25, 0.75, 0, 0, 0.42778],
                "42": [0, 0.75, 0, 0, 0.55],
                "43": [0.11667, 0.61667, 0, 0, 0.85556],
                "44": [0.10556, 0.13056, 0, 0, 0.30556],
                "45": [0, 0.45833, 0, 0, 0.36667],
                "46": [0, 0.13056, 0, 0, 0.30556],
                "47": [0.25, 0.75, 0, 0, 0.55],
                "48": [0, 0.69444, 0, 0, 0.55],
                "49": [0, 0.69444, 0, 0, 0.55],
                "50": [0, 0.69444, 0, 0, 0.55],
                "51": [0, 0.69444, 0, 0, 0.55],
                "52": [0, 0.69444, 0, 0, 0.55],
                "53": [0, 0.69444, 0, 0, 0.55],
                "54": [0, 0.69444, 0, 0, 0.55],
                "55": [0, 0.69444, 0, 0, 0.55],
                "56": [0, 0.69444, 0, 0, 0.55],
                "57": [0, 0.69444, 0, 0, 0.55],
                "58": [0, 0.45833, 0, 0, 0.30556],
                "59": [0.10556, 0.45833, 0, 0, 0.30556],
                "61": [-0.09375, 0.40625, 0, 0, 0.85556],
                "63": [0, 0.69444, 0, 0, 0.51945],
                "64": [0, 0.69444, 0, 0, 0.73334],
                "65": [0, 0.69444, 0, 0, 0.73334],
                "66": [0, 0.69444, 0, 0, 0.73334],
                "67": [0, 0.69444, 0, 0, 0.70278],
                "68": [0, 0.69444, 0, 0, 0.79445],
                "69": [0, 0.69444, 0, 0, 0.64167],
                "70": [0, 0.69444, 0, 0, 0.61111],
                "71": [0, 0.69444, 0, 0, 0.73334],
                "72": [0, 0.69444, 0, 0, 0.79445],
                "73": [0, 0.69444, 0, 0, 0.33056],
                "74": [0, 0.69444, 0, 0, 0.51945],
                "75": [0, 0.69444, 0, 0, 0.76389],
                "76": [0, 0.69444, 0, 0, 0.58056],
                "77": [0, 0.69444, 0, 0, 0.97778],
                "78": [0, 0.69444, 0, 0, 0.79445],
                "79": [0, 0.69444, 0, 0, 0.79445],
                "80": [0, 0.69444, 0, 0, 0.70278],
                "81": [0.10556, 0.69444, 0, 0, 0.79445],
                "82": [0, 0.69444, 0, 0, 0.70278],
                "83": [0, 0.69444, 0, 0, 0.61111],
                "84": [0, 0.69444, 0, 0, 0.73334],
                "85": [0, 0.69444, 0, 0, 0.76389],
                "86": [0, 0.69444, 0.01528, 0, 0.73334],
                "87": [0, 0.69444, 0.01528, 0, 1.03889],
                "88": [0, 0.69444, 0, 0, 0.73334],
                "89": [0, 0.69444, 0.0275, 0, 0.73334],
                "90": [0, 0.69444, 0, 0, 0.67223],
                "91": [0.25, 0.75, 0, 0, 0.34306],
                "93": [0.25, 0.75, 0, 0, 0.34306],
                "94": [0, 0.69444, 0, 0, 0.55],
                "95": [0.35, 0.10833, 0.03056, 0, 0.55],
                "97": [0, 0.45833, 0, 0, 0.525],
                "98": [0, 0.69444, 0, 0, 0.56111],
                "99": [0, 0.45833, 0, 0, 0.48889],
                "100": [0, 0.69444, 0, 0, 0.56111],
                "101": [0, 0.45833, 0, 0, 0.51111],
                "102": [0, 0.69444, 0.07639, 0, 0.33611],
                "103": [0.19444, 0.45833, 0.01528, 0, 0.55],
                "104": [0, 0.69444, 0, 0, 0.56111],
                "105": [0, 0.69444, 0, 0, 0.25556],
                "106": [0.19444, 0.69444, 0, 0, 0.28611],
                "107": [0, 0.69444, 0, 0, 0.53056],
                "108": [0, 0.69444, 0, 0, 0.25556],
                "109": [0, 0.45833, 0, 0, 0.86667],
                "110": [0, 0.45833, 0, 0, 0.56111],
                "111": [0, 0.45833, 0, 0, 0.55],
                "112": [0.19444, 0.45833, 0, 0, 0.56111],
                "113": [0.19444, 0.45833, 0, 0, 0.56111],
                "114": [0, 0.45833, 0.01528, 0, 0.37222],
                "115": [0, 0.45833, 0, 0, 0.42167],
                "116": [0, 0.58929, 0, 0, 0.40417],
                "117": [0, 0.45833, 0, 0, 0.56111],
                "118": [0, 0.45833, 0.01528, 0, 0.5],
                "119": [0, 0.45833, 0.01528, 0, 0.74445],
                "120": [0, 0.45833, 0, 0, 0.5],
                "121": [0.19444, 0.45833, 0.01528, 0, 0.5],
                "122": [0, 0.45833, 0, 0, 0.47639],
                "126": [0.35, 0.34444, 0, 0, 0.55],
                "160": [0, 0, 0, 0, 0.25],
                "168": [0, 0.69444, 0, 0, 0.55],
                "176": [0, 0.69444, 0, 0, 0.73334],
                "180": [0, 0.69444, 0, 0, 0.55],
                "184": [0.17014, 0, 0, 0, 0.48889],
                "305": [0, 0.45833, 0, 0, 0.25556],
                "567": [0.19444, 0.45833, 0, 0, 0.28611],
                "710": [0, 0.69444, 0, 0, 0.55],
                "711": [0, 0.63542, 0, 0, 0.55],
                "713": [0, 0.63778, 0, 0, 0.55],
                "728": [0, 0.69444, 0, 0, 0.55],
                "729": [0, 0.69444, 0, 0, 0.30556],
                "730": [0, 0.69444, 0, 0, 0.73334],
                "732": [0, 0.69444, 0, 0, 0.55],
                "733": [0, 0.69444, 0, 0, 0.55],
                "915": [0, 0.69444, 0, 0, 0.58056],
                "916": [0, 0.69444, 0, 0, 0.91667],
                "920": [0, 0.69444, 0, 0, 0.85556],
                "923": [0, 0.69444, 0, 0, 0.67223],
                "926": [0, 0.69444, 0, 0, 0.73334],
                "928": [0, 0.69444, 0, 0, 0.79445],
                "931": [0, 0.69444, 0, 0, 0.79445],
                "933": [0, 0.69444, 0, 0, 0.85556],
                "934": [0, 0.69444, 0, 0, 0.79445],
                "936": [0, 0.69444, 0, 0, 0.85556],
                "937": [0, 0.69444, 0, 0, 0.79445],
                "8211": [0, 0.45833, 0.03056, 0, 0.55],
                "8212": [0, 0.45833, 0.03056, 0, 1.10001],
                "8216": [0, 0.69444, 0, 0, 0.30556],
                "8217": [0, 0.69444, 0, 0, 0.30556],
                "8220": [0, 0.69444, 0, 0, 0.55834],
                "8221": [0, 0.69444, 0, 0, 0.55834]
              },
              "SansSerif-Italic": {
                "32": [0, 0, 0, 0, 0.25],
                "33": [0, 0.69444, 0.05733, 0, 0.31945],
                "34": [0, 0.69444, 316e-5, 0, 0.5],
                "35": [0.19444, 0.69444, 0.05087, 0, 0.83334],
                "36": [0.05556, 0.75, 0.11156, 0, 0.5],
                "37": [0.05556, 0.75, 0.03126, 0, 0.83334],
                "38": [0, 0.69444, 0.03058, 0, 0.75834],
                "39": [0, 0.69444, 0.07816, 0, 0.27778],
                "40": [0.25, 0.75, 0.13164, 0, 0.38889],
                "41": [0.25, 0.75, 0.02536, 0, 0.38889],
                "42": [0, 0.75, 0.11775, 0, 0.5],
                "43": [0.08333, 0.58333, 0.02536, 0, 0.77778],
                "44": [0.125, 0.08333, 0, 0, 0.27778],
                "45": [0, 0.44444, 0.01946, 0, 0.33333],
                "46": [0, 0.08333, 0, 0, 0.27778],
                "47": [0.25, 0.75, 0.13164, 0, 0.5],
                "48": [0, 0.65556, 0.11156, 0, 0.5],
                "49": [0, 0.65556, 0.11156, 0, 0.5],
                "50": [0, 0.65556, 0.11156, 0, 0.5],
                "51": [0, 0.65556, 0.11156, 0, 0.5],
                "52": [0, 0.65556, 0.11156, 0, 0.5],
                "53": [0, 0.65556, 0.11156, 0, 0.5],
                "54": [0, 0.65556, 0.11156, 0, 0.5],
                "55": [0, 0.65556, 0.11156, 0, 0.5],
                "56": [0, 0.65556, 0.11156, 0, 0.5],
                "57": [0, 0.65556, 0.11156, 0, 0.5],
                "58": [0, 0.44444, 0.02502, 0, 0.27778],
                "59": [0.125, 0.44444, 0.02502, 0, 0.27778],
                "61": [-0.13, 0.37, 0.05087, 0, 0.77778],
                "63": [0, 0.69444, 0.11809, 0, 0.47222],
                "64": [0, 0.69444, 0.07555, 0, 0.66667],
                "65": [0, 0.69444, 0, 0, 0.66667],
                "66": [0, 0.69444, 0.08293, 0, 0.66667],
                "67": [0, 0.69444, 0.11983, 0, 0.63889],
                "68": [0, 0.69444, 0.07555, 0, 0.72223],
                "69": [0, 0.69444, 0.11983, 0, 0.59722],
                "70": [0, 0.69444, 0.13372, 0, 0.56945],
                "71": [0, 0.69444, 0.11983, 0, 0.66667],
                "72": [0, 0.69444, 0.08094, 0, 0.70834],
                "73": [0, 0.69444, 0.13372, 0, 0.27778],
                "74": [0, 0.69444, 0.08094, 0, 0.47222],
                "75": [0, 0.69444, 0.11983, 0, 0.69445],
                "76": [0, 0.69444, 0, 0, 0.54167],
                "77": [0, 0.69444, 0.08094, 0, 0.875],
                "78": [0, 0.69444, 0.08094, 0, 0.70834],
                "79": [0, 0.69444, 0.07555, 0, 0.73611],
                "80": [0, 0.69444, 0.08293, 0, 0.63889],
                "81": [0.125, 0.69444, 0.07555, 0, 0.73611],
                "82": [0, 0.69444, 0.08293, 0, 0.64584],
                "83": [0, 0.69444, 0.09205, 0, 0.55556],
                "84": [0, 0.69444, 0.13372, 0, 0.68056],
                "85": [0, 0.69444, 0.08094, 0, 0.6875],
                "86": [0, 0.69444, 0.1615, 0, 0.66667],
                "87": [0, 0.69444, 0.1615, 0, 0.94445],
                "88": [0, 0.69444, 0.13372, 0, 0.66667],
                "89": [0, 0.69444, 0.17261, 0, 0.66667],
                "90": [0, 0.69444, 0.11983, 0, 0.61111],
                "91": [0.25, 0.75, 0.15942, 0, 0.28889],
                "93": [0.25, 0.75, 0.08719, 0, 0.28889],
                "94": [0, 0.69444, 0.0799, 0, 0.5],
                "95": [0.35, 0.09444, 0.08616, 0, 0.5],
                "97": [0, 0.44444, 981e-5, 0, 0.48056],
                "98": [0, 0.69444, 0.03057, 0, 0.51667],
                "99": [0, 0.44444, 0.08336, 0, 0.44445],
                "100": [0, 0.69444, 0.09483, 0, 0.51667],
                "101": [0, 0.44444, 0.06778, 0, 0.44445],
                "102": [0, 0.69444, 0.21705, 0, 0.30556],
                "103": [0.19444, 0.44444, 0.10836, 0, 0.5],
                "104": [0, 0.69444, 0.01778, 0, 0.51667],
                "105": [0, 0.67937, 0.09718, 0, 0.23889],
                "106": [0.19444, 0.67937, 0.09162, 0, 0.26667],
                "107": [0, 0.69444, 0.08336, 0, 0.48889],
                "108": [0, 0.69444, 0.09483, 0, 0.23889],
                "109": [0, 0.44444, 0.01778, 0, 0.79445],
                "110": [0, 0.44444, 0.01778, 0, 0.51667],
                "111": [0, 0.44444, 0.06613, 0, 0.5],
                "112": [0.19444, 0.44444, 0.0389, 0, 0.51667],
                "113": [0.19444, 0.44444, 0.04169, 0, 0.51667],
                "114": [0, 0.44444, 0.10836, 0, 0.34167],
                "115": [0, 0.44444, 0.0778, 0, 0.38333],
                "116": [0, 0.57143, 0.07225, 0, 0.36111],
                "117": [0, 0.44444, 0.04169, 0, 0.51667],
                "118": [0, 0.44444, 0.10836, 0, 0.46111],
                "119": [0, 0.44444, 0.10836, 0, 0.68334],
                "120": [0, 0.44444, 0.09169, 0, 0.46111],
                "121": [0.19444, 0.44444, 0.10836, 0, 0.46111],
                "122": [0, 0.44444, 0.08752, 0, 0.43472],
                "126": [0.35, 0.32659, 0.08826, 0, 0.5],
                "160": [0, 0, 0, 0, 0.25],
                "168": [0, 0.67937, 0.06385, 0, 0.5],
                "176": [0, 0.69444, 0, 0, 0.73752],
                "184": [0.17014, 0, 0, 0, 0.44445],
                "305": [0, 0.44444, 0.04169, 0, 0.23889],
                "567": [0.19444, 0.44444, 0.04169, 0, 0.26667],
                "710": [0, 0.69444, 0.0799, 0, 0.5],
                "711": [0, 0.63194, 0.08432, 0, 0.5],
                "713": [0, 0.60889, 0.08776, 0, 0.5],
                "714": [0, 0.69444, 0.09205, 0, 0.5],
                "715": [0, 0.69444, 0, 0, 0.5],
                "728": [0, 0.69444, 0.09483, 0, 0.5],
                "729": [0, 0.67937, 0.07774, 0, 0.27778],
                "730": [0, 0.69444, 0, 0, 0.73752],
                "732": [0, 0.67659, 0.08826, 0, 0.5],
                "733": [0, 0.69444, 0.09205, 0, 0.5],
                "915": [0, 0.69444, 0.13372, 0, 0.54167],
                "916": [0, 0.69444, 0, 0, 0.83334],
                "920": [0, 0.69444, 0.07555, 0, 0.77778],
                "923": [0, 0.69444, 0, 0, 0.61111],
                "926": [0, 0.69444, 0.12816, 0, 0.66667],
                "928": [0, 0.69444, 0.08094, 0, 0.70834],
                "931": [0, 0.69444, 0.11983, 0, 0.72222],
                "933": [0, 0.69444, 0.09031, 0, 0.77778],
                "934": [0, 0.69444, 0.04603, 0, 0.72222],
                "936": [0, 0.69444, 0.09031, 0, 0.77778],
                "937": [0, 0.69444, 0.08293, 0, 0.72222],
                "8211": [0, 0.44444, 0.08616, 0, 0.5],
                "8212": [0, 0.44444, 0.08616, 0, 1],
                "8216": [0, 0.69444, 0.07816, 0, 0.27778],
                "8217": [0, 0.69444, 0.07816, 0, 0.27778],
                "8220": [0, 0.69444, 0.14205, 0, 0.5],
                "8221": [0, 0.69444, 316e-5, 0, 0.5]
              },
              "SansSerif-Regular": {
                "32": [0, 0, 0, 0, 0.25],
                "33": [0, 0.69444, 0, 0, 0.31945],
                "34": [0, 0.69444, 0, 0, 0.5],
                "35": [0.19444, 0.69444, 0, 0, 0.83334],
                "36": [0.05556, 0.75, 0, 0, 0.5],
                "37": [0.05556, 0.75, 0, 0, 0.83334],
                "38": [0, 0.69444, 0, 0, 0.75834],
                "39": [0, 0.69444, 0, 0, 0.27778],
                "40": [0.25, 0.75, 0, 0, 0.38889],
                "41": [0.25, 0.75, 0, 0, 0.38889],
                "42": [0, 0.75, 0, 0, 0.5],
                "43": [0.08333, 0.58333, 0, 0, 0.77778],
                "44": [0.125, 0.08333, 0, 0, 0.27778],
                "45": [0, 0.44444, 0, 0, 0.33333],
                "46": [0, 0.08333, 0, 0, 0.27778],
                "47": [0.25, 0.75, 0, 0, 0.5],
                "48": [0, 0.65556, 0, 0, 0.5],
                "49": [0, 0.65556, 0, 0, 0.5],
                "50": [0, 0.65556, 0, 0, 0.5],
                "51": [0, 0.65556, 0, 0, 0.5],
                "52": [0, 0.65556, 0, 0, 0.5],
                "53": [0, 0.65556, 0, 0, 0.5],
                "54": [0, 0.65556, 0, 0, 0.5],
                "55": [0, 0.65556, 0, 0, 0.5],
                "56": [0, 0.65556, 0, 0, 0.5],
                "57": [0, 0.65556, 0, 0, 0.5],
                "58": [0, 0.44444, 0, 0, 0.27778],
                "59": [0.125, 0.44444, 0, 0, 0.27778],
                "61": [-0.13, 0.37, 0, 0, 0.77778],
                "63": [0, 0.69444, 0, 0, 0.47222],
                "64": [0, 0.69444, 0, 0, 0.66667],
                "65": [0, 0.69444, 0, 0, 0.66667],
                "66": [0, 0.69444, 0, 0, 0.66667],
                "67": [0, 0.69444, 0, 0, 0.63889],
                "68": [0, 0.69444, 0, 0, 0.72223],
                "69": [0, 0.69444, 0, 0, 0.59722],
                "70": [0, 0.69444, 0, 0, 0.56945],
                "71": [0, 0.69444, 0, 0, 0.66667],
                "72": [0, 0.69444, 0, 0, 0.70834],
                "73": [0, 0.69444, 0, 0, 0.27778],
                "74": [0, 0.69444, 0, 0, 0.47222],
                "75": [0, 0.69444, 0, 0, 0.69445],
                "76": [0, 0.69444, 0, 0, 0.54167],
                "77": [0, 0.69444, 0, 0, 0.875],
                "78": [0, 0.69444, 0, 0, 0.70834],
                "79": [0, 0.69444, 0, 0, 0.73611],
                "80": [0, 0.69444, 0, 0, 0.63889],
                "81": [0.125, 0.69444, 0, 0, 0.73611],
                "82": [0, 0.69444, 0, 0, 0.64584],
                "83": [0, 0.69444, 0, 0, 0.55556],
                "84": [0, 0.69444, 0, 0, 0.68056],
                "85": [0, 0.69444, 0, 0, 0.6875],
                "86": [0, 0.69444, 0.01389, 0, 0.66667],
                "87": [0, 0.69444, 0.01389, 0, 0.94445],
                "88": [0, 0.69444, 0, 0, 0.66667],
                "89": [0, 0.69444, 0.025, 0, 0.66667],
                "90": [0, 0.69444, 0, 0, 0.61111],
                "91": [0.25, 0.75, 0, 0, 0.28889],
                "93": [0.25, 0.75, 0, 0, 0.28889],
                "94": [0, 0.69444, 0, 0, 0.5],
                "95": [0.35, 0.09444, 0.02778, 0, 0.5],
                "97": [0, 0.44444, 0, 0, 0.48056],
                "98": [0, 0.69444, 0, 0, 0.51667],
                "99": [0, 0.44444, 0, 0, 0.44445],
                "100": [0, 0.69444, 0, 0, 0.51667],
                "101": [0, 0.44444, 0, 0, 0.44445],
                "102": [0, 0.69444, 0.06944, 0, 0.30556],
                "103": [0.19444, 0.44444, 0.01389, 0, 0.5],
                "104": [0, 0.69444, 0, 0, 0.51667],
                "105": [0, 0.67937, 0, 0, 0.23889],
                "106": [0.19444, 0.67937, 0, 0, 0.26667],
                "107": [0, 0.69444, 0, 0, 0.48889],
                "108": [0, 0.69444, 0, 0, 0.23889],
                "109": [0, 0.44444, 0, 0, 0.79445],
                "110": [0, 0.44444, 0, 0, 0.51667],
                "111": [0, 0.44444, 0, 0, 0.5],
                "112": [0.19444, 0.44444, 0, 0, 0.51667],
                "113": [0.19444, 0.44444, 0, 0, 0.51667],
                "114": [0, 0.44444, 0.01389, 0, 0.34167],
                "115": [0, 0.44444, 0, 0, 0.38333],
                "116": [0, 0.57143, 0, 0, 0.36111],
                "117": [0, 0.44444, 0, 0, 0.51667],
                "118": [0, 0.44444, 0.01389, 0, 0.46111],
                "119": [0, 0.44444, 0.01389, 0, 0.68334],
                "120": [0, 0.44444, 0, 0, 0.46111],
                "121": [0.19444, 0.44444, 0.01389, 0, 0.46111],
                "122": [0, 0.44444, 0, 0, 0.43472],
                "126": [0.35, 0.32659, 0, 0, 0.5],
                "160": [0, 0, 0, 0, 0.25],
                "168": [0, 0.67937, 0, 0, 0.5],
                "176": [0, 0.69444, 0, 0, 0.66667],
                "184": [0.17014, 0, 0, 0, 0.44445],
                "305": [0, 0.44444, 0, 0, 0.23889],
                "567": [0.19444, 0.44444, 0, 0, 0.26667],
                "710": [0, 0.69444, 0, 0, 0.5],
                "711": [0, 0.63194, 0, 0, 0.5],
                "713": [0, 0.60889, 0, 0, 0.5],
                "714": [0, 0.69444, 0, 0, 0.5],
                "715": [0, 0.69444, 0, 0, 0.5],
                "728": [0, 0.69444, 0, 0, 0.5],
                "729": [0, 0.67937, 0, 0, 0.27778],
                "730": [0, 0.69444, 0, 0, 0.66667],
                "732": [0, 0.67659, 0, 0, 0.5],
                "733": [0, 0.69444, 0, 0, 0.5],
                "915": [0, 0.69444, 0, 0, 0.54167],
                "916": [0, 0.69444, 0, 0, 0.83334],
                "920": [0, 0.69444, 0, 0, 0.77778],
                "923": [0, 0.69444, 0, 0, 0.61111],
                "926": [0, 0.69444, 0, 0, 0.66667],
                "928": [0, 0.69444, 0, 0, 0.70834],
                "931": [0, 0.69444, 0, 0, 0.72222],
                "933": [0, 0.69444, 0, 0, 0.77778],
                "934": [0, 0.69444, 0, 0, 0.72222],
                "936": [0, 0.69444, 0, 0, 0.77778],
                "937": [0, 0.69444, 0, 0, 0.72222],
                "8211": [0, 0.44444, 0.02778, 0, 0.5],
                "8212": [0, 0.44444, 0.02778, 0, 1],
                "8216": [0, 0.69444, 0, 0, 0.27778],
                "8217": [0, 0.69444, 0, 0, 0.27778],
                "8220": [0, 0.69444, 0, 0, 0.5],
                "8221": [0, 0.69444, 0, 0, 0.5]
              },
              "Script-Regular": {
                "32": [0, 0, 0, 0, 0.25],
                "65": [0, 0.7, 0.22925, 0, 0.80253],
                "66": [0, 0.7, 0.04087, 0, 0.90757],
                "67": [0, 0.7, 0.1689, 0, 0.66619],
                "68": [0, 0.7, 0.09371, 0, 0.77443],
                "69": [0, 0.7, 0.18583, 0, 0.56162],
                "70": [0, 0.7, 0.13634, 0, 0.89544],
                "71": [0, 0.7, 0.17322, 0, 0.60961],
                "72": [0, 0.7, 0.29694, 0, 0.96919],
                "73": [0, 0.7, 0.19189, 0, 0.80907],
                "74": [0.27778, 0.7, 0.19189, 0, 1.05159],
                "75": [0, 0.7, 0.31259, 0, 0.91364],
                "76": [0, 0.7, 0.19189, 0, 0.87373],
                "77": [0, 0.7, 0.15981, 0, 1.08031],
                "78": [0, 0.7, 0.3525, 0, 0.9015],
                "79": [0, 0.7, 0.08078, 0, 0.73787],
                "80": [0, 0.7, 0.08078, 0, 1.01262],
                "81": [0, 0.7, 0.03305, 0, 0.88282],
                "82": [0, 0.7, 0.06259, 0, 0.85],
                "83": [0, 0.7, 0.19189, 0, 0.86767],
                "84": [0, 0.7, 0.29087, 0, 0.74697],
                "85": [0, 0.7, 0.25815, 0, 0.79996],
                "86": [0, 0.7, 0.27523, 0, 0.62204],
                "87": [0, 0.7, 0.27523, 0, 0.80532],
                "88": [0, 0.7, 0.26006, 0, 0.94445],
                "89": [0, 0.7, 0.2939, 0, 0.70961],
                "90": [0, 0.7, 0.24037, 0, 0.8212],
                "160": [0, 0, 0, 0, 0.25]
              },
              "Size1-Regular": {
                "32": [0, 0, 0, 0, 0.25],
                "40": [0.35001, 0.85, 0, 0, 0.45834],
                "41": [0.35001, 0.85, 0, 0, 0.45834],
                "47": [0.35001, 0.85, 0, 0, 0.57778],
                "91": [0.35001, 0.85, 0, 0, 0.41667],
                "92": [0.35001, 0.85, 0, 0, 0.57778],
                "93": [0.35001, 0.85, 0, 0, 0.41667],
                "123": [0.35001, 0.85, 0, 0, 0.58334],
                "125": [0.35001, 0.85, 0, 0, 0.58334],
                "160": [0, 0, 0, 0, 0.25],
                "710": [0, 0.72222, 0, 0, 0.55556],
                "732": [0, 0.72222, 0, 0, 0.55556],
                "770": [0, 0.72222, 0, 0, 0.55556],
                "771": [0, 0.72222, 0, 0, 0.55556],
                "8214": [-99e-5, 0.601, 0, 0, 0.77778],
                "8593": [1e-5, 0.6, 0, 0, 0.66667],
                "8595": [1e-5, 0.6, 0, 0, 0.66667],
                "8657": [1e-5, 0.6, 0, 0, 0.77778],
                "8659": [1e-5, 0.6, 0, 0, 0.77778],
                "8719": [0.25001, 0.75, 0, 0, 0.94445],
                "8720": [0.25001, 0.75, 0, 0, 0.94445],
                "8721": [0.25001, 0.75, 0, 0, 1.05556],
                "8730": [0.35001, 0.85, 0, 0, 1],
                "8739": [-599e-5, 0.606, 0, 0, 0.33333],
                "8741": [-599e-5, 0.606, 0, 0, 0.55556],
                "8747": [0.30612, 0.805, 0.19445, 0, 0.47222],
                "8748": [0.306, 0.805, 0.19445, 0, 0.47222],
                "8749": [0.306, 0.805, 0.19445, 0, 0.47222],
                "8750": [0.30612, 0.805, 0.19445, 0, 0.47222],
                "8896": [0.25001, 0.75, 0, 0, 0.83334],
                "8897": [0.25001, 0.75, 0, 0, 0.83334],
                "8898": [0.25001, 0.75, 0, 0, 0.83334],
                "8899": [0.25001, 0.75, 0, 0, 0.83334],
                "8968": [0.35001, 0.85, 0, 0, 0.47222],
                "8969": [0.35001, 0.85, 0, 0, 0.47222],
                "8970": [0.35001, 0.85, 0, 0, 0.47222],
                "8971": [0.35001, 0.85, 0, 0, 0.47222],
                "9168": [-99e-5, 0.601, 0, 0, 0.66667],
                "10216": [0.35001, 0.85, 0, 0, 0.47222],
                "10217": [0.35001, 0.85, 0, 0, 0.47222],
                "10752": [0.25001, 0.75, 0, 0, 1.11111],
                "10753": [0.25001, 0.75, 0, 0, 1.11111],
                "10754": [0.25001, 0.75, 0, 0, 1.11111],
                "10756": [0.25001, 0.75, 0, 0, 0.83334],
                "10758": [0.25001, 0.75, 0, 0, 0.83334]
              },
              "Size2-Regular": {
                "32": [0, 0, 0, 0, 0.25],
                "40": [0.65002, 1.15, 0, 0, 0.59722],
                "41": [0.65002, 1.15, 0, 0, 0.59722],
                "47": [0.65002, 1.15, 0, 0, 0.81111],
                "91": [0.65002, 1.15, 0, 0, 0.47222],
                "92": [0.65002, 1.15, 0, 0, 0.81111],
                "93": [0.65002, 1.15, 0, 0, 0.47222],
                "123": [0.65002, 1.15, 0, 0, 0.66667],
                "125": [0.65002, 1.15, 0, 0, 0.66667],
                "160": [0, 0, 0, 0, 0.25],
                "710": [0, 0.75, 0, 0, 1],
                "732": [0, 0.75, 0, 0, 1],
                "770": [0, 0.75, 0, 0, 1],
                "771": [0, 0.75, 0, 0, 1],
                "8719": [0.55001, 1.05, 0, 0, 1.27778],
                "8720": [0.55001, 1.05, 0, 0, 1.27778],
                "8721": [0.55001, 1.05, 0, 0, 1.44445],
                "8730": [0.65002, 1.15, 0, 0, 1],
                "8747": [0.86225, 1.36, 0.44445, 0, 0.55556],
                "8748": [0.862, 1.36, 0.44445, 0, 0.55556],
                "8749": [0.862, 1.36, 0.44445, 0, 0.55556],
                "8750": [0.86225, 1.36, 0.44445, 0, 0.55556],
                "8896": [0.55001, 1.05, 0, 0, 1.11111],
                "8897": [0.55001, 1.05, 0, 0, 1.11111],
                "8898": [0.55001, 1.05, 0, 0, 1.11111],
                "8899": [0.55001, 1.05, 0, 0, 1.11111],
                "8968": [0.65002, 1.15, 0, 0, 0.52778],
                "8969": [0.65002, 1.15, 0, 0, 0.52778],
                "8970": [0.65002, 1.15, 0, 0, 0.52778],
                "8971": [0.65002, 1.15, 0, 0, 0.52778],
                "10216": [0.65002, 1.15, 0, 0, 0.61111],
                "10217": [0.65002, 1.15, 0, 0, 0.61111],
                "10752": [0.55001, 1.05, 0, 0, 1.51112],
                "10753": [0.55001, 1.05, 0, 0, 1.51112],
                "10754": [0.55001, 1.05, 0, 0, 1.51112],
                "10756": [0.55001, 1.05, 0, 0, 1.11111],
                "10758": [0.55001, 1.05, 0, 0, 1.11111]
              },
              "Size3-Regular": {
                "32": [0, 0, 0, 0, 0.25],
                "40": [0.95003, 1.45, 0, 0, 0.73611],
                "41": [0.95003, 1.45, 0, 0, 0.73611],
                "47": [0.95003, 1.45, 0, 0, 1.04445],
                "91": [0.95003, 1.45, 0, 0, 0.52778],
                "92": [0.95003, 1.45, 0, 0, 1.04445],
                "93": [0.95003, 1.45, 0, 0, 0.52778],
                "123": [0.95003, 1.45, 0, 0, 0.75],
                "125": [0.95003, 1.45, 0, 0, 0.75],
                "160": [0, 0, 0, 0, 0.25],
                "710": [0, 0.75, 0, 0, 1.44445],
                "732": [0, 0.75, 0, 0, 1.44445],
                "770": [0, 0.75, 0, 0, 1.44445],
                "771": [0, 0.75, 0, 0, 1.44445],
                "8730": [0.95003, 1.45, 0, 0, 1],
                "8968": [0.95003, 1.45, 0, 0, 0.58334],
                "8969": [0.95003, 1.45, 0, 0, 0.58334],
                "8970": [0.95003, 1.45, 0, 0, 0.58334],
                "8971": [0.95003, 1.45, 0, 0, 0.58334],
                "10216": [0.95003, 1.45, 0, 0, 0.75],
                "10217": [0.95003, 1.45, 0, 0, 0.75]
              },
              "Size4-Regular": {
                "32": [0, 0, 0, 0, 0.25],
                "40": [1.25003, 1.75, 0, 0, 0.79167],
                "41": [1.25003, 1.75, 0, 0, 0.79167],
                "47": [1.25003, 1.75, 0, 0, 1.27778],
                "91": [1.25003, 1.75, 0, 0, 0.58334],
                "92": [1.25003, 1.75, 0, 0, 1.27778],
                "93": [1.25003, 1.75, 0, 0, 0.58334],
                "123": [1.25003, 1.75, 0, 0, 0.80556],
                "125": [1.25003, 1.75, 0, 0, 0.80556],
                "160": [0, 0, 0, 0, 0.25],
                "710": [0, 0.825, 0, 0, 1.8889],
                "732": [0, 0.825, 0, 0, 1.8889],
                "770": [0, 0.825, 0, 0, 1.8889],
                "771": [0, 0.825, 0, 0, 1.8889],
                "8730": [1.25003, 1.75, 0, 0, 1],
                "8968": [1.25003, 1.75, 0, 0, 0.63889],
                "8969": [1.25003, 1.75, 0, 0, 0.63889],
                "8970": [1.25003, 1.75, 0, 0, 0.63889],
                "8971": [1.25003, 1.75, 0, 0, 0.63889],
                "9115": [0.64502, 1.155, 0, 0, 0.875],
                "9116": [1e-5, 0.6, 0, 0, 0.875],
                "9117": [0.64502, 1.155, 0, 0, 0.875],
                "9118": [0.64502, 1.155, 0, 0, 0.875],
                "9119": [1e-5, 0.6, 0, 0, 0.875],
                "9120": [0.64502, 1.155, 0, 0, 0.875],
                "9121": [0.64502, 1.155, 0, 0, 0.66667],
                "9122": [-99e-5, 0.601, 0, 0, 0.66667],
                "9123": [0.64502, 1.155, 0, 0, 0.66667],
                "9124": [0.64502, 1.155, 0, 0, 0.66667],
                "9125": [-99e-5, 0.601, 0, 0, 0.66667],
                "9126": [0.64502, 1.155, 0, 0, 0.66667],
                "9127": [1e-5, 0.9, 0, 0, 0.88889],
                "9128": [0.65002, 1.15, 0, 0, 0.88889],
                "9129": [0.90001, 0, 0, 0, 0.88889],
                "9130": [0, 0.3, 0, 0, 0.88889],
                "9131": [1e-5, 0.9, 0, 0, 0.88889],
                "9132": [0.65002, 1.15, 0, 0, 0.88889],
                "9133": [0.90001, 0, 0, 0, 0.88889],
                "9143": [0.88502, 0.915, 0, 0, 1.05556],
                "10216": [1.25003, 1.75, 0, 0, 0.80556],
                "10217": [1.25003, 1.75, 0, 0, 0.80556],
                "57344": [-499e-5, 0.605, 0, 0, 1.05556],
                "57345": [-499e-5, 0.605, 0, 0, 1.05556],
                "57680": [0, 0.12, 0, 0, 0.45],
                "57681": [0, 0.12, 0, 0, 0.45],
                "57682": [0, 0.12, 0, 0, 0.45],
                "57683": [0, 0.12, 0, 0, 0.45]
              },
              "Typewriter-Regular": {
                "32": [0, 0, 0, 0, 0.525],
                "33": [0, 0.61111, 0, 0, 0.525],
                "34": [0, 0.61111, 0, 0, 0.525],
                "35": [0, 0.61111, 0, 0, 0.525],
                "36": [0.08333, 0.69444, 0, 0, 0.525],
                "37": [0.08333, 0.69444, 0, 0, 0.525],
                "38": [0, 0.61111, 0, 0, 0.525],
                "39": [0, 0.61111, 0, 0, 0.525],
                "40": [0.08333, 0.69444, 0, 0, 0.525],
                "41": [0.08333, 0.69444, 0, 0, 0.525],
                "42": [0, 0.52083, 0, 0, 0.525],
                "43": [-0.08056, 0.53055, 0, 0, 0.525],
                "44": [0.13889, 0.125, 0, 0, 0.525],
                "45": [-0.08056, 0.53055, 0, 0, 0.525],
                "46": [0, 0.125, 0, 0, 0.525],
                "47": [0.08333, 0.69444, 0, 0, 0.525],
                "48": [0, 0.61111, 0, 0, 0.525],
                "49": [0, 0.61111, 0, 0, 0.525],
                "50": [0, 0.61111, 0, 0, 0.525],
                "51": [0, 0.61111, 0, 0, 0.525],
                "52": [0, 0.61111, 0, 0, 0.525],
                "53": [0, 0.61111, 0, 0, 0.525],
                "54": [0, 0.61111, 0, 0, 0.525],
                "55": [0, 0.61111, 0, 0, 0.525],
                "56": [0, 0.61111, 0, 0, 0.525],
                "57": [0, 0.61111, 0, 0, 0.525],
                "58": [0, 0.43056, 0, 0, 0.525],
                "59": [0.13889, 0.43056, 0, 0, 0.525],
                "60": [-0.05556, 0.55556, 0, 0, 0.525],
                "61": [-0.19549, 0.41562, 0, 0, 0.525],
                "62": [-0.05556, 0.55556, 0, 0, 0.525],
                "63": [0, 0.61111, 0, 0, 0.525],
                "64": [0, 0.61111, 0, 0, 0.525],
                "65": [0, 0.61111, 0, 0, 0.525],
                "66": [0, 0.61111, 0, 0, 0.525],
                "67": [0, 0.61111, 0, 0, 0.525],
                "68": [0, 0.61111, 0, 0, 0.525],
                "69": [0, 0.61111, 0, 0, 0.525],
                "70": [0, 0.61111, 0, 0, 0.525],
                "71": [0, 0.61111, 0, 0, 0.525],
                "72": [0, 0.61111, 0, 0, 0.525],
                "73": [0, 0.61111, 0, 0, 0.525],
                "74": [0, 0.61111, 0, 0, 0.525],
                "75": [0, 0.61111, 0, 0, 0.525],
                "76": [0, 0.61111, 0, 0, 0.525],
                "77": [0, 0.61111, 0, 0, 0.525],
                "78": [0, 0.61111, 0, 0, 0.525],
                "79": [0, 0.61111, 0, 0, 0.525],
                "80": [0, 0.61111, 0, 0, 0.525],
                "81": [0.13889, 0.61111, 0, 0, 0.525],
                "82": [0, 0.61111, 0, 0, 0.525],
                "83": [0, 0.61111, 0, 0, 0.525],
                "84": [0, 0.61111, 0, 0, 0.525],
                "85": [0, 0.61111, 0, 0, 0.525],
                "86": [0, 0.61111, 0, 0, 0.525],
                "87": [0, 0.61111, 0, 0, 0.525],
                "88": [0, 0.61111, 0, 0, 0.525],
                "89": [0, 0.61111, 0, 0, 0.525],
                "90": [0, 0.61111, 0, 0, 0.525],
                "91": [0.08333, 0.69444, 0, 0, 0.525],
                "92": [0.08333, 0.69444, 0, 0, 0.525],
                "93": [0.08333, 0.69444, 0, 0, 0.525],
                "94": [0, 0.61111, 0, 0, 0.525],
                "95": [0.09514, 0, 0, 0, 0.525],
                "96": [0, 0.61111, 0, 0, 0.525],
                "97": [0, 0.43056, 0, 0, 0.525],
                "98": [0, 0.61111, 0, 0, 0.525],
                "99": [0, 0.43056, 0, 0, 0.525],
                "100": [0, 0.61111, 0, 0, 0.525],
                "101": [0, 0.43056, 0, 0, 0.525],
                "102": [0, 0.61111, 0, 0, 0.525],
                "103": [0.22222, 0.43056, 0, 0, 0.525],
                "104": [0, 0.61111, 0, 0, 0.525],
                "105": [0, 0.61111, 0, 0, 0.525],
                "106": [0.22222, 0.61111, 0, 0, 0.525],
                "107": [0, 0.61111, 0, 0, 0.525],
                "108": [0, 0.61111, 0, 0, 0.525],
                "109": [0, 0.43056, 0, 0, 0.525],
                "110": [0, 0.43056, 0, 0, 0.525],
                "111": [0, 0.43056, 0, 0, 0.525],
                "112": [0.22222, 0.43056, 0, 0, 0.525],
                "113": [0.22222, 0.43056, 0, 0, 0.525],
                "114": [0, 0.43056, 0, 0, 0.525],
                "115": [0, 0.43056, 0, 0, 0.525],
                "116": [0, 0.55358, 0, 0, 0.525],
                "117": [0, 0.43056, 0, 0, 0.525],
                "118": [0, 0.43056, 0, 0, 0.525],
                "119": [0, 0.43056, 0, 0, 0.525],
                "120": [0, 0.43056, 0, 0, 0.525],
                "121": [0.22222, 0.43056, 0, 0, 0.525],
                "122": [0, 0.43056, 0, 0, 0.525],
                "123": [0.08333, 0.69444, 0, 0, 0.525],
                "124": [0.08333, 0.69444, 0, 0, 0.525],
                "125": [0.08333, 0.69444, 0, 0, 0.525],
                "126": [0, 0.61111, 0, 0, 0.525],
                "127": [0, 0.61111, 0, 0, 0.525],
                "160": [0, 0, 0, 0, 0.525],
                "176": [0, 0.61111, 0, 0, 0.525],
                "184": [0.19445, 0, 0, 0, 0.525],
                "305": [0, 0.43056, 0, 0, 0.525],
                "567": [0.22222, 0.43056, 0, 0, 0.525],
                "711": [0, 0.56597, 0, 0, 0.525],
                "713": [0, 0.56555, 0, 0, 0.525],
                "714": [0, 0.61111, 0, 0, 0.525],
                "715": [0, 0.61111, 0, 0, 0.525],
                "728": [0, 0.61111, 0, 0, 0.525],
                "730": [0, 0.61111, 0, 0, 0.525],
                "770": [0, 0.61111, 0, 0, 0.525],
                "771": [0, 0.61111, 0, 0, 0.525],
                "776": [0, 0.61111, 0, 0, 0.525],
                "915": [0, 0.61111, 0, 0, 0.525],
                "916": [0, 0.61111, 0, 0, 0.525],
                "920": [0, 0.61111, 0, 0, 0.525],
                "923": [0, 0.61111, 0, 0, 0.525],
                "926": [0, 0.61111, 0, 0, 0.525],
                "928": [0, 0.61111, 0, 0, 0.525],
                "931": [0, 0.61111, 0, 0, 0.525],
                "933": [0, 0.61111, 0, 0, 0.525],
                "934": [0, 0.61111, 0, 0, 0.525],
                "936": [0, 0.61111, 0, 0, 0.525],
                "937": [0, 0.61111, 0, 0, 0.525],
                "8216": [0, 0.61111, 0, 0, 0.525],
                "8217": [0, 0.61111, 0, 0, 0.525],
                "8242": [0, 0.61111, 0, 0, 0.525],
                "9251": [0.11111, 0.21944, 0, 0, 0.525]
              }
            };
            var sigmasAndXis = {
              slant: [0.25, 0.25, 0.25],
              // sigma1
              space: [0, 0, 0],
              // sigma2
              stretch: [0, 0, 0],
              // sigma3
              shrink: [0, 0, 0],
              // sigma4
              xHeight: [0.431, 0.431, 0.431],
              // sigma5
              quad: [1, 1.171, 1.472],
              // sigma6
              extraSpace: [0, 0, 0],
              // sigma7
              num1: [0.677, 0.732, 0.925],
              // sigma8
              num2: [0.394, 0.384, 0.387],
              // sigma9
              num3: [0.444, 0.471, 0.504],
              // sigma10
              denom1: [0.686, 0.752, 1.025],
              // sigma11
              denom2: [0.345, 0.344, 0.532],
              // sigma12
              sup1: [0.413, 0.503, 0.504],
              // sigma13
              sup2: [0.363, 0.431, 0.404],
              // sigma14
              sup3: [0.289, 0.286, 0.294],
              // sigma15
              sub1: [0.15, 0.143, 0.2],
              // sigma16
              sub2: [0.247, 0.286, 0.4],
              // sigma17
              supDrop: [0.386, 0.353, 0.494],
              // sigma18
              subDrop: [0.05, 0.071, 0.1],
              // sigma19
              delim1: [2.39, 1.7, 1.98],
              // sigma20
              delim2: [1.01, 1.157, 1.42],
              // sigma21
              axisHeight: [0.25, 0.25, 0.25],
              // sigma22
              // These font metrics are extracted from TeX by using tftopl on cmex10.tfm;
              // they correspond to the font parameters of the extension fonts (family 3).
              // See the TeXbook, page 441. In AMSTeX, the extension fonts scale; to
              // match cmex7, we'd use cmex7.tfm values for script and scriptscript
              // values.
              defaultRuleThickness: [0.04, 0.049, 0.049],
              // xi8; cmex7: 0.049
              bigOpSpacing1: [0.111, 0.111, 0.111],
              // xi9
              bigOpSpacing2: [0.166, 0.166, 0.166],
              // xi10
              bigOpSpacing3: [0.2, 0.2, 0.2],
              // xi11
              bigOpSpacing4: [0.6, 0.611, 0.611],
              // xi12; cmex7: 0.611
              bigOpSpacing5: [0.1, 0.143, 0.143],
              // xi13; cmex7: 0.143
              // The \sqrt rule width is taken from the height of the surd character.
              // Since we use the same font at all sizes, this thickness doesn't scale.
              sqrtRuleThickness: [0.04, 0.04, 0.04],
              // This value determines how large a pt is, for metrics which are defined
              // in terms of pts.
              // This value is also used in katex.less; if you change it make sure the
              // values match.
              ptPerEm: [10, 10, 10],
              // The space between adjacent `|` columns in an array definition. From
              // `\showthe\doublerulesep` in LaTeX. Equals 2.0 / ptPerEm.
              doubleRuleSep: [0.2, 0.2, 0.2],
              // The width of separator lines in {array} environments. From
              // `\showthe\arrayrulewidth` in LaTeX. Equals 0.4 / ptPerEm.
              arrayRuleWidth: [0.04, 0.04, 0.04],
              // Two values from LaTeX source2e:
              fboxsep: [0.3, 0.3, 0.3],
              //        3 pt / ptPerEm
              fboxrule: [0.04, 0.04, 0.04]
              // 0.4 pt / ptPerEm
            };
            var extraCharacterMap = {
              // Latin-1
              "Å": "A",
              "Ç": "C",
              "Ð": "D",
              "Þ": "o",
              "å": "a",
              "ç": "c",
              "ð": "d",
              "þ": "o",
              // Cyrillic
              "А": "A",
              "Б": "B",
              "В": "B",
              "Г": "F",
              "Д": "A",
              "Е": "E",
              "Ж": "K",
              "З": "3",
              "И": "N",
              "Й": "N",
              "К": "K",
              "Л": "N",
              "М": "M",
              "Н": "H",
              "О": "O",
              "П": "N",
              "Р": "P",
              "С": "C",
              "Т": "T",
              "У": "y",
              "Ф": "O",
              "Х": "X",
              "Ц": "U",
              "Ч": "h",
              "Ш": "W",
              "Щ": "W",
              "Ъ": "B",
              "Ы": "X",
              "Ь": "B",
              "Э": "3",
              "Ю": "X",
              "Я": "R",
              "а": "a",
              "б": "b",
              "в": "a",
              "г": "r",
              "д": "y",
              "е": "e",
              "ж": "m",
              "з": "e",
              "и": "n",
              "й": "n",
              "к": "n",
              "л": "n",
              "м": "m",
              "н": "n",
              "о": "o",
              "п": "n",
              "р": "p",
              "с": "c",
              "т": "o",
              "у": "y",
              "ф": "b",
              "х": "x",
              "ц": "n",
              "ч": "n",
              "ш": "w",
              "щ": "w",
              "ъ": "a",
              "ы": "m",
              "ь": "a",
              "э": "e",
              "ю": "m",
              "я": "r"
            };
            function setFontMetrics(fontName, metrics) {
              fontMetricsData[fontName] = metrics;
            }
            function getCharacterMetrics(character, font, mode) {
              if (!fontMetricsData[font]) {
                throw new Error("Font metrics not found for font: " + font + ".");
              }
              var ch = character.charCodeAt(0);
              var metrics = fontMetricsData[font][ch];
              if (!metrics && character[0] in extraCharacterMap) {
                ch = extraCharacterMap[character[0]].charCodeAt(0);
                metrics = fontMetricsData[font][ch];
              }
              if (!metrics && mode === "text") {
                if (supportedCodepoint(ch)) {
                  metrics = fontMetricsData[font][77];
                }
              }
              if (metrics) {
                return {
                  depth: metrics[0],
                  height: metrics[1],
                  italic: metrics[2],
                  skew: metrics[3],
                  width: metrics[4]
                };
              }
            }
            var fontMetricsBySizeIndex = {};
            function getGlobalMetrics(size) {
              var sizeIndex;
              if (size >= 5) {
                sizeIndex = 0;
              } else if (size >= 3) {
                sizeIndex = 1;
              } else {
                sizeIndex = 2;
              }
              if (!fontMetricsBySizeIndex[sizeIndex]) {
                var metrics = fontMetricsBySizeIndex[sizeIndex] = {
                  cssEmPerMu: sigmasAndXis.quad[sizeIndex] / 18
                };
                for (var key in sigmasAndXis) {
                  if (sigmasAndXis.hasOwnProperty(key)) {
                    metrics[key] = sigmasAndXis[key][sizeIndex];
                  }
                }
              }
              return fontMetricsBySizeIndex[sizeIndex];
            }
            var ATOMS = {
              "bin": 1,
              "close": 1,
              "inner": 1,
              "open": 1,
              "punct": 1,
              "rel": 1
            };
            var NON_ATOMS = {
              "accent-token": 1,
              "mathord": 1,
              "op-token": 1,
              "spacing": 1,
              "textord": 1
            };
            var symbols = {
              "math": {},
              "text": {}
            };
            var src_symbols = symbols;
            function defineSymbol(mode, font, group, replace2, name2, acceptUnicodeChar) {
              symbols[mode][name2] = {
                font,
                group,
                replace: replace2
              };
              if (acceptUnicodeChar && replace2) {
                symbols[mode][replace2] = symbols[mode][name2];
              }
            }
            var symbols_math = "math";
            var symbols_text = "text";
            var main = "main";
            var ams = "ams";
            var symbols_accent = "accent-token";
            var bin = "bin";
            var symbols_close = "close";
            var symbols_inner = "inner";
            var mathord = "mathord";
            var op = "op-token";
            var symbols_open = "open";
            var punct = "punct";
            var rel = "rel";
            var symbols_spacing = "spacing";
            var symbols_textord = "textord";
            defineSymbol(symbols_math, main, rel, "≡", "\\equiv", true);
            defineSymbol(symbols_math, main, rel, "≺", "\\prec", true);
            defineSymbol(symbols_math, main, rel, "≻", "\\succ", true);
            defineSymbol(symbols_math, main, rel, "∼", "\\sim", true);
            defineSymbol(symbols_math, main, rel, "⊥", "\\perp");
            defineSymbol(symbols_math, main, rel, "⪯", "\\preceq", true);
            defineSymbol(symbols_math, main, rel, "⪰", "\\succeq", true);
            defineSymbol(symbols_math, main, rel, "≃", "\\simeq", true);
            defineSymbol(symbols_math, main, rel, "∣", "\\mid", true);
            defineSymbol(symbols_math, main, rel, "≪", "\\ll", true);
            defineSymbol(symbols_math, main, rel, "≫", "\\gg", true);
            defineSymbol(symbols_math, main, rel, "≍", "\\asymp", true);
            defineSymbol(symbols_math, main, rel, "∥", "\\parallel");
            defineSymbol(symbols_math, main, rel, "⋈", "\\bowtie", true);
            defineSymbol(symbols_math, main, rel, "⌣", "\\smile", true);
            defineSymbol(symbols_math, main, rel, "⊑", "\\sqsubseteq", true);
            defineSymbol(symbols_math, main, rel, "⊒", "\\sqsupseteq", true);
            defineSymbol(symbols_math, main, rel, "≐", "\\doteq", true);
            defineSymbol(symbols_math, main, rel, "⌢", "\\frown", true);
            defineSymbol(symbols_math, main, rel, "∋", "\\ni", true);
            defineSymbol(symbols_math, main, rel, "∝", "\\propto", true);
            defineSymbol(symbols_math, main, rel, "⊢", "\\vdash", true);
            defineSymbol(symbols_math, main, rel, "⊣", "\\dashv", true);
            defineSymbol(symbols_math, main, rel, "∋", "\\owns");
            defineSymbol(symbols_math, main, punct, ".", "\\ldotp");
            defineSymbol(symbols_math, main, punct, "⋅", "\\cdotp");
            defineSymbol(symbols_math, main, symbols_textord, "#", "\\#");
            defineSymbol(symbols_text, main, symbols_textord, "#", "\\#");
            defineSymbol(symbols_math, main, symbols_textord, "&", "\\&");
            defineSymbol(symbols_text, main, symbols_textord, "&", "\\&");
            defineSymbol(symbols_math, main, symbols_textord, "ℵ", "\\aleph", true);
            defineSymbol(symbols_math, main, symbols_textord, "∀", "\\forall", true);
            defineSymbol(symbols_math, main, symbols_textord, "ℏ", "\\hbar", true);
            defineSymbol(symbols_math, main, symbols_textord, "∃", "\\exists", true);
            defineSymbol(symbols_math, main, symbols_textord, "∇", "\\nabla", true);
            defineSymbol(symbols_math, main, symbols_textord, "♭", "\\flat", true);
            defineSymbol(symbols_math, main, symbols_textord, "ℓ", "\\ell", true);
            defineSymbol(symbols_math, main, symbols_textord, "♮", "\\natural", true);
            defineSymbol(symbols_math, main, symbols_textord, "♣", "\\clubsuit", true);
            defineSymbol(symbols_math, main, symbols_textord, "℘", "\\wp", true);
            defineSymbol(symbols_math, main, symbols_textord, "♯", "\\sharp", true);
            defineSymbol(symbols_math, main, symbols_textord, "♢", "\\diamondsuit", true);
            defineSymbol(symbols_math, main, symbols_textord, "ℜ", "\\Re", true);
            defineSymbol(symbols_math, main, symbols_textord, "♡", "\\heartsuit", true);
            defineSymbol(symbols_math, main, symbols_textord, "ℑ", "\\Im", true);
            defineSymbol(symbols_math, main, symbols_textord, "♠", "\\spadesuit", true);
            defineSymbol(symbols_text, main, symbols_textord, "§", "\\S", true);
            defineSymbol(symbols_text, main, symbols_textord, "¶", "\\P", true);
            defineSymbol(symbols_math, main, symbols_textord, "†", "\\dag");
            defineSymbol(symbols_text, main, symbols_textord, "†", "\\dag");
            defineSymbol(symbols_text, main, symbols_textord, "†", "\\textdagger");
            defineSymbol(symbols_math, main, symbols_textord, "‡", "\\ddag");
            defineSymbol(symbols_text, main, symbols_textord, "‡", "\\ddag");
            defineSymbol(symbols_text, main, symbols_textord, "‡", "\\textdaggerdbl");
            defineSymbol(symbols_math, main, symbols_close, "⎱", "\\rmoustache", true);
            defineSymbol(symbols_math, main, symbols_open, "⎰", "\\lmoustache", true);
            defineSymbol(symbols_math, main, symbols_close, "⟯", "\\rgroup", true);
            defineSymbol(symbols_math, main, symbols_open, "⟮", "\\lgroup", true);
            defineSymbol(symbols_math, main, bin, "∓", "\\mp", true);
            defineSymbol(symbols_math, main, bin, "⊖", "\\ominus", true);
            defineSymbol(symbols_math, main, bin, "⊎", "\\uplus", true);
            defineSymbol(symbols_math, main, bin, "⊓", "\\sqcap", true);
            defineSymbol(symbols_math, main, bin, "∗", "\\ast");
            defineSymbol(symbols_math, main, bin, "⊔", "\\sqcup", true);
            defineSymbol(symbols_math, main, bin, "◯", "\\bigcirc");
            defineSymbol(symbols_math, main, bin, "∙", "\\bullet");
            defineSymbol(symbols_math, main, bin, "‡", "\\ddagger");
            defineSymbol(symbols_math, main, bin, "≀", "\\wr", true);
            defineSymbol(symbols_math, main, bin, "⨿", "\\amalg");
            defineSymbol(symbols_math, main, bin, "&", "\\And");
            defineSymbol(symbols_math, main, rel, "⟵", "\\longleftarrow", true);
            defineSymbol(symbols_math, main, rel, "⇐", "\\Leftarrow", true);
            defineSymbol(symbols_math, main, rel, "⟸", "\\Longleftarrow", true);
            defineSymbol(symbols_math, main, rel, "⟶", "\\longrightarrow", true);
            defineSymbol(symbols_math, main, rel, "⇒", "\\Rightarrow", true);
            defineSymbol(symbols_math, main, rel, "⟹", "\\Longrightarrow", true);
            defineSymbol(symbols_math, main, rel, "↔", "\\leftrightarrow", true);
            defineSymbol(symbols_math, main, rel, "⟷", "\\longleftrightarrow", true);
            defineSymbol(symbols_math, main, rel, "⇔", "\\Leftrightarrow", true);
            defineSymbol(symbols_math, main, rel, "⟺", "\\Longleftrightarrow", true);
            defineSymbol(symbols_math, main, rel, "↦", "\\mapsto", true);
            defineSymbol(symbols_math, main, rel, "⟼", "\\longmapsto", true);
            defineSymbol(symbols_math, main, rel, "↗", "\\nearrow", true);
            defineSymbol(symbols_math, main, rel, "↩", "\\hookleftarrow", true);
            defineSymbol(symbols_math, main, rel, "↪", "\\hookrightarrow", true);
            defineSymbol(symbols_math, main, rel, "↘", "\\searrow", true);
            defineSymbol(symbols_math, main, rel, "↼", "\\leftharpoonup", true);
            defineSymbol(symbols_math, main, rel, "⇀", "\\rightharpoonup", true);
            defineSymbol(symbols_math, main, rel, "↙", "\\swarrow", true);
            defineSymbol(symbols_math, main, rel, "↽", "\\leftharpoondown", true);
            defineSymbol(symbols_math, main, rel, "⇁", "\\rightharpoondown", true);
            defineSymbol(symbols_math, main, rel, "↖", "\\nwarrow", true);
            defineSymbol(symbols_math, main, rel, "⇌", "\\rightleftharpoons", true);
            defineSymbol(symbols_math, ams, rel, "≮", "\\nless", true);
            defineSymbol(symbols_math, ams, rel, "", "\\@nleqslant");
            defineSymbol(symbols_math, ams, rel, "", "\\@nleqq");
            defineSymbol(symbols_math, ams, rel, "⪇", "\\lneq", true);
            defineSymbol(symbols_math, ams, rel, "≨", "\\lneqq", true);
            defineSymbol(symbols_math, ams, rel, "", "\\@lvertneqq");
            defineSymbol(symbols_math, ams, rel, "⋦", "\\lnsim", true);
            defineSymbol(symbols_math, ams, rel, "⪉", "\\lnapprox", true);
            defineSymbol(symbols_math, ams, rel, "⊀", "\\nprec", true);
            defineSymbol(symbols_math, ams, rel, "⋠", "\\npreceq", true);
            defineSymbol(symbols_math, ams, rel, "⋨", "\\precnsim", true);
            defineSymbol(symbols_math, ams, rel, "⪹", "\\precnapprox", true);
            defineSymbol(symbols_math, ams, rel, "≁", "\\nsim", true);
            defineSymbol(symbols_math, ams, rel, "", "\\@nshortmid");
            defineSymbol(symbols_math, ams, rel, "∤", "\\nmid", true);
            defineSymbol(symbols_math, ams, rel, "⊬", "\\nvdash", true);
            defineSymbol(symbols_math, ams, rel, "⊭", "\\nvDash", true);
            defineSymbol(symbols_math, ams, rel, "⋪", "\\ntriangleleft");
            defineSymbol(symbols_math, ams, rel, "⋬", "\\ntrianglelefteq", true);
            defineSymbol(symbols_math, ams, rel, "⊊", "\\subsetneq", true);
            defineSymbol(symbols_math, ams, rel, "", "\\@varsubsetneq");
            defineSymbol(symbols_math, ams, rel, "⫋", "\\subsetneqq", true);
            defineSymbol(symbols_math, ams, rel, "", "\\@varsubsetneqq");
            defineSymbol(symbols_math, ams, rel, "≯", "\\ngtr", true);
            defineSymbol(symbols_math, ams, rel, "", "\\@ngeqslant");
            defineSymbol(symbols_math, ams, rel, "", "\\@ngeqq");
            defineSymbol(symbols_math, ams, rel, "⪈", "\\gneq", true);
            defineSymbol(symbols_math, ams, rel, "≩", "\\gneqq", true);
            defineSymbol(symbols_math, ams, rel, "", "\\@gvertneqq");
            defineSymbol(symbols_math, ams, rel, "⋧", "\\gnsim", true);
            defineSymbol(symbols_math, ams, rel, "⪊", "\\gnapprox", true);
            defineSymbol(symbols_math, ams, rel, "⊁", "\\nsucc", true);
            defineSymbol(symbols_math, ams, rel, "⋡", "\\nsucceq", true);
            defineSymbol(symbols_math, ams, rel, "⋩", "\\succnsim", true);
            defineSymbol(symbols_math, ams, rel, "⪺", "\\succnapprox", true);
            defineSymbol(symbols_math, ams, rel, "≆", "\\ncong", true);
            defineSymbol(symbols_math, ams, rel, "", "\\@nshortparallel");
            defineSymbol(symbols_math, ams, rel, "∦", "\\nparallel", true);
            defineSymbol(symbols_math, ams, rel, "⊯", "\\nVDash", true);
            defineSymbol(symbols_math, ams, rel, "⋫", "\\ntriangleright");
            defineSymbol(symbols_math, ams, rel, "⋭", "\\ntrianglerighteq", true);
            defineSymbol(symbols_math, ams, rel, "", "\\@nsupseteqq");
            defineSymbol(symbols_math, ams, rel, "⊋", "\\supsetneq", true);
            defineSymbol(symbols_math, ams, rel, "", "\\@varsupsetneq");
            defineSymbol(symbols_math, ams, rel, "⫌", "\\supsetneqq", true);
            defineSymbol(symbols_math, ams, rel, "", "\\@varsupsetneqq");
            defineSymbol(symbols_math, ams, rel, "⊮", "\\nVdash", true);
            defineSymbol(symbols_math, ams, rel, "⪵", "\\precneqq", true);
            defineSymbol(symbols_math, ams, rel, "⪶", "\\succneqq", true);
            defineSymbol(symbols_math, ams, rel, "", "\\@nsubseteqq");
            defineSymbol(symbols_math, ams, bin, "⊴", "\\unlhd");
            defineSymbol(symbols_math, ams, bin, "⊵", "\\unrhd");
            defineSymbol(symbols_math, ams, rel, "↚", "\\nleftarrow", true);
            defineSymbol(symbols_math, ams, rel, "↛", "\\nrightarrow", true);
            defineSymbol(symbols_math, ams, rel, "⇍", "\\nLeftarrow", true);
            defineSymbol(symbols_math, ams, rel, "⇏", "\\nRightarrow", true);
            defineSymbol(symbols_math, ams, rel, "↮", "\\nleftrightarrow", true);
            defineSymbol(symbols_math, ams, rel, "⇎", "\\nLeftrightarrow", true);
            defineSymbol(symbols_math, ams, rel, "△", "\\vartriangle");
            defineSymbol(symbols_math, ams, symbols_textord, "ℏ", "\\hslash");
            defineSymbol(symbols_math, ams, symbols_textord, "▽", "\\triangledown");
            defineSymbol(symbols_math, ams, symbols_textord, "◊", "\\lozenge");
            defineSymbol(symbols_math, ams, symbols_textord, "Ⓢ", "\\circledS");
            defineSymbol(symbols_math, ams, symbols_textord, "®", "\\circledR");
            defineSymbol(symbols_text, ams, symbols_textord, "®", "\\circledR");
            defineSymbol(symbols_math, ams, symbols_textord, "∡", "\\measuredangle", true);
            defineSymbol(symbols_math, ams, symbols_textord, "∄", "\\nexists");
            defineSymbol(symbols_math, ams, symbols_textord, "℧", "\\mho");
            defineSymbol(symbols_math, ams, symbols_textord, "Ⅎ", "\\Finv", true);
            defineSymbol(symbols_math, ams, symbols_textord, "⅁", "\\Game", true);
            defineSymbol(symbols_math, ams, symbols_textord, "‵", "\\backprime");
            defineSymbol(symbols_math, ams, symbols_textord, "▲", "\\blacktriangle");
            defineSymbol(symbols_math, ams, symbols_textord, "▼", "\\blacktriangledown");
            defineSymbol(symbols_math, ams, symbols_textord, "■", "\\blacksquare");
            defineSymbol(symbols_math, ams, symbols_textord, "⧫", "\\blacklozenge");
            defineSymbol(symbols_math, ams, symbols_textord, "★", "\\bigstar");
            defineSymbol(symbols_math, ams, symbols_textord, "∢", "\\sphericalangle", true);
            defineSymbol(symbols_math, ams, symbols_textord, "∁", "\\complement", true);
            defineSymbol(symbols_math, ams, symbols_textord, "ð", "\\eth", true);
            defineSymbol(symbols_text, main, symbols_textord, "ð", "ð");
            defineSymbol(symbols_math, ams, symbols_textord, "╱", "\\diagup");
            defineSymbol(symbols_math, ams, symbols_textord, "╲", "\\diagdown");
            defineSymbol(symbols_math, ams, symbols_textord, "□", "\\square");
            defineSymbol(symbols_math, ams, symbols_textord, "□", "\\Box");
            defineSymbol(symbols_math, ams, symbols_textord, "◊", "\\Diamond");
            defineSymbol(symbols_math, ams, symbols_textord, "¥", "\\yen", true);
            defineSymbol(symbols_text, ams, symbols_textord, "¥", "\\yen", true);
            defineSymbol(symbols_math, ams, symbols_textord, "✓", "\\checkmark", true);
            defineSymbol(symbols_text, ams, symbols_textord, "✓", "\\checkmark");
            defineSymbol(symbols_math, ams, symbols_textord, "ℶ", "\\beth", true);
            defineSymbol(symbols_math, ams, symbols_textord, "ℸ", "\\daleth", true);
            defineSymbol(symbols_math, ams, symbols_textord, "ℷ", "\\gimel", true);
            defineSymbol(symbols_math, ams, symbols_textord, "ϝ", "\\digamma", true);
            defineSymbol(symbols_math, ams, symbols_textord, "ϰ", "\\varkappa");
            defineSymbol(symbols_math, ams, symbols_open, "┌", "\\@ulcorner", true);
            defineSymbol(symbols_math, ams, symbols_close, "┐", "\\@urcorner", true);
            defineSymbol(symbols_math, ams, symbols_open, "└", "\\@llcorner", true);
            defineSymbol(symbols_math, ams, symbols_close, "┘", "\\@lrcorner", true);
            defineSymbol(symbols_math, ams, rel, "≦", "\\leqq", true);
            defineSymbol(symbols_math, ams, rel, "⩽", "\\leqslant", true);
            defineSymbol(symbols_math, ams, rel, "⪕", "\\eqslantless", true);
            defineSymbol(symbols_math, ams, rel, "≲", "\\lesssim", true);
            defineSymbol(symbols_math, ams, rel, "⪅", "\\lessapprox", true);
            defineSymbol(symbols_math, ams, rel, "≊", "\\approxeq", true);
            defineSymbol(symbols_math, ams, bin, "⋖", "\\lessdot");
            defineSymbol(symbols_math, ams, rel, "⋘", "\\lll", true);
            defineSymbol(symbols_math, ams, rel, "≶", "\\lessgtr", true);
            defineSymbol(symbols_math, ams, rel, "⋚", "\\lesseqgtr", true);
            defineSymbol(symbols_math, ams, rel, "⪋", "\\lesseqqgtr", true);
            defineSymbol(symbols_math, ams, rel, "≑", "\\doteqdot");
            defineSymbol(symbols_math, ams, rel, "≓", "\\risingdotseq", true);
            defineSymbol(symbols_math, ams, rel, "≒", "\\fallingdotseq", true);
            defineSymbol(symbols_math, ams, rel, "∽", "\\backsim", true);
            defineSymbol(symbols_math, ams, rel, "⋍", "\\backsimeq", true);
            defineSymbol(symbols_math, ams, rel, "⫅", "\\subseteqq", true);
            defineSymbol(symbols_math, ams, rel, "⋐", "\\Subset", true);
            defineSymbol(symbols_math, ams, rel, "⊏", "\\sqsubset", true);
            defineSymbol(symbols_math, ams, rel, "≼", "\\preccurlyeq", true);
            defineSymbol(symbols_math, ams, rel, "⋞", "\\curlyeqprec", true);
            defineSymbol(symbols_math, ams, rel, "≾", "\\precsim", true);
            defineSymbol(symbols_math, ams, rel, "⪷", "\\precapprox", true);
            defineSymbol(symbols_math, ams, rel, "⊲", "\\vartriangleleft");
            defineSymbol(symbols_math, ams, rel, "⊴", "\\trianglelefteq");
            defineSymbol(symbols_math, ams, rel, "⊨", "\\vDash", true);
            defineSymbol(symbols_math, ams, rel, "⊪", "\\Vvdash", true);
            defineSymbol(symbols_math, ams, rel, "⌣", "\\smallsmile");
            defineSymbol(symbols_math, ams, rel, "⌢", "\\smallfrown");
            defineSymbol(symbols_math, ams, rel, "≏", "\\bumpeq", true);
            defineSymbol(symbols_math, ams, rel, "≎", "\\Bumpeq", true);
            defineSymbol(symbols_math, ams, rel, "≧", "\\geqq", true);
            defineSymbol(symbols_math, ams, rel, "⩾", "\\geqslant", true);
            defineSymbol(symbols_math, ams, rel, "⪖", "\\eqslantgtr", true);
            defineSymbol(symbols_math, ams, rel, "≳", "\\gtrsim", true);
            defineSymbol(symbols_math, ams, rel, "⪆", "\\gtrapprox", true);
            defineSymbol(symbols_math, ams, bin, "⋗", "\\gtrdot");
            defineSymbol(symbols_math, ams, rel, "⋙", "\\ggg", true);
            defineSymbol(symbols_math, ams, rel, "≷", "\\gtrless", true);
            defineSymbol(symbols_math, ams, rel, "⋛", "\\gtreqless", true);
            defineSymbol(symbols_math, ams, rel, "⪌", "\\gtreqqless", true);
            defineSymbol(symbols_math, ams, rel, "≖", "\\eqcirc", true);
            defineSymbol(symbols_math, ams, rel, "≗", "\\circeq", true);
            defineSymbol(symbols_math, ams, rel, "≜", "\\triangleq", true);
            defineSymbol(symbols_math, ams, rel, "∼", "\\thicksim");
            defineSymbol(symbols_math, ams, rel, "≈", "\\thickapprox");
            defineSymbol(symbols_math, ams, rel, "⫆", "\\supseteqq", true);
            defineSymbol(symbols_math, ams, rel, "⋑", "\\Supset", true);
            defineSymbol(symbols_math, ams, rel, "⊐", "\\sqsupset", true);
            defineSymbol(symbols_math, ams, rel, "≽", "\\succcurlyeq", true);
            defineSymbol(symbols_math, ams, rel, "⋟", "\\curlyeqsucc", true);
            defineSymbol(symbols_math, ams, rel, "≿", "\\succsim", true);
            defineSymbol(symbols_math, ams, rel, "⪸", "\\succapprox", true);
            defineSymbol(symbols_math, ams, rel, "⊳", "\\vartriangleright");
            defineSymbol(symbols_math, ams, rel, "⊵", "\\trianglerighteq");
            defineSymbol(symbols_math, ams, rel, "⊩", "\\Vdash", true);
            defineSymbol(symbols_math, ams, rel, "∣", "\\shortmid");
            defineSymbol(symbols_math, ams, rel, "∥", "\\shortparallel");
            defineSymbol(symbols_math, ams, rel, "≬", "\\between", true);
            defineSymbol(symbols_math, ams, rel, "⋔", "\\pitchfork", true);
            defineSymbol(symbols_math, ams, rel, "∝", "\\varpropto");
            defineSymbol(symbols_math, ams, rel, "◀", "\\blacktriangleleft");
            defineSymbol(symbols_math, ams, rel, "∴", "\\therefore", true);
            defineSymbol(symbols_math, ams, rel, "∍", "\\backepsilon");
            defineSymbol(symbols_math, ams, rel, "▶", "\\blacktriangleright");
            defineSymbol(symbols_math, ams, rel, "∵", "\\because", true);
            defineSymbol(symbols_math, ams, rel, "⋘", "\\llless");
            defineSymbol(symbols_math, ams, rel, "⋙", "\\gggtr");
            defineSymbol(symbols_math, ams, bin, "⊲", "\\lhd");
            defineSymbol(symbols_math, ams, bin, "⊳", "\\rhd");
            defineSymbol(symbols_math, ams, rel, "≂", "\\eqsim", true);
            defineSymbol(symbols_math, main, rel, "⋈", "\\Join");
            defineSymbol(symbols_math, ams, rel, "≑", "\\Doteq", true);
            defineSymbol(symbols_math, ams, bin, "∔", "\\dotplus", true);
            defineSymbol(symbols_math, ams, bin, "∖", "\\smallsetminus");
            defineSymbol(symbols_math, ams, bin, "⋒", "\\Cap", true);
            defineSymbol(symbols_math, ams, bin, "⋓", "\\Cup", true);
            defineSymbol(symbols_math, ams, bin, "⩞", "\\doublebarwedge", true);
            defineSymbol(symbols_math, ams, bin, "⊟", "\\boxminus", true);
            defineSymbol(symbols_math, ams, bin, "⊞", "\\boxplus", true);
            defineSymbol(symbols_math, ams, bin, "⋇", "\\divideontimes", true);
            defineSymbol(symbols_math, ams, bin, "⋉", "\\ltimes", true);
            defineSymbol(symbols_math, ams, bin, "⋊", "\\rtimes", true);
            defineSymbol(symbols_math, ams, bin, "⋋", "\\leftthreetimes", true);
            defineSymbol(symbols_math, ams, bin, "⋌", "\\rightthreetimes", true);
            defineSymbol(symbols_math, ams, bin, "⋏", "\\curlywedge", true);
            defineSymbol(symbols_math, ams, bin, "⋎", "\\curlyvee", true);
            defineSymbol(symbols_math, ams, bin, "⊝", "\\circleddash", true);
            defineSymbol(symbols_math, ams, bin, "⊛", "\\circledast", true);
            defineSymbol(symbols_math, ams, bin, "⋅", "\\centerdot");
            defineSymbol(symbols_math, ams, bin, "⊺", "\\intercal", true);
            defineSymbol(symbols_math, ams, bin, "⋒", "\\doublecap");
            defineSymbol(symbols_math, ams, bin, "⋓", "\\doublecup");
            defineSymbol(symbols_math, ams, bin, "⊠", "\\boxtimes", true);
            defineSymbol(symbols_math, ams, rel, "⇢", "\\dashrightarrow", true);
            defineSymbol(symbols_math, ams, rel, "⇠", "\\dashleftarrow", true);
            defineSymbol(symbols_math, ams, rel, "⇇", "\\leftleftarrows", true);
            defineSymbol(symbols_math, ams, rel, "⇆", "\\leftrightarrows", true);
            defineSymbol(symbols_math, ams, rel, "⇚", "\\Lleftarrow", true);
            defineSymbol(symbols_math, ams, rel, "↞", "\\twoheadleftarrow", true);
            defineSymbol(symbols_math, ams, rel, "↢", "\\leftarrowtail", true);
            defineSymbol(symbols_math, ams, rel, "↫", "\\looparrowleft", true);
            defineSymbol(symbols_math, ams, rel, "⇋", "\\leftrightharpoons", true);
            defineSymbol(symbols_math, ams, rel, "↶", "\\curvearrowleft", true);
            defineSymbol(symbols_math, ams, rel, "↺", "\\circlearrowleft", true);
            defineSymbol(symbols_math, ams, rel, "↰", "\\Lsh", true);
            defineSymbol(symbols_math, ams, rel, "⇈", "\\upuparrows", true);
            defineSymbol(symbols_math, ams, rel, "↿", "\\upharpoonleft", true);
            defineSymbol(symbols_math, ams, rel, "⇃", "\\downharpoonleft", true);
            defineSymbol(symbols_math, ams, rel, "⊸", "\\multimap", true);
            defineSymbol(symbols_math, ams, rel, "↭", "\\leftrightsquigarrow", true);
            defineSymbol(symbols_math, ams, rel, "⇉", "\\rightrightarrows", true);
            defineSymbol(symbols_math, ams, rel, "⇄", "\\rightleftarrows", true);
            defineSymbol(symbols_math, ams, rel, "↠", "\\twoheadrightarrow", true);
            defineSymbol(symbols_math, ams, rel, "↣", "\\rightarrowtail", true);
            defineSymbol(symbols_math, ams, rel, "↬", "\\looparrowright", true);
            defineSymbol(symbols_math, ams, rel, "↷", "\\curvearrowright", true);
            defineSymbol(symbols_math, ams, rel, "↻", "\\circlearrowright", true);
            defineSymbol(symbols_math, ams, rel, "↱", "\\Rsh", true);
            defineSymbol(symbols_math, ams, rel, "⇊", "\\downdownarrows", true);
            defineSymbol(symbols_math, ams, rel, "↾", "\\upharpoonright", true);
            defineSymbol(symbols_math, ams, rel, "⇂", "\\downharpoonright", true);
            defineSymbol(symbols_math, ams, rel, "⇝", "\\rightsquigarrow", true);
            defineSymbol(symbols_math, ams, rel, "⇝", "\\leadsto");
            defineSymbol(symbols_math, ams, rel, "⇛", "\\Rrightarrow", true);
            defineSymbol(symbols_math, ams, rel, "↾", "\\restriction");
            defineSymbol(symbols_math, main, symbols_textord, "‘", "`");
            defineSymbol(symbols_math, main, symbols_textord, "$", "\\$");
            defineSymbol(symbols_text, main, symbols_textord, "$", "\\$");
            defineSymbol(symbols_text, main, symbols_textord, "$", "\\textdollar");
            defineSymbol(symbols_math, main, symbols_textord, "%", "\\%");
            defineSymbol(symbols_text, main, symbols_textord, "%", "\\%");
            defineSymbol(symbols_math, main, symbols_textord, "_", "\\_");
            defineSymbol(symbols_text, main, symbols_textord, "_", "\\_");
            defineSymbol(symbols_text, main, symbols_textord, "_", "\\textunderscore");
            defineSymbol(symbols_math, main, symbols_textord, "∠", "\\angle", true);
            defineSymbol(symbols_math, main, symbols_textord, "∞", "\\infty", true);
            defineSymbol(symbols_math, main, symbols_textord, "′", "\\prime");
            defineSymbol(symbols_math, main, symbols_textord, "△", "\\triangle");
            defineSymbol(symbols_math, main, symbols_textord, "Γ", "\\Gamma", true);
            defineSymbol(symbols_math, main, symbols_textord, "Δ", "\\Delta", true);
            defineSymbol(symbols_math, main, symbols_textord, "Θ", "\\Theta", true);
            defineSymbol(symbols_math, main, symbols_textord, "Λ", "\\Lambda", true);
            defineSymbol(symbols_math, main, symbols_textord, "Ξ", "\\Xi", true);
            defineSymbol(symbols_math, main, symbols_textord, "Π", "\\Pi", true);
            defineSymbol(symbols_math, main, symbols_textord, "Σ", "\\Sigma", true);
            defineSymbol(symbols_math, main, symbols_textord, "Υ", "\\Upsilon", true);
            defineSymbol(symbols_math, main, symbols_textord, "Φ", "\\Phi", true);
            defineSymbol(symbols_math, main, symbols_textord, "Ψ", "\\Psi", true);
            defineSymbol(symbols_math, main, symbols_textord, "Ω", "\\Omega", true);
            defineSymbol(symbols_math, main, symbols_textord, "A", "Α");
            defineSymbol(symbols_math, main, symbols_textord, "B", "Β");
            defineSymbol(symbols_math, main, symbols_textord, "E", "Ε");
            defineSymbol(symbols_math, main, symbols_textord, "Z", "Ζ");
            defineSymbol(symbols_math, main, symbols_textord, "H", "Η");
            defineSymbol(symbols_math, main, symbols_textord, "I", "Ι");
            defineSymbol(symbols_math, main, symbols_textord, "K", "Κ");
            defineSymbol(symbols_math, main, symbols_textord, "M", "Μ");
            defineSymbol(symbols_math, main, symbols_textord, "N", "Ν");
            defineSymbol(symbols_math, main, symbols_textord, "O", "Ο");
            defineSymbol(symbols_math, main, symbols_textord, "P", "Ρ");
            defineSymbol(symbols_math, main, symbols_textord, "T", "Τ");
            defineSymbol(symbols_math, main, symbols_textord, "X", "Χ");
            defineSymbol(symbols_math, main, symbols_textord, "¬", "\\neg", true);
            defineSymbol(symbols_math, main, symbols_textord, "¬", "\\lnot");
            defineSymbol(symbols_math, main, symbols_textord, "⊤", "\\top");
            defineSymbol(symbols_math, main, symbols_textord, "⊥", "\\bot");
            defineSymbol(symbols_math, main, symbols_textord, "∅", "\\emptyset");
            defineSymbol(symbols_math, ams, symbols_textord, "∅", "\\varnothing");
            defineSymbol(symbols_math, main, mathord, "α", "\\alpha", true);
            defineSymbol(symbols_math, main, mathord, "β", "\\beta", true);
            defineSymbol(symbols_math, main, mathord, "γ", "\\gamma", true);
            defineSymbol(symbols_math, main, mathord, "δ", "\\delta", true);
            defineSymbol(symbols_math, main, mathord, "ϵ", "\\epsilon", true);
            defineSymbol(symbols_math, main, mathord, "ζ", "\\zeta", true);
            defineSymbol(symbols_math, main, mathord, "η", "\\eta", true);
            defineSymbol(symbols_math, main, mathord, "θ", "\\theta", true);
            defineSymbol(symbols_math, main, mathord, "ι", "\\iota", true);
            defineSymbol(symbols_math, main, mathord, "κ", "\\kappa", true);
            defineSymbol(symbols_math, main, mathord, "λ", "\\lambda", true);
            defineSymbol(symbols_math, main, mathord, "μ", "\\mu", true);
            defineSymbol(symbols_math, main, mathord, "ν", "\\nu", true);
            defineSymbol(symbols_math, main, mathord, "ξ", "\\xi", true);
            defineSymbol(symbols_math, main, mathord, "ο", "\\omicron", true);
            defineSymbol(symbols_math, main, mathord, "π", "\\pi", true);
            defineSymbol(symbols_math, main, mathord, "ρ", "\\rho", true);
            defineSymbol(symbols_math, main, mathord, "σ", "\\sigma", true);
            defineSymbol(symbols_math, main, mathord, "τ", "\\tau", true);
            defineSymbol(symbols_math, main, mathord, "υ", "\\upsilon", true);
            defineSymbol(symbols_math, main, mathord, "ϕ", "\\phi", true);
            defineSymbol(symbols_math, main, mathord, "χ", "\\chi", true);
            defineSymbol(symbols_math, main, mathord, "ψ", "\\psi", true);
            defineSymbol(symbols_math, main, mathord, "ω", "\\omega", true);
            defineSymbol(symbols_math, main, mathord, "ε", "\\varepsilon", true);
            defineSymbol(symbols_math, main, mathord, "ϑ", "\\vartheta", true);
            defineSymbol(symbols_math, main, mathord, "ϖ", "\\varpi", true);
            defineSymbol(symbols_math, main, mathord, "ϱ", "\\varrho", true);
            defineSymbol(symbols_math, main, mathord, "ς", "\\varsigma", true);
            defineSymbol(symbols_math, main, mathord, "φ", "\\varphi", true);
            defineSymbol(symbols_math, main, bin, "∗", "*");
            defineSymbol(symbols_math, main, bin, "+", "+");
            defineSymbol(symbols_math, main, bin, "−", "-");
            defineSymbol(symbols_math, main, bin, "⋅", "\\cdot", true);
            defineSymbol(symbols_math, main, bin, "∘", "\\circ");
            defineSymbol(symbols_math, main, bin, "÷", "\\div", true);
            defineSymbol(symbols_math, main, bin, "±", "\\pm", true);
            defineSymbol(symbols_math, main, bin, "×", "\\times", true);
            defineSymbol(symbols_math, main, bin, "∩", "\\cap", true);
            defineSymbol(symbols_math, main, bin, "∪", "\\cup", true);
            defineSymbol(symbols_math, main, bin, "∖", "\\setminus");
            defineSymbol(symbols_math, main, bin, "∧", "\\land");
            defineSymbol(symbols_math, main, bin, "∨", "\\lor");
            defineSymbol(symbols_math, main, bin, "∧", "\\wedge", true);
            defineSymbol(symbols_math, main, bin, "∨", "\\vee", true);
            defineSymbol(symbols_math, main, symbols_textord, "√", "\\surd");
            defineSymbol(symbols_math, main, symbols_open, "⟨", "\\langle", true);
            defineSymbol(symbols_math, main, symbols_open, "∣", "\\lvert");
            defineSymbol(symbols_math, main, symbols_open, "∥", "\\lVert");
            defineSymbol(symbols_math, main, symbols_close, "?", "?");
            defineSymbol(symbols_math, main, symbols_close, "!", "!");
            defineSymbol(symbols_math, main, symbols_close, "⟩", "\\rangle", true);
            defineSymbol(symbols_math, main, symbols_close, "∣", "\\rvert");
            defineSymbol(symbols_math, main, symbols_close, "∥", "\\rVert");
            defineSymbol(symbols_math, main, rel, "=", "=");
            defineSymbol(symbols_math, main, rel, ":", ":");
            defineSymbol(symbols_math, main, rel, "≈", "\\approx", true);
            defineSymbol(symbols_math, main, rel, "≅", "\\cong", true);
            defineSymbol(symbols_math, main, rel, "≥", "\\ge");
            defineSymbol(symbols_math, main, rel, "≥", "\\geq", true);
            defineSymbol(symbols_math, main, rel, "←", "\\gets");
            defineSymbol(symbols_math, main, rel, ">", "\\gt", true);
            defineSymbol(symbols_math, main, rel, "∈", "\\in", true);
            defineSymbol(symbols_math, main, rel, "", "\\@not");
            defineSymbol(symbols_math, main, rel, "⊂", "\\subset", true);
            defineSymbol(symbols_math, main, rel, "⊃", "\\supset", true);
            defineSymbol(symbols_math, main, rel, "⊆", "\\subseteq", true);
            defineSymbol(symbols_math, main, rel, "⊇", "\\supseteq", true);
            defineSymbol(symbols_math, ams, rel, "⊈", "\\nsubseteq", true);
            defineSymbol(symbols_math, ams, rel, "⊉", "\\nsupseteq", true);
            defineSymbol(symbols_math, main, rel, "⊨", "\\models");
            defineSymbol(symbols_math, main, rel, "←", "\\leftarrow", true);
            defineSymbol(symbols_math, main, rel, "≤", "\\le");
            defineSymbol(symbols_math, main, rel, "≤", "\\leq", true);
            defineSymbol(symbols_math, main, rel, "<", "\\lt", true);
            defineSymbol(symbols_math, main, rel, "→", "\\rightarrow", true);
            defineSymbol(symbols_math, main, rel, "→", "\\to");
            defineSymbol(symbols_math, ams, rel, "≱", "\\ngeq", true);
            defineSymbol(symbols_math, ams, rel, "≰", "\\nleq", true);
            defineSymbol(symbols_math, main, symbols_spacing, " ", "\\ ");
            defineSymbol(symbols_math, main, symbols_spacing, " ", "~");
            defineSymbol(symbols_math, main, symbols_spacing, " ", "\\space");
            defineSymbol(symbols_math, main, symbols_spacing, " ", "\\nobreakspace");
            defineSymbol(symbols_text, main, symbols_spacing, " ", "\\ ");
            defineSymbol(symbols_text, main, symbols_spacing, " ", " ");
            defineSymbol(symbols_text, main, symbols_spacing, " ", "~");
            defineSymbol(symbols_text, main, symbols_spacing, " ", "\\space");
            defineSymbol(symbols_text, main, symbols_spacing, " ", "\\nobreakspace");
            defineSymbol(symbols_math, main, symbols_spacing, null, "\\nobreak");
            defineSymbol(symbols_math, main, symbols_spacing, null, "\\allowbreak");
            defineSymbol(symbols_math, main, punct, ",", ",");
            defineSymbol(symbols_math, main, punct, ";", ";");
            defineSymbol(symbols_math, ams, bin, "⊼", "\\barwedge", true);
            defineSymbol(symbols_math, ams, bin, "⊻", "\\veebar", true);
            defineSymbol(symbols_math, main, bin, "⊙", "\\odot", true);
            defineSymbol(symbols_math, main, bin, "⊕", "\\oplus", true);
            defineSymbol(symbols_math, main, bin, "⊗", "\\otimes", true);
            defineSymbol(symbols_math, main, symbols_textord, "∂", "\\partial", true);
            defineSymbol(symbols_math, main, bin, "⊘", "\\oslash", true);
            defineSymbol(symbols_math, ams, bin, "⊚", "\\circledcirc", true);
            defineSymbol(symbols_math, ams, bin, "⊡", "\\boxdot", true);
            defineSymbol(symbols_math, main, bin, "△", "\\bigtriangleup");
            defineSymbol(symbols_math, main, bin, "▽", "\\bigtriangledown");
            defineSymbol(symbols_math, main, bin, "†", "\\dagger");
            defineSymbol(symbols_math, main, bin, "⋄", "\\diamond");
            defineSymbol(symbols_math, main, bin, "⋆", "\\star");
            defineSymbol(symbols_math, main, bin, "◃", "\\triangleleft");
            defineSymbol(symbols_math, main, bin, "▹", "\\triangleright");
            defineSymbol(symbols_math, main, symbols_open, "{", "\\{");
            defineSymbol(symbols_text, main, symbols_textord, "{", "\\{");
            defineSymbol(symbols_text, main, symbols_textord, "{", "\\textbraceleft");
            defineSymbol(symbols_math, main, symbols_close, "}", "\\}");
            defineSymbol(symbols_text, main, symbols_textord, "}", "\\}");
            defineSymbol(symbols_text, main, symbols_textord, "}", "\\textbraceright");
            defineSymbol(symbols_math, main, symbols_open, "{", "\\lbrace");
            defineSymbol(symbols_math, main, symbols_close, "}", "\\rbrace");
            defineSymbol(symbols_math, main, symbols_open, "[", "\\lbrack", true);
            defineSymbol(symbols_text, main, symbols_textord, "[", "\\lbrack", true);
            defineSymbol(symbols_math, main, symbols_close, "]", "\\rbrack", true);
            defineSymbol(symbols_text, main, symbols_textord, "]", "\\rbrack", true);
            defineSymbol(symbols_math, main, symbols_open, "(", "\\lparen", true);
            defineSymbol(symbols_math, main, symbols_close, ")", "\\rparen", true);
            defineSymbol(symbols_text, main, symbols_textord, "<", "\\textless", true);
            defineSymbol(symbols_text, main, symbols_textord, ">", "\\textgreater", true);
            defineSymbol(symbols_math, main, symbols_open, "⌊", "\\lfloor", true);
            defineSymbol(symbols_math, main, symbols_close, "⌋", "\\rfloor", true);
            defineSymbol(symbols_math, main, symbols_open, "⌈", "\\lceil", true);
            defineSymbol(symbols_math, main, symbols_close, "⌉", "\\rceil", true);
            defineSymbol(symbols_math, main, symbols_textord, "\\", "\\backslash");
            defineSymbol(symbols_math, main, symbols_textord, "∣", "|");
            defineSymbol(symbols_math, main, symbols_textord, "∣", "\\vert");
            defineSymbol(symbols_text, main, symbols_textord, "|", "\\textbar", true);
            defineSymbol(symbols_math, main, symbols_textord, "∥", "\\|");
            defineSymbol(symbols_math, main, symbols_textord, "∥", "\\Vert");
            defineSymbol(symbols_text, main, symbols_textord, "∥", "\\textbardbl");
            defineSymbol(symbols_text, main, symbols_textord, "~", "\\textasciitilde");
            defineSymbol(symbols_text, main, symbols_textord, "\\", "\\textbackslash");
            defineSymbol(symbols_text, main, symbols_textord, "^", "\\textasciicircum");
            defineSymbol(symbols_math, main, rel, "↑", "\\uparrow", true);
            defineSymbol(symbols_math, main, rel, "⇑", "\\Uparrow", true);
            defineSymbol(symbols_math, main, rel, "↓", "\\downarrow", true);
            defineSymbol(symbols_math, main, rel, "⇓", "\\Downarrow", true);
            defineSymbol(symbols_math, main, rel, "↕", "\\updownarrow", true);
            defineSymbol(symbols_math, main, rel, "⇕", "\\Updownarrow", true);
            defineSymbol(symbols_math, main, op, "∐", "\\coprod");
            defineSymbol(symbols_math, main, op, "⋁", "\\bigvee");
            defineSymbol(symbols_math, main, op, "⋀", "\\bigwedge");
            defineSymbol(symbols_math, main, op, "⨄", "\\biguplus");
            defineSymbol(symbols_math, main, op, "⋂", "\\bigcap");
            defineSymbol(symbols_math, main, op, "⋃", "\\bigcup");
            defineSymbol(symbols_math, main, op, "∫", "\\int");
            defineSymbol(symbols_math, main, op, "∫", "\\intop");
            defineSymbol(symbols_math, main, op, "∬", "\\iint");
            defineSymbol(symbols_math, main, op, "∭", "\\iiint");
            defineSymbol(symbols_math, main, op, "∏", "\\prod");
            defineSymbol(symbols_math, main, op, "∑", "\\sum");
            defineSymbol(symbols_math, main, op, "⨂", "\\bigotimes");
            defineSymbol(symbols_math, main, op, "⨁", "\\bigoplus");
            defineSymbol(symbols_math, main, op, "⨀", "\\bigodot");
            defineSymbol(symbols_math, main, op, "∮", "\\oint");
            defineSymbol(symbols_math, main, op, "⨆", "\\bigsqcup");
            defineSymbol(symbols_math, main, op, "∫", "\\smallint");
            defineSymbol(symbols_text, main, symbols_inner, "…", "\\textellipsis");
            defineSymbol(symbols_math, main, symbols_inner, "…", "\\mathellipsis");
            defineSymbol(symbols_text, main, symbols_inner, "…", "\\ldots", true);
            defineSymbol(symbols_math, main, symbols_inner, "…", "\\ldots", true);
            defineSymbol(symbols_math, main, symbols_inner, "⋯", "\\@cdots", true);
            defineSymbol(symbols_math, main, symbols_inner, "⋱", "\\ddots", true);
            defineSymbol(symbols_math, main, symbols_textord, "⋮", "\\varvdots");
            defineSymbol(symbols_math, main, symbols_accent, "ˊ", "\\acute");
            defineSymbol(symbols_math, main, symbols_accent, "ˋ", "\\grave");
            defineSymbol(symbols_math, main, symbols_accent, "¨", "\\ddot");
            defineSymbol(symbols_math, main, symbols_accent, "~", "\\tilde");
            defineSymbol(symbols_math, main, symbols_accent, "ˉ", "\\bar");
            defineSymbol(symbols_math, main, symbols_accent, "˘", "\\breve");
            defineSymbol(symbols_math, main, symbols_accent, "ˇ", "\\check");
            defineSymbol(symbols_math, main, symbols_accent, "^", "\\hat");
            defineSymbol(symbols_math, main, symbols_accent, "⃗", "\\vec");
            defineSymbol(symbols_math, main, symbols_accent, "˙", "\\dot");
            defineSymbol(symbols_math, main, symbols_accent, "˚", "\\mathring");
            defineSymbol(symbols_math, main, mathord, "", "\\@imath");
            defineSymbol(symbols_math, main, mathord, "", "\\@jmath");
            defineSymbol(symbols_math, main, symbols_textord, "ı", "ı");
            defineSymbol(symbols_math, main, symbols_textord, "ȷ", "ȷ");
            defineSymbol(symbols_text, main, symbols_textord, "ı", "\\i", true);
            defineSymbol(symbols_text, main, symbols_textord, "ȷ", "\\j", true);
            defineSymbol(symbols_text, main, symbols_textord, "ß", "\\ss", true);
            defineSymbol(symbols_text, main, symbols_textord, "æ", "\\ae", true);
            defineSymbol(symbols_text, main, symbols_textord, "œ", "\\oe", true);
            defineSymbol(symbols_text, main, symbols_textord, "ø", "\\o", true);
            defineSymbol(symbols_text, main, symbols_textord, "Æ", "\\AE", true);
            defineSymbol(symbols_text, main, symbols_textord, "Œ", "\\OE", true);
            defineSymbol(symbols_text, main, symbols_textord, "Ø", "\\O", true);
            defineSymbol(symbols_text, main, symbols_accent, "ˊ", "\\'");
            defineSymbol(symbols_text, main, symbols_accent, "ˋ", "\\`");
            defineSymbol(symbols_text, main, symbols_accent, "ˆ", "\\^");
            defineSymbol(symbols_text, main, symbols_accent, "˜", "\\~");
            defineSymbol(symbols_text, main, symbols_accent, "ˉ", "\\=");
            defineSymbol(symbols_text, main, symbols_accent, "˘", "\\u");
            defineSymbol(symbols_text, main, symbols_accent, "˙", "\\.");
            defineSymbol(symbols_text, main, symbols_accent, "˚", "\\r");
            defineSymbol(symbols_text, main, symbols_accent, "ˇ", "\\v");
            defineSymbol(symbols_text, main, symbols_accent, "¨", '\\"');
            defineSymbol(symbols_text, main, symbols_accent, "˝", "\\H");
            defineSymbol(symbols_text, main, symbols_accent, "◯", "\\textcircled");
            var ligatures = {
              "--": true,
              "---": true,
              "``": true,
              "''": true
            };
            defineSymbol(symbols_text, main, symbols_textord, "–", "--", true);
            defineSymbol(symbols_text, main, symbols_textord, "–", "\\textendash");
            defineSymbol(symbols_text, main, symbols_textord, "—", "---", true);
            defineSymbol(symbols_text, main, symbols_textord, "—", "\\textemdash");
            defineSymbol(symbols_text, main, symbols_textord, "‘", "`", true);
            defineSymbol(symbols_text, main, symbols_textord, "‘", "\\textquoteleft");
            defineSymbol(symbols_text, main, symbols_textord, "’", "'", true);
            defineSymbol(symbols_text, main, symbols_textord, "’", "\\textquoteright");
            defineSymbol(symbols_text, main, symbols_textord, "“", "``", true);
            defineSymbol(symbols_text, main, symbols_textord, "“", "\\textquotedblleft");
            defineSymbol(symbols_text, main, symbols_textord, "”", "''", true);
            defineSymbol(symbols_text, main, symbols_textord, "”", "\\textquotedblright");
            defineSymbol(symbols_math, main, symbols_textord, "°", "\\degree", true);
            defineSymbol(symbols_text, main, symbols_textord, "°", "\\degree");
            defineSymbol(symbols_text, main, symbols_textord, "°", "\\textdegree", true);
            defineSymbol(symbols_math, main, symbols_textord, "£", "\\pounds");
            defineSymbol(symbols_math, main, symbols_textord, "£", "\\mathsterling", true);
            defineSymbol(symbols_text, main, symbols_textord, "£", "\\pounds");
            defineSymbol(symbols_text, main, symbols_textord, "£", "\\textsterling", true);
            defineSymbol(symbols_math, ams, symbols_textord, "✠", "\\maltese");
            defineSymbol(symbols_text, ams, symbols_textord, "✠", "\\maltese");
            var mathTextSymbols = '0123456789/@."';
            for (var symbols_i = 0; symbols_i < mathTextSymbols.length; symbols_i++) {
              var symbols_ch = mathTextSymbols.charAt(symbols_i);
              defineSymbol(symbols_math, main, symbols_textord, symbols_ch, symbols_ch);
            }
            var textSymbols = '0123456789!@*()-=+";:?/.,';
            for (var src_symbols_i = 0; src_symbols_i < textSymbols.length; src_symbols_i++) {
              var _ch = textSymbols.charAt(src_symbols_i);
              defineSymbol(symbols_text, main, symbols_textord, _ch, _ch);
            }
            var letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
            for (var symbols_i2 = 0; symbols_i2 < letters.length; symbols_i2++) {
              var _ch2 = letters.charAt(symbols_i2);
              defineSymbol(symbols_math, main, mathord, _ch2, _ch2);
              defineSymbol(symbols_text, main, symbols_textord, _ch2, _ch2);
            }
            defineSymbol(symbols_math, ams, symbols_textord, "C", "ℂ");
            defineSymbol(symbols_text, ams, symbols_textord, "C", "ℂ");
            defineSymbol(symbols_math, ams, symbols_textord, "H", "ℍ");
            defineSymbol(symbols_text, ams, symbols_textord, "H", "ℍ");
            defineSymbol(symbols_math, ams, symbols_textord, "N", "ℕ");
            defineSymbol(symbols_text, ams, symbols_textord, "N", "ℕ");
            defineSymbol(symbols_math, ams, symbols_textord, "P", "ℙ");
            defineSymbol(symbols_text, ams, symbols_textord, "P", "ℙ");
            defineSymbol(symbols_math, ams, symbols_textord, "Q", "ℚ");
            defineSymbol(symbols_text, ams, symbols_textord, "Q", "ℚ");
            defineSymbol(symbols_math, ams, symbols_textord, "R", "ℝ");
            defineSymbol(symbols_text, ams, symbols_textord, "R", "ℝ");
            defineSymbol(symbols_math, ams, symbols_textord, "Z", "ℤ");
            defineSymbol(symbols_text, ams, symbols_textord, "Z", "ℤ");
            defineSymbol(symbols_math, main, mathord, "h", "ℎ");
            defineSymbol(symbols_text, main, mathord, "h", "ℎ");
            var symbols_wideChar = "";
            for (var symbols_i3 = 0; symbols_i3 < letters.length; symbols_i3++) {
              var _ch3 = letters.charAt(symbols_i3);
              symbols_wideChar = String.fromCharCode(55349, 56320 + symbols_i3);
              defineSymbol(symbols_math, main, mathord, _ch3, symbols_wideChar);
              defineSymbol(symbols_text, main, symbols_textord, _ch3, symbols_wideChar);
              symbols_wideChar = String.fromCharCode(55349, 56372 + symbols_i3);
              defineSymbol(symbols_math, main, mathord, _ch3, symbols_wideChar);
              defineSymbol(symbols_text, main, symbols_textord, _ch3, symbols_wideChar);
              symbols_wideChar = String.fromCharCode(55349, 56424 + symbols_i3);
              defineSymbol(symbols_math, main, mathord, _ch3, symbols_wideChar);
              defineSymbol(symbols_text, main, symbols_textord, _ch3, symbols_wideChar);
              symbols_wideChar = String.fromCharCode(55349, 56580 + symbols_i3);
              defineSymbol(symbols_math, main, mathord, _ch3, symbols_wideChar);
              defineSymbol(symbols_text, main, symbols_textord, _ch3, symbols_wideChar);
              symbols_wideChar = String.fromCharCode(55349, 56736 + symbols_i3);
              defineSymbol(symbols_math, main, mathord, _ch3, symbols_wideChar);
              defineSymbol(symbols_text, main, symbols_textord, _ch3, symbols_wideChar);
              symbols_wideChar = String.fromCharCode(55349, 56788 + symbols_i3);
              defineSymbol(symbols_math, main, mathord, _ch3, symbols_wideChar);
              defineSymbol(symbols_text, main, symbols_textord, _ch3, symbols_wideChar);
              symbols_wideChar = String.fromCharCode(55349, 56840 + symbols_i3);
              defineSymbol(symbols_math, main, mathord, _ch3, symbols_wideChar);
              defineSymbol(symbols_text, main, symbols_textord, _ch3, symbols_wideChar);
              symbols_wideChar = String.fromCharCode(55349, 56944 + symbols_i3);
              defineSymbol(symbols_math, main, mathord, _ch3, symbols_wideChar);
              defineSymbol(symbols_text, main, symbols_textord, _ch3, symbols_wideChar);
              if (symbols_i3 < 26) {
                symbols_wideChar = String.fromCharCode(55349, 56632 + symbols_i3);
                defineSymbol(symbols_math, main, mathord, _ch3, symbols_wideChar);
                defineSymbol(symbols_text, main, symbols_textord, _ch3, symbols_wideChar);
                symbols_wideChar = String.fromCharCode(55349, 56476 + symbols_i3);
                defineSymbol(symbols_math, main, mathord, _ch3, symbols_wideChar);
                defineSymbol(symbols_text, main, symbols_textord, _ch3, symbols_wideChar);
              }
            }
            symbols_wideChar = String.fromCharCode(55349, 56668);
            defineSymbol(symbols_math, main, mathord, "k", symbols_wideChar);
            defineSymbol(symbols_text, main, symbols_textord, "k", symbols_wideChar);
            for (var symbols_i4 = 0; symbols_i4 < 10; symbols_i4++) {
              var _ch4 = symbols_i4.toString();
              symbols_wideChar = String.fromCharCode(55349, 57294 + symbols_i4);
              defineSymbol(symbols_math, main, mathord, _ch4, symbols_wideChar);
              defineSymbol(symbols_text, main, symbols_textord, _ch4, symbols_wideChar);
              symbols_wideChar = String.fromCharCode(55349, 57314 + symbols_i4);
              defineSymbol(symbols_math, main, mathord, _ch4, symbols_wideChar);
              defineSymbol(symbols_text, main, symbols_textord, _ch4, symbols_wideChar);
              symbols_wideChar = String.fromCharCode(55349, 57324 + symbols_i4);
              defineSymbol(symbols_math, main, mathord, _ch4, symbols_wideChar);
              defineSymbol(symbols_text, main, symbols_textord, _ch4, symbols_wideChar);
              symbols_wideChar = String.fromCharCode(55349, 57334 + symbols_i4);
              defineSymbol(symbols_math, main, mathord, _ch4, symbols_wideChar);
              defineSymbol(symbols_text, main, symbols_textord, _ch4, symbols_wideChar);
            }
            var extraLatin = "ÇÐÞçþ";
            for (var _i5 = 0; _i5 < extraLatin.length; _i5++) {
              var _ch5 = extraLatin.charAt(_i5);
              defineSymbol(symbols_math, main, mathord, _ch5, _ch5);
              defineSymbol(symbols_text, main, symbols_textord, _ch5, _ch5);
            }
            var wideLatinLetterData = [
              ["mathbf", "textbf", "Main-Bold"],
              // A-Z bold upright
              ["mathbf", "textbf", "Main-Bold"],
              // a-z bold upright
              ["mathnormal", "textit", "Math-Italic"],
              // A-Z italic
              ["mathnormal", "textit", "Math-Italic"],
              // a-z italic
              ["boldsymbol", "boldsymbol", "Main-BoldItalic"],
              // A-Z bold italic
              ["boldsymbol", "boldsymbol", "Main-BoldItalic"],
              // a-z bold italic
              // Map fancy A-Z letters to script, not calligraphic.
              // This aligns with unicode-math and math fonts (except Cambria Math).
              ["mathscr", "textscr", "Script-Regular"],
              // A-Z script
              ["", "", ""],
              // a-z script.  No font
              ["", "", ""],
              // A-Z bold script. No font
              ["", "", ""],
              // a-z bold script. No font
              ["mathfrak", "textfrak", "Fraktur-Regular"],
              // A-Z Fraktur
              ["mathfrak", "textfrak", "Fraktur-Regular"],
              // a-z Fraktur
              ["mathbb", "textbb", "AMS-Regular"],
              // A-Z double-struck
              ["mathbb", "textbb", "AMS-Regular"],
              // k double-struck
              ["", "", ""],
              // A-Z bold Fraktur No font metrics
              ["", "", ""],
              // a-z bold Fraktur.   No font.
              ["mathsf", "textsf", "SansSerif-Regular"],
              // A-Z sans-serif
              ["mathsf", "textsf", "SansSerif-Regular"],
              // a-z sans-serif
              ["mathboldsf", "textboldsf", "SansSerif-Bold"],
              // A-Z bold sans-serif
              ["mathboldsf", "textboldsf", "SansSerif-Bold"],
              // a-z bold sans-serif
              ["mathitsf", "textitsf", "SansSerif-Italic"],
              // A-Z italic sans-serif
              ["mathitsf", "textitsf", "SansSerif-Italic"],
              // a-z italic sans-serif
              ["", "", ""],
              // A-Z bold italic sans. No font
              ["", "", ""],
              // a-z bold italic sans. No font
              ["mathtt", "texttt", "Typewriter-Regular"],
              // A-Z monospace
              ["mathtt", "texttt", "Typewriter-Regular"]
            ];
            var wideNumeralData = [
              ["mathbf", "textbf", "Main-Bold"],
              // 0-9 bold
              ["", "", ""],
              // 0-9 double-struck. No KaTeX font.
              ["mathsf", "textsf", "SansSerif-Regular"],
              // 0-9 sans-serif
              ["mathboldsf", "textboldsf", "SansSerif-Bold"],
              // 0-9 bold sans-serif
              ["mathtt", "texttt", "Typewriter-Regular"]
            ];
            var wide_character_wideCharacterFont = function wideCharacterFont(wideChar, mode) {
              var H = wideChar.charCodeAt(0);
              var L = wideChar.charCodeAt(1);
              var codePoint = (H - 55296) * 1024 + (L - 56320) + 65536;
              var j = mode === "math" ? 0 : 1;
              if (119808 <= codePoint && codePoint < 120484) {
                var i = Math.floor((codePoint - 119808) / 26);
                return [wideLatinLetterData[i][2], wideLatinLetterData[i][j]];
              } else if (120782 <= codePoint && codePoint <= 120831) {
                var _i = Math.floor((codePoint - 120782) / 10);
                return [wideNumeralData[_i][2], wideNumeralData[_i][j]];
              } else if (codePoint === 120485 || codePoint === 120486) {
                return [wideLatinLetterData[0][2], wideLatinLetterData[0][j]];
              } else if (120486 < codePoint && codePoint < 120782) {
                return ["", ""];
              } else {
                throw new src_ParseError("Unsupported character: " + wideChar);
              }
            };
            var sizeStyleMap = [
              // Each element contains [textsize, scriptsize, scriptscriptsize].
              // The size mappings are taken from TeX with \normalsize=10pt.
              [1, 1, 1],
              // size1: [5, 5, 5]              \tiny
              [2, 1, 1],
              // size2: [6, 5, 5]
              [3, 1, 1],
              // size3: [7, 5, 5]              \scriptsize
              [4, 2, 1],
              // size4: [8, 6, 5]              \footnotesize
              [5, 2, 1],
              // size5: [9, 6, 5]              \small
              [6, 3, 1],
              // size6: [10, 7, 5]             \normalsize
              [7, 4, 2],
              // size7: [12, 8, 6]             \large
              [8, 6, 3],
              // size8: [14.4, 10, 7]          \Large
              [9, 7, 6],
              // size9: [17.28, 12, 10]        \LARGE
              [10, 8, 7],
              // size10: [20.74, 14.4, 12]     \huge
              [11, 10, 9]
            ];
            var sizeMultipliers = [
              // fontMetrics.js:getGlobalMetrics also uses size indexes, so if
              // you change size indexes, change that function.
              0.5,
              0.6,
              0.7,
              0.8,
              0.9,
              1,
              1.2,
              1.44,
              1.728,
              2.074,
              2.488
            ];
            var sizeAtStyle = function sizeAtStyle2(size, style) {
              return style.size < 2 ? size : sizeStyleMap[size - 1][style.size - 1];
            };
            var Options_Options = function() {
              function Options(data2) {
                this.style = void 0;
                this.color = void 0;
                this.size = void 0;
                this.textSize = void 0;
                this.phantom = void 0;
                this.font = void 0;
                this.fontFamily = void 0;
                this.fontWeight = void 0;
                this.fontShape = void 0;
                this.sizeMultiplier = void 0;
                this.maxSize = void 0;
                this.minRuleThickness = void 0;
                this._fontMetrics = void 0;
                this.style = data2.style;
                this.color = data2.color;
                this.size = data2.size || Options.BASESIZE;
                this.textSize = data2.textSize || this.size;
                this.phantom = !!data2.phantom;
                this.font = data2.font || "";
                this.fontFamily = data2.fontFamily || "";
                this.fontWeight = data2.fontWeight || "";
                this.fontShape = data2.fontShape || "";
                this.sizeMultiplier = sizeMultipliers[this.size - 1];
                this.maxSize = data2.maxSize;
                this.minRuleThickness = data2.minRuleThickness;
                this._fontMetrics = void 0;
              }
              var _proto = Options.prototype;
              _proto.extend = function extend3(extension) {
                var data2 = {
                  style: this.style,
                  size: this.size,
                  textSize: this.textSize,
                  color: this.color,
                  phantom: this.phantom,
                  font: this.font,
                  fontFamily: this.fontFamily,
                  fontWeight: this.fontWeight,
                  fontShape: this.fontShape,
                  maxSize: this.maxSize,
                  minRuleThickness: this.minRuleThickness
                };
                for (var key in extension) {
                  if (extension.hasOwnProperty(key)) {
                    data2[key] = extension[key];
                  }
                }
                return new Options(data2);
              };
              _proto.havingStyle = function havingStyle(style) {
                if (this.style === style) {
                  return this;
                } else {
                  return this.extend({
                    style,
                    size: sizeAtStyle(this.textSize, style)
                  });
                }
              };
              _proto.havingCrampedStyle = function havingCrampedStyle() {
                return this.havingStyle(this.style.cramp());
              };
              _proto.havingSize = function havingSize(size) {
                if (this.size === size && this.textSize === size) {
                  return this;
                } else {
                  return this.extend({
                    style: this.style.text(),
                    size,
                    textSize: size,
                    sizeMultiplier: sizeMultipliers[size - 1]
                  });
                }
              };
              _proto.havingBaseStyle = function havingBaseStyle(style) {
                style = style || this.style.text();
                var wantSize = sizeAtStyle(Options.BASESIZE, style);
                if (this.size === wantSize && this.textSize === Options.BASESIZE && this.style === style) {
                  return this;
                } else {
                  return this.extend({
                    style,
                    size: wantSize
                  });
                }
              };
              _proto.havingBaseSizing = function havingBaseSizing() {
                var size;
                switch (this.style.id) {
                  case 4:
                  case 5:
                    size = 3;
                    break;
                  case 6:
                  case 7:
                    size = 1;
                    break;
                  default:
                    size = 6;
                }
                return this.extend({
                  style: this.style.text(),
                  size
                });
              };
              _proto.withColor = function withColor(color) {
                return this.extend({
                  color
                });
              };
              _proto.withPhantom = function withPhantom() {
                return this.extend({
                  phantom: true
                });
              };
              _proto.withFont = function withFont(font) {
                return this.extend({
                  font
                });
              };
              _proto.withTextFontFamily = function withTextFontFamily(fontFamily) {
                return this.extend({
                  fontFamily,
                  font: ""
                });
              };
              _proto.withTextFontWeight = function withTextFontWeight(fontWeight) {
                return this.extend({
                  fontWeight,
                  font: ""
                });
              };
              _proto.withTextFontShape = function withTextFontShape(fontShape) {
                return this.extend({
                  fontShape,
                  font: ""
                });
              };
              _proto.sizingClasses = function sizingClasses(oldOptions) {
                if (oldOptions.size !== this.size) {
                  return ["sizing", "reset-size" + oldOptions.size, "size" + this.size];
                } else {
                  return [];
                }
              };
              _proto.baseSizingClasses = function baseSizingClasses() {
                if (this.size !== Options.BASESIZE) {
                  return ["sizing", "reset-size" + this.size, "size" + Options.BASESIZE];
                } else {
                  return [];
                }
              };
              _proto.fontMetrics = function fontMetrics() {
                if (!this._fontMetrics) {
                  this._fontMetrics = getGlobalMetrics(this.size);
                }
                return this._fontMetrics;
              };
              _proto.getColor = function getColor() {
                if (this.phantom) {
                  return "transparent";
                } else {
                  return this.color;
                }
              };
              return Options;
            }();
            Options_Options.BASESIZE = 6;
            var src_Options = Options_Options;
            var ptPerUnit = {
              // https://en.wikibooks.org/wiki/LaTeX/Lengths and
              // https://tex.stackexchange.com/a/8263
              "pt": 1,
              // TeX point
              "mm": 7227 / 2540,
              // millimeter
              "cm": 7227 / 254,
              // centimeter
              "in": 72.27,
              // inch
              "bp": 803 / 800,
              // big (PostScript) points
              "pc": 12,
              // pica
              "dd": 1238 / 1157,
              // didot
              "cc": 14856 / 1157,
              // cicero (12 didot)
              "nd": 685 / 642,
              // new didot
              "nc": 1370 / 107,
              // new cicero (12 new didot)
              "sp": 1 / 65536,
              // scaled point (TeX's internal smallest unit)
              // https://tex.stackexchange.com/a/41371
              "px": 803 / 800
              // \pdfpxdimen defaults to 1 bp in pdfTeX and LuaTeX
            };
            var relativeUnit = {
              "ex": true,
              "em": true,
              "mu": true
            };
            var validUnit = function validUnit2(unit) {
              if (typeof unit !== "string") {
                unit = unit.unit;
              }
              return unit in ptPerUnit || unit in relativeUnit || unit === "ex";
            };
            var units_calculateSize = function calculateSize(sizeValue, options) {
              var scale;
              if (sizeValue.unit in ptPerUnit) {
                scale = ptPerUnit[sizeValue.unit] / options.fontMetrics().ptPerEm / options.sizeMultiplier;
              } else if (sizeValue.unit === "mu") {
                scale = options.fontMetrics().cssEmPerMu;
              } else {
                var unitOptions;
                if (options.style.isTight()) {
                  unitOptions = options.havingStyle(options.style.text());
                } else {
                  unitOptions = options;
                }
                if (sizeValue.unit === "ex") {
                  scale = unitOptions.fontMetrics().xHeight;
                } else if (sizeValue.unit === "em") {
                  scale = unitOptions.fontMetrics().quad;
                } else {
                  throw new src_ParseError("Invalid unit: '" + sizeValue.unit + "'");
                }
                if (unitOptions !== options) {
                  scale *= unitOptions.sizeMultiplier / options.sizeMultiplier;
                }
              }
              return Math.min(sizeValue.number * scale, options.maxSize);
            };
            var buildCommon_lookupSymbol = function lookupSymbol(value, fontName, mode) {
              if (src_symbols[mode][value] && src_symbols[mode][value].replace) {
                value = src_symbols[mode][value].replace;
              }
              return {
                value,
                metrics: getCharacterMetrics(value, fontName, mode)
              };
            };
            var buildCommon_makeSymbol = function makeSymbol(value, fontName, mode, options, classes) {
              var lookup = buildCommon_lookupSymbol(value, fontName, mode);
              var metrics = lookup.metrics;
              value = lookup.value;
              var symbolNode;
              if (metrics) {
                var italic = metrics.italic;
                if (mode === "text" || options && options.font === "mathit") {
                  italic = 0;
                }
                symbolNode = new domTree_SymbolNode(value, metrics.height, metrics.depth, italic, metrics.skew, metrics.width, classes);
              } else {
                typeof console !== "undefined" && console.warn("No character metrics " + ("for '" + value + "' in style '" + fontName + "' and mode '" + mode + "'"));
                symbolNode = new domTree_SymbolNode(value, 0, 0, 0, 0, 0, classes);
              }
              if (options) {
                symbolNode.maxFontSize = options.sizeMultiplier;
                if (options.style.isTight()) {
                  symbolNode.classes.push("mtight");
                }
                var color = options.getColor();
                if (color) {
                  symbolNode.style.color = color;
                }
              }
              return symbolNode;
            };
            var buildCommon_mathsym = function mathsym(value, mode, options, classes) {
              if (classes === void 0) {
                classes = [];
              }
              if (options.font === "boldsymbol" && buildCommon_lookupSymbol(value, "Main-Bold", mode).metrics) {
                return buildCommon_makeSymbol(value, "Main-Bold", mode, options, classes.concat(["mathbf"]));
              } else if (value === "\\" || src_symbols[mode][value].font === "main") {
                return buildCommon_makeSymbol(value, "Main-Regular", mode, options, classes);
              } else {
                return buildCommon_makeSymbol(value, "AMS-Regular", mode, options, classes.concat(["amsrm"]));
              }
            };
            var boldsymbol = function boldsymbol2(value, mode, options, classes, type2) {
              if (type2 !== "textord" && buildCommon_lookupSymbol(value, "Math-BoldItalic", mode).metrics) {
                return {
                  fontName: "Math-BoldItalic",
                  fontClass: "boldsymbol"
                };
              } else {
                return {
                  fontName: "Main-Bold",
                  fontClass: "mathbf"
                };
              }
            };
            var buildCommon_makeOrd = function makeOrd(group, options, type2) {
              var mode = group.mode;
              var text4 = group.text;
              var classes = ["mord"];
              var isFont = mode === "math" || mode === "text" && options.font;
              var fontOrFamily = isFont ? options.font : options.fontFamily;
              if (text4.charCodeAt(0) === 55349) {
                var _wideCharacterFont = wide_character_wideCharacterFont(text4, mode), wideFontName = _wideCharacterFont[0], wideFontClass = _wideCharacterFont[1];
                return buildCommon_makeSymbol(text4, wideFontName, mode, options, classes.concat(wideFontClass));
              } else if (fontOrFamily) {
                var fontName;
                var fontClasses;
                if (fontOrFamily === "boldsymbol") {
                  var fontData = boldsymbol(text4, mode, options, classes, type2);
                  fontName = fontData.fontName;
                  fontClasses = [fontData.fontClass];
                } else if (isFont) {
                  fontName = fontMap[fontOrFamily].fontName;
                  fontClasses = [fontOrFamily];
                } else {
                  fontName = retrieveTextFontName(fontOrFamily, options.fontWeight, options.fontShape);
                  fontClasses = [fontOrFamily, options.fontWeight, options.fontShape];
                }
                if (buildCommon_lookupSymbol(text4, fontName, mode).metrics) {
                  return buildCommon_makeSymbol(text4, fontName, mode, options, classes.concat(fontClasses));
                } else if (ligatures.hasOwnProperty(text4) && fontName.substr(0, 10) === "Typewriter") {
                  var parts = [];
                  for (var i = 0; i < text4.length; i++) {
                    parts.push(buildCommon_makeSymbol(text4[i], fontName, mode, options, classes.concat(fontClasses)));
                  }
                  return buildCommon_makeFragment(parts);
                }
              }
              if (type2 === "mathord") {
                return buildCommon_makeSymbol(text4, "Math-Italic", mode, options, classes.concat(["mathnormal"]));
              } else if (type2 === "textord") {
                var font = src_symbols[mode][text4] && src_symbols[mode][text4].font;
                if (font === "ams") {
                  var _fontName = retrieveTextFontName("amsrm", options.fontWeight, options.fontShape);
                  return buildCommon_makeSymbol(text4, _fontName, mode, options, classes.concat("amsrm", options.fontWeight, options.fontShape));
                } else if (font === "main" || !font) {
                  var _fontName2 = retrieveTextFontName("textrm", options.fontWeight, options.fontShape);
                  return buildCommon_makeSymbol(text4, _fontName2, mode, options, classes.concat(options.fontWeight, options.fontShape));
                } else {
                  var _fontName3 = retrieveTextFontName(font, options.fontWeight, options.fontShape);
                  return buildCommon_makeSymbol(text4, _fontName3, mode, options, classes.concat(_fontName3, options.fontWeight, options.fontShape));
                }
              } else {
                throw new Error("unexpected type: " + type2 + " in makeOrd");
              }
            };
            var buildCommon_canCombine = function canCombine(prev2, next2) {
              if (createClass(prev2.classes) !== createClass(next2.classes) || prev2.skew !== next2.skew || prev2.maxFontSize !== next2.maxFontSize) {
                return false;
              }
              for (var style in prev2.style) {
                if (prev2.style.hasOwnProperty(style) && prev2.style[style] !== next2.style[style]) {
                  return false;
                }
              }
              for (var _style in next2.style) {
                if (next2.style.hasOwnProperty(_style) && prev2.style[_style] !== next2.style[_style]) {
                  return false;
                }
              }
              return true;
            };
            var buildCommon_tryCombineChars = function tryCombineChars(chars) {
              for (var i = 0; i < chars.length - 1; i++) {
                var prev2 = chars[i];
                var next2 = chars[i + 1];
                if (prev2 instanceof domTree_SymbolNode && next2 instanceof domTree_SymbolNode && buildCommon_canCombine(prev2, next2)) {
                  prev2.text += next2.text;
                  prev2.height = Math.max(prev2.height, next2.height);
                  prev2.depth = Math.max(prev2.depth, next2.depth);
                  prev2.italic = next2.italic;
                  chars.splice(i + 1, 1);
                  i--;
                }
              }
              return chars;
            };
            var sizeElementFromChildren = function sizeElementFromChildren2(elem) {
              var height = 0;
              var depth = 0;
              var maxFontSize = 0;
              for (var i = 0; i < elem.children.length; i++) {
                var child = elem.children[i];
                if (child.height > height) {
                  height = child.height;
                }
                if (child.depth > depth) {
                  depth = child.depth;
                }
                if (child.maxFontSize > maxFontSize) {
                  maxFontSize = child.maxFontSize;
                }
              }
              elem.height = height;
              elem.depth = depth;
              elem.maxFontSize = maxFontSize;
            };
            var buildCommon_makeSpan = function makeSpan(classes, children2, options, style) {
              var span = new domTree_Span(classes, children2, options, style);
              sizeElementFromChildren(span);
              return span;
            };
            var buildCommon_makeSvgSpan = function makeSvgSpan(classes, children2, options, style) {
              return new domTree_Span(classes, children2, options, style);
            };
            var makeLineSpan = function makeLineSpan2(className, options, thickness) {
              var line = buildCommon_makeSpan([className], [], options);
              line.height = Math.max(thickness || options.fontMetrics().defaultRuleThickness, options.minRuleThickness);
              line.style.borderBottomWidth = line.height + "em";
              line.maxFontSize = 1;
              return line;
            };
            var buildCommon_makeAnchor = function makeAnchor(href, classes, children2, options) {
              var anchor = new domTree_Anchor(href, classes, children2, options);
              sizeElementFromChildren(anchor);
              return anchor;
            };
            var buildCommon_makeFragment = function makeFragment(children2) {
              var fragment = new tree_DocumentFragment(children2);
              sizeElementFromChildren(fragment);
              return fragment;
            };
            var buildCommon_wrapFragment = function wrapFragment(group, options) {
              if (group instanceof tree_DocumentFragment) {
                return buildCommon_makeSpan([], [group], options);
              }
              return group;
            };
            var getVListChildrenAndDepth = function getVListChildrenAndDepth2(params) {
              if (params.positionType === "individualShift") {
                var oldChildren = params.children;
                var children2 = [oldChildren[0]];
                var _depth = -oldChildren[0].shift - oldChildren[0].elem.depth;
                var currPos = _depth;
                for (var i = 1; i < oldChildren.length; i++) {
                  var diff = -oldChildren[i].shift - currPos - oldChildren[i].elem.depth;
                  var size = diff - (oldChildren[i - 1].elem.height + oldChildren[i - 1].elem.depth);
                  currPos = currPos + diff;
                  children2.push({
                    type: "kern",
                    size
                  });
                  children2.push(oldChildren[i]);
                }
                return {
                  children: children2,
                  depth: _depth
                };
              }
              var depth;
              if (params.positionType === "top") {
                var bottom = params.positionData;
                for (var _i = 0; _i < params.children.length; _i++) {
                  var child = params.children[_i];
                  bottom -= child.type === "kern" ? child.size : child.elem.height + child.elem.depth;
                }
                depth = bottom;
              } else if (params.positionType === "bottom") {
                depth = -params.positionData;
              } else {
                var firstChild = params.children[0];
                if (firstChild.type !== "elem") {
                  throw new Error('First child must have type "elem".');
                }
                if (params.positionType === "shift") {
                  depth = -firstChild.elem.depth - params.positionData;
                } else if (params.positionType === "firstBaseline") {
                  depth = -firstChild.elem.depth;
                } else {
                  throw new Error("Invalid positionType " + params.positionType + ".");
                }
              }
              return {
                children: params.children,
                depth
              };
            };
            var buildCommon_makeVList = function makeVList(params, options) {
              var _getVListChildrenAndD = getVListChildrenAndDepth(params), children2 = _getVListChildrenAndD.children, depth = _getVListChildrenAndD.depth;
              var pstrutSize = 0;
              for (var i = 0; i < children2.length; i++) {
                var child = children2[i];
                if (child.type === "elem") {
                  var elem = child.elem;
                  pstrutSize = Math.max(pstrutSize, elem.maxFontSize, elem.height);
                }
              }
              pstrutSize += 2;
              var pstrut = buildCommon_makeSpan(["pstrut"], []);
              pstrut.style.height = pstrutSize + "em";
              var realChildren = [];
              var minPos = depth;
              var maxPos = depth;
              var currPos = depth;
              for (var _i2 = 0; _i2 < children2.length; _i2++) {
                var _child = children2[_i2];
                if (_child.type === "kern") {
                  currPos += _child.size;
                } else {
                  var _elem = _child.elem;
                  var classes = _child.wrapperClasses || [];
                  var style = _child.wrapperStyle || {};
                  var childWrap = buildCommon_makeSpan(classes, [pstrut, _elem], void 0, style);
                  childWrap.style.top = -pstrutSize - currPos - _elem.depth + "em";
                  if (_child.marginLeft) {
                    childWrap.style.marginLeft = _child.marginLeft;
                  }
                  if (_child.marginRight) {
                    childWrap.style.marginRight = _child.marginRight;
                  }
                  realChildren.push(childWrap);
                  currPos += _elem.height + _elem.depth;
                }
                minPos = Math.min(minPos, currPos);
                maxPos = Math.max(maxPos, currPos);
              }
              var vlist = buildCommon_makeSpan(["vlist"], realChildren);
              vlist.style.height = maxPos + "em";
              var rows;
              if (minPos < 0) {
                var emptySpan = buildCommon_makeSpan([], []);
                var depthStrut = buildCommon_makeSpan(["vlist"], [emptySpan]);
                depthStrut.style.height = -minPos + "em";
                var topStrut = buildCommon_makeSpan(["vlist-s"], [new domTree_SymbolNode("​")]);
                rows = [buildCommon_makeSpan(["vlist-r"], [vlist, topStrut]), buildCommon_makeSpan(["vlist-r"], [depthStrut])];
              } else {
                rows = [buildCommon_makeSpan(["vlist-r"], [vlist])];
              }
              var vtable = buildCommon_makeSpan(["vlist-t"], rows);
              if (rows.length === 2) {
                vtable.classes.push("vlist-t2");
              }
              vtable.height = maxPos;
              vtable.depth = -minPos;
              return vtable;
            };
            var buildCommon_makeGlue = function makeGlue(measurement, options) {
              var rule = buildCommon_makeSpan(["mspace"], [], options);
              var size = units_calculateSize(measurement, options);
              rule.style.marginRight = size + "em";
              return rule;
            };
            var retrieveTextFontName = function retrieveTextFontName2(fontFamily, fontWeight, fontShape) {
              var baseFontName = "";
              switch (fontFamily) {
                case "amsrm":
                  baseFontName = "AMS";
                  break;
                case "textrm":
                  baseFontName = "Main";
                  break;
                case "textsf":
                  baseFontName = "SansSerif";
                  break;
                case "texttt":
                  baseFontName = "Typewriter";
                  break;
                default:
                  baseFontName = fontFamily;
              }
              var fontStylesName;
              if (fontWeight === "textbf" && fontShape === "textit") {
                fontStylesName = "BoldItalic";
              } else if (fontWeight === "textbf") {
                fontStylesName = "Bold";
              } else if (fontWeight === "textit") {
                fontStylesName = "Italic";
              } else {
                fontStylesName = "Regular";
              }
              return baseFontName + "-" + fontStylesName;
            };
            var fontMap = {
              // styles
              "mathbf": {
                variant: "bold",
                fontName: "Main-Bold"
              },
              "mathrm": {
                variant: "normal",
                fontName: "Main-Regular"
              },
              "textit": {
                variant: "italic",
                fontName: "Main-Italic"
              },
              "mathit": {
                variant: "italic",
                fontName: "Main-Italic"
              },
              "mathnormal": {
                variant: "italic",
                fontName: "Math-Italic"
              },
              // "boldsymbol" is missing because they require the use of multiple fonts:
              // Math-BoldItalic and Main-Bold.  This is handled by a special case in
              // makeOrd which ends up calling boldsymbol.
              // families
              "mathbb": {
                variant: "double-struck",
                fontName: "AMS-Regular"
              },
              "mathcal": {
                variant: "script",
                fontName: "Caligraphic-Regular"
              },
              "mathfrak": {
                variant: "fraktur",
                fontName: "Fraktur-Regular"
              },
              "mathscr": {
                variant: "script",
                fontName: "Script-Regular"
              },
              "mathsf": {
                variant: "sans-serif",
                fontName: "SansSerif-Regular"
              },
              "mathtt": {
                variant: "monospace",
                fontName: "Typewriter-Regular"
              }
            };
            var svgData = {
              //   path, width, height
              vec: ["vec", 0.471, 0.714],
              // values from the font glyph
              oiintSize1: ["oiintSize1", 0.957, 0.499],
              // oval to overlay the integrand
              oiintSize2: ["oiintSize2", 1.472, 0.659],
              oiiintSize1: ["oiiintSize1", 1.304, 0.499],
              oiiintSize2: ["oiiintSize2", 1.98, 0.659],
              leftParenInner: ["leftParenInner", 0.875, 0.3],
              rightParenInner: ["rightParenInner", 0.875, 0.3]
            };
            var buildCommon_staticSvg = function staticSvg(value, options) {
              var _svgData$value = svgData[value], pathName = _svgData$value[0], width = _svgData$value[1], height = _svgData$value[2];
              var path = new domTree_PathNode(pathName);
              var svgNode = new SvgNode([path], {
                "width": width + "em",
                "height": height + "em",
                // Override CSS rule `.katex svg { width: 100% }`
                "style": "width:" + width + "em",
                "viewBox": "0 0 " + 1e3 * width + " " + 1e3 * height,
                "preserveAspectRatio": "xMinYMin"
              });
              var span = buildCommon_makeSvgSpan(["overlay"], [svgNode], options);
              span.height = height;
              span.style.height = height + "em";
              span.style.width = width + "em";
              return span;
            };
            var buildCommon = {
              fontMap,
              makeSymbol: buildCommon_makeSymbol,
              mathsym: buildCommon_mathsym,
              makeSpan: buildCommon_makeSpan,
              makeSvgSpan: buildCommon_makeSvgSpan,
              makeLineSpan,
              makeAnchor: buildCommon_makeAnchor,
              makeFragment: buildCommon_makeFragment,
              wrapFragment: buildCommon_wrapFragment,
              makeVList: buildCommon_makeVList,
              makeOrd: buildCommon_makeOrd,
              makeGlue: buildCommon_makeGlue,
              staticSvg: buildCommon_staticSvg,
              svgData,
              tryCombineChars: buildCommon_tryCombineChars
            };
            var thinspace = {
              number: 3,
              unit: "mu"
            };
            var mediumspace = {
              number: 4,
              unit: "mu"
            };
            var thickspace = {
              number: 5,
              unit: "mu"
            };
            var spacings = {
              mord: {
                mop: thinspace,
                mbin: mediumspace,
                mrel: thickspace,
                minner: thinspace
              },
              mop: {
                mord: thinspace,
                mop: thinspace,
                mrel: thickspace,
                minner: thinspace
              },
              mbin: {
                mord: mediumspace,
                mop: mediumspace,
                mopen: mediumspace,
                minner: mediumspace
              },
              mrel: {
                mord: thickspace,
                mop: thickspace,
                mopen: thickspace,
                minner: thickspace
              },
              mopen: {},
              mclose: {
                mop: thinspace,
                mbin: mediumspace,
                mrel: thickspace,
                minner: thinspace
              },
              mpunct: {
                mord: thinspace,
                mop: thinspace,
                mrel: thickspace,
                mopen: thinspace,
                mclose: thinspace,
                mpunct: thinspace,
                minner: thinspace
              },
              minner: {
                mord: thinspace,
                mop: thinspace,
                mbin: mediumspace,
                mrel: thickspace,
                mopen: thinspace,
                mpunct: thinspace,
                minner: thinspace
              }
            };
            var tightSpacings = {
              mord: {
                mop: thinspace
              },
              mop: {
                mord: thinspace,
                mop: thinspace
              },
              mbin: {},
              mrel: {},
              mopen: {},
              mclose: {
                mop: thinspace
              },
              mpunct: {},
              minner: {
                mop: thinspace
              }
            };
            var _functions = {};
            var _htmlGroupBuilders = {};
            var _mathmlGroupBuilders = {};
            function defineFunction(_ref) {
              var type2 = _ref.type, names = _ref.names, props = _ref.props, handler = _ref.handler, htmlBuilder = _ref.htmlBuilder, mathmlBuilder = _ref.mathmlBuilder;
              var data2 = {
                type: type2,
                numArgs: props.numArgs,
                argTypes: props.argTypes,
                greediness: props.greediness === void 0 ? 1 : props.greediness,
                allowedInText: !!props.allowedInText,
                allowedInMath: props.allowedInMath === void 0 ? true : props.allowedInMath,
                numOptionalArgs: props.numOptionalArgs || 0,
                infix: !!props.infix,
                handler
              };
              for (var i = 0; i < names.length; ++i) {
                _functions[names[i]] = data2;
              }
              if (type2) {
                if (htmlBuilder) {
                  _htmlGroupBuilders[type2] = htmlBuilder;
                }
                if (mathmlBuilder) {
                  _mathmlGroupBuilders[type2] = mathmlBuilder;
                }
              }
            }
            function defineFunctionBuilders(_ref2) {
              var type2 = _ref2.type, htmlBuilder = _ref2.htmlBuilder, mathmlBuilder = _ref2.mathmlBuilder;
              defineFunction({
                type: type2,
                names: [],
                props: {
                  numArgs: 0
                },
                handler: function handler() {
                  throw new Error("Should never be called.");
                },
                htmlBuilder,
                mathmlBuilder
              });
            }
            var ordargument = function ordargument2(arg) {
              return arg.type === "ordgroup" ? arg.body : [arg];
            };
            var buildHTML_makeSpan = buildCommon.makeSpan;
            var binLeftCanceller = ["leftmost", "mbin", "mopen", "mrel", "mop", "mpunct"];
            var binRightCanceller = ["rightmost", "mrel", "mclose", "mpunct"];
            var styleMap = {
              "display": src_Style.DISPLAY,
              "text": src_Style.TEXT,
              "script": src_Style.SCRIPT,
              "scriptscript": src_Style.SCRIPTSCRIPT
            };
            var DomEnum = {
              mord: "mord",
              mop: "mop",
              mbin: "mbin",
              mrel: "mrel",
              mopen: "mopen",
              mclose: "mclose",
              mpunct: "mpunct",
              minner: "minner"
            };
            var buildHTML_buildExpression = function buildExpression(expression, options, isRealGroup, surrounding) {
              if (surrounding === void 0) {
                surrounding = [null, null];
              }
              var groups = [];
              for (var i = 0; i < expression.length; i++) {
                var output = buildHTML_buildGroup(expression[i], options);
                if (output instanceof tree_DocumentFragment) {
                  var children2 = output.children;
                  groups.push.apply(groups, children2);
                } else {
                  groups.push(output);
                }
              }
              if (!isRealGroup) {
                return groups;
              }
              var glueOptions = options;
              if (expression.length === 1) {
                var node = expression[0];
                if (node.type === "sizing") {
                  glueOptions = options.havingSize(node.size);
                } else if (node.type === "styling") {
                  glueOptions = options.havingStyle(styleMap[node.style]);
                }
              }
              var dummyPrev = buildHTML_makeSpan([surrounding[0] || "leftmost"], [], options);
              var dummyNext = buildHTML_makeSpan([surrounding[1] || "rightmost"], [], options);
              var isRoot = isRealGroup === "root";
              traverseNonSpaceNodes(groups, function(node2, prev2) {
                var prevType = prev2.classes[0];
                var type2 = node2.classes[0];
                if (prevType === "mbin" && utils.contains(binRightCanceller, type2)) {
                  prev2.classes[0] = "mord";
                } else if (type2 === "mbin" && utils.contains(binLeftCanceller, prevType)) {
                  node2.classes[0] = "mord";
                }
              }, {
                node: dummyPrev
              }, dummyNext, isRoot);
              traverseNonSpaceNodes(groups, function(node2, prev2) {
                var prevType = getTypeOfDomTree(prev2);
                var type2 = getTypeOfDomTree(node2);
                var space = prevType && type2 ? node2.hasClass("mtight") ? tightSpacings[prevType][type2] : spacings[prevType][type2] : null;
                if (space) {
                  return buildCommon.makeGlue(space, glueOptions);
                }
              }, {
                node: dummyPrev
              }, dummyNext, isRoot);
              return groups;
            };
            var traverseNonSpaceNodes = function traverseNonSpaceNodes2(nodes, callback, prev2, next2, isRoot) {
              if (next2) {
                nodes.push(next2);
              }
              var i = 0;
              for (; i < nodes.length; i++) {
                var node = nodes[i];
                var partialGroup = buildHTML_checkPartialGroup(node);
                if (partialGroup) {
                  traverseNonSpaceNodes2(partialGroup.children, callback, prev2, null, isRoot);
                  continue;
                }
                var nonspace = !node.hasClass("mspace");
                if (nonspace) {
                  var result = callback(node, prev2.node);
                  if (result) {
                    if (prev2.insertAfter) {
                      prev2.insertAfter(result);
                    } else {
                      nodes.unshift(result);
                      i++;
                    }
                  }
                }
                if (nonspace) {
                  prev2.node = node;
                } else if (isRoot && node.hasClass("newline")) {
                  prev2.node = buildHTML_makeSpan(["leftmost"]);
                }
                prev2.insertAfter = /* @__PURE__ */ function(index2) {
                  return function(n) {
                    nodes.splice(index2 + 1, 0, n);
                    i++;
                  };
                }(i);
              }
              if (next2) {
                nodes.pop();
              }
            };
            var buildHTML_checkPartialGroup = function checkPartialGroup(node) {
              if (node instanceof tree_DocumentFragment || node instanceof domTree_Anchor || node instanceof domTree_Span && node.hasClass("enclosing")) {
                return node;
              }
              return null;
            };
            var getOutermostNode = function getOutermostNode2(node, side) {
              var partialGroup = buildHTML_checkPartialGroup(node);
              if (partialGroup) {
                var children2 = partialGroup.children;
                if (children2.length) {
                  if (side === "right") {
                    return getOutermostNode2(children2[children2.length - 1], "right");
                  } else if (side === "left") {
                    return getOutermostNode2(children2[0], "left");
                  }
                }
              }
              return node;
            };
            var getTypeOfDomTree = function getTypeOfDomTree2(node, side) {
              if (!node) {
                return null;
              }
              if (side) {
                node = getOutermostNode(node, side);
              }
              return DomEnum[node.classes[0]] || null;
            };
            var makeNullDelimiter = function makeNullDelimiter2(options, classes) {
              var moreClasses = ["nulldelimiter"].concat(options.baseSizingClasses());
              return buildHTML_makeSpan(classes.concat(moreClasses));
            };
            var buildHTML_buildGroup = function buildGroup(group, options, baseOptions) {
              if (!group) {
                return buildHTML_makeSpan();
              }
              if (_htmlGroupBuilders[group.type]) {
                var groupNode = _htmlGroupBuilders[group.type](group, options);
                if (baseOptions && options.size !== baseOptions.size) {
                  groupNode = buildHTML_makeSpan(options.sizingClasses(baseOptions), [groupNode], options);
                  var multiplier = options.sizeMultiplier / baseOptions.sizeMultiplier;
                  groupNode.height *= multiplier;
                  groupNode.depth *= multiplier;
                }
                return groupNode;
              } else {
                throw new src_ParseError("Got group of unknown type: '" + group.type + "'");
              }
            };
            function buildHTMLUnbreakable(children2, options) {
              var body = buildHTML_makeSpan(["base"], children2, options);
              var strut = buildHTML_makeSpan(["strut"]);
              strut.style.height = body.height + body.depth + "em";
              strut.style.verticalAlign = -body.depth + "em";
              body.children.unshift(strut);
              return body;
            }
            function buildHTML(tree, options) {
              var tag = null;
              if (tree.length === 1 && tree[0].type === "tag") {
                tag = tree[0].tag;
                tree = tree[0].body;
              }
              var expression = buildHTML_buildExpression(tree, options, "root");
              var children2 = [];
              var parts = [];
              for (var i = 0; i < expression.length; i++) {
                parts.push(expression[i]);
                if (expression[i].hasClass("mbin") || expression[i].hasClass("mrel") || expression[i].hasClass("allowbreak")) {
                  var nobreak = false;
                  while (i < expression.length - 1 && expression[i + 1].hasClass("mspace") && !expression[i + 1].hasClass("newline")) {
                    i++;
                    parts.push(expression[i]);
                    if (expression[i].hasClass("nobreak")) {
                      nobreak = true;
                    }
                  }
                  if (!nobreak) {
                    children2.push(buildHTMLUnbreakable(parts, options));
                    parts = [];
                  }
                } else if (expression[i].hasClass("newline")) {
                  parts.pop();
                  if (parts.length > 0) {
                    children2.push(buildHTMLUnbreakable(parts, options));
                    parts = [];
                  }
                  children2.push(expression[i]);
                }
              }
              if (parts.length > 0) {
                children2.push(buildHTMLUnbreakable(parts, options));
              }
              var tagChild;
              if (tag) {
                tagChild = buildHTMLUnbreakable(buildHTML_buildExpression(tag, options, true));
                tagChild.classes = ["tag"];
                children2.push(tagChild);
              }
              var htmlNode = buildHTML_makeSpan(["katex-html"], children2);
              htmlNode.setAttribute("aria-hidden", "true");
              if (tagChild) {
                var strut = tagChild.children[0];
                strut.style.height = htmlNode.height + htmlNode.depth + "em";
                strut.style.verticalAlign = -htmlNode.depth + "em";
              }
              return htmlNode;
            }
            function newDocumentFragment(children2) {
              return new tree_DocumentFragment(children2);
            }
            var mathMLTree_MathNode = function() {
              function MathNode(type2, children2) {
                this.type = void 0;
                this.attributes = void 0;
                this.children = void 0;
                this.type = type2;
                this.attributes = {};
                this.children = children2 || [];
              }
              var _proto = MathNode.prototype;
              _proto.setAttribute = function setAttribute(name2, value) {
                this.attributes[name2] = value;
              };
              _proto.getAttribute = function getAttribute(name2) {
                return this.attributes[name2];
              };
              _proto.toNode = function toNode() {
                var node = document.createElementNS("http://www.w3.org/1998/Math/MathML", this.type);
                for (var attr2 in this.attributes) {
                  if (Object.prototype.hasOwnProperty.call(this.attributes, attr2)) {
                    node.setAttribute(attr2, this.attributes[attr2]);
                  }
                }
                for (var i = 0; i < this.children.length; i++) {
                  node.appendChild(this.children[i].toNode());
                }
                return node;
              };
              _proto.toMarkup = function toMarkup() {
                var markup = "<" + this.type;
                for (var attr2 in this.attributes) {
                  if (Object.prototype.hasOwnProperty.call(this.attributes, attr2)) {
                    markup += " " + attr2 + '="';
                    markup += utils.escape(this.attributes[attr2]);
                    markup += '"';
                  }
                }
                markup += ">";
                for (var i = 0; i < this.children.length; i++) {
                  markup += this.children[i].toMarkup();
                }
                markup += "</" + this.type + ">";
                return markup;
              };
              _proto.toText = function toText() {
                return this.children.map(function(child) {
                  return child.toText();
                }).join("");
              };
              return MathNode;
            }();
            var mathMLTree_TextNode = function() {
              function TextNode(text4) {
                this.text = void 0;
                this.text = text4;
              }
              var _proto2 = TextNode.prototype;
              _proto2.toNode = function toNode() {
                return document.createTextNode(this.text);
              };
              _proto2.toMarkup = function toMarkup() {
                return utils.escape(this.toText());
              };
              _proto2.toText = function toText() {
                return this.text;
              };
              return TextNode;
            }();
            var SpaceNode = function() {
              function SpaceNode2(width) {
                this.width = void 0;
                this.character = void 0;
                this.width = width;
                if (width >= 0.05555 && width <= 0.05556) {
                  this.character = " ";
                } else if (width >= 0.1666 && width <= 0.1667) {
                  this.character = " ";
                } else if (width >= 0.2222 && width <= 0.2223) {
                  this.character = " ";
                } else if (width >= 0.2777 && width <= 0.2778) {
                  this.character = "  ";
                } else if (width >= -0.05556 && width <= -0.05555) {
                  this.character = " ⁣";
                } else if (width >= -0.1667 && width <= -0.1666) {
                  this.character = " ⁣";
                } else if (width >= -0.2223 && width <= -0.2222) {
                  this.character = " ⁣";
                } else if (width >= -0.2778 && width <= -0.2777) {
                  this.character = " ⁣";
                } else {
                  this.character = null;
                }
              }
              var _proto3 = SpaceNode2.prototype;
              _proto3.toNode = function toNode() {
                if (this.character) {
                  return document.createTextNode(this.character);
                } else {
                  var node = document.createElementNS("http://www.w3.org/1998/Math/MathML", "mspace");
                  node.setAttribute("width", this.width + "em");
                  return node;
                }
              };
              _proto3.toMarkup = function toMarkup() {
                if (this.character) {
                  return "<mtext>" + this.character + "</mtext>";
                } else {
                  return '<mspace width="' + this.width + 'em"/>';
                }
              };
              _proto3.toText = function toText() {
                if (this.character) {
                  return this.character;
                } else {
                  return " ";
                }
              };
              return SpaceNode2;
            }();
            var mathMLTree = {
              MathNode: mathMLTree_MathNode,
              TextNode: mathMLTree_TextNode,
              SpaceNode,
              newDocumentFragment
            };
            var buildMathML_makeText = function makeText(text4, mode, options) {
              if (src_symbols[mode][text4] && src_symbols[mode][text4].replace && text4.charCodeAt(0) !== 55349 && !(ligatures.hasOwnProperty(text4) && options && (options.fontFamily && options.fontFamily.substr(4, 2) === "tt" || options.font && options.font.substr(4, 2) === "tt"))) {
                text4 = src_symbols[mode][text4].replace;
              }
              return new mathMLTree.TextNode(text4);
            };
            var buildMathML_makeRow = function makeRow(body) {
              if (body.length === 1) {
                return body[0];
              } else {
                return new mathMLTree.MathNode("mrow", body);
              }
            };
            var buildMathML_getVariant = function getVariant(group, options) {
              if (options.fontFamily === "texttt") {
                return "monospace";
              } else if (options.fontFamily === "textsf") {
                if (options.fontShape === "textit" && options.fontWeight === "textbf") {
                  return "sans-serif-bold-italic";
                } else if (options.fontShape === "textit") {
                  return "sans-serif-italic";
                } else if (options.fontWeight === "textbf") {
                  return "bold-sans-serif";
                } else {
                  return "sans-serif";
                }
              } else if (options.fontShape === "textit" && options.fontWeight === "textbf") {
                return "bold-italic";
              } else if (options.fontShape === "textit") {
                return "italic";
              } else if (options.fontWeight === "textbf") {
                return "bold";
              }
              var font = options.font;
              if (!font || font === "mathnormal") {
                return null;
              }
              var mode = group.mode;
              if (font === "mathit") {
                return "italic";
              } else if (font === "boldsymbol") {
                return group.type === "textord" ? "bold" : "bold-italic";
              } else if (font === "mathbf") {
                return "bold";
              } else if (font === "mathbb") {
                return "double-struck";
              } else if (font === "mathfrak") {
                return "fraktur";
              } else if (font === "mathscr" || font === "mathcal") {
                return "script";
              } else if (font === "mathsf") {
                return "sans-serif";
              } else if (font === "mathtt") {
                return "monospace";
              }
              var text4 = group.text;
              if (utils.contains(["\\imath", "\\jmath"], text4)) {
                return null;
              }
              if (src_symbols[mode][text4] && src_symbols[mode][text4].replace) {
                text4 = src_symbols[mode][text4].replace;
              }
              var fontName = buildCommon.fontMap[font].fontName;
              if (getCharacterMetrics(text4, fontName, mode)) {
                return buildCommon.fontMap[font].variant;
              }
              return null;
            };
            var buildMathML_buildExpression = function buildExpression(expression, options, isOrdgroup) {
              if (expression.length === 1) {
                var group = buildMathML_buildGroup(expression[0], options);
                if (isOrdgroup && group instanceof mathMLTree_MathNode && group.type === "mo") {
                  group.setAttribute("lspace", "0em");
                  group.setAttribute("rspace", "0em");
                }
                return [group];
              }
              var groups = [];
              var lastGroup;
              for (var i = 0; i < expression.length; i++) {
                var _group = buildMathML_buildGroup(expression[i], options);
                if (_group instanceof mathMLTree_MathNode && lastGroup instanceof mathMLTree_MathNode) {
                  if (_group.type === "mtext" && lastGroup.type === "mtext" && _group.getAttribute("mathvariant") === lastGroup.getAttribute("mathvariant")) {
                    var _lastGroup$children;
                    (_lastGroup$children = lastGroup.children).push.apply(_lastGroup$children, _group.children);
                    continue;
                  } else if (_group.type === "mn" && lastGroup.type === "mn") {
                    var _lastGroup$children2;
                    (_lastGroup$children2 = lastGroup.children).push.apply(_lastGroup$children2, _group.children);
                    continue;
                  } else if (_group.type === "mi" && _group.children.length === 1 && lastGroup.type === "mn") {
                    var child = _group.children[0];
                    if (child instanceof mathMLTree_TextNode && child.text === ".") {
                      var _lastGroup$children3;
                      (_lastGroup$children3 = lastGroup.children).push.apply(_lastGroup$children3, _group.children);
                      continue;
                    }
                  } else if (lastGroup.type === "mi" && lastGroup.children.length === 1) {
                    var lastChild = lastGroup.children[0];
                    if (lastChild instanceof mathMLTree_TextNode && lastChild.text === "̸" && (_group.type === "mo" || _group.type === "mi" || _group.type === "mn")) {
                      var _child = _group.children[0];
                      if (_child instanceof mathMLTree_TextNode && _child.text.length > 0) {
                        _child.text = _child.text.slice(0, 1) + "̸" + _child.text.slice(1);
                        groups.pop();
                      }
                    }
                  }
                }
                groups.push(_group);
                lastGroup = _group;
              }
              return groups;
            };
            var buildExpressionRow = function buildExpressionRow2(expression, options, isOrdgroup) {
              return buildMathML_makeRow(buildMathML_buildExpression(expression, options, isOrdgroup));
            };
            var buildMathML_buildGroup = function buildGroup(group, options) {
              if (!group) {
                return new mathMLTree.MathNode("mrow");
              }
              if (_mathmlGroupBuilders[group.type]) {
                var result = _mathmlGroupBuilders[group.type](group, options);
                return result;
              } else {
                throw new src_ParseError("Got group of unknown type: '" + group.type + "'");
              }
            };
            function buildMathML(tree, texExpression, options, isDisplayMode, forMathmlOnly) {
              var expression = buildMathML_buildExpression(tree, options);
              var wrapper;
              if (expression.length === 1 && expression[0] instanceof mathMLTree_MathNode && utils.contains(["mrow", "mtable"], expression[0].type)) {
                wrapper = expression[0];
              } else {
                wrapper = new mathMLTree.MathNode("mrow", expression);
              }
              var annotation = new mathMLTree.MathNode("annotation", [new mathMLTree.TextNode(texExpression)]);
              annotation.setAttribute("encoding", "application/x-tex");
              var semantics = new mathMLTree.MathNode("semantics", [wrapper, annotation]);
              var math = new mathMLTree.MathNode("math", [semantics]);
              math.setAttribute("xmlns", "http://www.w3.org/1998/Math/MathML");
              if (isDisplayMode) {
                math.setAttribute("display", "block");
              }
              var wrapperClass = forMathmlOnly ? "katex" : "katex-mathml";
              return buildCommon.makeSpan([wrapperClass], [math]);
            }
            var buildTree_optionsFromSettings = function optionsFromSettings(settings) {
              return new src_Options({
                style: settings.displayMode ? src_Style.DISPLAY : src_Style.TEXT,
                maxSize: settings.maxSize,
                minRuleThickness: settings.minRuleThickness
              });
            };
            var buildTree_displayWrap = function displayWrap(node, settings) {
              if (settings.displayMode) {
                var classes = ["katex-display"];
                if (settings.leqno) {
                  classes.push("leqno");
                }
                if (settings.fleqn) {
                  classes.push("fleqn");
                }
                node = buildCommon.makeSpan(classes, [node]);
              }
              return node;
            };
            var buildTree_buildTree = function buildTree2(tree, expression, settings) {
              var options = buildTree_optionsFromSettings(settings);
              var katexNode;
              if (settings.output === "mathml") {
                return buildMathML(tree, expression, options, settings.displayMode, true);
              } else if (settings.output === "html") {
                var htmlNode = buildHTML(tree, options);
                katexNode = buildCommon.makeSpan(["katex"], [htmlNode]);
              } else {
                var mathMLNode = buildMathML(tree, expression, options, settings.displayMode, false);
                var _htmlNode = buildHTML(tree, options);
                katexNode = buildCommon.makeSpan(["katex"], [mathMLNode, _htmlNode]);
              }
              return buildTree_displayWrap(katexNode, settings);
            };
            var buildTree_buildHTMLTree = function buildHTMLTree(tree, expression, settings) {
              var options = buildTree_optionsFromSettings(settings);
              var htmlNode = buildHTML(tree, options);
              var katexNode = buildCommon.makeSpan(["katex"], [htmlNode]);
              return buildTree_displayWrap(katexNode, settings);
            };
            var src_buildTree = buildTree_buildTree;
            var stretchyCodePoint = {
              widehat: "^",
              widecheck: "ˇ",
              widetilde: "~",
              utilde: "~",
              overleftarrow: "←",
              underleftarrow: "←",
              xleftarrow: "←",
              overrightarrow: "→",
              underrightarrow: "→",
              xrightarrow: "→",
              underbrace: "⏟",
              overbrace: "⏞",
              overgroup: "⏠",
              undergroup: "⏡",
              overleftrightarrow: "↔",
              underleftrightarrow: "↔",
              xleftrightarrow: "↔",
              Overrightarrow: "⇒",
              xRightarrow: "⇒",
              overleftharpoon: "↼",
              xleftharpoonup: "↼",
              overrightharpoon: "⇀",
              xrightharpoonup: "⇀",
              xLeftarrow: "⇐",
              xLeftrightarrow: "⇔",
              xhookleftarrow: "↩",
              xhookrightarrow: "↪",
              xmapsto: "↦",
              xrightharpoondown: "⇁",
              xleftharpoondown: "↽",
              xrightleftharpoons: "⇌",
              xleftrightharpoons: "⇋",
              xtwoheadleftarrow: "↞",
              xtwoheadrightarrow: "↠",
              xlongequal: "=",
              xtofrom: "⇄",
              xrightleftarrows: "⇄",
              xrightequilibrium: "⇌",
              // Not a perfect match.
              xleftequilibrium: "⇋"
              // None better available.
            };
            var stretchy_mathMLnode = function mathMLnode(label) {
              var node = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode(stretchyCodePoint[label.substr(1)])]);
              node.setAttribute("stretchy", "true");
              return node;
            };
            var katexImagesData = {
              //   path(s), minWidth, height, align
              overrightarrow: [["rightarrow"], 0.888, 522, "xMaxYMin"],
              overleftarrow: [["leftarrow"], 0.888, 522, "xMinYMin"],
              underrightarrow: [["rightarrow"], 0.888, 522, "xMaxYMin"],
              underleftarrow: [["leftarrow"], 0.888, 522, "xMinYMin"],
              xrightarrow: [["rightarrow"], 1.469, 522, "xMaxYMin"],
              xleftarrow: [["leftarrow"], 1.469, 522, "xMinYMin"],
              Overrightarrow: [["doublerightarrow"], 0.888, 560, "xMaxYMin"],
              xRightarrow: [["doublerightarrow"], 1.526, 560, "xMaxYMin"],
              xLeftarrow: [["doubleleftarrow"], 1.526, 560, "xMinYMin"],
              overleftharpoon: [["leftharpoon"], 0.888, 522, "xMinYMin"],
              xleftharpoonup: [["leftharpoon"], 0.888, 522, "xMinYMin"],
              xleftharpoondown: [["leftharpoondown"], 0.888, 522, "xMinYMin"],
              overrightharpoon: [["rightharpoon"], 0.888, 522, "xMaxYMin"],
              xrightharpoonup: [["rightharpoon"], 0.888, 522, "xMaxYMin"],
              xrightharpoondown: [["rightharpoondown"], 0.888, 522, "xMaxYMin"],
              xlongequal: [["longequal"], 0.888, 334, "xMinYMin"],
              xtwoheadleftarrow: [["twoheadleftarrow"], 0.888, 334, "xMinYMin"],
              xtwoheadrightarrow: [["twoheadrightarrow"], 0.888, 334, "xMaxYMin"],
              overleftrightarrow: [["leftarrow", "rightarrow"], 0.888, 522],
              overbrace: [["leftbrace", "midbrace", "rightbrace"], 1.6, 548],
              underbrace: [["leftbraceunder", "midbraceunder", "rightbraceunder"], 1.6, 548],
              underleftrightarrow: [["leftarrow", "rightarrow"], 0.888, 522],
              xleftrightarrow: [["leftarrow", "rightarrow"], 1.75, 522],
              xLeftrightarrow: [["doubleleftarrow", "doublerightarrow"], 1.75, 560],
              xrightleftharpoons: [["leftharpoondownplus", "rightharpoonplus"], 1.75, 716],
              xleftrightharpoons: [["leftharpoonplus", "rightharpoondownplus"], 1.75, 716],
              xhookleftarrow: [["leftarrow", "righthook"], 1.08, 522],
              xhookrightarrow: [["lefthook", "rightarrow"], 1.08, 522],
              overlinesegment: [["leftlinesegment", "rightlinesegment"], 0.888, 522],
              underlinesegment: [["leftlinesegment", "rightlinesegment"], 0.888, 522],
              overgroup: [["leftgroup", "rightgroup"], 0.888, 342],
              undergroup: [["leftgroupunder", "rightgroupunder"], 0.888, 342],
              xmapsto: [["leftmapsto", "rightarrow"], 1.5, 522],
              xtofrom: [["leftToFrom", "rightToFrom"], 1.75, 528],
              // The next three arrows are from the mhchem package.
              // In mhchem.sty, min-length is 2.0em. But these arrows might appear in the
              // document as \xrightarrow or \xrightleftharpoons. Those have
              // min-length = 1.75em, so we set min-length on these next three to match.
              xrightleftarrows: [["baraboveleftarrow", "rightarrowabovebar"], 1.75, 901],
              xrightequilibrium: [["baraboveshortleftharpoon", "rightharpoonaboveshortbar"], 1.75, 716],
              xleftequilibrium: [["shortbaraboveleftharpoon", "shortrightharpoonabovebar"], 1.75, 716]
            };
            var groupLength = function groupLength2(arg) {
              if (arg.type === "ordgroup") {
                return arg.body.length;
              } else {
                return 1;
              }
            };
            var stretchy_svgSpan = function svgSpan(group, options) {
              function buildSvgSpan_() {
                var viewBoxWidth = 4e5;
                var label = group.label.substr(1);
                if (utils.contains(["widehat", "widecheck", "widetilde", "utilde"], label)) {
                  var grp = group;
                  var numChars = groupLength(grp.base);
                  var viewBoxHeight;
                  var pathName;
                  var _height;
                  if (numChars > 5) {
                    if (label === "widehat" || label === "widecheck") {
                      viewBoxHeight = 420;
                      viewBoxWidth = 2364;
                      _height = 0.42;
                      pathName = label + "4";
                    } else {
                      viewBoxHeight = 312;
                      viewBoxWidth = 2340;
                      _height = 0.34;
                      pathName = "tilde4";
                    }
                  } else {
                    var imgIndex = [1, 1, 2, 2, 3, 3][numChars];
                    if (label === "widehat" || label === "widecheck") {
                      viewBoxWidth = [0, 1062, 2364, 2364, 2364][imgIndex];
                      viewBoxHeight = [0, 239, 300, 360, 420][imgIndex];
                      _height = [0, 0.24, 0.3, 0.3, 0.36, 0.42][imgIndex];
                      pathName = label + imgIndex;
                    } else {
                      viewBoxWidth = [0, 600, 1033, 2339, 2340][imgIndex];
                      viewBoxHeight = [0, 260, 286, 306, 312][imgIndex];
                      _height = [0, 0.26, 0.286, 0.3, 0.306, 0.34][imgIndex];
                      pathName = "tilde" + imgIndex;
                    }
                  }
                  var path = new domTree_PathNode(pathName);
                  var svgNode = new SvgNode([path], {
                    "width": "100%",
                    "height": _height + "em",
                    "viewBox": "0 0 " + viewBoxWidth + " " + viewBoxHeight,
                    "preserveAspectRatio": "none"
                  });
                  return {
                    span: buildCommon.makeSvgSpan([], [svgNode], options),
                    minWidth: 0,
                    height: _height
                  };
                } else {
                  var spans = [];
                  var data2 = katexImagesData[label];
                  var paths = data2[0], _minWidth = data2[1], _viewBoxHeight = data2[2];
                  var _height2 = _viewBoxHeight / 1e3;
                  var numSvgChildren = paths.length;
                  var widthClasses;
                  var aligns;
                  if (numSvgChildren === 1) {
                    var align1 = data2[3];
                    widthClasses = ["hide-tail"];
                    aligns = [align1];
                  } else if (numSvgChildren === 2) {
                    widthClasses = ["halfarrow-left", "halfarrow-right"];
                    aligns = ["xMinYMin", "xMaxYMin"];
                  } else if (numSvgChildren === 3) {
                    widthClasses = ["brace-left", "brace-center", "brace-right"];
                    aligns = ["xMinYMin", "xMidYMin", "xMaxYMin"];
                  } else {
                    throw new Error("Correct katexImagesData or update code here to support\n                    " + numSvgChildren + " children.");
                  }
                  for (var i = 0; i < numSvgChildren; i++) {
                    var _path = new domTree_PathNode(paths[i]);
                    var _svgNode = new SvgNode([_path], {
                      "width": "400em",
                      "height": _height2 + "em",
                      "viewBox": "0 0 " + viewBoxWidth + " " + _viewBoxHeight,
                      "preserveAspectRatio": aligns[i] + " slice"
                    });
                    var _span = buildCommon.makeSvgSpan([widthClasses[i]], [_svgNode], options);
                    if (numSvgChildren === 1) {
                      return {
                        span: _span,
                        minWidth: _minWidth,
                        height: _height2
                      };
                    } else {
                      _span.style.height = _height2 + "em";
                      spans.push(_span);
                    }
                  }
                  return {
                    span: buildCommon.makeSpan(["stretchy"], spans, options),
                    minWidth: _minWidth,
                    height: _height2
                  };
                }
              }
              var _buildSvgSpan_ = buildSvgSpan_(), span = _buildSvgSpan_.span, minWidth = _buildSvgSpan_.minWidth, height = _buildSvgSpan_.height;
              span.height = height;
              span.style.height = height + "em";
              if (minWidth > 0) {
                span.style.minWidth = minWidth + "em";
              }
              return span;
            };
            var stretchy_encloseSpan = function encloseSpan(inner, label, pad, options) {
              var img;
              var totalHeight = inner.height + inner.depth + 2 * pad;
              if (/fbox|color/.test(label)) {
                img = buildCommon.makeSpan(["stretchy", label], [], options);
                if (label === "fbox") {
                  var color = options.color && options.getColor();
                  if (color) {
                    img.style.borderColor = color;
                  }
                }
              } else {
                var lines = [];
                if (/^[bx]cancel$/.test(label)) {
                  lines.push(new LineNode({
                    "x1": "0",
                    "y1": "0",
                    "x2": "100%",
                    "y2": "100%",
                    "stroke-width": "0.046em"
                  }));
                }
                if (/^x?cancel$/.test(label)) {
                  lines.push(new LineNode({
                    "x1": "0",
                    "y1": "100%",
                    "x2": "100%",
                    "y2": "0",
                    "stroke-width": "0.046em"
                  }));
                }
                var svgNode = new SvgNode(lines, {
                  "width": "100%",
                  "height": totalHeight + "em"
                });
                img = buildCommon.makeSvgSpan([], [svgNode], options);
              }
              img.height = totalHeight;
              img.style.height = totalHeight + "em";
              return img;
            };
            var stretchy = {
              encloseSpan: stretchy_encloseSpan,
              mathMLnode: stretchy_mathMLnode,
              svgSpan: stretchy_svgSpan
            };
            function assertNodeType(node, type2) {
              if (!node || node.type !== type2) {
                throw new Error("Expected node of type " + type2 + ", but got " + (node ? "node of type " + node.type : String(node)));
              }
              return node;
            }
            function assertSymbolNodeType(node) {
              var typedNode = checkSymbolNodeType(node);
              if (!typedNode) {
                throw new Error("Expected node of symbol group type, but got " + (node ? "node of type " + node.type : String(node)));
              }
              return typedNode;
            }
            function checkSymbolNodeType(node) {
              if (node && (node.type === "atom" || NON_ATOMS.hasOwnProperty(node.type))) {
                return node;
              }
              return null;
            }
            var accent_htmlBuilder = function htmlBuilder(grp, options) {
              var base2;
              var group;
              var supSubGroup;
              if (grp && grp.type === "supsub") {
                group = assertNodeType(grp.base, "accent");
                base2 = group.base;
                grp.base = base2;
                supSubGroup = assertSpan(buildHTML_buildGroup(grp, options));
                grp.base = group;
              } else {
                group = assertNodeType(grp, "accent");
                base2 = group.base;
              }
              var body = buildHTML_buildGroup(base2, options.havingCrampedStyle());
              var mustShift = group.isShifty && utils.isCharacterBox(base2);
              var skew2 = 0;
              if (mustShift) {
                var baseChar = utils.getBaseElem(base2);
                var baseGroup = buildHTML_buildGroup(baseChar, options.havingCrampedStyle());
                skew2 = assertSymbolDomNode(baseGroup).skew;
              }
              var clearance = Math.min(body.height, options.fontMetrics().xHeight);
              var accentBody;
              if (!group.isStretchy) {
                var accent;
                var width;
                if (group.label === "\\vec") {
                  accent = buildCommon.staticSvg("vec", options);
                  width = buildCommon.svgData.vec[1];
                } else {
                  accent = buildCommon.makeOrd({
                    mode: group.mode,
                    text: group.label
                  }, options, "textord");
                  accent = assertSymbolDomNode(accent);
                  accent.italic = 0;
                  width = accent.width;
                }
                accentBody = buildCommon.makeSpan(["accent-body"], [accent]);
                var accentFull = group.label === "\\textcircled";
                if (accentFull) {
                  accentBody.classes.push("accent-full");
                  clearance = body.height;
                }
                var left = skew2;
                if (!accentFull) {
                  left -= width / 2;
                }
                accentBody.style.left = left + "em";
                if (group.label === "\\textcircled") {
                  accentBody.style.top = ".2em";
                }
                accentBody = buildCommon.makeVList({
                  positionType: "firstBaseline",
                  children: [{
                    type: "elem",
                    elem: body
                  }, {
                    type: "kern",
                    size: -clearance
                  }, {
                    type: "elem",
                    elem: accentBody
                  }]
                }, options);
              } else {
                accentBody = stretchy.svgSpan(group, options);
                accentBody = buildCommon.makeVList({
                  positionType: "firstBaseline",
                  children: [{
                    type: "elem",
                    elem: body
                  }, {
                    type: "elem",
                    elem: accentBody,
                    wrapperClasses: ["svg-align"],
                    wrapperStyle: skew2 > 0 ? {
                      width: "calc(100% - " + 2 * skew2 + "em)",
                      marginLeft: 2 * skew2 + "em"
                    } : void 0
                  }]
                }, options);
              }
              var accentWrap = buildCommon.makeSpan(["mord", "accent"], [accentBody], options);
              if (supSubGroup) {
                supSubGroup.children[0] = accentWrap;
                supSubGroup.height = Math.max(accentWrap.height, supSubGroup.height);
                supSubGroup.classes[0] = "mord";
                return supSubGroup;
              } else {
                return accentWrap;
              }
            };
            var accent_mathmlBuilder = function mathmlBuilder(group, options) {
              var accentNode = group.isStretchy ? stretchy.mathMLnode(group.label) : new mathMLTree.MathNode("mo", [buildMathML_makeText(group.label, group.mode)]);
              var node = new mathMLTree.MathNode("mover", [buildMathML_buildGroup(group.base, options), accentNode]);
              node.setAttribute("accent", "true");
              return node;
            };
            var NON_STRETCHY_ACCENT_REGEX = new RegExp(["\\acute", "\\grave", "\\ddot", "\\tilde", "\\bar", "\\breve", "\\check", "\\hat", "\\vec", "\\dot", "\\mathring"].map(function(accent) {
              return "\\" + accent;
            }).join("|"));
            defineFunction({
              type: "accent",
              names: ["\\acute", "\\grave", "\\ddot", "\\tilde", "\\bar", "\\breve", "\\check", "\\hat", "\\vec", "\\dot", "\\mathring", "\\widecheck", "\\widehat", "\\widetilde", "\\overrightarrow", "\\overleftarrow", "\\Overrightarrow", "\\overleftrightarrow", "\\overgroup", "\\overlinesegment", "\\overleftharpoon", "\\overrightharpoon"],
              props: {
                numArgs: 1
              },
              handler: function handler(context, args) {
                var base2 = args[0];
                var isStretchy = !NON_STRETCHY_ACCENT_REGEX.test(context.funcName);
                var isShifty = !isStretchy || context.funcName === "\\widehat" || context.funcName === "\\widetilde" || context.funcName === "\\widecheck";
                return {
                  type: "accent",
                  mode: context.parser.mode,
                  label: context.funcName,
                  isStretchy,
                  isShifty,
                  base: base2
                };
              },
              htmlBuilder: accent_htmlBuilder,
              mathmlBuilder: accent_mathmlBuilder
            });
            defineFunction({
              type: "accent",
              names: ["\\'", "\\`", "\\^", "\\~", "\\=", "\\u", "\\.", '\\"', "\\r", "\\H", "\\v", "\\textcircled"],
              props: {
                numArgs: 1,
                allowedInText: true,
                allowedInMath: false
              },
              handler: function handler(context, args) {
                var base2 = args[0];
                return {
                  type: "accent",
                  mode: context.parser.mode,
                  label: context.funcName,
                  isStretchy: false,
                  isShifty: true,
                  base: base2
                };
              },
              htmlBuilder: accent_htmlBuilder,
              mathmlBuilder: accent_mathmlBuilder
            });
            defineFunction({
              type: "accentUnder",
              names: ["\\underleftarrow", "\\underrightarrow", "\\underleftrightarrow", "\\undergroup", "\\underlinesegment", "\\utilde"],
              props: {
                numArgs: 1
              },
              handler: function handler(_ref, args) {
                var parser = _ref.parser, funcName = _ref.funcName;
                var base2 = args[0];
                return {
                  type: "accentUnder",
                  mode: parser.mode,
                  label: funcName,
                  base: base2
                };
              },
              htmlBuilder: function htmlBuilder(group, options) {
                var innerGroup = buildHTML_buildGroup(group.base, options);
                var accentBody = stretchy.svgSpan(group, options);
                var kern = group.label === "\\utilde" ? 0.12 : 0;
                var vlist = buildCommon.makeVList({
                  positionType: "top",
                  positionData: innerGroup.height,
                  children: [{
                    type: "elem",
                    elem: accentBody,
                    wrapperClasses: ["svg-align"]
                  }, {
                    type: "kern",
                    size: kern
                  }, {
                    type: "elem",
                    elem: innerGroup
                  }]
                }, options);
                return buildCommon.makeSpan(["mord", "accentunder"], [vlist], options);
              },
              mathmlBuilder: function mathmlBuilder(group, options) {
                var accentNode = stretchy.mathMLnode(group.label);
                var node = new mathMLTree.MathNode("munder", [buildMathML_buildGroup(group.base, options), accentNode]);
                node.setAttribute("accentunder", "true");
                return node;
              }
            });
            var arrow_paddedNode = function paddedNode(group) {
              var node = new mathMLTree.MathNode("mpadded", group ? [group] : []);
              node.setAttribute("width", "+0.6em");
              node.setAttribute("lspace", "0.3em");
              return node;
            };
            defineFunction({
              type: "xArrow",
              names: [
                "\\xleftarrow",
                "\\xrightarrow",
                "\\xLeftarrow",
                "\\xRightarrow",
                "\\xleftrightarrow",
                "\\xLeftrightarrow",
                "\\xhookleftarrow",
                "\\xhookrightarrow",
                "\\xmapsto",
                "\\xrightharpoondown",
                "\\xrightharpoonup",
                "\\xleftharpoondown",
                "\\xleftharpoonup",
                "\\xrightleftharpoons",
                "\\xleftrightharpoons",
                "\\xlongequal",
                "\\xtwoheadrightarrow",
                "\\xtwoheadleftarrow",
                "\\xtofrom",
                // The next 3 functions are here to support the mhchem extension.
                // Direct use of these functions is discouraged and may break someday.
                "\\xrightleftarrows",
                "\\xrightequilibrium",
                "\\xleftequilibrium"
              ],
              props: {
                numArgs: 1,
                numOptionalArgs: 1
              },
              handler: function handler(_ref, args, optArgs) {
                var parser = _ref.parser, funcName = _ref.funcName;
                return {
                  type: "xArrow",
                  mode: parser.mode,
                  label: funcName,
                  body: args[0],
                  below: optArgs[0]
                };
              },
              // Flow is unable to correctly infer the type of `group`, even though it's
              // unamibiguously determined from the passed-in `type` above.
              htmlBuilder: function htmlBuilder(group, options) {
                var style = options.style;
                var newOptions = options.havingStyle(style.sup());
                var upperGroup = buildCommon.wrapFragment(buildHTML_buildGroup(group.body, newOptions, options), options);
                upperGroup.classes.push("x-arrow-pad");
                var lowerGroup;
                if (group.below) {
                  newOptions = options.havingStyle(style.sub());
                  lowerGroup = buildCommon.wrapFragment(buildHTML_buildGroup(group.below, newOptions, options), options);
                  lowerGroup.classes.push("x-arrow-pad");
                }
                var arrowBody = stretchy.svgSpan(group, options);
                var arrowShift = -options.fontMetrics().axisHeight + 0.5 * arrowBody.height;
                var upperShift = -options.fontMetrics().axisHeight - 0.5 * arrowBody.height - 0.111;
                if (upperGroup.depth > 0.25 || group.label === "\\xleftequilibrium") {
                  upperShift -= upperGroup.depth;
                }
                var vlist;
                if (lowerGroup) {
                  var lowerShift = -options.fontMetrics().axisHeight + lowerGroup.height + 0.5 * arrowBody.height + 0.111;
                  vlist = buildCommon.makeVList({
                    positionType: "individualShift",
                    children: [{
                      type: "elem",
                      elem: upperGroup,
                      shift: upperShift
                    }, {
                      type: "elem",
                      elem: arrowBody,
                      shift: arrowShift
                    }, {
                      type: "elem",
                      elem: lowerGroup,
                      shift: lowerShift
                    }]
                  }, options);
                } else {
                  vlist = buildCommon.makeVList({
                    positionType: "individualShift",
                    children: [{
                      type: "elem",
                      elem: upperGroup,
                      shift: upperShift
                    }, {
                      type: "elem",
                      elem: arrowBody,
                      shift: arrowShift
                    }]
                  }, options);
                }
                vlist.children[0].children[0].children[1].classes.push("svg-align");
                return buildCommon.makeSpan(["mrel", "x-arrow"], [vlist], options);
              },
              mathmlBuilder: function mathmlBuilder(group, options) {
                var arrowNode = stretchy.mathMLnode(group.label);
                var node;
                if (group.body) {
                  var upperNode = arrow_paddedNode(buildMathML_buildGroup(group.body, options));
                  if (group.below) {
                    var lowerNode = arrow_paddedNode(buildMathML_buildGroup(group.below, options));
                    node = new mathMLTree.MathNode("munderover", [arrowNode, lowerNode, upperNode]);
                  } else {
                    node = new mathMLTree.MathNode("mover", [arrowNode, upperNode]);
                  }
                } else if (group.below) {
                  var _lowerNode = arrow_paddedNode(buildMathML_buildGroup(group.below, options));
                  node = new mathMLTree.MathNode("munder", [arrowNode, _lowerNode]);
                } else {
                  node = arrow_paddedNode();
                  node = new mathMLTree.MathNode("mover", [arrowNode, node]);
                }
                return node;
              }
            });
            defineFunction({
              type: "textord",
              names: ["\\@char"],
              props: {
                numArgs: 1,
                allowedInText: true
              },
              handler: function handler(_ref, args) {
                var parser = _ref.parser;
                var arg = assertNodeType(args[0], "ordgroup");
                var group = arg.body;
                var number = "";
                for (var i = 0; i < group.length; i++) {
                  var node = assertNodeType(group[i], "textord");
                  number += node.text;
                }
                var code2 = parseInt(number);
                if (isNaN(code2)) {
                  throw new src_ParseError("\\@char has non-numeric argument " + number);
                }
                return {
                  type: "textord",
                  mode: parser.mode,
                  text: String.fromCharCode(code2)
                };
              }
            });
            var color_htmlBuilder = function htmlBuilder(group, options) {
              var elements = buildHTML_buildExpression(group.body, options.withColor(group.color), false);
              return buildCommon.makeFragment(elements);
            };
            var color_mathmlBuilder = function mathmlBuilder(group, options) {
              var inner = buildMathML_buildExpression(group.body, options.withColor(group.color));
              var node = new mathMLTree.MathNode("mstyle", inner);
              node.setAttribute("mathcolor", group.color);
              return node;
            };
            defineFunction({
              type: "color",
              names: ["\\textcolor"],
              props: {
                numArgs: 2,
                allowedInText: true,
                greediness: 3,
                argTypes: ["color", "original"]
              },
              handler: function handler(_ref, args) {
                var parser = _ref.parser;
                var color = assertNodeType(args[0], "color-token").color;
                var body = args[1];
                return {
                  type: "color",
                  mode: parser.mode,
                  color,
                  body: ordargument(body)
                };
              },
              htmlBuilder: color_htmlBuilder,
              mathmlBuilder: color_mathmlBuilder
            });
            defineFunction({
              type: "color",
              names: ["\\color"],
              props: {
                numArgs: 1,
                allowedInText: true,
                greediness: 3,
                argTypes: ["color"]
              },
              handler: function handler(_ref2, args) {
                var parser = _ref2.parser, breakOnTokenText = _ref2.breakOnTokenText;
                var color = assertNodeType(args[0], "color-token").color;
                parser.gullet.macros.set("\\current@color", color);
                var body = parser.parseExpression(true, breakOnTokenText);
                return {
                  type: "color",
                  mode: parser.mode,
                  color,
                  body
                };
              },
              htmlBuilder: color_htmlBuilder,
              mathmlBuilder: color_mathmlBuilder
            });
            defineFunction({
              type: "cr",
              names: ["\\cr", "\\newline"],
              props: {
                numArgs: 0,
                numOptionalArgs: 1,
                argTypes: ["size"],
                allowedInText: true
              },
              handler: function handler(_ref, args, optArgs) {
                var parser = _ref.parser, funcName = _ref.funcName;
                var size = optArgs[0];
                var newRow = funcName === "\\cr";
                var newLine = false;
                if (!newRow) {
                  if (parser.settings.displayMode && parser.settings.useStrictBehavior("newLineInDisplayMode", "In LaTeX, \\\\ or \\newline does nothing in display mode")) {
                    newLine = false;
                  } else {
                    newLine = true;
                  }
                }
                return {
                  type: "cr",
                  mode: parser.mode,
                  newLine,
                  newRow,
                  size: size && assertNodeType(size, "size").value
                };
              },
              // The following builders are called only at the top level,
              // not within tabular/array environments.
              htmlBuilder: function htmlBuilder(group, options) {
                if (group.newRow) {
                  throw new src_ParseError("\\cr valid only within a tabular/array environment");
                }
                var span = buildCommon.makeSpan(["mspace"], [], options);
                if (group.newLine) {
                  span.classes.push("newline");
                  if (group.size) {
                    span.style.marginTop = units_calculateSize(group.size, options) + "em";
                  }
                }
                return span;
              },
              mathmlBuilder: function mathmlBuilder(group, options) {
                var node = new mathMLTree.MathNode("mspace");
                if (group.newLine) {
                  node.setAttribute("linebreak", "newline");
                  if (group.size) {
                    node.setAttribute("height", units_calculateSize(group.size, options) + "em");
                  }
                }
                return node;
              }
            });
            var globalMap = {
              "\\global": "\\global",
              "\\long": "\\\\globallong",
              "\\\\globallong": "\\\\globallong",
              "\\def": "\\gdef",
              "\\gdef": "\\gdef",
              "\\edef": "\\xdef",
              "\\xdef": "\\xdef",
              "\\let": "\\\\globallet",
              "\\futurelet": "\\\\globalfuture"
            };
            var def_checkControlSequence = function checkControlSequence(tok) {
              var name2 = tok.text;
              if (/^(?:[\\{}$&#^_]|EOF)$/.test(name2)) {
                throw new src_ParseError("Expected a control sequence", tok);
              }
              return name2;
            };
            var getRHS = function getRHS2(parser) {
              var tok = parser.gullet.popToken();
              if (tok.text === "=") {
                tok = parser.gullet.popToken();
                if (tok.text === " ") {
                  tok = parser.gullet.popToken();
                }
              }
              return tok;
            };
            var letCommand = function letCommand2(parser, name2, tok, global) {
              var macro = parser.gullet.macros.get(tok.text);
              if (macro == null) {
                tok.noexpand = true;
                macro = {
                  tokens: [tok],
                  numArgs: 0,
                  // reproduce the same behavior in expansion
                  unexpandable: !parser.gullet.isExpandable(tok.text)
                };
              }
              parser.gullet.macros.set(name2, macro, global);
            };
            defineFunction({
              type: "internal",
              names: ["\\global", "\\long", "\\\\globallong"],
              props: {
                numArgs: 0,
                allowedInText: true
              },
              handler: function handler(_ref) {
                var parser = _ref.parser, funcName = _ref.funcName;
                parser.consumeSpaces();
                var token = parser.fetch();
                if (globalMap[token.text]) {
                  if (funcName === "\\global" || funcName === "\\\\globallong") {
                    token.text = globalMap[token.text];
                  }
                  return assertNodeType(parser.parseFunction(), "internal");
                }
                throw new src_ParseError("Invalid token after macro prefix", token);
              }
            });
            defineFunction({
              type: "internal",
              names: ["\\def", "\\gdef", "\\edef", "\\xdef"],
              props: {
                numArgs: 0,
                allowedInText: true
              },
              handler: function handler(_ref2) {
                var parser = _ref2.parser, funcName = _ref2.funcName;
                var arg = parser.gullet.consumeArgs(1)[0];
                if (arg.length !== 1) {
                  throw new src_ParseError("\\gdef's first argument must be a macro name");
                }
                var name2 = arg[0].text;
                var numArgs = 0;
                arg = parser.gullet.consumeArgs(1)[0];
                while (arg.length === 1 && arg[0].text === "#") {
                  arg = parser.gullet.consumeArgs(1)[0];
                  if (arg.length !== 1) {
                    throw new src_ParseError('Invalid argument number length "' + arg.length + '"');
                  }
                  if (!/^[1-9]$/.test(arg[0].text)) {
                    throw new src_ParseError('Invalid argument number "' + arg[0].text + '"');
                  }
                  numArgs++;
                  if (parseInt(arg[0].text) !== numArgs) {
                    throw new src_ParseError('Argument number "' + arg[0].text + '" out of order');
                  }
                  arg = parser.gullet.consumeArgs(1)[0];
                }
                if (funcName === "\\edef" || funcName === "\\xdef") {
                  arg = parser.gullet.expandTokens(arg);
                  arg.reverse();
                }
                parser.gullet.macros.set(name2, {
                  tokens: arg,
                  numArgs
                }, funcName === globalMap[funcName]);
                return {
                  type: "internal",
                  mode: parser.mode
                };
              }
            });
            defineFunction({
              type: "internal",
              names: ["\\let", "\\\\globallet"],
              props: {
                numArgs: 0,
                allowedInText: true
              },
              handler: function handler(_ref3) {
                var parser = _ref3.parser, funcName = _ref3.funcName;
                var name2 = def_checkControlSequence(parser.gullet.popToken());
                parser.gullet.consumeSpaces();
                var tok = getRHS(parser);
                letCommand(parser, name2, tok, funcName === "\\\\globallet");
                return {
                  type: "internal",
                  mode: parser.mode
                };
              }
            });
            defineFunction({
              type: "internal",
              names: ["\\futurelet", "\\\\globalfuture"],
              props: {
                numArgs: 0,
                allowedInText: true
              },
              handler: function handler(_ref4) {
                var parser = _ref4.parser, funcName = _ref4.funcName;
                var name2 = def_checkControlSequence(parser.gullet.popToken());
                var middle = parser.gullet.popToken();
                var tok = parser.gullet.popToken();
                letCommand(parser, name2, tok, funcName === "\\\\globalfuture");
                parser.gullet.pushToken(tok);
                parser.gullet.pushToken(middle);
                return {
                  type: "internal",
                  mode: parser.mode
                };
              }
            });
            var delimiter_getMetrics = function getMetrics(symbol, font, mode) {
              var replace2 = src_symbols.math[symbol] && src_symbols.math[symbol].replace;
              var metrics = getCharacterMetrics(replace2 || symbol, font, mode);
              if (!metrics) {
                throw new Error("Unsupported symbol " + symbol + " and font size " + font + ".");
              }
              return metrics;
            };
            var delimiter_styleWrap = function styleWrap(delim, toStyle, options, classes) {
              var newOptions = options.havingBaseStyle(toStyle);
              var span = buildCommon.makeSpan(classes.concat(newOptions.sizingClasses(options)), [delim], options);
              var delimSizeMultiplier = newOptions.sizeMultiplier / options.sizeMultiplier;
              span.height *= delimSizeMultiplier;
              span.depth *= delimSizeMultiplier;
              span.maxFontSize = newOptions.sizeMultiplier;
              return span;
            };
            var centerSpan = function centerSpan2(span, options, style) {
              var newOptions = options.havingBaseStyle(style);
              var shift = (1 - options.sizeMultiplier / newOptions.sizeMultiplier) * options.fontMetrics().axisHeight;
              span.classes.push("delimcenter");
              span.style.top = shift + "em";
              span.height -= shift;
              span.depth += shift;
            };
            var delimiter_makeSmallDelim = function makeSmallDelim(delim, style, center, options, mode, classes) {
              var text4 = buildCommon.makeSymbol(delim, "Main-Regular", mode, options);
              var span = delimiter_styleWrap(text4, style, options, classes);
              if (center) {
                centerSpan(span, options, style);
              }
              return span;
            };
            var delimiter_mathrmSize = function mathrmSize(value, size, mode, options) {
              return buildCommon.makeSymbol(value, "Size" + size + "-Regular", mode, options);
            };
            var delimiter_makeLargeDelim = function makeLargeDelim(delim, size, center, options, mode, classes) {
              var inner = delimiter_mathrmSize(delim, size, mode, options);
              var span = delimiter_styleWrap(buildCommon.makeSpan(["delimsizing", "size" + size], [inner], options), src_Style.TEXT, options, classes);
              if (center) {
                centerSpan(span, options, src_Style.TEXT);
              }
              return span;
            };
            var delimiter_makeInner = function makeInner(symbol, font, mode) {
              var sizeClass;
              if (font === "Size1-Regular") {
                sizeClass = "delim-size1";
              } else {
                sizeClass = "delim-size4";
              }
              var inner = buildCommon.makeSpan(["delimsizinginner", sizeClass], [buildCommon.makeSpan([], [buildCommon.makeSymbol(symbol, font, mode)])]);
              return {
                type: "elem",
                elem: inner
              };
            };
            var lap = {
              type: "kern",
              size: -5e-3
            };
            var delimiter_makeStackedDelim = function makeStackedDelim(delim, heightTotal, center, options, mode, classes) {
              var top;
              var middle;
              var repeat2;
              var bottom;
              top = repeat2 = bottom = delim;
              middle = null;
              var font = "Size1-Regular";
              if (delim === "\\uparrow") {
                repeat2 = bottom = "⏐";
              } else if (delim === "\\Uparrow") {
                repeat2 = bottom = "‖";
              } else if (delim === "\\downarrow") {
                top = repeat2 = "⏐";
              } else if (delim === "\\Downarrow") {
                top = repeat2 = "‖";
              } else if (delim === "\\updownarrow") {
                top = "\\uparrow";
                repeat2 = "⏐";
                bottom = "\\downarrow";
              } else if (delim === "\\Updownarrow") {
                top = "\\Uparrow";
                repeat2 = "‖";
                bottom = "\\Downarrow";
              } else if (delim === "[" || delim === "\\lbrack") {
                top = "⎡";
                repeat2 = "⎢";
                bottom = "⎣";
                font = "Size4-Regular";
              } else if (delim === "]" || delim === "\\rbrack") {
                top = "⎤";
                repeat2 = "⎥";
                bottom = "⎦";
                font = "Size4-Regular";
              } else if (delim === "\\lfloor" || delim === "⌊") {
                repeat2 = top = "⎢";
                bottom = "⎣";
                font = "Size4-Regular";
              } else if (delim === "\\lceil" || delim === "⌈") {
                top = "⎡";
                repeat2 = bottom = "⎢";
                font = "Size4-Regular";
              } else if (delim === "\\rfloor" || delim === "⌋") {
                repeat2 = top = "⎥";
                bottom = "⎦";
                font = "Size4-Regular";
              } else if (delim === "\\rceil" || delim === "⌉") {
                top = "⎤";
                repeat2 = bottom = "⎥";
                font = "Size4-Regular";
              } else if (delim === "(" || delim === "\\lparen") {
                top = "⎛";
                repeat2 = "⎜";
                bottom = "⎝";
                font = "Size4-Regular";
              } else if (delim === ")" || delim === "\\rparen") {
                top = "⎞";
                repeat2 = "⎟";
                bottom = "⎠";
                font = "Size4-Regular";
              } else if (delim === "\\{" || delim === "\\lbrace") {
                top = "⎧";
                middle = "⎨";
                bottom = "⎩";
                repeat2 = "⎪";
                font = "Size4-Regular";
              } else if (delim === "\\}" || delim === "\\rbrace") {
                top = "⎫";
                middle = "⎬";
                bottom = "⎭";
                repeat2 = "⎪";
                font = "Size4-Regular";
              } else if (delim === "\\lgroup" || delim === "⟮") {
                top = "⎧";
                bottom = "⎩";
                repeat2 = "⎪";
                font = "Size4-Regular";
              } else if (delim === "\\rgroup" || delim === "⟯") {
                top = "⎫";
                bottom = "⎭";
                repeat2 = "⎪";
                font = "Size4-Regular";
              } else if (delim === "\\lmoustache" || delim === "⎰") {
                top = "⎧";
                bottom = "⎭";
                repeat2 = "⎪";
                font = "Size4-Regular";
              } else if (delim === "\\rmoustache" || delim === "⎱") {
                top = "⎫";
                bottom = "⎩";
                repeat2 = "⎪";
                font = "Size4-Regular";
              }
              var topMetrics = delimiter_getMetrics(top, font, mode);
              var topHeightTotal = topMetrics.height + topMetrics.depth;
              var repeatMetrics = delimiter_getMetrics(repeat2, font, mode);
              var repeatHeightTotal = repeatMetrics.height + repeatMetrics.depth;
              var bottomMetrics = delimiter_getMetrics(bottom, font, mode);
              var bottomHeightTotal = bottomMetrics.height + bottomMetrics.depth;
              var middleHeightTotal = 0;
              var middleFactor = 1;
              if (middle !== null) {
                var middleMetrics = delimiter_getMetrics(middle, font, mode);
                middleHeightTotal = middleMetrics.height + middleMetrics.depth;
                middleFactor = 2;
              }
              var minHeight = topHeightTotal + bottomHeightTotal + middleHeightTotal;
              var repeatCount = Math.max(0, Math.ceil((heightTotal - minHeight) / (middleFactor * repeatHeightTotal)));
              var realHeightTotal = minHeight + repeatCount * middleFactor * repeatHeightTotal;
              var axisHeight = options.fontMetrics().axisHeight;
              if (center) {
                axisHeight *= options.sizeMultiplier;
              }
              var depth = realHeightTotal / 2 - axisHeight;
              var shiftOfExtraElement = (repeatCount + 1) * 5e-3 - repeatHeightTotal;
              var inners = [];
              inners.push(delimiter_makeInner(bottom, font, mode));
              if (middle === null) {
                for (var i = 0; i < repeatCount; i++) {
                  inners.push(lap);
                  inners.push(delimiter_makeInner(repeat2, font, mode));
                }
              } else {
                for (var _i = 0; _i < repeatCount; _i++) {
                  inners.push(lap);
                  inners.push(delimiter_makeInner(repeat2, font, mode));
                }
                inners.push({
                  type: "kern",
                  size: shiftOfExtraElement
                });
                inners.push(delimiter_makeInner(repeat2, font, mode));
                inners.push(lap);
                inners.push(delimiter_makeInner(middle, font, mode));
                for (var _i2 = 0; _i2 < repeatCount; _i2++) {
                  inners.push(lap);
                  inners.push(delimiter_makeInner(repeat2, font, mode));
                }
              }
              if ((repeat2 === "⎜" || repeat2 === "⎟") && repeatCount === 0) {
                var overlap = buildCommon.svgData.leftParenInner[2] / 2;
                inners.push({
                  type: "kern",
                  size: -overlap
                });
                var pathName = repeat2 === "⎜" ? "leftParenInner" : "rightParenInner";
                var innerSpan = buildCommon.staticSvg(pathName, options);
                inners.push({
                  type: "elem",
                  elem: innerSpan
                });
                inners.push({
                  type: "kern",
                  size: -overlap
                });
              } else {
                inners.push({
                  type: "kern",
                  size: shiftOfExtraElement
                });
                inners.push(delimiter_makeInner(repeat2, font, mode));
                inners.push(lap);
              }
              inners.push(delimiter_makeInner(top, font, mode));
              var newOptions = options.havingBaseStyle(src_Style.TEXT);
              var inner = buildCommon.makeVList({
                positionType: "bottom",
                positionData: depth,
                children: inners
              }, newOptions);
              return delimiter_styleWrap(buildCommon.makeSpan(["delimsizing", "mult"], [inner], newOptions), src_Style.TEXT, options, classes);
            };
            var vbPad = 80;
            var emPad = 0.08;
            var delimiter_sqrtSvg = function sqrtSvg(sqrtName, height, viewBoxHeight, extraViniculum, options) {
              var path = sqrtPath(sqrtName, extraViniculum, viewBoxHeight);
              var pathNode = new domTree_PathNode(sqrtName, path);
              var svg = new SvgNode([pathNode], {
                // Note: 1000:1 ratio of viewBox to document em width.
                "width": "400em",
                "height": height + "em",
                "viewBox": "0 0 400000 " + viewBoxHeight,
                "preserveAspectRatio": "xMinYMin slice"
              });
              return buildCommon.makeSvgSpan(["hide-tail"], [svg], options);
            };
            var makeSqrtImage = function makeSqrtImage2(height, options) {
              var newOptions = options.havingBaseSizing();
              var delim = traverseSequence("\\surd", height * newOptions.sizeMultiplier, stackLargeDelimiterSequence, newOptions);
              var sizeMultiplier = newOptions.sizeMultiplier;
              var extraViniculum = Math.max(0, options.minRuleThickness - options.fontMetrics().sqrtRuleThickness);
              var span;
              var spanHeight = 0;
              var texHeight = 0;
              var viewBoxHeight = 0;
              var advanceWidth;
              if (delim.type === "small") {
                viewBoxHeight = 1e3 + 1e3 * extraViniculum + vbPad;
                if (height < 1) {
                  sizeMultiplier = 1;
                } else if (height < 1.4) {
                  sizeMultiplier = 0.7;
                }
                spanHeight = (1 + extraViniculum + emPad) / sizeMultiplier;
                texHeight = (1 + extraViniculum) / sizeMultiplier;
                span = delimiter_sqrtSvg("sqrtMain", spanHeight, viewBoxHeight, extraViniculum, options);
                span.style.minWidth = "0.853em";
                advanceWidth = 0.833 / sizeMultiplier;
              } else if (delim.type === "large") {
                viewBoxHeight = (1e3 + vbPad) * sizeToMaxHeight[delim.size];
                texHeight = (sizeToMaxHeight[delim.size] + extraViniculum) / sizeMultiplier;
                spanHeight = (sizeToMaxHeight[delim.size] + extraViniculum + emPad) / sizeMultiplier;
                span = delimiter_sqrtSvg("sqrtSize" + delim.size, spanHeight, viewBoxHeight, extraViniculum, options);
                span.style.minWidth = "1.02em";
                advanceWidth = 1 / sizeMultiplier;
              } else {
                spanHeight = height + extraViniculum + emPad;
                texHeight = height + extraViniculum;
                viewBoxHeight = Math.floor(1e3 * height + extraViniculum) + vbPad;
                span = delimiter_sqrtSvg("sqrtTall", spanHeight, viewBoxHeight, extraViniculum, options);
                span.style.minWidth = "0.742em";
                advanceWidth = 1.056;
              }
              span.height = texHeight;
              span.style.height = spanHeight + "em";
              return {
                span,
                advanceWidth,
                // Calculate the actual line width.
                // This actually should depend on the chosen font -- e.g. \boldmath
                // should use the thicker surd symbols from e.g. KaTeX_Main-Bold, and
                // have thicker rules.
                ruleWidth: (options.fontMetrics().sqrtRuleThickness + extraViniculum) * sizeMultiplier
              };
            };
            var stackLargeDelimiters = ["(", "\\lparen", ")", "\\rparen", "[", "\\lbrack", "]", "\\rbrack", "\\{", "\\lbrace", "\\}", "\\rbrace", "\\lfloor", "\\rfloor", "⌊", "⌋", "\\lceil", "\\rceil", "⌈", "⌉", "\\surd"];
            var stackAlwaysDelimiters = ["\\uparrow", "\\downarrow", "\\updownarrow", "\\Uparrow", "\\Downarrow", "\\Updownarrow", "|", "\\|", "\\vert", "\\Vert", "\\lvert", "\\rvert", "\\lVert", "\\rVert", "\\lgroup", "\\rgroup", "⟮", "⟯", "\\lmoustache", "\\rmoustache", "⎰", "⎱"];
            var stackNeverDelimiters = ["<", ">", "\\langle", "\\rangle", "/", "\\backslash", "\\lt", "\\gt"];
            var sizeToMaxHeight = [0, 1.2, 1.8, 2.4, 3];
            var delimiter_makeSizedDelim = function makeSizedDelim(delim, size, options, mode, classes) {
              if (delim === "<" || delim === "\\lt" || delim === "⟨") {
                delim = "\\langle";
              } else if (delim === ">" || delim === "\\gt" || delim === "⟩") {
                delim = "\\rangle";
              }
              if (utils.contains(stackLargeDelimiters, delim) || utils.contains(stackNeverDelimiters, delim)) {
                return delimiter_makeLargeDelim(delim, size, false, options, mode, classes);
              } else if (utils.contains(stackAlwaysDelimiters, delim)) {
                return delimiter_makeStackedDelim(delim, sizeToMaxHeight[size], false, options, mode, classes);
              } else {
                throw new src_ParseError("Illegal delimiter: '" + delim + "'");
              }
            };
            var stackNeverDelimiterSequence = [{
              type: "small",
              style: src_Style.SCRIPTSCRIPT
            }, {
              type: "small",
              style: src_Style.SCRIPT
            }, {
              type: "small",
              style: src_Style.TEXT
            }, {
              type: "large",
              size: 1
            }, {
              type: "large",
              size: 2
            }, {
              type: "large",
              size: 3
            }, {
              type: "large",
              size: 4
            }];
            var stackAlwaysDelimiterSequence = [{
              type: "small",
              style: src_Style.SCRIPTSCRIPT
            }, {
              type: "small",
              style: src_Style.SCRIPT
            }, {
              type: "small",
              style: src_Style.TEXT
            }, {
              type: "stack"
            }];
            var stackLargeDelimiterSequence = [{
              type: "small",
              style: src_Style.SCRIPTSCRIPT
            }, {
              type: "small",
              style: src_Style.SCRIPT
            }, {
              type: "small",
              style: src_Style.TEXT
            }, {
              type: "large",
              size: 1
            }, {
              type: "large",
              size: 2
            }, {
              type: "large",
              size: 3
            }, {
              type: "large",
              size: 4
            }, {
              type: "stack"
            }];
            var delimTypeToFont = function delimTypeToFont2(type2) {
              if (type2.type === "small") {
                return "Main-Regular";
              } else if (type2.type === "large") {
                return "Size" + type2.size + "-Regular";
              } else if (type2.type === "stack") {
                return "Size4-Regular";
              } else {
                throw new Error("Add support for delim type '" + type2.type + "' here.");
              }
            };
            var traverseSequence = function traverseSequence2(delim, height, sequence, options) {
              var start = Math.min(2, 3 - options.style.size);
              for (var i = start; i < sequence.length; i++) {
                if (sequence[i].type === "stack") {
                  break;
                }
                var metrics = delimiter_getMetrics(delim, delimTypeToFont(sequence[i]), "math");
                var heightDepth = metrics.height + metrics.depth;
                if (sequence[i].type === "small") {
                  var newOptions = options.havingBaseStyle(sequence[i].style);
                  heightDepth *= newOptions.sizeMultiplier;
                }
                if (heightDepth > height) {
                  return sequence[i];
                }
              }
              return sequence[sequence.length - 1];
            };
            var delimiter_makeCustomSizedDelim = function makeCustomSizedDelim(delim, height, center, options, mode, classes) {
              if (delim === "<" || delim === "\\lt" || delim === "⟨") {
                delim = "\\langle";
              } else if (delim === ">" || delim === "\\gt" || delim === "⟩") {
                delim = "\\rangle";
              }
              var sequence;
              if (utils.contains(stackNeverDelimiters, delim)) {
                sequence = stackNeverDelimiterSequence;
              } else if (utils.contains(stackLargeDelimiters, delim)) {
                sequence = stackLargeDelimiterSequence;
              } else {
                sequence = stackAlwaysDelimiterSequence;
              }
              var delimType = traverseSequence(delim, height, sequence, options);
              if (delimType.type === "small") {
                return delimiter_makeSmallDelim(delim, delimType.style, center, options, mode, classes);
              } else if (delimType.type === "large") {
                return delimiter_makeLargeDelim(delim, delimType.size, center, options, mode, classes);
              } else {
                return delimiter_makeStackedDelim(delim, height, center, options, mode, classes);
              }
            };
            var makeLeftRightDelim = function makeLeftRightDelim2(delim, height, depth, options, mode, classes) {
              var axisHeight = options.fontMetrics().axisHeight * options.sizeMultiplier;
              var delimiterFactor = 901;
              var delimiterExtend = 5 / options.fontMetrics().ptPerEm;
              var maxDistFromAxis = Math.max(height - axisHeight, depth + axisHeight);
              var totalHeight = Math.max(
                // In real TeX, calculations are done using integral values which are
                // 65536 per pt, or 655360 per em. So, the division here truncates in
                // TeX but doesn't here, producing different results. If we wanted to
                // exactly match TeX's calculation, we could do
                //   Math.floor(655360 * maxDistFromAxis / 500) *
                //    delimiterFactor / 655360
                // (To see the difference, compare
                //    x^{x^{\left(\rule{0.1em}{0.68em}\right)}}
                // in TeX and KaTeX)
                maxDistFromAxis / 500 * delimiterFactor,
                2 * maxDistFromAxis - delimiterExtend
              );
              return delimiter_makeCustomSizedDelim(delim, totalHeight, true, options, mode, classes);
            };
            var delimiter2 = {
              sqrtImage: makeSqrtImage,
              sizedDelim: delimiter_makeSizedDelim,
              customSizedDelim: delimiter_makeCustomSizedDelim,
              leftRightDelim: makeLeftRightDelim
            };
            var delimiterSizes = {
              "\\bigl": {
                mclass: "mopen",
                size: 1
              },
              "\\Bigl": {
                mclass: "mopen",
                size: 2
              },
              "\\biggl": {
                mclass: "mopen",
                size: 3
              },
              "\\Biggl": {
                mclass: "mopen",
                size: 4
              },
              "\\bigr": {
                mclass: "mclose",
                size: 1
              },
              "\\Bigr": {
                mclass: "mclose",
                size: 2
              },
              "\\biggr": {
                mclass: "mclose",
                size: 3
              },
              "\\Biggr": {
                mclass: "mclose",
                size: 4
              },
              "\\bigm": {
                mclass: "mrel",
                size: 1
              },
              "\\Bigm": {
                mclass: "mrel",
                size: 2
              },
              "\\biggm": {
                mclass: "mrel",
                size: 3
              },
              "\\Biggm": {
                mclass: "mrel",
                size: 4
              },
              "\\big": {
                mclass: "mord",
                size: 1
              },
              "\\Big": {
                mclass: "mord",
                size: 2
              },
              "\\bigg": {
                mclass: "mord",
                size: 3
              },
              "\\Bigg": {
                mclass: "mord",
                size: 4
              }
            };
            var delimiters = ["(", "\\lparen", ")", "\\rparen", "[", "\\lbrack", "]", "\\rbrack", "\\{", "\\lbrace", "\\}", "\\rbrace", "\\lfloor", "\\rfloor", "⌊", "⌋", "\\lceil", "\\rceil", "⌈", "⌉", "<", ">", "\\langle", "⟨", "\\rangle", "⟩", "\\lt", "\\gt", "\\lvert", "\\rvert", "\\lVert", "\\rVert", "\\lgroup", "\\rgroup", "⟮", "⟯", "\\lmoustache", "\\rmoustache", "⎰", "⎱", "/", "\\backslash", "|", "\\vert", "\\|", "\\Vert", "\\uparrow", "\\Uparrow", "\\downarrow", "\\Downarrow", "\\updownarrow", "\\Updownarrow", "."];
            function checkDelimiter(delim, context) {
              var symDelim = checkSymbolNodeType(delim);
              if (symDelim && utils.contains(delimiters, symDelim.text)) {
                return symDelim;
              } else if (symDelim) {
                throw new src_ParseError("Invalid delimiter '" + symDelim.text + "' after '" + context.funcName + "'", delim);
              } else {
                throw new src_ParseError("Invalid delimiter type '" + delim.type + "'", delim);
              }
            }
            defineFunction({
              type: "delimsizing",
              names: ["\\bigl", "\\Bigl", "\\biggl", "\\Biggl", "\\bigr", "\\Bigr", "\\biggr", "\\Biggr", "\\bigm", "\\Bigm", "\\biggm", "\\Biggm", "\\big", "\\Big", "\\bigg", "\\Bigg"],
              props: {
                numArgs: 1
              },
              handler: function handler(context, args) {
                var delim = checkDelimiter(args[0], context);
                return {
                  type: "delimsizing",
                  mode: context.parser.mode,
                  size: delimiterSizes[context.funcName].size,
                  mclass: delimiterSizes[context.funcName].mclass,
                  delim: delim.text
                };
              },
              htmlBuilder: function htmlBuilder(group, options) {
                if (group.delim === ".") {
                  return buildCommon.makeSpan([group.mclass]);
                }
                return delimiter2.sizedDelim(group.delim, group.size, options, group.mode, [group.mclass]);
              },
              mathmlBuilder: function mathmlBuilder(group) {
                var children2 = [];
                if (group.delim !== ".") {
                  children2.push(buildMathML_makeText(group.delim, group.mode));
                }
                var node = new mathMLTree.MathNode("mo", children2);
                if (group.mclass === "mopen" || group.mclass === "mclose") {
                  node.setAttribute("fence", "true");
                } else {
                  node.setAttribute("fence", "false");
                }
                return node;
              }
            });
            function assertParsed(group) {
              if (!group.body) {
                throw new Error("Bug: The leftright ParseNode wasn't fully parsed.");
              }
            }
            defineFunction({
              type: "leftright-right",
              names: ["\\right"],
              props: {
                numArgs: 1
              },
              handler: function handler(context, args) {
                var color = context.parser.gullet.macros.get("\\current@color");
                if (color && typeof color !== "string") {
                  throw new src_ParseError("\\current@color set to non-string in \\right");
                }
                return {
                  type: "leftright-right",
                  mode: context.parser.mode,
                  delim: checkDelimiter(args[0], context).text,
                  color
                  // undefined if not set via \color
                };
              }
            });
            defineFunction({
              type: "leftright",
              names: ["\\left"],
              props: {
                numArgs: 1
              },
              handler: function handler(context, args) {
                var delim = checkDelimiter(args[0], context);
                var parser = context.parser;
                ++parser.leftrightDepth;
                var body = parser.parseExpression(false);
                --parser.leftrightDepth;
                parser.expect("\\right", false);
                var right = assertNodeType(parser.parseFunction(), "leftright-right");
                return {
                  type: "leftright",
                  mode: parser.mode,
                  body,
                  left: delim.text,
                  right: right.delim,
                  rightColor: right.color
                };
              },
              htmlBuilder: function htmlBuilder(group, options) {
                assertParsed(group);
                var inner = buildHTML_buildExpression(group.body, options, true, ["mopen", "mclose"]);
                var innerHeight = 0;
                var innerDepth = 0;
                var hadMiddle = false;
                for (var i = 0; i < inner.length; i++) {
                  if (inner[i].isMiddle) {
                    hadMiddle = true;
                  } else {
                    innerHeight = Math.max(inner[i].height, innerHeight);
                    innerDepth = Math.max(inner[i].depth, innerDepth);
                  }
                }
                innerHeight *= options.sizeMultiplier;
                innerDepth *= options.sizeMultiplier;
                var leftDelim;
                if (group.left === ".") {
                  leftDelim = makeNullDelimiter(options, ["mopen"]);
                } else {
                  leftDelim = delimiter2.leftRightDelim(group.left, innerHeight, innerDepth, options, group.mode, ["mopen"]);
                }
                inner.unshift(leftDelim);
                if (hadMiddle) {
                  for (var _i = 1; _i < inner.length; _i++) {
                    var middleDelim = inner[_i];
                    var isMiddle = middleDelim.isMiddle;
                    if (isMiddle) {
                      inner[_i] = delimiter2.leftRightDelim(isMiddle.delim, innerHeight, innerDepth, isMiddle.options, group.mode, []);
                    }
                  }
                }
                var rightDelim;
                if (group.right === ".") {
                  rightDelim = makeNullDelimiter(options, ["mclose"]);
                } else {
                  var colorOptions = group.rightColor ? options.withColor(group.rightColor) : options;
                  rightDelim = delimiter2.leftRightDelim(group.right, innerHeight, innerDepth, colorOptions, group.mode, ["mclose"]);
                }
                inner.push(rightDelim);
                return buildCommon.makeSpan(["minner"], inner, options);
              },
              mathmlBuilder: function mathmlBuilder(group, options) {
                assertParsed(group);
                var inner = buildMathML_buildExpression(group.body, options);
                if (group.left !== ".") {
                  var leftNode = new mathMLTree.MathNode("mo", [buildMathML_makeText(group.left, group.mode)]);
                  leftNode.setAttribute("fence", "true");
                  inner.unshift(leftNode);
                }
                if (group.right !== ".") {
                  var rightNode = new mathMLTree.MathNode("mo", [buildMathML_makeText(group.right, group.mode)]);
                  rightNode.setAttribute("fence", "true");
                  if (group.rightColor) {
                    rightNode.setAttribute("mathcolor", group.rightColor);
                  }
                  inner.push(rightNode);
                }
                return buildMathML_makeRow(inner);
              }
            });
            defineFunction({
              type: "middle",
              names: ["\\middle"],
              props: {
                numArgs: 1
              },
              handler: function handler(context, args) {
                var delim = checkDelimiter(args[0], context);
                if (!context.parser.leftrightDepth) {
                  throw new src_ParseError("\\middle without preceding \\left", delim);
                }
                return {
                  type: "middle",
                  mode: context.parser.mode,
                  delim: delim.text
                };
              },
              htmlBuilder: function htmlBuilder(group, options) {
                var middleDelim;
                if (group.delim === ".") {
                  middleDelim = makeNullDelimiter(options, []);
                } else {
                  middleDelim = delimiter2.sizedDelim(group.delim, 1, options, group.mode, []);
                  var isMiddle = {
                    delim: group.delim,
                    options
                  };
                  middleDelim.isMiddle = isMiddle;
                }
                return middleDelim;
              },
              mathmlBuilder: function mathmlBuilder(group, options) {
                var textNode = group.delim === "\\vert" || group.delim === "|" ? buildMathML_makeText("|", "text") : buildMathML_makeText(group.delim, group.mode);
                var middleNode = new mathMLTree.MathNode("mo", [textNode]);
                middleNode.setAttribute("fence", "true");
                middleNode.setAttribute("lspace", "0.05em");
                middleNode.setAttribute("rspace", "0.05em");
                return middleNode;
              }
            });
            var enclose_htmlBuilder = function htmlBuilder(group, options) {
              var inner = buildCommon.wrapFragment(buildHTML_buildGroup(group.body, options), options);
              var label = group.label.substr(1);
              var scale = options.sizeMultiplier;
              var img;
              var imgShift = 0;
              var isSingleChar = utils.isCharacterBox(group.body);
              if (label === "sout") {
                img = buildCommon.makeSpan(["stretchy", "sout"]);
                img.height = options.fontMetrics().defaultRuleThickness / scale;
                imgShift = -0.5 * options.fontMetrics().xHeight;
              } else {
                if (/cancel/.test(label)) {
                  if (!isSingleChar) {
                    inner.classes.push("cancel-pad");
                  }
                } else {
                  inner.classes.push("boxpad");
                }
                var vertPad = 0;
                var ruleThickness = 0;
                if (/box/.test(label)) {
                  ruleThickness = Math.max(
                    options.fontMetrics().fboxrule,
                    // default
                    options.minRuleThickness
                    // User override.
                  );
                  vertPad = options.fontMetrics().fboxsep + (label === "colorbox" ? 0 : ruleThickness);
                } else {
                  vertPad = isSingleChar ? 0.2 : 0;
                }
                img = stretchy.encloseSpan(inner, label, vertPad, options);
                if (/fbox|boxed|fcolorbox/.test(label)) {
                  img.style.borderStyle = "solid";
                  img.style.borderWidth = ruleThickness + "em";
                }
                imgShift = inner.depth + vertPad;
                if (group.backgroundColor) {
                  img.style.backgroundColor = group.backgroundColor;
                  if (group.borderColor) {
                    img.style.borderColor = group.borderColor;
                  }
                }
              }
              var vlist;
              if (group.backgroundColor) {
                vlist = buildCommon.makeVList({
                  positionType: "individualShift",
                  children: [
                    // Put the color background behind inner;
                    {
                      type: "elem",
                      elem: img,
                      shift: imgShift
                    },
                    {
                      type: "elem",
                      elem: inner,
                      shift: 0
                    }
                  ]
                }, options);
              } else {
                vlist = buildCommon.makeVList({
                  positionType: "individualShift",
                  children: [
                    // Write the \cancel stroke on top of inner.
                    {
                      type: "elem",
                      elem: inner,
                      shift: 0
                    },
                    {
                      type: "elem",
                      elem: img,
                      shift: imgShift,
                      wrapperClasses: /cancel/.test(label) ? ["svg-align"] : []
                    }
                  ]
                }, options);
              }
              if (/cancel/.test(label)) {
                vlist.height = inner.height;
                vlist.depth = inner.depth;
              }
              if (/cancel/.test(label) && !isSingleChar) {
                return buildCommon.makeSpan(["mord", "cancel-lap"], [vlist], options);
              } else {
                return buildCommon.makeSpan(["mord"], [vlist], options);
              }
            };
            var enclose_mathmlBuilder = function mathmlBuilder(group, options) {
              var fboxsep = 0;
              var node = new mathMLTree.MathNode(group.label.indexOf("colorbox") > -1 ? "mpadded" : "menclose", [buildMathML_buildGroup(group.body, options)]);
              switch (group.label) {
                case "\\cancel":
                  node.setAttribute("notation", "updiagonalstrike");
                  break;
                case "\\bcancel":
                  node.setAttribute("notation", "downdiagonalstrike");
                  break;
                case "\\sout":
                  node.setAttribute("notation", "horizontalstrike");
                  break;
                case "\\fbox":
                  node.setAttribute("notation", "box");
                  break;
                case "\\fcolorbox":
                case "\\colorbox":
                  fboxsep = options.fontMetrics().fboxsep * options.fontMetrics().ptPerEm;
                  node.setAttribute("width", "+" + 2 * fboxsep + "pt");
                  node.setAttribute("height", "+" + 2 * fboxsep + "pt");
                  node.setAttribute("lspace", fboxsep + "pt");
                  node.setAttribute("voffset", fboxsep + "pt");
                  if (group.label === "\\fcolorbox") {
                    var thk = Math.max(
                      options.fontMetrics().fboxrule,
                      // default
                      options.minRuleThickness
                      // user override
                    );
                    node.setAttribute("style", "border: " + thk + "em solid " + String(group.borderColor));
                  }
                  break;
                case "\\xcancel":
                  node.setAttribute("notation", "updiagonalstrike downdiagonalstrike");
                  break;
              }
              if (group.backgroundColor) {
                node.setAttribute("mathbackground", group.backgroundColor);
              }
              return node;
            };
            defineFunction({
              type: "enclose",
              names: ["\\colorbox"],
              props: {
                numArgs: 2,
                allowedInText: true,
                greediness: 3,
                argTypes: ["color", "text"]
              },
              handler: function handler(_ref, args, optArgs) {
                var parser = _ref.parser, funcName = _ref.funcName;
                var color = assertNodeType(args[0], "color-token").color;
                var body = args[1];
                return {
                  type: "enclose",
                  mode: parser.mode,
                  label: funcName,
                  backgroundColor: color,
                  body
                };
              },
              htmlBuilder: enclose_htmlBuilder,
              mathmlBuilder: enclose_mathmlBuilder
            });
            defineFunction({
              type: "enclose",
              names: ["\\fcolorbox"],
              props: {
                numArgs: 3,
                allowedInText: true,
                greediness: 3,
                argTypes: ["color", "color", "text"]
              },
              handler: function handler(_ref2, args, optArgs) {
                var parser = _ref2.parser, funcName = _ref2.funcName;
                var borderColor = assertNodeType(args[0], "color-token").color;
                var backgroundColor = assertNodeType(args[1], "color-token").color;
                var body = args[2];
                return {
                  type: "enclose",
                  mode: parser.mode,
                  label: funcName,
                  backgroundColor,
                  borderColor,
                  body
                };
              },
              htmlBuilder: enclose_htmlBuilder,
              mathmlBuilder: enclose_mathmlBuilder
            });
            defineFunction({
              type: "enclose",
              names: ["\\fbox"],
              props: {
                numArgs: 1,
                argTypes: ["hbox"],
                allowedInText: true
              },
              handler: function handler(_ref3, args) {
                var parser = _ref3.parser;
                return {
                  type: "enclose",
                  mode: parser.mode,
                  label: "\\fbox",
                  body: args[0]
                };
              }
            });
            defineFunction({
              type: "enclose",
              names: ["\\cancel", "\\bcancel", "\\xcancel", "\\sout"],
              props: {
                numArgs: 1
              },
              handler: function handler(_ref4, args, optArgs) {
                var parser = _ref4.parser, funcName = _ref4.funcName;
                var body = args[0];
                return {
                  type: "enclose",
                  mode: parser.mode,
                  label: funcName,
                  body
                };
              },
              htmlBuilder: enclose_htmlBuilder,
              mathmlBuilder: enclose_mathmlBuilder
            });
            var _environments = {};
            function defineEnvironment(_ref) {
              var type2 = _ref.type, names = _ref.names, props = _ref.props, handler = _ref.handler, htmlBuilder = _ref.htmlBuilder, mathmlBuilder = _ref.mathmlBuilder;
              var data2 = {
                type: type2,
                numArgs: props.numArgs || 0,
                greediness: 1,
                allowedInText: false,
                numOptionalArgs: 0,
                handler
              };
              for (var i = 0; i < names.length; ++i) {
                _environments[names[i]] = data2;
              }
              if (htmlBuilder) {
                _htmlGroupBuilders[type2] = htmlBuilder;
              }
              if (mathmlBuilder) {
                _mathmlGroupBuilders[type2] = mathmlBuilder;
              }
            }
            function getHLines(parser) {
              var hlineInfo = [];
              parser.consumeSpaces();
              var nxt = parser.fetch().text;
              while (nxt === "\\hline" || nxt === "\\hdashline") {
                parser.consume();
                hlineInfo.push(nxt === "\\hdashline");
                parser.consumeSpaces();
                nxt = parser.fetch().text;
              }
              return hlineInfo;
            }
            function parseArray(parser, _ref, style) {
              var hskipBeforeAndAfter = _ref.hskipBeforeAndAfter, addJot = _ref.addJot, cols = _ref.cols, arraystretch = _ref.arraystretch, colSeparationType = _ref.colSeparationType;
              parser.gullet.beginGroup();
              parser.gullet.macros.set("\\\\", "\\cr");
              if (!arraystretch) {
                var stretch = parser.gullet.expandMacroAsText("\\arraystretch");
                if (stretch == null) {
                  arraystretch = 1;
                } else {
                  arraystretch = parseFloat(stretch);
                  if (!arraystretch || arraystretch < 0) {
                    throw new src_ParseError("Invalid \\arraystretch: " + stretch);
                  }
                }
              }
              parser.gullet.beginGroup();
              var row = [];
              var body = [row];
              var rowGaps = [];
              var hLinesBeforeRow = [];
              hLinesBeforeRow.push(getHLines(parser));
              while (true) {
                var cell = parser.parseExpression(false, "\\cr");
                parser.gullet.endGroup();
                parser.gullet.beginGroup();
                cell = {
                  type: "ordgroup",
                  mode: parser.mode,
                  body: cell
                };
                if (style) {
                  cell = {
                    type: "styling",
                    mode: parser.mode,
                    style,
                    body: [cell]
                  };
                }
                row.push(cell);
                var next2 = parser.fetch().text;
                if (next2 === "&") {
                  parser.consume();
                } else if (next2 === "\\end") {
                  if (row.length === 1 && cell.type === "styling" && cell.body[0].body.length === 0) {
                    body.pop();
                  }
                  if (hLinesBeforeRow.length < body.length + 1) {
                    hLinesBeforeRow.push([]);
                  }
                  break;
                } else if (next2 === "\\cr") {
                  var cr = assertNodeType(parser.parseFunction(), "cr");
                  rowGaps.push(cr.size);
                  hLinesBeforeRow.push(getHLines(parser));
                  row = [];
                  body.push(row);
                } else {
                  throw new src_ParseError("Expected & or \\\\ or \\cr or \\end", parser.nextToken);
                }
              }
              parser.gullet.endGroup();
              parser.gullet.endGroup();
              return {
                type: "array",
                mode: parser.mode,
                addJot,
                arraystretch,
                body,
                cols,
                rowGaps,
                hskipBeforeAndAfter,
                hLinesBeforeRow,
                colSeparationType
              };
            }
            function dCellStyle(envName) {
              if (envName.substr(0, 1) === "d") {
                return "display";
              } else {
                return "text";
              }
            }
            var array_htmlBuilder = function htmlBuilder(group, options) {
              var r;
              var c;
              var nr = group.body.length;
              var hLinesBeforeRow = group.hLinesBeforeRow;
              var nc = 0;
              var body = new Array(nr);
              var hlines = [];
              var ruleThickness = Math.max(
                // From LaTeX \showthe\arrayrulewidth. Equals 0.04 em.
                options.fontMetrics().arrayRuleWidth,
                options.minRuleThickness
                // User override.
              );
              var pt = 1 / options.fontMetrics().ptPerEm;
              var arraycolsep = 5 * pt;
              if (group.colSeparationType && group.colSeparationType === "small") {
                var localMultiplier = options.havingStyle(src_Style.SCRIPT).sizeMultiplier;
                arraycolsep = 0.2778 * (localMultiplier / options.sizeMultiplier);
              }
              var baselineskip = 12 * pt;
              var jot = 3 * pt;
              var arrayskip = group.arraystretch * baselineskip;
              var arstrutHeight = 0.7 * arrayskip;
              var arstrutDepth = 0.3 * arrayskip;
              var totalHeight = 0;
              function setHLinePos(hlinesInGap) {
                for (var i = 0; i < hlinesInGap.length; ++i) {
                  if (i > 0) {
                    totalHeight += 0.25;
                  }
                  hlines.push({
                    pos: totalHeight,
                    isDashed: hlinesInGap[i]
                  });
                }
              }
              setHLinePos(hLinesBeforeRow[0]);
              for (r = 0; r < group.body.length; ++r) {
                var inrow = group.body[r];
                var height = arstrutHeight;
                var depth = arstrutDepth;
                if (nc < inrow.length) {
                  nc = inrow.length;
                }
                var outrow = new Array(inrow.length);
                for (c = 0; c < inrow.length; ++c) {
                  var elt = buildHTML_buildGroup(inrow[c], options);
                  if (depth < elt.depth) {
                    depth = elt.depth;
                  }
                  if (height < elt.height) {
                    height = elt.height;
                  }
                  outrow[c] = elt;
                }
                var rowGap = group.rowGaps[r];
                var gap = 0;
                if (rowGap) {
                  gap = units_calculateSize(rowGap, options);
                  if (gap > 0) {
                    gap += arstrutDepth;
                    if (depth < gap) {
                      depth = gap;
                    }
                    gap = 0;
                  }
                }
                if (group.addJot) {
                  depth += jot;
                }
                outrow.height = height;
                outrow.depth = depth;
                totalHeight += height;
                outrow.pos = totalHeight;
                totalHeight += depth + gap;
                body[r] = outrow;
                setHLinePos(hLinesBeforeRow[r + 1]);
              }
              var offset = totalHeight / 2 + options.fontMetrics().axisHeight;
              var colDescriptions = group.cols || [];
              var cols = [];
              var colSep;
              var colDescrNum;
              for (
                c = 0, colDescrNum = 0;
                // Continue while either there are more columns or more column
                // descriptions, so trailing separators don't get lost.
                c < nc || colDescrNum < colDescriptions.length;
                ++c, ++colDescrNum
              ) {
                var colDescr = colDescriptions[colDescrNum] || {};
                var firstSeparator = true;
                while (colDescr.type === "separator") {
                  if (!firstSeparator) {
                    colSep = buildCommon.makeSpan(["arraycolsep"], []);
                    colSep.style.width = options.fontMetrics().doubleRuleSep + "em";
                    cols.push(colSep);
                  }
                  if (colDescr.separator === "|" || colDescr.separator === ":") {
                    var lineType = colDescr.separator === "|" ? "solid" : "dashed";
                    var separator = buildCommon.makeSpan(["vertical-separator"], [], options);
                    separator.style.height = totalHeight + "em";
                    separator.style.borderRightWidth = ruleThickness + "em";
                    separator.style.borderRightStyle = lineType;
                    separator.style.margin = "0 -" + ruleThickness / 2 + "em";
                    separator.style.verticalAlign = -(totalHeight - offset) + "em";
                    cols.push(separator);
                  } else {
                    throw new src_ParseError("Invalid separator type: " + colDescr.separator);
                  }
                  colDescrNum++;
                  colDescr = colDescriptions[colDescrNum] || {};
                  firstSeparator = false;
                }
                if (c >= nc) {
                  continue;
                }
                var sepwidth = void 0;
                if (c > 0 || group.hskipBeforeAndAfter) {
                  sepwidth = utils.deflt(colDescr.pregap, arraycolsep);
                  if (sepwidth !== 0) {
                    colSep = buildCommon.makeSpan(["arraycolsep"], []);
                    colSep.style.width = sepwidth + "em";
                    cols.push(colSep);
                  }
                }
                var col = [];
                for (r = 0; r < nr; ++r) {
                  var row = body[r];
                  var elem = row[c];
                  if (!elem) {
                    continue;
                  }
                  var shift = row.pos - offset;
                  elem.depth = row.depth;
                  elem.height = row.height;
                  col.push({
                    type: "elem",
                    elem,
                    shift
                  });
                }
                col = buildCommon.makeVList({
                  positionType: "individualShift",
                  children: col
                }, options);
                col = buildCommon.makeSpan(["col-align-" + (colDescr.align || "c")], [col]);
                cols.push(col);
                if (c < nc - 1 || group.hskipBeforeAndAfter) {
                  sepwidth = utils.deflt(colDescr.postgap, arraycolsep);
                  if (sepwidth !== 0) {
                    colSep = buildCommon.makeSpan(["arraycolsep"], []);
                    colSep.style.width = sepwidth + "em";
                    cols.push(colSep);
                  }
                }
              }
              body = buildCommon.makeSpan(["mtable"], cols);
              if (hlines.length > 0) {
                var line = buildCommon.makeLineSpan("hline", options, ruleThickness);
                var dashes = buildCommon.makeLineSpan("hdashline", options, ruleThickness);
                var vListElems = [{
                  type: "elem",
                  elem: body,
                  shift: 0
                }];
                while (hlines.length > 0) {
                  var hline = hlines.pop();
                  var lineShift = hline.pos - offset;
                  if (hline.isDashed) {
                    vListElems.push({
                      type: "elem",
                      elem: dashes,
                      shift: lineShift
                    });
                  } else {
                    vListElems.push({
                      type: "elem",
                      elem: line,
                      shift: lineShift
                    });
                  }
                }
                body = buildCommon.makeVList({
                  positionType: "individualShift",
                  children: vListElems
                }, options);
              }
              return buildCommon.makeSpan(["mord"], [body], options);
            };
            var alignMap = {
              c: "center ",
              l: "left ",
              r: "right "
            };
            var array_mathmlBuilder = function mathmlBuilder(group, options) {
              var table2 = new mathMLTree.MathNode("mtable", group.body.map(function(row) {
                return new mathMLTree.MathNode("mtr", row.map(function(cell) {
                  return new mathMLTree.MathNode("mtd", [buildMathML_buildGroup(cell, options)]);
                }));
              }));
              var gap = group.arraystretch === 0.5 ? 0.1 : 0.16 + group.arraystretch - 1 + (group.addJot ? 0.09 : 0);
              table2.setAttribute("rowspacing", gap + "em");
              var menclose = "";
              var align = "";
              if (group.cols && group.cols.length > 0) {
                var cols = group.cols;
                var columnLines = "";
                var prevTypeWasAlign = false;
                var iStart = 0;
                var iEnd = cols.length;
                if (cols[0].type === "separator") {
                  menclose += "top ";
                  iStart = 1;
                }
                if (cols[cols.length - 1].type === "separator") {
                  menclose += "bottom ";
                  iEnd -= 1;
                }
                for (var i = iStart; i < iEnd; i++) {
                  if (cols[i].type === "align") {
                    align += alignMap[cols[i].align];
                    if (prevTypeWasAlign) {
                      columnLines += "none ";
                    }
                    prevTypeWasAlign = true;
                  } else if (cols[i].type === "separator") {
                    if (prevTypeWasAlign) {
                      columnLines += cols[i].separator === "|" ? "solid " : "dashed ";
                      prevTypeWasAlign = false;
                    }
                  }
                }
                table2.setAttribute("columnalign", align.trim());
                if (/[sd]/.test(columnLines)) {
                  table2.setAttribute("columnlines", columnLines.trim());
                }
              }
              if (group.colSeparationType === "align") {
                var _cols = group.cols || [];
                var spacing = "";
                for (var _i = 1; _i < _cols.length; _i++) {
                  spacing += _i % 2 ? "0em " : "1em ";
                }
                table2.setAttribute("columnspacing", spacing.trim());
              } else if (group.colSeparationType === "alignat") {
                table2.setAttribute("columnspacing", "0em");
              } else if (group.colSeparationType === "small") {
                table2.setAttribute("columnspacing", "0.2778em");
              } else {
                table2.setAttribute("columnspacing", "1em");
              }
              var rowLines = "";
              var hlines = group.hLinesBeforeRow;
              menclose += hlines[0].length > 0 ? "left " : "";
              menclose += hlines[hlines.length - 1].length > 0 ? "right " : "";
              for (var _i2 = 1; _i2 < hlines.length - 1; _i2++) {
                rowLines += hlines[_i2].length === 0 ? "none " : hlines[_i2][0] ? "dashed " : "solid ";
              }
              if (/[sd]/.test(rowLines)) {
                table2.setAttribute("rowlines", rowLines.trim());
              }
              if (menclose !== "") {
                table2 = new mathMLTree.MathNode("menclose", [table2]);
                table2.setAttribute("notation", menclose.trim());
              }
              if (group.arraystretch && group.arraystretch < 1) {
                table2 = new mathMLTree.MathNode("mstyle", [table2]);
                table2.setAttribute("scriptlevel", "1");
              }
              return table2;
            };
            var array_alignedHandler = function alignedHandler(context, args) {
              var cols = [];
              var res = parseArray(context.parser, {
                cols,
                addJot: true
              }, "display");
              var numMaths;
              var numCols = 0;
              var emptyGroup = {
                type: "ordgroup",
                mode: context.mode,
                body: []
              };
              if (args[0] && args[0].type === "ordgroup") {
                var arg0 = "";
                for (var i = 0; i < args[0].body.length; i++) {
                  var textord = assertNodeType(args[0].body[i], "textord");
                  arg0 += textord.text;
                }
                numMaths = Number(arg0);
                numCols = numMaths * 2;
              }
              var isAligned = !numCols;
              res.body.forEach(function(row) {
                for (var _i3 = 1; _i3 < row.length; _i3 += 2) {
                  var styling = assertNodeType(row[_i3], "styling");
                  var ordgroup = assertNodeType(styling.body[0], "ordgroup");
                  ordgroup.body.unshift(emptyGroup);
                }
                if (!isAligned) {
                  var curMaths = row.length / 2;
                  if (numMaths < curMaths) {
                    throw new src_ParseError("Too many math in a row: " + ("expected " + numMaths + ", but got " + curMaths), row[0]);
                  }
                } else if (numCols < row.length) {
                  numCols = row.length;
                }
              });
              for (var _i4 = 0; _i4 < numCols; ++_i4) {
                var align = "r";
                var pregap = 0;
                if (_i4 % 2 === 1) {
                  align = "l";
                } else if (_i4 > 0 && isAligned) {
                  pregap = 1;
                }
                cols[_i4] = {
                  type: "align",
                  align,
                  pregap,
                  postgap: 0
                };
              }
              res.colSeparationType = isAligned ? "align" : "alignat";
              return res;
            };
            defineEnvironment({
              type: "array",
              names: ["array", "darray"],
              props: {
                numArgs: 1
              },
              handler: function handler(context, args) {
                var symNode = checkSymbolNodeType(args[0]);
                var colalign = symNode ? [args[0]] : assertNodeType(args[0], "ordgroup").body;
                var cols = colalign.map(function(nde) {
                  var node = assertSymbolNodeType(nde);
                  var ca = node.text;
                  if ("lcr".indexOf(ca) !== -1) {
                    return {
                      type: "align",
                      align: ca
                    };
                  } else if (ca === "|") {
                    return {
                      type: "separator",
                      separator: "|"
                    };
                  } else if (ca === ":") {
                    return {
                      type: "separator",
                      separator: ":"
                    };
                  }
                  throw new src_ParseError("Unknown column alignment: " + ca, nde);
                });
                var res = {
                  cols,
                  hskipBeforeAndAfter: true
                  // \@preamble in lttab.dtx
                };
                return parseArray(context.parser, res, dCellStyle(context.envName));
              },
              htmlBuilder: array_htmlBuilder,
              mathmlBuilder: array_mathmlBuilder
            });
            defineEnvironment({
              type: "array",
              names: ["matrix", "pmatrix", "bmatrix", "Bmatrix", "vmatrix", "Vmatrix"],
              props: {
                numArgs: 0
              },
              handler: function handler(context) {
                var delimiters2 = {
                  "matrix": null,
                  "pmatrix": ["(", ")"],
                  "bmatrix": ["[", "]"],
                  "Bmatrix": ["\\{", "\\}"],
                  "vmatrix": ["|", "|"],
                  "Vmatrix": ["\\Vert", "\\Vert"]
                }[context.envName];
                var payload = {
                  hskipBeforeAndAfter: false
                };
                var res = parseArray(context.parser, payload, dCellStyle(context.envName));
                return delimiters2 ? {
                  type: "leftright",
                  mode: context.mode,
                  body: [res],
                  left: delimiters2[0],
                  right: delimiters2[1],
                  rightColor: void 0
                  // \right uninfluenced by \color in array
                } : res;
              },
              htmlBuilder: array_htmlBuilder,
              mathmlBuilder: array_mathmlBuilder
            });
            defineEnvironment({
              type: "array",
              names: ["smallmatrix"],
              props: {
                numArgs: 0
              },
              handler: function handler(context) {
                var payload = {
                  arraystretch: 0.5
                };
                var res = parseArray(context.parser, payload, "script");
                res.colSeparationType = "small";
                return res;
              },
              htmlBuilder: array_htmlBuilder,
              mathmlBuilder: array_mathmlBuilder
            });
            defineEnvironment({
              type: "array",
              names: ["subarray"],
              props: {
                numArgs: 1
              },
              handler: function handler(context, args) {
                var symNode = checkSymbolNodeType(args[0]);
                var colalign = symNode ? [args[0]] : assertNodeType(args[0], "ordgroup").body;
                var cols = colalign.map(function(nde) {
                  var node = assertSymbolNodeType(nde);
                  var ca = node.text;
                  if ("lc".indexOf(ca) !== -1) {
                    return {
                      type: "align",
                      align: ca
                    };
                  }
                  throw new src_ParseError("Unknown column alignment: " + ca, nde);
                });
                if (cols.length > 1) {
                  throw new src_ParseError("{subarray} can contain only one column");
                }
                var res = {
                  cols,
                  hskipBeforeAndAfter: false,
                  arraystretch: 0.5
                };
                res = parseArray(context.parser, res, "script");
                if (res.body.length > 0 && res.body[0].length > 1) {
                  throw new src_ParseError("{subarray} can contain only one column");
                }
                return res;
              },
              htmlBuilder: array_htmlBuilder,
              mathmlBuilder: array_mathmlBuilder
            });
            defineEnvironment({
              type: "array",
              names: ["cases", "dcases", "rcases", "drcases"],
              props: {
                numArgs: 0
              },
              handler: function handler(context) {
                var payload = {
                  arraystretch: 1.2,
                  cols: [{
                    type: "align",
                    align: "l",
                    pregap: 0,
                    // TODO(kevinb) get the current style.
                    // For now we use the metrics for TEXT style which is what we were
                    // doing before.  Before attempting to get the current style we
                    // should look at TeX's behavior especially for \over and matrices.
                    postgap: 1
                    /* 1em quad */
                  }, {
                    type: "align",
                    align: "l",
                    pregap: 0,
                    postgap: 0
                  }]
                };
                var res = parseArray(context.parser, payload, dCellStyle(context.envName));
                return {
                  type: "leftright",
                  mode: context.mode,
                  body: [res],
                  left: context.envName.indexOf("r") > -1 ? "." : "\\{",
                  right: context.envName.indexOf("r") > -1 ? "\\}" : ".",
                  rightColor: void 0
                };
              },
              htmlBuilder: array_htmlBuilder,
              mathmlBuilder: array_mathmlBuilder
            });
            defineEnvironment({
              type: "array",
              names: ["aligned"],
              props: {
                numArgs: 0
              },
              handler: array_alignedHandler,
              htmlBuilder: array_htmlBuilder,
              mathmlBuilder: array_mathmlBuilder
            });
            defineEnvironment({
              type: "array",
              names: ["gathered"],
              props: {
                numArgs: 0
              },
              handler: function handler(context) {
                var res = {
                  cols: [{
                    type: "align",
                    align: "c"
                  }],
                  addJot: true
                };
                return parseArray(context.parser, res, "display");
              },
              htmlBuilder: array_htmlBuilder,
              mathmlBuilder: array_mathmlBuilder
            });
            defineEnvironment({
              type: "array",
              names: ["alignedat"],
              // One for numbered and for unnumbered;
              // but, KaTeX doesn't supports math numbering yet,
              // they make no difference for now.
              props: {
                numArgs: 1
              },
              handler: array_alignedHandler,
              htmlBuilder: array_htmlBuilder,
              mathmlBuilder: array_mathmlBuilder
            });
            defineFunction({
              type: "text",
              // Doesn't matter what this is.
              names: ["\\hline", "\\hdashline"],
              props: {
                numArgs: 0,
                allowedInText: true,
                allowedInMath: true
              },
              handler: function handler(context, args) {
                throw new src_ParseError(context.funcName + " valid only within array environment");
              }
            });
            var environments = _environments;
            var src_environments = environments;
            defineFunction({
              type: "environment",
              names: ["\\begin", "\\end"],
              props: {
                numArgs: 1,
                argTypes: ["text"]
              },
              handler: function handler(_ref, args) {
                var parser = _ref.parser, funcName = _ref.funcName;
                var nameGroup = args[0];
                if (nameGroup.type !== "ordgroup") {
                  throw new src_ParseError("Invalid environment name", nameGroup);
                }
                var envName = "";
                for (var i = 0; i < nameGroup.body.length; ++i) {
                  envName += assertNodeType(nameGroup.body[i], "textord").text;
                }
                if (funcName === "\\begin") {
                  if (!src_environments.hasOwnProperty(envName)) {
                    throw new src_ParseError("No such environment: " + envName, nameGroup);
                  }
                  var env = src_environments[envName];
                  var _parser$parseArgument = parser.parseArguments("\\begin{" + envName + "}", env), _args = _parser$parseArgument.args, optArgs = _parser$parseArgument.optArgs;
                  var context = {
                    mode: parser.mode,
                    envName,
                    parser
                  };
                  var result = env.handler(context, _args, optArgs);
                  parser.expect("\\end", false);
                  var endNameToken = parser.nextToken;
                  var end2 = assertNodeType(parser.parseFunction(), "environment");
                  if (end2.name !== envName) {
                    throw new src_ParseError("Mismatch: \\begin{" + envName + "} matched by \\end{" + end2.name + "}", endNameToken);
                  }
                  return result;
                }
                return {
                  type: "environment",
                  mode: parser.mode,
                  name: envName,
                  nameGroup
                };
              }
            });
            var mclass_makeSpan = buildCommon.makeSpan;
            function mclass_htmlBuilder(group, options) {
              var elements = buildHTML_buildExpression(group.body, options, true);
              return mclass_makeSpan([group.mclass], elements, options);
            }
            function mclass_mathmlBuilder(group, options) {
              var node;
              var inner = buildMathML_buildExpression(group.body, options);
              if (group.mclass === "minner") {
                return mathMLTree.newDocumentFragment(inner);
              } else if (group.mclass === "mord") {
                if (group.isCharacterBox) {
                  node = inner[0];
                  node.type = "mi";
                } else {
                  node = new mathMLTree.MathNode("mi", inner);
                }
              } else {
                if (group.isCharacterBox) {
                  node = inner[0];
                  node.type = "mo";
                } else {
                  node = new mathMLTree.MathNode("mo", inner);
                }
                if (group.mclass === "mbin") {
                  node.attributes.lspace = "0.22em";
                  node.attributes.rspace = "0.22em";
                } else if (group.mclass === "mpunct") {
                  node.attributes.lspace = "0em";
                  node.attributes.rspace = "0.17em";
                } else if (group.mclass === "mopen" || group.mclass === "mclose") {
                  node.attributes.lspace = "0em";
                  node.attributes.rspace = "0em";
                }
              }
              return node;
            }
            defineFunction({
              type: "mclass",
              names: ["\\mathord", "\\mathbin", "\\mathrel", "\\mathopen", "\\mathclose", "\\mathpunct", "\\mathinner"],
              props: {
                numArgs: 1
              },
              handler: function handler(_ref, args) {
                var parser = _ref.parser, funcName = _ref.funcName;
                var body = args[0];
                return {
                  type: "mclass",
                  mode: parser.mode,
                  mclass: "m" + funcName.substr(5),
                  // TODO(kevinb): don't prefix with 'm'
                  body: ordargument(body),
                  isCharacterBox: utils.isCharacterBox(body)
                };
              },
              htmlBuilder: mclass_htmlBuilder,
              mathmlBuilder: mclass_mathmlBuilder
            });
            var binrelClass = function binrelClass2(arg) {
              var atom = arg.type === "ordgroup" && arg.body.length ? arg.body[0] : arg;
              if (atom.type === "atom" && (atom.family === "bin" || atom.family === "rel")) {
                return "m" + atom.family;
              } else {
                return "mord";
              }
            };
            defineFunction({
              type: "mclass",
              names: ["\\@binrel"],
              props: {
                numArgs: 2
              },
              handler: function handler(_ref2, args) {
                var parser = _ref2.parser;
                return {
                  type: "mclass",
                  mode: parser.mode,
                  mclass: binrelClass(args[0]),
                  body: [args[1]],
                  isCharacterBox: utils.isCharacterBox(args[1])
                };
              }
            });
            defineFunction({
              type: "mclass",
              names: ["\\stackrel", "\\overset", "\\underset"],
              props: {
                numArgs: 2
              },
              handler: function handler(_ref3, args) {
                var parser = _ref3.parser, funcName = _ref3.funcName;
                var baseArg = args[1];
                var shiftedArg = args[0];
                var mclass;
                if (funcName !== "\\stackrel") {
                  mclass = binrelClass(baseArg);
                } else {
                  mclass = "mrel";
                }
                var baseOp = {
                  type: "op",
                  mode: baseArg.mode,
                  limits: true,
                  alwaysHandleSupSub: true,
                  parentIsSupSub: false,
                  symbol: false,
                  suppressBaseShift: funcName !== "\\stackrel",
                  body: ordargument(baseArg)
                };
                var supsub = {
                  type: "supsub",
                  mode: shiftedArg.mode,
                  base: baseOp,
                  sup: funcName === "\\underset" ? null : shiftedArg,
                  sub: funcName === "\\underset" ? shiftedArg : null
                };
                return {
                  type: "mclass",
                  mode: parser.mode,
                  mclass,
                  body: [supsub],
                  isCharacterBox: utils.isCharacterBox(supsub)
                };
              },
              htmlBuilder: mclass_htmlBuilder,
              mathmlBuilder: mclass_mathmlBuilder
            });
            var font_htmlBuilder = function htmlBuilder(group, options) {
              var font = group.font;
              var newOptions = options.withFont(font);
              return buildHTML_buildGroup(group.body, newOptions);
            };
            var font_mathmlBuilder = function mathmlBuilder(group, options) {
              var font = group.font;
              var newOptions = options.withFont(font);
              return buildMathML_buildGroup(group.body, newOptions);
            };
            var fontAliases = {
              "\\Bbb": "\\mathbb",
              "\\bold": "\\mathbf",
              "\\frak": "\\mathfrak",
              "\\bm": "\\boldsymbol"
            };
            defineFunction({
              type: "font",
              names: [
                // styles, except \boldsymbol defined below
                "\\mathrm",
                "\\mathit",
                "\\mathbf",
                "\\mathnormal",
                // families
                "\\mathbb",
                "\\mathcal",
                "\\mathfrak",
                "\\mathscr",
                "\\mathsf",
                "\\mathtt",
                // aliases, except \bm defined below
                "\\Bbb",
                "\\bold",
                "\\frak"
              ],
              props: {
                numArgs: 1,
                greediness: 2
              },
              handler: function handler(_ref, args) {
                var parser = _ref.parser, funcName = _ref.funcName;
                var body = args[0];
                var func = funcName;
                if (func in fontAliases) {
                  func = fontAliases[func];
                }
                return {
                  type: "font",
                  mode: parser.mode,
                  font: func.slice(1),
                  body
                };
              },
              htmlBuilder: font_htmlBuilder,
              mathmlBuilder: font_mathmlBuilder
            });
            defineFunction({
              type: "mclass",
              names: ["\\boldsymbol", "\\bm"],
              props: {
                numArgs: 1,
                greediness: 2
              },
              handler: function handler(_ref2, args) {
                var parser = _ref2.parser;
                var body = args[0];
                var isCharacterBox = utils.isCharacterBox(body);
                return {
                  type: "mclass",
                  mode: parser.mode,
                  mclass: binrelClass(body),
                  body: [{
                    type: "font",
                    mode: parser.mode,
                    font: "boldsymbol",
                    body
                  }],
                  isCharacterBox
                };
              }
            });
            defineFunction({
              type: "font",
              names: ["\\rm", "\\sf", "\\tt", "\\bf", "\\it", "\\cal"],
              props: {
                numArgs: 0,
                allowedInText: true
              },
              handler: function handler(_ref3, args) {
                var parser = _ref3.parser, funcName = _ref3.funcName, breakOnTokenText = _ref3.breakOnTokenText;
                var mode = parser.mode;
                var body = parser.parseExpression(true, breakOnTokenText);
                var style = "math" + funcName.slice(1);
                return {
                  type: "font",
                  mode,
                  font: style,
                  body: {
                    type: "ordgroup",
                    mode: parser.mode,
                    body
                  }
                };
              },
              htmlBuilder: font_htmlBuilder,
              mathmlBuilder: font_mathmlBuilder
            });
            var genfrac_adjustStyle = function adjustStyle(size, originalStyle) {
              var style = originalStyle;
              if (size === "display") {
                style = style.id >= src_Style.SCRIPT.id ? style.text() : src_Style.DISPLAY;
              } else if (size === "text" && style.size === src_Style.DISPLAY.size) {
                style = src_Style.TEXT;
              } else if (size === "script") {
                style = src_Style.SCRIPT;
              } else if (size === "scriptscript") {
                style = src_Style.SCRIPTSCRIPT;
              }
              return style;
            };
            var genfrac_htmlBuilder = function htmlBuilder(group, options) {
              var style = genfrac_adjustStyle(group.size, options.style);
              var nstyle = style.fracNum();
              var dstyle = style.fracDen();
              var newOptions;
              newOptions = options.havingStyle(nstyle);
              var numerm = buildHTML_buildGroup(group.numer, newOptions, options);
              if (group.continued) {
                var hStrut = 8.5 / options.fontMetrics().ptPerEm;
                var dStrut = 3.5 / options.fontMetrics().ptPerEm;
                numerm.height = numerm.height < hStrut ? hStrut : numerm.height;
                numerm.depth = numerm.depth < dStrut ? dStrut : numerm.depth;
              }
              newOptions = options.havingStyle(dstyle);
              var denomm = buildHTML_buildGroup(group.denom, newOptions, options);
              var rule;
              var ruleWidth;
              var ruleSpacing;
              if (group.hasBarLine) {
                if (group.barSize) {
                  ruleWidth = units_calculateSize(group.barSize, options);
                  rule = buildCommon.makeLineSpan("frac-line", options, ruleWidth);
                } else {
                  rule = buildCommon.makeLineSpan("frac-line", options);
                }
                ruleWidth = rule.height;
                ruleSpacing = rule.height;
              } else {
                rule = null;
                ruleWidth = 0;
                ruleSpacing = options.fontMetrics().defaultRuleThickness;
              }
              var numShift;
              var clearance;
              var denomShift;
              if (style.size === src_Style.DISPLAY.size || group.size === "display") {
                numShift = options.fontMetrics().num1;
                if (ruleWidth > 0) {
                  clearance = 3 * ruleSpacing;
                } else {
                  clearance = 7 * ruleSpacing;
                }
                denomShift = options.fontMetrics().denom1;
              } else {
                if (ruleWidth > 0) {
                  numShift = options.fontMetrics().num2;
                  clearance = ruleSpacing;
                } else {
                  numShift = options.fontMetrics().num3;
                  clearance = 3 * ruleSpacing;
                }
                denomShift = options.fontMetrics().denom2;
              }
              var frac;
              if (!rule) {
                var candidateClearance = numShift - numerm.depth - (denomm.height - denomShift);
                if (candidateClearance < clearance) {
                  numShift += 0.5 * (clearance - candidateClearance);
                  denomShift += 0.5 * (clearance - candidateClearance);
                }
                frac = buildCommon.makeVList({
                  positionType: "individualShift",
                  children: [{
                    type: "elem",
                    elem: denomm,
                    shift: denomShift
                  }, {
                    type: "elem",
                    elem: numerm,
                    shift: -numShift
                  }]
                }, options);
              } else {
                var axisHeight = options.fontMetrics().axisHeight;
                if (numShift - numerm.depth - (axisHeight + 0.5 * ruleWidth) < clearance) {
                  numShift += clearance - (numShift - numerm.depth - (axisHeight + 0.5 * ruleWidth));
                }
                if (axisHeight - 0.5 * ruleWidth - (denomm.height - denomShift) < clearance) {
                  denomShift += clearance - (axisHeight - 0.5 * ruleWidth - (denomm.height - denomShift));
                }
                var midShift = -(axisHeight - 0.5 * ruleWidth);
                frac = buildCommon.makeVList({
                  positionType: "individualShift",
                  children: [{
                    type: "elem",
                    elem: denomm,
                    shift: denomShift
                  }, {
                    type: "elem",
                    elem: rule,
                    shift: midShift
                  }, {
                    type: "elem",
                    elem: numerm,
                    shift: -numShift
                  }]
                }, options);
              }
              newOptions = options.havingStyle(style);
              frac.height *= newOptions.sizeMultiplier / options.sizeMultiplier;
              frac.depth *= newOptions.sizeMultiplier / options.sizeMultiplier;
              var delimSize;
              if (style.size === src_Style.DISPLAY.size) {
                delimSize = options.fontMetrics().delim1;
              } else {
                delimSize = options.fontMetrics().delim2;
              }
              var leftDelim;
              var rightDelim;
              if (group.leftDelim == null) {
                leftDelim = makeNullDelimiter(options, ["mopen"]);
              } else {
                leftDelim = delimiter2.customSizedDelim(group.leftDelim, delimSize, true, options.havingStyle(style), group.mode, ["mopen"]);
              }
              if (group.continued) {
                rightDelim = buildCommon.makeSpan([]);
              } else if (group.rightDelim == null) {
                rightDelim = makeNullDelimiter(options, ["mclose"]);
              } else {
                rightDelim = delimiter2.customSizedDelim(group.rightDelim, delimSize, true, options.havingStyle(style), group.mode, ["mclose"]);
              }
              return buildCommon.makeSpan(["mord"].concat(newOptions.sizingClasses(options)), [leftDelim, buildCommon.makeSpan(["mfrac"], [frac]), rightDelim], options);
            };
            var genfrac_mathmlBuilder = function mathmlBuilder(group, options) {
              var node = new mathMLTree.MathNode("mfrac", [buildMathML_buildGroup(group.numer, options), buildMathML_buildGroup(group.denom, options)]);
              if (!group.hasBarLine) {
                node.setAttribute("linethickness", "0px");
              } else if (group.barSize) {
                var ruleWidth = units_calculateSize(group.barSize, options);
                node.setAttribute("linethickness", ruleWidth + "em");
              }
              var style = genfrac_adjustStyle(group.size, options.style);
              if (style.size !== options.style.size) {
                node = new mathMLTree.MathNode("mstyle", [node]);
                var isDisplay = style.size === src_Style.DISPLAY.size ? "true" : "false";
                node.setAttribute("displaystyle", isDisplay);
                node.setAttribute("scriptlevel", "0");
              }
              if (group.leftDelim != null || group.rightDelim != null) {
                var withDelims = [];
                if (group.leftDelim != null) {
                  var leftOp = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode(group.leftDelim.replace("\\", ""))]);
                  leftOp.setAttribute("fence", "true");
                  withDelims.push(leftOp);
                }
                withDelims.push(node);
                if (group.rightDelim != null) {
                  var rightOp = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode(group.rightDelim.replace("\\", ""))]);
                  rightOp.setAttribute("fence", "true");
                  withDelims.push(rightOp);
                }
                return buildMathML_makeRow(withDelims);
              }
              return node;
            };
            defineFunction({
              type: "genfrac",
              names: [
                "\\cfrac",
                "\\dfrac",
                "\\frac",
                "\\tfrac",
                "\\dbinom",
                "\\binom",
                "\\tbinom",
                "\\\\atopfrac",
                // can’t be entered directly
                "\\\\bracefrac",
                "\\\\brackfrac"
              ],
              props: {
                numArgs: 2,
                greediness: 2
              },
              handler: function handler(_ref, args) {
                var parser = _ref.parser, funcName = _ref.funcName;
                var numer = args[0];
                var denom = args[1];
                var hasBarLine;
                var leftDelim = null;
                var rightDelim = null;
                var size = "auto";
                switch (funcName) {
                  case "\\cfrac":
                  case "\\dfrac":
                  case "\\frac":
                  case "\\tfrac":
                    hasBarLine = true;
                    break;
                  case "\\\\atopfrac":
                    hasBarLine = false;
                    break;
                  case "\\dbinom":
                  case "\\binom":
                  case "\\tbinom":
                    hasBarLine = false;
                    leftDelim = "(";
                    rightDelim = ")";
                    break;
                  case "\\\\bracefrac":
                    hasBarLine = false;
                    leftDelim = "\\{";
                    rightDelim = "\\}";
                    break;
                  case "\\\\brackfrac":
                    hasBarLine = false;
                    leftDelim = "[";
                    rightDelim = "]";
                    break;
                  default:
                    throw new Error("Unrecognized genfrac command");
                }
                switch (funcName) {
                  case "\\cfrac":
                  case "\\dfrac":
                  case "\\dbinom":
                    size = "display";
                    break;
                  case "\\tfrac":
                  case "\\tbinom":
                    size = "text";
                    break;
                }
                return {
                  type: "genfrac",
                  mode: parser.mode,
                  continued: funcName === "\\cfrac",
                  numer,
                  denom,
                  hasBarLine,
                  leftDelim,
                  rightDelim,
                  size,
                  barSize: null
                };
              },
              htmlBuilder: genfrac_htmlBuilder,
              mathmlBuilder: genfrac_mathmlBuilder
            });
            defineFunction({
              type: "infix",
              names: ["\\over", "\\choose", "\\atop", "\\brace", "\\brack"],
              props: {
                numArgs: 0,
                infix: true
              },
              handler: function handler(_ref2) {
                var parser = _ref2.parser, funcName = _ref2.funcName, token = _ref2.token;
                var replaceWith2;
                switch (funcName) {
                  case "\\over":
                    replaceWith2 = "\\frac";
                    break;
                  case "\\choose":
                    replaceWith2 = "\\binom";
                    break;
                  case "\\atop":
                    replaceWith2 = "\\\\atopfrac";
                    break;
                  case "\\brace":
                    replaceWith2 = "\\\\bracefrac";
                    break;
                  case "\\brack":
                    replaceWith2 = "\\\\brackfrac";
                    break;
                  default:
                    throw new Error("Unrecognized infix genfrac command");
                }
                return {
                  type: "infix",
                  mode: parser.mode,
                  replaceWith: replaceWith2,
                  token
                };
              }
            });
            var stylArray = ["display", "text", "script", "scriptscript"];
            var delimFromValue = function delimFromValue2(delimString) {
              var delim = null;
              if (delimString.length > 0) {
                delim = delimString;
                delim = delim === "." ? null : delim;
              }
              return delim;
            };
            defineFunction({
              type: "genfrac",
              names: ["\\genfrac"],
              props: {
                numArgs: 6,
                greediness: 6,
                argTypes: ["math", "math", "size", "text", "math", "math"]
              },
              handler: function handler(_ref3, args) {
                var parser = _ref3.parser;
                var numer = args[4];
                var denom = args[5];
                var leftDelim = args[0].type === "atom" && args[0].family === "open" ? delimFromValue(args[0].text) : null;
                var rightDelim = args[1].type === "atom" && args[1].family === "close" ? delimFromValue(args[1].text) : null;
                var barNode = assertNodeType(args[2], "size");
                var hasBarLine;
                var barSize = null;
                if (barNode.isBlank) {
                  hasBarLine = true;
                } else {
                  barSize = barNode.value;
                  hasBarLine = barSize.number > 0;
                }
                var size = "auto";
                var styl = args[3];
                if (styl.type === "ordgroup") {
                  if (styl.body.length > 0) {
                    var textOrd = assertNodeType(styl.body[0], "textord");
                    size = stylArray[Number(textOrd.text)];
                  }
                } else {
                  styl = assertNodeType(styl, "textord");
                  size = stylArray[Number(styl.text)];
                }
                return {
                  type: "genfrac",
                  mode: parser.mode,
                  numer,
                  denom,
                  continued: false,
                  hasBarLine,
                  barSize,
                  leftDelim,
                  rightDelim,
                  size
                };
              },
              htmlBuilder: genfrac_htmlBuilder,
              mathmlBuilder: genfrac_mathmlBuilder
            });
            defineFunction({
              type: "infix",
              names: ["\\above"],
              props: {
                numArgs: 1,
                argTypes: ["size"],
                infix: true
              },
              handler: function handler(_ref4, args) {
                var parser = _ref4.parser, funcName = _ref4.funcName, token = _ref4.token;
                return {
                  type: "infix",
                  mode: parser.mode,
                  replaceWith: "\\\\abovefrac",
                  size: assertNodeType(args[0], "size").value,
                  token
                };
              }
            });
            defineFunction({
              type: "genfrac",
              names: ["\\\\abovefrac"],
              props: {
                numArgs: 3,
                argTypes: ["math", "size", "math"]
              },
              handler: function handler(_ref5, args) {
                var parser = _ref5.parser, funcName = _ref5.funcName;
                var numer = args[0];
                var barSize = assert(assertNodeType(args[1], "infix").size);
                var denom = args[2];
                var hasBarLine = barSize.number > 0;
                return {
                  type: "genfrac",
                  mode: parser.mode,
                  numer,
                  denom,
                  continued: false,
                  hasBarLine,
                  barSize,
                  leftDelim: null,
                  rightDelim: null,
                  size: "auto"
                };
              },
              htmlBuilder: genfrac_htmlBuilder,
              mathmlBuilder: genfrac_mathmlBuilder
            });
            var horizBrace_htmlBuilder = function htmlBuilder(grp, options) {
              var style = options.style;
              var supSubGroup;
              var group;
              if (grp.type === "supsub") {
                supSubGroup = grp.sup ? buildHTML_buildGroup(grp.sup, options.havingStyle(style.sup()), options) : buildHTML_buildGroup(grp.sub, options.havingStyle(style.sub()), options);
                group = assertNodeType(grp.base, "horizBrace");
              } else {
                group = assertNodeType(grp, "horizBrace");
              }
              var body = buildHTML_buildGroup(group.base, options.havingBaseStyle(src_Style.DISPLAY));
              var braceBody = stretchy.svgSpan(group, options);
              var vlist;
              if (group.isOver) {
                vlist = buildCommon.makeVList({
                  positionType: "firstBaseline",
                  children: [{
                    type: "elem",
                    elem: body
                  }, {
                    type: "kern",
                    size: 0.1
                  }, {
                    type: "elem",
                    elem: braceBody
                  }]
                }, options);
                vlist.children[0].children[0].children[1].classes.push("svg-align");
              } else {
                vlist = buildCommon.makeVList({
                  positionType: "bottom",
                  positionData: body.depth + 0.1 + braceBody.height,
                  children: [{
                    type: "elem",
                    elem: braceBody
                  }, {
                    type: "kern",
                    size: 0.1
                  }, {
                    type: "elem",
                    elem: body
                  }]
                }, options);
                vlist.children[0].children[0].children[0].classes.push("svg-align");
              }
              if (supSubGroup) {
                var vSpan = buildCommon.makeSpan(["mord", group.isOver ? "mover" : "munder"], [vlist], options);
                if (group.isOver) {
                  vlist = buildCommon.makeVList({
                    positionType: "firstBaseline",
                    children: [{
                      type: "elem",
                      elem: vSpan
                    }, {
                      type: "kern",
                      size: 0.2
                    }, {
                      type: "elem",
                      elem: supSubGroup
                    }]
                  }, options);
                } else {
                  vlist = buildCommon.makeVList({
                    positionType: "bottom",
                    positionData: vSpan.depth + 0.2 + supSubGroup.height + supSubGroup.depth,
                    children: [{
                      type: "elem",
                      elem: supSubGroup
                    }, {
                      type: "kern",
                      size: 0.2
                    }, {
                      type: "elem",
                      elem: vSpan
                    }]
                  }, options);
                }
              }
              return buildCommon.makeSpan(["mord", group.isOver ? "mover" : "munder"], [vlist], options);
            };
            var horizBrace_mathmlBuilder = function mathmlBuilder(group, options) {
              var accentNode = stretchy.mathMLnode(group.label);
              return new mathMLTree.MathNode(group.isOver ? "mover" : "munder", [buildMathML_buildGroup(group.base, options), accentNode]);
            };
            defineFunction({
              type: "horizBrace",
              names: ["\\overbrace", "\\underbrace"],
              props: {
                numArgs: 1
              },
              handler: function handler(_ref, args) {
                var parser = _ref.parser, funcName = _ref.funcName;
                return {
                  type: "horizBrace",
                  mode: parser.mode,
                  label: funcName,
                  isOver: /^\\over/.test(funcName),
                  base: args[0]
                };
              },
              htmlBuilder: horizBrace_htmlBuilder,
              mathmlBuilder: horizBrace_mathmlBuilder
            });
            defineFunction({
              type: "href",
              names: ["\\href"],
              props: {
                numArgs: 2,
                argTypes: ["url", "original"],
                allowedInText: true
              },
              handler: function handler(_ref, args) {
                var parser = _ref.parser;
                var body = args[1];
                var href = assertNodeType(args[0], "url").url;
                if (!parser.settings.isTrusted({
                  command: "\\href",
                  url: href
                })) {
                  return parser.formatUnsupportedCmd("\\href");
                }
                return {
                  type: "href",
                  mode: parser.mode,
                  href,
                  body: ordargument(body)
                };
              },
              htmlBuilder: function htmlBuilder(group, options) {
                var elements = buildHTML_buildExpression(group.body, options, false);
                return buildCommon.makeAnchor(group.href, [], elements, options);
              },
              mathmlBuilder: function mathmlBuilder(group, options) {
                var math = buildExpressionRow(group.body, options);
                if (!(math instanceof mathMLTree_MathNode)) {
                  math = new mathMLTree_MathNode("mrow", [math]);
                }
                math.setAttribute("href", group.href);
                return math;
              }
            });
            defineFunction({
              type: "href",
              names: ["\\url"],
              props: {
                numArgs: 1,
                argTypes: ["url"],
                allowedInText: true
              },
              handler: function handler(_ref2, args) {
                var parser = _ref2.parser;
                var href = assertNodeType(args[0], "url").url;
                if (!parser.settings.isTrusted({
                  command: "\\url",
                  url: href
                })) {
                  return parser.formatUnsupportedCmd("\\url");
                }
                var chars = [];
                for (var i = 0; i < href.length; i++) {
                  var c = href[i];
                  if (c === "~") {
                    c = "\\textasciitilde";
                  }
                  chars.push({
                    type: "textord",
                    mode: "text",
                    text: c
                  });
                }
                var body = {
                  type: "text",
                  mode: parser.mode,
                  font: "\\texttt",
                  body: chars
                };
                return {
                  type: "href",
                  mode: parser.mode,
                  href,
                  body: ordargument(body)
                };
              }
            });
            defineFunction({
              type: "html",
              names: ["\\htmlClass", "\\htmlId", "\\htmlStyle", "\\htmlData"],
              props: {
                numArgs: 2,
                argTypes: ["raw", "original"],
                allowedInText: true
              },
              handler: function handler(_ref, args) {
                var parser = _ref.parser, funcName = _ref.funcName, token = _ref.token;
                var value = assertNodeType(args[0], "raw").string;
                var body = args[1];
                if (parser.settings.strict) {
                  parser.settings.reportNonstrict("htmlExtension", "HTML extension is disabled on strict mode");
                }
                var trustContext;
                var attributes2 = {};
                switch (funcName) {
                  case "\\htmlClass":
                    attributes2.class = value;
                    trustContext = {
                      command: "\\htmlClass",
                      class: value
                    };
                    break;
                  case "\\htmlId":
                    attributes2.id = value;
                    trustContext = {
                      command: "\\htmlId",
                      id: value
                    };
                    break;
                  case "\\htmlStyle":
                    attributes2.style = value;
                    trustContext = {
                      command: "\\htmlStyle",
                      style: value
                    };
                    break;
                  case "\\htmlData": {
                    var data2 = value.split(",");
                    for (var i = 0; i < data2.length; i++) {
                      var keyVal = data2[i].split("=");
                      if (keyVal.length !== 2) {
                        throw new src_ParseError("Error parsing key-value for \\htmlData");
                      }
                      attributes2["data-" + keyVal[0].trim()] = keyVal[1].trim();
                    }
                    trustContext = {
                      command: "\\htmlData",
                      attributes: attributes2
                    };
                    break;
                  }
                  default:
                    throw new Error("Unrecognized html command");
                }
                if (!parser.settings.isTrusted(trustContext)) {
                  return parser.formatUnsupportedCmd(funcName);
                }
                return {
                  type: "html",
                  mode: parser.mode,
                  attributes: attributes2,
                  body: ordargument(body)
                };
              },
              htmlBuilder: function htmlBuilder(group, options) {
                var elements = buildHTML_buildExpression(group.body, options, false);
                var classes = ["enclosing"];
                if (group.attributes.class) {
                  classes.push.apply(classes, group.attributes.class.trim().split(/\s+/));
                }
                var span = buildCommon.makeSpan(classes, elements, options);
                for (var attr2 in group.attributes) {
                  if (attr2 !== "class" && group.attributes.hasOwnProperty(attr2)) {
                    span.setAttribute(attr2, group.attributes[attr2]);
                  }
                }
                return span;
              },
              mathmlBuilder: function mathmlBuilder(group, options) {
                return buildExpressionRow(group.body, options);
              }
            });
            defineFunction({
              type: "htmlmathml",
              names: ["\\html@mathml"],
              props: {
                numArgs: 2,
                allowedInText: true
              },
              handler: function handler(_ref, args) {
                var parser = _ref.parser;
                return {
                  type: "htmlmathml",
                  mode: parser.mode,
                  html: ordargument(args[0]),
                  mathml: ordargument(args[1])
                };
              },
              htmlBuilder: function htmlBuilder(group, options) {
                var elements = buildHTML_buildExpression(group.html, options, false);
                return buildCommon.makeFragment(elements);
              },
              mathmlBuilder: function mathmlBuilder(group, options) {
                return buildExpressionRow(group.mathml, options);
              }
            });
            var includegraphics_sizeData = function sizeData(str2) {
              if (/^[-+]? *(\d+(\.\d*)?|\.\d+)$/.test(str2)) {
                return {
                  number: +str2,
                  unit: "bp"
                };
              } else {
                var match2 = /([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/.exec(str2);
                if (!match2) {
                  throw new src_ParseError("Invalid size: '" + str2 + "' in \\includegraphics");
                }
                var data2 = {
                  number: +(match2[1] + match2[2]),
                  // sign + magnitude, cast to number
                  unit: match2[3]
                };
                if (!validUnit(data2)) {
                  throw new src_ParseError("Invalid unit: '" + data2.unit + "' in \\includegraphics.");
                }
                return data2;
              }
            };
            defineFunction({
              type: "includegraphics",
              names: ["\\includegraphics"],
              props: {
                numArgs: 1,
                numOptionalArgs: 1,
                argTypes: ["raw", "url"],
                allowedInText: false
              },
              handler: function handler(_ref, args, optArgs) {
                var parser = _ref.parser;
                var width = {
                  number: 0,
                  unit: "em"
                };
                var height = {
                  number: 0.9,
                  unit: "em"
                };
                var totalheight = {
                  number: 0,
                  unit: "em"
                };
                var alt = "";
                if (optArgs[0]) {
                  var attributeStr = assertNodeType(optArgs[0], "raw").string;
                  var attributes2 = attributeStr.split(",");
                  for (var i = 0; i < attributes2.length; i++) {
                    var keyVal = attributes2[i].split("=");
                    if (keyVal.length === 2) {
                      var str2 = keyVal[1].trim();
                      switch (keyVal[0].trim()) {
                        case "alt":
                          alt = str2;
                          break;
                        case "width":
                          width = includegraphics_sizeData(str2);
                          break;
                        case "height":
                          height = includegraphics_sizeData(str2);
                          break;
                        case "totalheight":
                          totalheight = includegraphics_sizeData(str2);
                          break;
                        default:
                          throw new src_ParseError("Invalid key: '" + keyVal[0] + "' in \\includegraphics.");
                      }
                    }
                  }
                }
                var src = assertNodeType(args[0], "url").url;
                if (alt === "") {
                  alt = src;
                  alt = alt.replace(/^.*[\\/]/, "");
                  alt = alt.substring(0, alt.lastIndexOf("."));
                }
                if (!parser.settings.isTrusted({
                  command: "\\includegraphics",
                  url: src
                })) {
                  return parser.formatUnsupportedCmd("\\includegraphics");
                }
                return {
                  type: "includegraphics",
                  mode: parser.mode,
                  alt,
                  width,
                  height,
                  totalheight,
                  src
                };
              },
              htmlBuilder: function htmlBuilder(group, options) {
                var height = units_calculateSize(group.height, options);
                var depth = 0;
                if (group.totalheight.number > 0) {
                  depth = units_calculateSize(group.totalheight, options) - height;
                  depth = Number(depth.toFixed(2));
                }
                var width = 0;
                if (group.width.number > 0) {
                  width = units_calculateSize(group.width, options);
                }
                var style = {
                  height: height + depth + "em"
                };
                if (width > 0) {
                  style.width = width + "em";
                }
                if (depth > 0) {
                  style.verticalAlign = -depth + "em";
                }
                var node = new domTree_Img(group.src, group.alt, style);
                node.height = height;
                node.depth = depth;
                return node;
              },
              mathmlBuilder: function mathmlBuilder(group, options) {
                var node = new mathMLTree.MathNode("mglyph", []);
                node.setAttribute("alt", group.alt);
                var height = units_calculateSize(group.height, options);
                var depth = 0;
                if (group.totalheight.number > 0) {
                  depth = units_calculateSize(group.totalheight, options) - height;
                  depth = depth.toFixed(2);
                  node.setAttribute("valign", "-" + depth + "em");
                }
                node.setAttribute("height", height + depth + "em");
                if (group.width.number > 0) {
                  var width = units_calculateSize(group.width, options);
                  node.setAttribute("width", width + "em");
                }
                node.setAttribute("src", group.src);
                return node;
              }
            });
            defineFunction({
              type: "kern",
              names: ["\\kern", "\\mkern", "\\hskip", "\\mskip"],
              props: {
                numArgs: 1,
                argTypes: ["size"],
                allowedInText: true
              },
              handler: function handler(_ref, args) {
                var parser = _ref.parser, funcName = _ref.funcName;
                var size = assertNodeType(args[0], "size");
                if (parser.settings.strict) {
                  var mathFunction = funcName[1] === "m";
                  var muUnit = size.value.unit === "mu";
                  if (mathFunction) {
                    if (!muUnit) {
                      parser.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + funcName + " supports only mu units, " + ("not " + size.value.unit + " units"));
                    }
                    if (parser.mode !== "math") {
                      parser.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + funcName + " works only in math mode");
                    }
                  } else {
                    if (muUnit) {
                      parser.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + funcName + " doesn't support mu units");
                    }
                  }
                }
                return {
                  type: "kern",
                  mode: parser.mode,
                  dimension: size.value
                };
              },
              htmlBuilder: function htmlBuilder(group, options) {
                return buildCommon.makeGlue(group.dimension, options);
              },
              mathmlBuilder: function mathmlBuilder(group, options) {
                var dimension = units_calculateSize(group.dimension, options);
                return new mathMLTree.SpaceNode(dimension);
              }
            });
            defineFunction({
              type: "lap",
              names: ["\\mathllap", "\\mathrlap", "\\mathclap"],
              props: {
                numArgs: 1,
                allowedInText: true
              },
              handler: function handler(_ref, args) {
                var parser = _ref.parser, funcName = _ref.funcName;
                var body = args[0];
                return {
                  type: "lap",
                  mode: parser.mode,
                  alignment: funcName.slice(5),
                  body
                };
              },
              htmlBuilder: function htmlBuilder(group, options) {
                var inner;
                if (group.alignment === "clap") {
                  inner = buildCommon.makeSpan([], [buildHTML_buildGroup(group.body, options)]);
                  inner = buildCommon.makeSpan(["inner"], [inner], options);
                } else {
                  inner = buildCommon.makeSpan(["inner"], [buildHTML_buildGroup(group.body, options)]);
                }
                var fix = buildCommon.makeSpan(["fix"], []);
                var node = buildCommon.makeSpan([group.alignment], [inner, fix], options);
                var strut = buildCommon.makeSpan(["strut"]);
                strut.style.height = node.height + node.depth + "em";
                strut.style.verticalAlign = -node.depth + "em";
                node.children.unshift(strut);
                node = buildCommon.makeSpan(["thinbox"], [node], options);
                return buildCommon.makeSpan(["mord", "vbox"], [node], options);
              },
              mathmlBuilder: function mathmlBuilder(group, options) {
                var node = new mathMLTree.MathNode("mpadded", [buildMathML_buildGroup(group.body, options)]);
                if (group.alignment !== "rlap") {
                  var offset = group.alignment === "llap" ? "-1" : "-0.5";
                  node.setAttribute("lspace", offset + "width");
                }
                node.setAttribute("width", "0px");
                return node;
              }
            });
            defineFunction({
              type: "styling",
              names: ["\\(", "$"],
              props: {
                numArgs: 0,
                allowedInText: true,
                allowedInMath: false
              },
              handler: function handler(_ref, args) {
                var funcName = _ref.funcName, parser = _ref.parser;
                var outerMode = parser.mode;
                parser.switchMode("math");
                var close = funcName === "\\(" ? "\\)" : "$";
                var body = parser.parseExpression(false, close);
                parser.expect(close);
                parser.switchMode(outerMode);
                return {
                  type: "styling",
                  mode: parser.mode,
                  style: "text",
                  body
                };
              }
            });
            defineFunction({
              type: "text",
              // Doesn't matter what this is.
              names: ["\\)", "\\]"],
              props: {
                numArgs: 0,
                allowedInText: true,
                allowedInMath: false
              },
              handler: function handler(context, args) {
                throw new src_ParseError("Mismatched " + context.funcName);
              }
            });
            var mathchoice_chooseMathStyle = function chooseMathStyle(group, options) {
              switch (options.style.size) {
                case src_Style.DISPLAY.size:
                  return group.display;
                case src_Style.TEXT.size:
                  return group.text;
                case src_Style.SCRIPT.size:
                  return group.script;
                case src_Style.SCRIPTSCRIPT.size:
                  return group.scriptscript;
                default:
                  return group.text;
              }
            };
            defineFunction({
              type: "mathchoice",
              names: ["\\mathchoice"],
              props: {
                numArgs: 4
              },
              handler: function handler(_ref, args) {
                var parser = _ref.parser;
                return {
                  type: "mathchoice",
                  mode: parser.mode,
                  display: ordargument(args[0]),
                  text: ordargument(args[1]),
                  script: ordargument(args[2]),
                  scriptscript: ordargument(args[3])
                };
              },
              htmlBuilder: function htmlBuilder(group, options) {
                var body = mathchoice_chooseMathStyle(group, options);
                var elements = buildHTML_buildExpression(body, options, false);
                return buildCommon.makeFragment(elements);
              },
              mathmlBuilder: function mathmlBuilder(group, options) {
                var body = mathchoice_chooseMathStyle(group, options);
                return buildExpressionRow(body, options);
              }
            });
            var assembleSupSub_assembleSupSub = function assembleSupSub(base2, supGroup, subGroup, options, style, slant, baseShift) {
              base2 = buildCommon.makeSpan([], [base2]);
              var sub;
              var sup;
              if (supGroup) {
                var elem = buildHTML_buildGroup(supGroup, options.havingStyle(style.sup()), options);
                sup = {
                  elem,
                  kern: Math.max(options.fontMetrics().bigOpSpacing1, options.fontMetrics().bigOpSpacing3 - elem.depth)
                };
              }
              if (subGroup) {
                var _elem = buildHTML_buildGroup(subGroup, options.havingStyle(style.sub()), options);
                sub = {
                  elem: _elem,
                  kern: Math.max(options.fontMetrics().bigOpSpacing2, options.fontMetrics().bigOpSpacing4 - _elem.height)
                };
              }
              var finalGroup;
              if (sup && sub) {
                var bottom = options.fontMetrics().bigOpSpacing5 + sub.elem.height + sub.elem.depth + sub.kern + base2.depth + baseShift;
                finalGroup = buildCommon.makeVList({
                  positionType: "bottom",
                  positionData: bottom,
                  children: [{
                    type: "kern",
                    size: options.fontMetrics().bigOpSpacing5
                  }, {
                    type: "elem",
                    elem: sub.elem,
                    marginLeft: -slant + "em"
                  }, {
                    type: "kern",
                    size: sub.kern
                  }, {
                    type: "elem",
                    elem: base2
                  }, {
                    type: "kern",
                    size: sup.kern
                  }, {
                    type: "elem",
                    elem: sup.elem,
                    marginLeft: slant + "em"
                  }, {
                    type: "kern",
                    size: options.fontMetrics().bigOpSpacing5
                  }]
                }, options);
              } else if (sub) {
                var top = base2.height - baseShift;
                finalGroup = buildCommon.makeVList({
                  positionType: "top",
                  positionData: top,
                  children: [{
                    type: "kern",
                    size: options.fontMetrics().bigOpSpacing5
                  }, {
                    type: "elem",
                    elem: sub.elem,
                    marginLeft: -slant + "em"
                  }, {
                    type: "kern",
                    size: sub.kern
                  }, {
                    type: "elem",
                    elem: base2
                  }]
                }, options);
              } else if (sup) {
                var _bottom = base2.depth + baseShift;
                finalGroup = buildCommon.makeVList({
                  positionType: "bottom",
                  positionData: _bottom,
                  children: [{
                    type: "elem",
                    elem: base2
                  }, {
                    type: "kern",
                    size: sup.kern
                  }, {
                    type: "elem",
                    elem: sup.elem,
                    marginLeft: slant + "em"
                  }, {
                    type: "kern",
                    size: options.fontMetrics().bigOpSpacing5
                  }]
                }, options);
              } else {
                return base2;
              }
              return buildCommon.makeSpan(["mop", "op-limits"], [finalGroup], options);
            };
            var noSuccessor = ["\\smallint"];
            var op_htmlBuilder = function htmlBuilder(grp, options) {
              var supGroup;
              var subGroup;
              var hasLimits = false;
              var group;
              if (grp.type === "supsub") {
                supGroup = grp.sup;
                subGroup = grp.sub;
                group = assertNodeType(grp.base, "op");
                hasLimits = true;
              } else {
                group = assertNodeType(grp, "op");
              }
              var style = options.style;
              var large = false;
              if (style.size === src_Style.DISPLAY.size && group.symbol && !utils.contains(noSuccessor, group.name)) {
                large = true;
              }
              var base2;
              if (group.symbol) {
                var fontName = large ? "Size2-Regular" : "Size1-Regular";
                var stash = "";
                if (group.name === "\\oiint" || group.name === "\\oiiint") {
                  stash = group.name.substr(1);
                  group.name = stash === "oiint" ? "\\iint" : "\\iiint";
                }
                base2 = buildCommon.makeSymbol(group.name, fontName, "math", options, ["mop", "op-symbol", large ? "large-op" : "small-op"]);
                if (stash.length > 0) {
                  var italic = base2.italic;
                  var oval = buildCommon.staticSvg(stash + "Size" + (large ? "2" : "1"), options);
                  base2 = buildCommon.makeVList({
                    positionType: "individualShift",
                    children: [{
                      type: "elem",
                      elem: base2,
                      shift: 0
                    }, {
                      type: "elem",
                      elem: oval,
                      shift: large ? 0.08 : 0
                    }]
                  }, options);
                  group.name = "\\" + stash;
                  base2.classes.unshift("mop");
                  base2.italic = italic;
                }
              } else if (group.body) {
                var inner = buildHTML_buildExpression(group.body, options, true);
                if (inner.length === 1 && inner[0] instanceof domTree_SymbolNode) {
                  base2 = inner[0];
                  base2.classes[0] = "mop";
                } else {
                  base2 = buildCommon.makeSpan(["mop"], buildCommon.tryCombineChars(inner), options);
                }
              } else {
                var output = [];
                for (var i = 1; i < group.name.length; i++) {
                  output.push(buildCommon.mathsym(group.name[i], group.mode, options));
                }
                base2 = buildCommon.makeSpan(["mop"], output, options);
              }
              var baseShift = 0;
              var slant = 0;
              if ((base2 instanceof domTree_SymbolNode || group.name === "\\oiint" || group.name === "\\oiiint") && !group.suppressBaseShift) {
                baseShift = (base2.height - base2.depth) / 2 - options.fontMetrics().axisHeight;
                slant = base2.italic;
              }
              if (hasLimits) {
                return assembleSupSub_assembleSupSub(base2, supGroup, subGroup, options, style, slant, baseShift);
              } else {
                if (baseShift) {
                  base2.style.position = "relative";
                  base2.style.top = baseShift + "em";
                }
                return base2;
              }
            };
            var op_mathmlBuilder = function mathmlBuilder(group, options) {
              var node;
              if (group.symbol) {
                node = new mathMLTree_MathNode("mo", [buildMathML_makeText(group.name, group.mode)]);
                if (utils.contains(noSuccessor, group.name)) {
                  node.setAttribute("largeop", "false");
                }
              } else if (group.body) {
                node = new mathMLTree_MathNode("mo", buildMathML_buildExpression(group.body, options));
              } else {
                node = new mathMLTree_MathNode("mi", [new mathMLTree_TextNode(group.name.slice(1))]);
                var operator = new mathMLTree_MathNode("mo", [buildMathML_makeText("⁡", "text")]);
                if (group.parentIsSupSub) {
                  node = new mathMLTree_MathNode("mo", [node, operator]);
                } else {
                  node = newDocumentFragment([node, operator]);
                }
              }
              return node;
            };
            var singleCharBigOps = {
              "∏": "\\prod",
              "∐": "\\coprod",
              "∑": "\\sum",
              "⋀": "\\bigwedge",
              "⋁": "\\bigvee",
              "⋂": "\\bigcap",
              "⋃": "\\bigcup",
              "⨀": "\\bigodot",
              "⨁": "\\bigoplus",
              "⨂": "\\bigotimes",
              "⨄": "\\biguplus",
              "⨆": "\\bigsqcup"
            };
            defineFunction({
              type: "op",
              names: ["\\coprod", "\\bigvee", "\\bigwedge", "\\biguplus", "\\bigcap", "\\bigcup", "\\intop", "\\prod", "\\sum", "\\bigotimes", "\\bigoplus", "\\bigodot", "\\bigsqcup", "\\smallint", "∏", "∐", "∑", "⋀", "⋁", "⋂", "⋃", "⨀", "⨁", "⨂", "⨄", "⨆"],
              props: {
                numArgs: 0
              },
              handler: function handler(_ref, args) {
                var parser = _ref.parser, funcName = _ref.funcName;
                var fName = funcName;
                if (fName.length === 1) {
                  fName = singleCharBigOps[fName];
                }
                return {
                  type: "op",
                  mode: parser.mode,
                  limits: true,
                  parentIsSupSub: false,
                  symbol: true,
                  name: fName
                };
              },
              htmlBuilder: op_htmlBuilder,
              mathmlBuilder: op_mathmlBuilder
            });
            defineFunction({
              type: "op",
              names: ["\\mathop"],
              props: {
                numArgs: 1
              },
              handler: function handler(_ref2, args) {
                var parser = _ref2.parser;
                var body = args[0];
                return {
                  type: "op",
                  mode: parser.mode,
                  limits: false,
                  parentIsSupSub: false,
                  symbol: false,
                  body: ordargument(body)
                };
              },
              htmlBuilder: op_htmlBuilder,
              mathmlBuilder: op_mathmlBuilder
            });
            var singleCharIntegrals = {
              "∫": "\\int",
              "∬": "\\iint",
              "∭": "\\iiint",
              "∮": "\\oint",
              "∯": "\\oiint",
              "∰": "\\oiiint"
            };
            defineFunction({
              type: "op",
              names: ["\\arcsin", "\\arccos", "\\arctan", "\\arctg", "\\arcctg", "\\arg", "\\ch", "\\cos", "\\cosec", "\\cosh", "\\cot", "\\cotg", "\\coth", "\\csc", "\\ctg", "\\cth", "\\deg", "\\dim", "\\exp", "\\hom", "\\ker", "\\lg", "\\ln", "\\log", "\\sec", "\\sin", "\\sinh", "\\sh", "\\tan", "\\tanh", "\\tg", "\\th"],
              props: {
                numArgs: 0
              },
              handler: function handler(_ref3) {
                var parser = _ref3.parser, funcName = _ref3.funcName;
                return {
                  type: "op",
                  mode: parser.mode,
                  limits: false,
                  parentIsSupSub: false,
                  symbol: false,
                  name: funcName
                };
              },
              htmlBuilder: op_htmlBuilder,
              mathmlBuilder: op_mathmlBuilder
            });
            defineFunction({
              type: "op",
              names: ["\\det", "\\gcd", "\\inf", "\\lim", "\\max", "\\min", "\\Pr", "\\sup"],
              props: {
                numArgs: 0
              },
              handler: function handler(_ref4) {
                var parser = _ref4.parser, funcName = _ref4.funcName;
                return {
                  type: "op",
                  mode: parser.mode,
                  limits: true,
                  parentIsSupSub: false,
                  symbol: false,
                  name: funcName
                };
              },
              htmlBuilder: op_htmlBuilder,
              mathmlBuilder: op_mathmlBuilder
            });
            defineFunction({
              type: "op",
              names: ["\\int", "\\iint", "\\iiint", "\\oint", "\\oiint", "\\oiiint", "∫", "∬", "∭", "∮", "∯", "∰"],
              props: {
                numArgs: 0
              },
              handler: function handler(_ref5) {
                var parser = _ref5.parser, funcName = _ref5.funcName;
                var fName = funcName;
                if (fName.length === 1) {
                  fName = singleCharIntegrals[fName];
                }
                return {
                  type: "op",
                  mode: parser.mode,
                  limits: false,
                  parentIsSupSub: false,
                  symbol: true,
                  name: fName
                };
              },
              htmlBuilder: op_htmlBuilder,
              mathmlBuilder: op_mathmlBuilder
            });
            var operatorname_htmlBuilder = function htmlBuilder(grp, options) {
              var supGroup;
              var subGroup;
              var hasLimits = false;
              var group;
              if (grp.type === "supsub") {
                supGroup = grp.sup;
                subGroup = grp.sub;
                group = assertNodeType(grp.base, "operatorname");
                hasLimits = true;
              } else {
                group = assertNodeType(grp, "operatorname");
              }
              var base2;
              if (group.body.length > 0) {
                var body = group.body.map(function(child2) {
                  var childText = child2.text;
                  if (typeof childText === "string") {
                    return {
                      type: "textord",
                      mode: child2.mode,
                      text: childText
                    };
                  } else {
                    return child2;
                  }
                });
                var expression = buildHTML_buildExpression(body, options.withFont("mathrm"), true);
                for (var i = 0; i < expression.length; i++) {
                  var child = expression[i];
                  if (child instanceof domTree_SymbolNode) {
                    child.text = child.text.replace(/\u2212/, "-").replace(/\u2217/, "*");
                  }
                }
                base2 = buildCommon.makeSpan(["mop"], expression, options);
              } else {
                base2 = buildCommon.makeSpan(["mop"], [], options);
              }
              if (hasLimits) {
                return assembleSupSub_assembleSupSub(base2, supGroup, subGroup, options, options.style, 0, 0);
              } else {
                return base2;
              }
            };
            var operatorname_mathmlBuilder = function mathmlBuilder(group, options) {
              var expression = buildMathML_buildExpression(group.body, options.withFont("mathrm"));
              var isAllString = true;
              for (var i = 0; i < expression.length; i++) {
                var node = expression[i];
                if (node instanceof mathMLTree.SpaceNode) {
                } else if (node instanceof mathMLTree.MathNode) {
                  switch (node.type) {
                    case "mi":
                    case "mn":
                    case "ms":
                    case "mspace":
                    case "mtext":
                      break;
                    case "mo": {
                      var child = node.children[0];
                      if (node.children.length === 1 && child instanceof mathMLTree.TextNode) {
                        child.text = child.text.replace(/\u2212/, "-").replace(/\u2217/, "*");
                      } else {
                        isAllString = false;
                      }
                      break;
                    }
                    default:
                      isAllString = false;
                  }
                } else {
                  isAllString = false;
                }
              }
              if (isAllString) {
                var word = expression.map(function(node2) {
                  return node2.toText();
                }).join("");
                expression = [new mathMLTree.TextNode(word)];
              }
              var identifier = new mathMLTree.MathNode("mi", expression);
              identifier.setAttribute("mathvariant", "normal");
              var operator = new mathMLTree.MathNode("mo", [buildMathML_makeText("⁡", "text")]);
              if (group.parentIsSupSub) {
                return new mathMLTree.MathNode("mo", [identifier, operator]);
              } else {
                return mathMLTree.newDocumentFragment([identifier, operator]);
              }
            };
            defineFunction({
              type: "operatorname",
              names: ["\\operatorname", "\\operatorname*"],
              props: {
                numArgs: 1
              },
              handler: function handler(_ref, args) {
                var parser = _ref.parser, funcName = _ref.funcName;
                var body = args[0];
                return {
                  type: "operatorname",
                  mode: parser.mode,
                  body: ordargument(body),
                  alwaysHandleSupSub: funcName === "\\operatorname*",
                  limits: false,
                  parentIsSupSub: false
                };
              },
              htmlBuilder: operatorname_htmlBuilder,
              mathmlBuilder: operatorname_mathmlBuilder
            });
            defineFunctionBuilders({
              type: "ordgroup",
              htmlBuilder: function htmlBuilder(group, options) {
                if (group.semisimple) {
                  return buildCommon.makeFragment(buildHTML_buildExpression(group.body, options, false));
                }
                return buildCommon.makeSpan(["mord"], buildHTML_buildExpression(group.body, options, true), options);
              },
              mathmlBuilder: function mathmlBuilder(group, options) {
                return buildExpressionRow(group.body, options, true);
              }
            });
            defineFunction({
              type: "overline",
              names: ["\\overline"],
              props: {
                numArgs: 1
              },
              handler: function handler(_ref, args) {
                var parser = _ref.parser;
                var body = args[0];
                return {
                  type: "overline",
                  mode: parser.mode,
                  body
                };
              },
              htmlBuilder: function htmlBuilder(group, options) {
                var innerGroup = buildHTML_buildGroup(group.body, options.havingCrampedStyle());
                var line = buildCommon.makeLineSpan("overline-line", options);
                var defaultRuleThickness = options.fontMetrics().defaultRuleThickness;
                var vlist = buildCommon.makeVList({
                  positionType: "firstBaseline",
                  children: [{
                    type: "elem",
                    elem: innerGroup
                  }, {
                    type: "kern",
                    size: 3 * defaultRuleThickness
                  }, {
                    type: "elem",
                    elem: line
                  }, {
                    type: "kern",
                    size: defaultRuleThickness
                  }]
                }, options);
                return buildCommon.makeSpan(["mord", "overline"], [vlist], options);
              },
              mathmlBuilder: function mathmlBuilder(group, options) {
                var operator = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode("‾")]);
                operator.setAttribute("stretchy", "true");
                var node = new mathMLTree.MathNode("mover", [buildMathML_buildGroup(group.body, options), operator]);
                node.setAttribute("accent", "true");
                return node;
              }
            });
            defineFunction({
              type: "phantom",
              names: ["\\phantom"],
              props: {
                numArgs: 1,
                allowedInText: true
              },
              handler: function handler(_ref, args) {
                var parser = _ref.parser;
                var body = args[0];
                return {
                  type: "phantom",
                  mode: parser.mode,
                  body: ordargument(body)
                };
              },
              htmlBuilder: function htmlBuilder(group, options) {
                var elements = buildHTML_buildExpression(group.body, options.withPhantom(), false);
                return buildCommon.makeFragment(elements);
              },
              mathmlBuilder: function mathmlBuilder(group, options) {
                var inner = buildMathML_buildExpression(group.body, options);
                return new mathMLTree.MathNode("mphantom", inner);
              }
            });
            defineFunction({
              type: "hphantom",
              names: ["\\hphantom"],
              props: {
                numArgs: 1,
                allowedInText: true
              },
              handler: function handler(_ref2, args) {
                var parser = _ref2.parser;
                var body = args[0];
                return {
                  type: "hphantom",
                  mode: parser.mode,
                  body
                };
              },
              htmlBuilder: function htmlBuilder(group, options) {
                var node = buildCommon.makeSpan([], [buildHTML_buildGroup(group.body, options.withPhantom())]);
                node.height = 0;
                node.depth = 0;
                if (node.children) {
                  for (var i = 0; i < node.children.length; i++) {
                    node.children[i].height = 0;
                    node.children[i].depth = 0;
                  }
                }
                node = buildCommon.makeVList({
                  positionType: "firstBaseline",
                  children: [{
                    type: "elem",
                    elem: node
                  }]
                }, options);
                return buildCommon.makeSpan(["mord"], [node], options);
              },
              mathmlBuilder: function mathmlBuilder(group, options) {
                var inner = buildMathML_buildExpression(ordargument(group.body), options);
                var phantom = new mathMLTree.MathNode("mphantom", inner);
                var node = new mathMLTree.MathNode("mpadded", [phantom]);
                node.setAttribute("height", "0px");
                node.setAttribute("depth", "0px");
                return node;
              }
            });
            defineFunction({
              type: "vphantom",
              names: ["\\vphantom"],
              props: {
                numArgs: 1,
                allowedInText: true
              },
              handler: function handler(_ref3, args) {
                var parser = _ref3.parser;
                var body = args[0];
                return {
                  type: "vphantom",
                  mode: parser.mode,
                  body
                };
              },
              htmlBuilder: function htmlBuilder(group, options) {
                var inner = buildCommon.makeSpan(["inner"], [buildHTML_buildGroup(group.body, options.withPhantom())]);
                var fix = buildCommon.makeSpan(["fix"], []);
                return buildCommon.makeSpan(["mord", "rlap"], [inner, fix], options);
              },
              mathmlBuilder: function mathmlBuilder(group, options) {
                var inner = buildMathML_buildExpression(ordargument(group.body), options);
                var phantom = new mathMLTree.MathNode("mphantom", inner);
                var node = new mathMLTree.MathNode("mpadded", [phantom]);
                node.setAttribute("width", "0px");
                return node;
              }
            });
            defineFunction({
              type: "raisebox",
              names: ["\\raisebox"],
              props: {
                numArgs: 2,
                argTypes: ["size", "hbox"],
                allowedInText: true
              },
              handler: function handler(_ref, args) {
                var parser = _ref.parser;
                var amount = assertNodeType(args[0], "size").value;
                var body = args[1];
                return {
                  type: "raisebox",
                  mode: parser.mode,
                  dy: amount,
                  body
                };
              },
              htmlBuilder: function htmlBuilder(group, options) {
                var body = buildHTML_buildGroup(group.body, options);
                var dy = units_calculateSize(group.dy, options);
                return buildCommon.makeVList({
                  positionType: "shift",
                  positionData: -dy,
                  children: [{
                    type: "elem",
                    elem: body
                  }]
                }, options);
              },
              mathmlBuilder: function mathmlBuilder(group, options) {
                var node = new mathMLTree.MathNode("mpadded", [buildMathML_buildGroup(group.body, options)]);
                var dy = group.dy.number + group.dy.unit;
                node.setAttribute("voffset", dy);
                return node;
              }
            });
            defineFunction({
              type: "rule",
              names: ["\\rule"],
              props: {
                numArgs: 2,
                numOptionalArgs: 1,
                argTypes: ["size", "size", "size"]
              },
              handler: function handler(_ref, args, optArgs) {
                var parser = _ref.parser;
                var shift = optArgs[0];
                var width = assertNodeType(args[0], "size");
                var height = assertNodeType(args[1], "size");
                return {
                  type: "rule",
                  mode: parser.mode,
                  shift: shift && assertNodeType(shift, "size").value,
                  width: width.value,
                  height: height.value
                };
              },
              htmlBuilder: function htmlBuilder(group, options) {
                var rule = buildCommon.makeSpan(["mord", "rule"], [], options);
                var width = units_calculateSize(group.width, options);
                var height = units_calculateSize(group.height, options);
                var shift = group.shift ? units_calculateSize(group.shift, options) : 0;
                rule.style.borderRightWidth = width + "em";
                rule.style.borderTopWidth = height + "em";
                rule.style.bottom = shift + "em";
                rule.width = width;
                rule.height = height + shift;
                rule.depth = -shift;
                rule.maxFontSize = height * 1.125 * options.sizeMultiplier;
                return rule;
              },
              mathmlBuilder: function mathmlBuilder(group, options) {
                var width = units_calculateSize(group.width, options);
                var height = units_calculateSize(group.height, options);
                var shift = group.shift ? units_calculateSize(group.shift, options) : 0;
                var color = options.color && options.getColor() || "black";
                var rule = new mathMLTree.MathNode("mspace");
                rule.setAttribute("mathbackground", color);
                rule.setAttribute("width", width + "em");
                rule.setAttribute("height", height + "em");
                var wrapper = new mathMLTree.MathNode("mpadded", [rule]);
                if (shift >= 0) {
                  wrapper.setAttribute("height", "+" + shift + "em");
                } else {
                  wrapper.setAttribute("height", shift + "em");
                  wrapper.setAttribute("depth", "+" + -shift + "em");
                }
                wrapper.setAttribute("voffset", shift + "em");
                return wrapper;
              }
            });
            function sizingGroup(value, options, baseOptions) {
              var inner = buildHTML_buildExpression(value, options, false);
              var multiplier = options.sizeMultiplier / baseOptions.sizeMultiplier;
              for (var i = 0; i < inner.length; i++) {
                var pos = inner[i].classes.indexOf("sizing");
                if (pos < 0) {
                  Array.prototype.push.apply(inner[i].classes, options.sizingClasses(baseOptions));
                } else if (inner[i].classes[pos + 1] === "reset-size" + options.size) {
                  inner[i].classes[pos + 1] = "reset-size" + baseOptions.size;
                }
                inner[i].height *= multiplier;
                inner[i].depth *= multiplier;
              }
              return buildCommon.makeFragment(inner);
            }
            var sizeFuncs = ["\\tiny", "\\sixptsize", "\\scriptsize", "\\footnotesize", "\\small", "\\normalsize", "\\large", "\\Large", "\\LARGE", "\\huge", "\\Huge"];
            var sizing_htmlBuilder = function htmlBuilder(group, options) {
              var newOptions = options.havingSize(group.size);
              return sizingGroup(group.body, newOptions, options);
            };
            defineFunction({
              type: "sizing",
              names: sizeFuncs,
              props: {
                numArgs: 0,
                allowedInText: true
              },
              handler: function handler(_ref, args) {
                var breakOnTokenText = _ref.breakOnTokenText, funcName = _ref.funcName, parser = _ref.parser;
                var body = parser.parseExpression(false, breakOnTokenText);
                return {
                  type: "sizing",
                  mode: parser.mode,
                  // Figure out what size to use based on the list of functions above
                  size: sizeFuncs.indexOf(funcName) + 1,
                  body
                };
              },
              htmlBuilder: sizing_htmlBuilder,
              mathmlBuilder: function mathmlBuilder(group, options) {
                var newOptions = options.havingSize(group.size);
                var inner = buildMathML_buildExpression(group.body, newOptions);
                var node = new mathMLTree.MathNode("mstyle", inner);
                node.setAttribute("mathsize", newOptions.sizeMultiplier + "em");
                return node;
              }
            });
            defineFunction({
              type: "smash",
              names: ["\\smash"],
              props: {
                numArgs: 1,
                numOptionalArgs: 1,
                allowedInText: true
              },
              handler: function handler(_ref, args, optArgs) {
                var parser = _ref.parser;
                var smashHeight = false;
                var smashDepth = false;
                var tbArg = optArgs[0] && assertNodeType(optArgs[0], "ordgroup");
                if (tbArg) {
                  var letter = "";
                  for (var i = 0; i < tbArg.body.length; ++i) {
                    var node = tbArg.body[i];
                    letter = node.text;
                    if (letter === "t") {
                      smashHeight = true;
                    } else if (letter === "b") {
                      smashDepth = true;
                    } else {
                      smashHeight = false;
                      smashDepth = false;
                      break;
                    }
                  }
                } else {
                  smashHeight = true;
                  smashDepth = true;
                }
                var body = args[0];
                return {
                  type: "smash",
                  mode: parser.mode,
                  body,
                  smashHeight,
                  smashDepth
                };
              },
              htmlBuilder: function htmlBuilder(group, options) {
                var node = buildCommon.makeSpan([], [buildHTML_buildGroup(group.body, options)]);
                if (!group.smashHeight && !group.smashDepth) {
                  return node;
                }
                if (group.smashHeight) {
                  node.height = 0;
                  if (node.children) {
                    for (var i = 0; i < node.children.length; i++) {
                      node.children[i].height = 0;
                    }
                  }
                }
                if (group.smashDepth) {
                  node.depth = 0;
                  if (node.children) {
                    for (var _i = 0; _i < node.children.length; _i++) {
                      node.children[_i].depth = 0;
                    }
                  }
                }
                var smashedNode = buildCommon.makeVList({
                  positionType: "firstBaseline",
                  children: [{
                    type: "elem",
                    elem: node
                  }]
                }, options);
                return buildCommon.makeSpan(["mord"], [smashedNode], options);
              },
              mathmlBuilder: function mathmlBuilder(group, options) {
                var node = new mathMLTree.MathNode("mpadded", [buildMathML_buildGroup(group.body, options)]);
                if (group.smashHeight) {
                  node.setAttribute("height", "0px");
                }
                if (group.smashDepth) {
                  node.setAttribute("depth", "0px");
                }
                return node;
              }
            });
            defineFunction({
              type: "sqrt",
              names: ["\\sqrt"],
              props: {
                numArgs: 1,
                numOptionalArgs: 1
              },
              handler: function handler(_ref, args, optArgs) {
                var parser = _ref.parser;
                var index2 = optArgs[0];
                var body = args[0];
                return {
                  type: "sqrt",
                  mode: parser.mode,
                  body,
                  index: index2
                };
              },
              htmlBuilder: function htmlBuilder(group, options) {
                var inner = buildHTML_buildGroup(group.body, options.havingCrampedStyle());
                if (inner.height === 0) {
                  inner.height = options.fontMetrics().xHeight;
                }
                inner = buildCommon.wrapFragment(inner, options);
                var metrics = options.fontMetrics();
                var theta = metrics.defaultRuleThickness;
                var phi = theta;
                if (options.style.id < src_Style.TEXT.id) {
                  phi = options.fontMetrics().xHeight;
                }
                var lineClearance = theta + phi / 4;
                var minDelimiterHeight = inner.height + inner.depth + lineClearance + theta;
                var _delimiter$sqrtImage = delimiter2.sqrtImage(minDelimiterHeight, options), img = _delimiter$sqrtImage.span, ruleWidth = _delimiter$sqrtImage.ruleWidth, advanceWidth = _delimiter$sqrtImage.advanceWidth;
                var delimDepth = img.height - ruleWidth;
                if (delimDepth > inner.height + inner.depth + lineClearance) {
                  lineClearance = (lineClearance + delimDepth - inner.height - inner.depth) / 2;
                }
                var imgShift = img.height - inner.height - lineClearance - ruleWidth;
                inner.style.paddingLeft = advanceWidth + "em";
                var body = buildCommon.makeVList({
                  positionType: "firstBaseline",
                  children: [{
                    type: "elem",
                    elem: inner,
                    wrapperClasses: ["svg-align"]
                  }, {
                    type: "kern",
                    size: -(inner.height + imgShift)
                  }, {
                    type: "elem",
                    elem: img
                  }, {
                    type: "kern",
                    size: ruleWidth
                  }]
                }, options);
                if (!group.index) {
                  return buildCommon.makeSpan(["mord", "sqrt"], [body], options);
                } else {
                  var newOptions = options.havingStyle(src_Style.SCRIPTSCRIPT);
                  var rootm = buildHTML_buildGroup(group.index, newOptions, options);
                  var toShift = 0.6 * (body.height - body.depth);
                  var rootVList = buildCommon.makeVList({
                    positionType: "shift",
                    positionData: -toShift,
                    children: [{
                      type: "elem",
                      elem: rootm
                    }]
                  }, options);
                  var rootVListWrap = buildCommon.makeSpan(["root"], [rootVList]);
                  return buildCommon.makeSpan(["mord", "sqrt"], [rootVListWrap, body], options);
                }
              },
              mathmlBuilder: function mathmlBuilder(group, options) {
                var body = group.body, index2 = group.index;
                return index2 ? new mathMLTree.MathNode("mroot", [buildMathML_buildGroup(body, options), buildMathML_buildGroup(index2, options)]) : new mathMLTree.MathNode("msqrt", [buildMathML_buildGroup(body, options)]);
              }
            });
            var styling_styleMap = {
              "display": src_Style.DISPLAY,
              "text": src_Style.TEXT,
              "script": src_Style.SCRIPT,
              "scriptscript": src_Style.SCRIPTSCRIPT
            };
            defineFunction({
              type: "styling",
              names: ["\\displaystyle", "\\textstyle", "\\scriptstyle", "\\scriptscriptstyle"],
              props: {
                numArgs: 0,
                allowedInText: true
              },
              handler: function handler(_ref, args) {
                var breakOnTokenText = _ref.breakOnTokenText, funcName = _ref.funcName, parser = _ref.parser;
                var body = parser.parseExpression(true, breakOnTokenText);
                var style = funcName.slice(1, funcName.length - 5);
                return {
                  type: "styling",
                  mode: parser.mode,
                  // Figure out what style to use by pulling out the style from
                  // the function name
                  style,
                  body
                };
              },
              htmlBuilder: function htmlBuilder(group, options) {
                var newStyle = styling_styleMap[group.style];
                var newOptions = options.havingStyle(newStyle).withFont("");
                return sizingGroup(group.body, newOptions, options);
              },
              mathmlBuilder: function mathmlBuilder(group, options) {
                var newStyle = styling_styleMap[group.style];
                var newOptions = options.havingStyle(newStyle);
                var inner = buildMathML_buildExpression(group.body, newOptions);
                var node = new mathMLTree.MathNode("mstyle", inner);
                var styleAttributes = {
                  "display": ["0", "true"],
                  "text": ["0", "false"],
                  "script": ["1", "false"],
                  "scriptscript": ["2", "false"]
                };
                var attr2 = styleAttributes[group.style];
                node.setAttribute("scriptlevel", attr2[0]);
                node.setAttribute("displaystyle", attr2[1]);
                return node;
              }
            });
            var supsub_htmlBuilderDelegate = function htmlBuilderDelegate(group, options) {
              var base2 = group.base;
              if (!base2) {
                return null;
              } else if (base2.type === "op") {
                var delegate = base2.limits && (options.style.size === src_Style.DISPLAY.size || base2.alwaysHandleSupSub);
                return delegate ? op_htmlBuilder : null;
              } else if (base2.type === "operatorname") {
                var _delegate = base2.alwaysHandleSupSub && (options.style.size === src_Style.DISPLAY.size || base2.limits);
                return _delegate ? operatorname_htmlBuilder : null;
              } else if (base2.type === "accent") {
                return utils.isCharacterBox(base2.base) ? accent_htmlBuilder : null;
              } else if (base2.type === "horizBrace") {
                var isSup = !group.sub;
                return isSup === base2.isOver ? horizBrace_htmlBuilder : null;
              } else {
                return null;
              }
            };
            defineFunctionBuilders({
              type: "supsub",
              htmlBuilder: function htmlBuilder(group, options) {
                var builderDelegate = supsub_htmlBuilderDelegate(group, options);
                if (builderDelegate) {
                  return builderDelegate(group, options);
                }
                var valueBase = group.base, valueSup = group.sup, valueSub = group.sub;
                var base2 = buildHTML_buildGroup(valueBase, options);
                var supm;
                var subm;
                var metrics = options.fontMetrics();
                var supShift = 0;
                var subShift = 0;
                var isCharacterBox = valueBase && utils.isCharacterBox(valueBase);
                if (valueSup) {
                  var newOptions = options.havingStyle(options.style.sup());
                  supm = buildHTML_buildGroup(valueSup, newOptions, options);
                  if (!isCharacterBox) {
                    supShift = base2.height - newOptions.fontMetrics().supDrop * newOptions.sizeMultiplier / options.sizeMultiplier;
                  }
                }
                if (valueSub) {
                  var _newOptions = options.havingStyle(options.style.sub());
                  subm = buildHTML_buildGroup(valueSub, _newOptions, options);
                  if (!isCharacterBox) {
                    subShift = base2.depth + _newOptions.fontMetrics().subDrop * _newOptions.sizeMultiplier / options.sizeMultiplier;
                  }
                }
                var minSupShift;
                if (options.style === src_Style.DISPLAY) {
                  minSupShift = metrics.sup1;
                } else if (options.style.cramped) {
                  minSupShift = metrics.sup3;
                } else {
                  minSupShift = metrics.sup2;
                }
                var multiplier = options.sizeMultiplier;
                var marginRight = 0.5 / metrics.ptPerEm / multiplier + "em";
                var marginLeft = null;
                if (subm) {
                  var isOiint = group.base && group.base.type === "op" && group.base.name && (group.base.name === "\\oiint" || group.base.name === "\\oiiint");
                  if (base2 instanceof domTree_SymbolNode || isOiint) {
                    marginLeft = -base2.italic + "em";
                  }
                }
                var supsub;
                if (supm && subm) {
                  supShift = Math.max(supShift, minSupShift, supm.depth + 0.25 * metrics.xHeight);
                  subShift = Math.max(subShift, metrics.sub2);
                  var ruleWidth = metrics.defaultRuleThickness;
                  var maxWidth = 4 * ruleWidth;
                  if (supShift - supm.depth - (subm.height - subShift) < maxWidth) {
                    subShift = maxWidth - (supShift - supm.depth) + subm.height;
                    var psi = 0.8 * metrics.xHeight - (supShift - supm.depth);
                    if (psi > 0) {
                      supShift += psi;
                      subShift -= psi;
                    }
                  }
                  var vlistElem = [{
                    type: "elem",
                    elem: subm,
                    shift: subShift,
                    marginRight,
                    marginLeft
                  }, {
                    type: "elem",
                    elem: supm,
                    shift: -supShift,
                    marginRight
                  }];
                  supsub = buildCommon.makeVList({
                    positionType: "individualShift",
                    children: vlistElem
                  }, options);
                } else if (subm) {
                  subShift = Math.max(subShift, metrics.sub1, subm.height - 0.8 * metrics.xHeight);
                  var _vlistElem = [{
                    type: "elem",
                    elem: subm,
                    marginLeft,
                    marginRight
                  }];
                  supsub = buildCommon.makeVList({
                    positionType: "shift",
                    positionData: subShift,
                    children: _vlistElem
                  }, options);
                } else if (supm) {
                  supShift = Math.max(supShift, minSupShift, supm.depth + 0.25 * metrics.xHeight);
                  supsub = buildCommon.makeVList({
                    positionType: "shift",
                    positionData: -supShift,
                    children: [{
                      type: "elem",
                      elem: supm,
                      marginRight
                    }]
                  }, options);
                } else {
                  throw new Error("supsub must have either sup or sub.");
                }
                var mclass = getTypeOfDomTree(base2, "right") || "mord";
                return buildCommon.makeSpan([mclass], [base2, buildCommon.makeSpan(["msupsub"], [supsub])], options);
              },
              mathmlBuilder: function mathmlBuilder(group, options) {
                var isBrace = false;
                var isOver;
                var isSup;
                if (group.base && group.base.type === "horizBrace") {
                  isSup = !!group.sup;
                  if (isSup === group.base.isOver) {
                    isBrace = true;
                    isOver = group.base.isOver;
                  }
                }
                if (group.base && (group.base.type === "op" || group.base.type === "operatorname")) {
                  group.base.parentIsSupSub = true;
                }
                var children2 = [buildMathML_buildGroup(group.base, options)];
                if (group.sub) {
                  children2.push(buildMathML_buildGroup(group.sub, options));
                }
                if (group.sup) {
                  children2.push(buildMathML_buildGroup(group.sup, options));
                }
                var nodeType;
                if (isBrace) {
                  nodeType = isOver ? "mover" : "munder";
                } else if (!group.sub) {
                  var base2 = group.base;
                  if (base2 && base2.type === "op" && base2.limits && (options.style === src_Style.DISPLAY || base2.alwaysHandleSupSub)) {
                    nodeType = "mover";
                  } else if (base2 && base2.type === "operatorname" && base2.alwaysHandleSupSub && (base2.limits || options.style === src_Style.DISPLAY)) {
                    nodeType = "mover";
                  } else {
                    nodeType = "msup";
                  }
                } else if (!group.sup) {
                  var _base = group.base;
                  if (_base && _base.type === "op" && _base.limits && (options.style === src_Style.DISPLAY || _base.alwaysHandleSupSub)) {
                    nodeType = "munder";
                  } else if (_base && _base.type === "operatorname" && _base.alwaysHandleSupSub && (_base.limits || options.style === src_Style.DISPLAY)) {
                    nodeType = "munder";
                  } else {
                    nodeType = "msub";
                  }
                } else {
                  var _base2 = group.base;
                  if (_base2 && _base2.type === "op" && _base2.limits && options.style === src_Style.DISPLAY) {
                    nodeType = "munderover";
                  } else if (_base2 && _base2.type === "operatorname" && _base2.alwaysHandleSupSub && (options.style === src_Style.DISPLAY || _base2.limits)) {
                    nodeType = "munderover";
                  } else {
                    nodeType = "msubsup";
                  }
                }
                var node = new mathMLTree.MathNode(nodeType, children2);
                return node;
              }
            });
            defineFunctionBuilders({
              type: "atom",
              htmlBuilder: function htmlBuilder(group, options) {
                return buildCommon.mathsym(group.text, group.mode, options, ["m" + group.family]);
              },
              mathmlBuilder: function mathmlBuilder(group, options) {
                var node = new mathMLTree.MathNode("mo", [buildMathML_makeText(group.text, group.mode)]);
                if (group.family === "bin") {
                  var variant = buildMathML_getVariant(group, options);
                  if (variant === "bold-italic") {
                    node.setAttribute("mathvariant", variant);
                  }
                } else if (group.family === "punct") {
                  node.setAttribute("separator", "true");
                } else if (group.family === "open" || group.family === "close") {
                  node.setAttribute("stretchy", "false");
                }
                return node;
              }
            });
            var defaultVariant = {
              "mi": "italic",
              "mn": "normal",
              "mtext": "normal"
            };
            defineFunctionBuilders({
              type: "mathord",
              htmlBuilder: function htmlBuilder(group, options) {
                return buildCommon.makeOrd(group, options, "mathord");
              },
              mathmlBuilder: function mathmlBuilder(group, options) {
                var node = new mathMLTree.MathNode("mi", [buildMathML_makeText(group.text, group.mode, options)]);
                var variant = buildMathML_getVariant(group, options) || "italic";
                if (variant !== defaultVariant[node.type]) {
                  node.setAttribute("mathvariant", variant);
                }
                return node;
              }
            });
            defineFunctionBuilders({
              type: "textord",
              htmlBuilder: function htmlBuilder(group, options) {
                return buildCommon.makeOrd(group, options, "textord");
              },
              mathmlBuilder: function mathmlBuilder(group, options) {
                var text4 = buildMathML_makeText(group.text, group.mode, options);
                var variant = buildMathML_getVariant(group, options) || "normal";
                var node;
                if (group.mode === "text") {
                  node = new mathMLTree.MathNode("mtext", [text4]);
                } else if (/[0-9]/.test(group.text)) {
                  node = new mathMLTree.MathNode("mn", [text4]);
                } else if (group.text === "\\prime") {
                  node = new mathMLTree.MathNode("mo", [text4]);
                } else {
                  node = new mathMLTree.MathNode("mi", [text4]);
                }
                if (variant !== defaultVariant[node.type]) {
                  node.setAttribute("mathvariant", variant);
                }
                return node;
              }
            });
            var cssSpace = {
              "\\nobreak": "nobreak",
              "\\allowbreak": "allowbreak"
            };
            var regularSpace = {
              " ": {},
              "\\ ": {},
              "~": {
                className: "nobreak"
              },
              "\\space": {},
              "\\nobreakspace": {
                className: "nobreak"
              }
            };
            defineFunctionBuilders({
              type: "spacing",
              htmlBuilder: function htmlBuilder(group, options) {
                if (regularSpace.hasOwnProperty(group.text)) {
                  var className = regularSpace[group.text].className || "";
                  if (group.mode === "text") {
                    var ord = buildCommon.makeOrd(group, options, "textord");
                    ord.classes.push(className);
                    return ord;
                  } else {
                    return buildCommon.makeSpan(["mspace", className], [buildCommon.mathsym(group.text, group.mode, options)], options);
                  }
                } else if (cssSpace.hasOwnProperty(group.text)) {
                  return buildCommon.makeSpan(["mspace", cssSpace[group.text]], [], options);
                } else {
                  throw new src_ParseError('Unknown type of space "' + group.text + '"');
                }
              },
              mathmlBuilder: function mathmlBuilder(group, options) {
                var node;
                if (regularSpace.hasOwnProperty(group.text)) {
                  node = new mathMLTree.MathNode("mtext", [new mathMLTree.TextNode(" ")]);
                } else if (cssSpace.hasOwnProperty(group.text)) {
                  return new mathMLTree.MathNode("mspace");
                } else {
                  throw new src_ParseError('Unknown type of space "' + group.text + '"');
                }
                return node;
              }
            });
            var tag_pad = function pad() {
              var padNode = new mathMLTree.MathNode("mtd", []);
              padNode.setAttribute("width", "50%");
              return padNode;
            };
            defineFunctionBuilders({
              type: "tag",
              mathmlBuilder: function mathmlBuilder(group, options) {
                var table2 = new mathMLTree.MathNode("mtable", [new mathMLTree.MathNode("mtr", [tag_pad(), new mathMLTree.MathNode("mtd", [buildExpressionRow(group.body, options)]), tag_pad(), new mathMLTree.MathNode("mtd", [buildExpressionRow(group.tag, options)])])]);
                table2.setAttribute("width", "100%");
                return table2;
              }
            });
            var textFontFamilies = {
              "\\text": void 0,
              "\\textrm": "textrm",
              "\\textsf": "textsf",
              "\\texttt": "texttt",
              "\\textnormal": "textrm"
            };
            var textFontWeights = {
              "\\textbf": "textbf",
              "\\textmd": "textmd"
            };
            var textFontShapes = {
              "\\textit": "textit",
              "\\textup": "textup"
            };
            var optionsWithFont = function optionsWithFont2(group, options) {
              var font = group.font;
              if (!font) {
                return options;
              } else if (textFontFamilies[font]) {
                return options.withTextFontFamily(textFontFamilies[font]);
              } else if (textFontWeights[font]) {
                return options.withTextFontWeight(textFontWeights[font]);
              } else {
                return options.withTextFontShape(textFontShapes[font]);
              }
            };
            defineFunction({
              type: "text",
              names: [
                // Font families
                "\\text",
                "\\textrm",
                "\\textsf",
                "\\texttt",
                "\\textnormal",
                // Font weights
                "\\textbf",
                "\\textmd",
                // Font Shapes
                "\\textit",
                "\\textup"
              ],
              props: {
                numArgs: 1,
                argTypes: ["text"],
                greediness: 2,
                allowedInText: true
              },
              handler: function handler(_ref, args) {
                var parser = _ref.parser, funcName = _ref.funcName;
                var body = args[0];
                return {
                  type: "text",
                  mode: parser.mode,
                  body: ordargument(body),
                  font: funcName
                };
              },
              htmlBuilder: function htmlBuilder(group, options) {
                var newOptions = optionsWithFont(group, options);
                var inner = buildHTML_buildExpression(group.body, newOptions, true);
                return buildCommon.makeSpan(["mord", "text"], buildCommon.tryCombineChars(inner), newOptions);
              },
              mathmlBuilder: function mathmlBuilder(group, options) {
                var newOptions = optionsWithFont(group, options);
                return buildExpressionRow(group.body, newOptions);
              }
            });
            defineFunction({
              type: "underline",
              names: ["\\underline"],
              props: {
                numArgs: 1,
                allowedInText: true
              },
              handler: function handler(_ref, args) {
                var parser = _ref.parser;
                return {
                  type: "underline",
                  mode: parser.mode,
                  body: args[0]
                };
              },
              htmlBuilder: function htmlBuilder(group, options) {
                var innerGroup = buildHTML_buildGroup(group.body, options);
                var line = buildCommon.makeLineSpan("underline-line", options);
                var defaultRuleThickness = options.fontMetrics().defaultRuleThickness;
                var vlist = buildCommon.makeVList({
                  positionType: "top",
                  positionData: innerGroup.height,
                  children: [{
                    type: "kern",
                    size: defaultRuleThickness
                  }, {
                    type: "elem",
                    elem: line
                  }, {
                    type: "kern",
                    size: 3 * defaultRuleThickness
                  }, {
                    type: "elem",
                    elem: innerGroup
                  }]
                }, options);
                return buildCommon.makeSpan(["mord", "underline"], [vlist], options);
              },
              mathmlBuilder: function mathmlBuilder(group, options) {
                var operator = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode("‾")]);
                operator.setAttribute("stretchy", "true");
                var node = new mathMLTree.MathNode("munder", [buildMathML_buildGroup(group.body, options), operator]);
                node.setAttribute("accentunder", "true");
                return node;
              }
            });
            defineFunction({
              type: "verb",
              names: ["\\verb"],
              props: {
                numArgs: 0,
                allowedInText: true
              },
              handler: function handler(context, args, optArgs) {
                throw new src_ParseError("\\verb ended by end of line instead of matching delimiter");
              },
              htmlBuilder: function htmlBuilder(group, options) {
                var text4 = makeVerb(group);
                var body = [];
                var newOptions = options.havingStyle(options.style.text());
                for (var i = 0; i < text4.length; i++) {
                  var c = text4[i];
                  if (c === "~") {
                    c = "\\textasciitilde";
                  }
                  body.push(buildCommon.makeSymbol(c, "Typewriter-Regular", group.mode, newOptions, ["mord", "texttt"]));
                }
                return buildCommon.makeSpan(["mord", "text"].concat(newOptions.sizingClasses(options)), buildCommon.tryCombineChars(body), newOptions);
              },
              mathmlBuilder: function mathmlBuilder(group, options) {
                var text4 = new mathMLTree.TextNode(makeVerb(group));
                var node = new mathMLTree.MathNode("mtext", [text4]);
                node.setAttribute("mathvariant", "monospace");
                return node;
              }
            });
            var makeVerb = function makeVerb2(group) {
              return group.body.replace(/ /g, group.star ? "␣" : " ");
            };
            var functions = _functions;
            var src_functions = functions;
            var spaceRegexString = "[ \r\n	]";
            var controlWordRegexString = "\\\\[a-zA-Z@]+";
            var controlSymbolRegexString = "\\\\[^\uD800-\uDFFF]";
            var controlWordWhitespaceRegexString = "" + controlWordRegexString + spaceRegexString + "*";
            var controlWordWhitespaceRegex = new RegExp("^(" + controlWordRegexString + ")" + spaceRegexString + "*$");
            var combiningDiacriticalMarkString = "[̀-ͯ]";
            var combiningDiacriticalMarksEndRegex = new RegExp(combiningDiacriticalMarkString + "+$");
            var tokenRegexString = "(" + spaceRegexString + "+)|([!-\\[\\]-‧‪-퟿豈-￿]" + // single codepoint
            (combiningDiacriticalMarkString + "*") + // ...plus accents
            "|[\uD800-\uDBFF][\uDC00-\uDFFF]" + // surrogate pair
            (combiningDiacriticalMarkString + "*") + // ...plus accents
            "|\\\\verb\\*([^]).*?\\3|\\\\verb([^*a-zA-Z]).*?\\4|\\\\operatorname\\*" + // \operatorname*
            ("|" + controlWordWhitespaceRegexString) + // \macroName + spaces
            ("|" + controlSymbolRegexString + ")");
            var Lexer_Lexer = function() {
              function Lexer(input, settings) {
                this.input = void 0;
                this.settings = void 0;
                this.tokenRegex = void 0;
                this.catcodes = void 0;
                this.input = input;
                this.settings = settings;
                this.tokenRegex = new RegExp(tokenRegexString, "g");
                this.catcodes = {
                  "%": 14
                  // comment character
                };
              }
              var _proto = Lexer.prototype;
              _proto.setCatcode = function setCatcode(char, code2) {
                this.catcodes[char] = code2;
              };
              _proto.lex = function lex() {
                var input = this.input;
                var pos = this.tokenRegex.lastIndex;
                if (pos === input.length) {
                  return new Token_Token("EOF", new SourceLocation(this, pos, pos));
                }
                var match2 = this.tokenRegex.exec(input);
                if (match2 === null || match2.index !== pos) {
                  throw new src_ParseError("Unexpected character: '" + input[pos] + "'", new Token_Token(input[pos], new SourceLocation(this, pos, pos + 1)));
                }
                var text4 = match2[2] || " ";
                if (this.catcodes[text4] === 14) {
                  var nlIndex = input.indexOf("\n", this.tokenRegex.lastIndex);
                  if (nlIndex === -1) {
                    this.tokenRegex.lastIndex = input.length;
                    this.settings.reportNonstrict("commentAtEnd", "% comment has no terminating newline; LaTeX would fail because of commenting the end of math mode (e.g. $)");
                  } else {
                    this.tokenRegex.lastIndex = nlIndex + 1;
                  }
                  return this.lex();
                }
                var controlMatch = text4.match(controlWordWhitespaceRegex);
                if (controlMatch) {
                  text4 = controlMatch[1];
                }
                return new Token_Token(text4, new SourceLocation(this, pos, this.tokenRegex.lastIndex));
              };
              return Lexer;
            }();
            var Namespace_Namespace = function() {
              function Namespace(builtins, globalMacros) {
                if (builtins === void 0) {
                  builtins = {};
                }
                if (globalMacros === void 0) {
                  globalMacros = {};
                }
                this.current = void 0;
                this.builtins = void 0;
                this.undefStack = void 0;
                this.current = globalMacros;
                this.builtins = builtins;
                this.undefStack = [];
              }
              var _proto = Namespace.prototype;
              _proto.beginGroup = function beginGroup() {
                this.undefStack.push({});
              };
              _proto.endGroup = function endGroup() {
                if (this.undefStack.length === 0) {
                  throw new src_ParseError("Unbalanced namespace destruction: attempt to pop global namespace; please report this as a bug");
                }
                var undefs = this.undefStack.pop();
                for (var undef in undefs) {
                  if (undefs.hasOwnProperty(undef)) {
                    if (undefs[undef] === void 0) {
                      delete this.current[undef];
                    } else {
                      this.current[undef] = undefs[undef];
                    }
                  }
                }
              };
              _proto.has = function has3(name2) {
                return this.current.hasOwnProperty(name2) || this.builtins.hasOwnProperty(name2);
              };
              _proto.get = function get2(name2) {
                if (this.current.hasOwnProperty(name2)) {
                  return this.current[name2];
                } else {
                  return this.builtins[name2];
                }
              };
              _proto.set = function set3(name2, value, global) {
                if (global === void 0) {
                  global = false;
                }
                if (global) {
                  for (var i = 0; i < this.undefStack.length; i++) {
                    delete this.undefStack[i][name2];
                  }
                  if (this.undefStack.length > 0) {
                    this.undefStack[this.undefStack.length - 1][name2] = value;
                  }
                } else {
                  var top = this.undefStack[this.undefStack.length - 1];
                  if (top && !top.hasOwnProperty(name2)) {
                    top[name2] = this.current[name2];
                  }
                }
                this.current[name2] = value;
              };
              return Namespace;
            }();
            var builtinMacros = {};
            var macros = builtinMacros;
            function defineMacro(name2, body) {
              builtinMacros[name2] = body;
            }
            defineMacro("\\noexpand", function(context) {
              var t = context.popToken();
              if (context.isExpandable(t.text)) {
                t.noexpand = true;
                t.treatAsRelax = true;
              }
              return {
                tokens: [t],
                numArgs: 0
              };
            });
            defineMacro("\\expandafter", function(context) {
              var t = context.popToken();
              context.expandOnce(true);
              return {
                tokens: [t],
                numArgs: 0
              };
            });
            defineMacro("\\@firstoftwo", function(context) {
              var args = context.consumeArgs(2);
              return {
                tokens: args[0],
                numArgs: 0
              };
            });
            defineMacro("\\@secondoftwo", function(context) {
              var args = context.consumeArgs(2);
              return {
                tokens: args[1],
                numArgs: 0
              };
            });
            defineMacro("\\@ifnextchar", function(context) {
              var args = context.consumeArgs(3);
              context.consumeSpaces();
              var nextToken = context.future();
              if (args[0].length === 1 && args[0][0].text === nextToken.text) {
                return {
                  tokens: args[1],
                  numArgs: 0
                };
              } else {
                return {
                  tokens: args[2],
                  numArgs: 0
                };
              }
            });
            defineMacro("\\@ifstar", "\\@ifnextchar *{\\@firstoftwo{#1}}");
            defineMacro("\\TextOrMath", function(context) {
              var args = context.consumeArgs(2);
              if (context.mode === "text") {
                return {
                  tokens: args[0],
                  numArgs: 0
                };
              } else {
                return {
                  tokens: args[1],
                  numArgs: 0
                };
              }
            });
            var digitToNumber = {
              "0": 0,
              "1": 1,
              "2": 2,
              "3": 3,
              "4": 4,
              "5": 5,
              "6": 6,
              "7": 7,
              "8": 8,
              "9": 9,
              "a": 10,
              "A": 10,
              "b": 11,
              "B": 11,
              "c": 12,
              "C": 12,
              "d": 13,
              "D": 13,
              "e": 14,
              "E": 14,
              "f": 15,
              "F": 15
            };
            defineMacro("\\char", function(context) {
              var token = context.popToken();
              var base2;
              var number = "";
              if (token.text === "'") {
                base2 = 8;
                token = context.popToken();
              } else if (token.text === '"') {
                base2 = 16;
                token = context.popToken();
              } else if (token.text === "`") {
                token = context.popToken();
                if (token.text[0] === "\\") {
                  number = token.text.charCodeAt(1);
                } else if (token.text === "EOF") {
                  throw new src_ParseError("\\char` missing argument");
                } else {
                  number = token.text.charCodeAt(0);
                }
              } else {
                base2 = 10;
              }
              if (base2) {
                number = digitToNumber[token.text];
                if (number == null || number >= base2) {
                  throw new src_ParseError("Invalid base-" + base2 + " digit " + token.text);
                }
                var digit;
                while ((digit = digitToNumber[context.future().text]) != null && digit < base2) {
                  number *= base2;
                  number += digit;
                  context.popToken();
                }
              }
              return "\\@char{" + number + "}";
            });
            var macros_newcommand = function newcommand(context, existsOK, nonexistsOK) {
              var arg = context.consumeArgs(1)[0];
              if (arg.length !== 1) {
                throw new src_ParseError("\\newcommand's first argument must be a macro name");
              }
              var name2 = arg[0].text;
              var exists = context.isDefined(name2);
              if (exists && !existsOK) {
                throw new src_ParseError("\\newcommand{" + name2 + "} attempting to redefine " + (name2 + "; use \\renewcommand"));
              }
              if (!exists && !nonexistsOK) {
                throw new src_ParseError("\\renewcommand{" + name2 + "} when command " + name2 + " does not yet exist; use \\newcommand");
              }
              var numArgs = 0;
              arg = context.consumeArgs(1)[0];
              if (arg.length === 1 && arg[0].text === "[") {
                var argText = "";
                var token = context.expandNextToken();
                while (token.text !== "]" && token.text !== "EOF") {
                  argText += token.text;
                  token = context.expandNextToken();
                }
                if (!argText.match(/^\s*[0-9]+\s*$/)) {
                  throw new src_ParseError("Invalid number of arguments: " + argText);
                }
                numArgs = parseInt(argText);
                arg = context.consumeArgs(1)[0];
              }
              context.macros.set(name2, {
                tokens: arg,
                numArgs
              });
              return "";
            };
            defineMacro("\\newcommand", function(context) {
              return macros_newcommand(context, false, true);
            });
            defineMacro("\\renewcommand", function(context) {
              return macros_newcommand(context, true, false);
            });
            defineMacro("\\providecommand", function(context) {
              return macros_newcommand(context, true, true);
            });
            defineMacro("\\message", function(context) {
              var arg = context.consumeArgs(1)[0];
              console.log(arg.reverse().map(function(token) {
                return token.text;
              }).join(""));
              return "";
            });
            defineMacro("\\errmessage", function(context) {
              var arg = context.consumeArgs(1)[0];
              console.error(arg.reverse().map(function(token) {
                return token.text;
              }).join(""));
              return "";
            });
            defineMacro("\\show", function(context) {
              var tok = context.popToken();
              var name2 = tok.text;
              console.log(tok, context.macros.get(name2), src_functions[name2], src_symbols.math[name2], src_symbols.text[name2]);
              return "";
            });
            defineMacro("\\bgroup", "{");
            defineMacro("\\egroup", "}");
            defineMacro("\\lq", "`");
            defineMacro("\\rq", "'");
            defineMacro("\\aa", "\\r a");
            defineMacro("\\AA", "\\r A");
            defineMacro("\\textcopyright", "\\html@mathml{\\textcircled{c}}{\\char`©}");
            defineMacro("\\copyright", "\\TextOrMath{\\textcopyright}{\\text{\\textcopyright}}");
            defineMacro("\\textregistered", "\\html@mathml{\\textcircled{\\scriptsize R}}{\\char`®}");
            defineMacro("ℬ", "\\mathscr{B}");
            defineMacro("ℰ", "\\mathscr{E}");
            defineMacro("ℱ", "\\mathscr{F}");
            defineMacro("ℋ", "\\mathscr{H}");
            defineMacro("ℐ", "\\mathscr{I}");
            defineMacro("ℒ", "\\mathscr{L}");
            defineMacro("ℳ", "\\mathscr{M}");
            defineMacro("ℛ", "\\mathscr{R}");
            defineMacro("ℭ", "\\mathfrak{C}");
            defineMacro("ℌ", "\\mathfrak{H}");
            defineMacro("ℨ", "\\mathfrak{Z}");
            defineMacro("\\Bbbk", "\\Bbb{k}");
            defineMacro("·", "\\cdotp");
            defineMacro("\\llap", "\\mathllap{\\textrm{#1}}");
            defineMacro("\\rlap", "\\mathrlap{\\textrm{#1}}");
            defineMacro("\\clap", "\\mathclap{\\textrm{#1}}");
            defineMacro("\\not", '\\html@mathml{\\mathrel{\\mathrlap\\@not}}{\\char"338}');
            defineMacro("\\neq", "\\html@mathml{\\mathrel{\\not=}}{\\mathrel{\\char`≠}}");
            defineMacro("\\ne", "\\neq");
            defineMacro("≠", "\\neq");
            defineMacro("\\notin", "\\html@mathml{\\mathrel{{\\in}\\mathllap{/\\mskip1mu}}}{\\mathrel{\\char`∉}}");
            defineMacro("∉", "\\notin");
            defineMacro("≘", "\\html@mathml{\\mathrel{=\\kern{-1em}\\raisebox{0.4em}{$\\scriptsize\\frown$}}}{\\mathrel{\\char`≘}}");
            defineMacro("≙", "\\html@mathml{\\stackrel{\\tiny\\wedge}{=}}{\\mathrel{\\char`≘}}");
            defineMacro("≚", "\\html@mathml{\\stackrel{\\tiny\\vee}{=}}{\\mathrel{\\char`≚}}");
            defineMacro("≛", "\\html@mathml{\\stackrel{\\scriptsize\\star}{=}}{\\mathrel{\\char`≛}}");
            defineMacro("≝", "\\html@mathml{\\stackrel{\\tiny\\mathrm{def}}{=}}{\\mathrel{\\char`≝}}");
            defineMacro("≞", "\\html@mathml{\\stackrel{\\tiny\\mathrm{m}}{=}}{\\mathrel{\\char`≞}}");
            defineMacro("≟", "\\html@mathml{\\stackrel{\\tiny?}{=}}{\\mathrel{\\char`≟}}");
            defineMacro("⟂", "\\perp");
            defineMacro("‼", "\\mathclose{!\\mkern-0.8mu!}");
            defineMacro("∌", "\\notni");
            defineMacro("⌜", "\\ulcorner");
            defineMacro("⌝", "\\urcorner");
            defineMacro("⌞", "\\llcorner");
            defineMacro("⌟", "\\lrcorner");
            defineMacro("©", "\\copyright");
            defineMacro("®", "\\textregistered");
            defineMacro("️", "\\textregistered");
            defineMacro("\\ulcorner", '\\html@mathml{\\@ulcorner}{\\mathop{\\char"231c}}');
            defineMacro("\\urcorner", '\\html@mathml{\\@urcorner}{\\mathop{\\char"231d}}');
            defineMacro("\\llcorner", '\\html@mathml{\\@llcorner}{\\mathop{\\char"231e}}');
            defineMacro("\\lrcorner", '\\html@mathml{\\@lrcorner}{\\mathop{\\char"231f}}');
            defineMacro("\\vdots", "\\mathord{\\varvdots\\rule{0pt}{15pt}}");
            defineMacro("⋮", "\\vdots");
            defineMacro("\\varGamma", "\\mathit{\\Gamma}");
            defineMacro("\\varDelta", "\\mathit{\\Delta}");
            defineMacro("\\varTheta", "\\mathit{\\Theta}");
            defineMacro("\\varLambda", "\\mathit{\\Lambda}");
            defineMacro("\\varXi", "\\mathit{\\Xi}");
            defineMacro("\\varPi", "\\mathit{\\Pi}");
            defineMacro("\\varSigma", "\\mathit{\\Sigma}");
            defineMacro("\\varUpsilon", "\\mathit{\\Upsilon}");
            defineMacro("\\varPhi", "\\mathit{\\Phi}");
            defineMacro("\\varPsi", "\\mathit{\\Psi}");
            defineMacro("\\varOmega", "\\mathit{\\Omega}");
            defineMacro("\\substack", "\\begin{subarray}{c}#1\\end{subarray}");
            defineMacro("\\colon", "\\nobreak\\mskip2mu\\mathpunct{}\\mathchoice{\\mkern-3mu}{\\mkern-3mu}{}{}{:}\\mskip6mu");
            defineMacro("\\boxed", "\\fbox{$\\displaystyle{#1}$}");
            defineMacro("\\iff", "\\DOTSB\\;\\Longleftrightarrow\\;");
            defineMacro("\\implies", "\\DOTSB\\;\\Longrightarrow\\;");
            defineMacro("\\impliedby", "\\DOTSB\\;\\Longleftarrow\\;");
            var dotsByToken = {
              ",": "\\dotsc",
              "\\not": "\\dotsb",
              // \keybin@ checks for the following:
              "+": "\\dotsb",
              "=": "\\dotsb",
              "<": "\\dotsb",
              ">": "\\dotsb",
              "-": "\\dotsb",
              "*": "\\dotsb",
              ":": "\\dotsb",
              // Symbols whose definition starts with \DOTSB:
              "\\DOTSB": "\\dotsb",
              "\\coprod": "\\dotsb",
              "\\bigvee": "\\dotsb",
              "\\bigwedge": "\\dotsb",
              "\\biguplus": "\\dotsb",
              "\\bigcap": "\\dotsb",
              "\\bigcup": "\\dotsb",
              "\\prod": "\\dotsb",
              "\\sum": "\\dotsb",
              "\\bigotimes": "\\dotsb",
              "\\bigoplus": "\\dotsb",
              "\\bigodot": "\\dotsb",
              "\\bigsqcup": "\\dotsb",
              "\\And": "\\dotsb",
              "\\longrightarrow": "\\dotsb",
              "\\Longrightarrow": "\\dotsb",
              "\\longleftarrow": "\\dotsb",
              "\\Longleftarrow": "\\dotsb",
              "\\longleftrightarrow": "\\dotsb",
              "\\Longleftrightarrow": "\\dotsb",
              "\\mapsto": "\\dotsb",
              "\\longmapsto": "\\dotsb",
              "\\hookrightarrow": "\\dotsb",
              "\\doteq": "\\dotsb",
              // Symbols whose definition starts with \mathbin:
              "\\mathbin": "\\dotsb",
              // Symbols whose definition starts with \mathrel:
              "\\mathrel": "\\dotsb",
              "\\relbar": "\\dotsb",
              "\\Relbar": "\\dotsb",
              "\\xrightarrow": "\\dotsb",
              "\\xleftarrow": "\\dotsb",
              // Symbols whose definition starts with \DOTSI:
              "\\DOTSI": "\\dotsi",
              "\\int": "\\dotsi",
              "\\oint": "\\dotsi",
              "\\iint": "\\dotsi",
              "\\iiint": "\\dotsi",
              "\\iiiint": "\\dotsi",
              "\\idotsint": "\\dotsi",
              // Symbols whose definition starts with \DOTSX:
              "\\DOTSX": "\\dotsx"
            };
            defineMacro("\\dots", function(context) {
              var thedots = "\\dotso";
              var next2 = context.expandAfterFuture().text;
              if (next2 in dotsByToken) {
                thedots = dotsByToken[next2];
              } else if (next2.substr(0, 4) === "\\not") {
                thedots = "\\dotsb";
              } else if (next2 in src_symbols.math) {
                if (utils.contains(["bin", "rel"], src_symbols.math[next2].group)) {
                  thedots = "\\dotsb";
                }
              }
              return thedots;
            });
            var spaceAfterDots = {
              // \rightdelim@ checks for the following:
              ")": true,
              "]": true,
              "\\rbrack": true,
              "\\}": true,
              "\\rbrace": true,
              "\\rangle": true,
              "\\rceil": true,
              "\\rfloor": true,
              "\\rgroup": true,
              "\\rmoustache": true,
              "\\right": true,
              "\\bigr": true,
              "\\biggr": true,
              "\\Bigr": true,
              "\\Biggr": true,
              // \extra@ also tests for the following:
              "$": true,
              // \extrap@ checks for the following:
              ";": true,
              ".": true,
              ",": true
            };
            defineMacro("\\dotso", function(context) {
              var next2 = context.future().text;
              if (next2 in spaceAfterDots) {
                return "\\ldots\\,";
              } else {
                return "\\ldots";
              }
            });
            defineMacro("\\dotsc", function(context) {
              var next2 = context.future().text;
              if (next2 in spaceAfterDots && next2 !== ",") {
                return "\\ldots\\,";
              } else {
                return "\\ldots";
              }
            });
            defineMacro("\\cdots", function(context) {
              var next2 = context.future().text;
              if (next2 in spaceAfterDots) {
                return "\\@cdots\\,";
              } else {
                return "\\@cdots";
              }
            });
            defineMacro("\\dotsb", "\\cdots");
            defineMacro("\\dotsm", "\\cdots");
            defineMacro("\\dotsi", "\\!\\cdots");
            defineMacro("\\dotsx", "\\ldots\\,");
            defineMacro("\\DOTSI", "\\relax");
            defineMacro("\\DOTSB", "\\relax");
            defineMacro("\\DOTSX", "\\relax");
            defineMacro("\\tmspace", "\\TextOrMath{\\kern#1#3}{\\mskip#1#2}\\relax");
            defineMacro("\\,", "\\tmspace+{3mu}{.1667em}");
            defineMacro("\\thinspace", "\\,");
            defineMacro("\\>", "\\mskip{4mu}");
            defineMacro("\\:", "\\tmspace+{4mu}{.2222em}");
            defineMacro("\\medspace", "\\:");
            defineMacro("\\;", "\\tmspace+{5mu}{.2777em}");
            defineMacro("\\thickspace", "\\;");
            defineMacro("\\!", "\\tmspace-{3mu}{.1667em}");
            defineMacro("\\negthinspace", "\\!");
            defineMacro("\\negmedspace", "\\tmspace-{4mu}{.2222em}");
            defineMacro("\\negthickspace", "\\tmspace-{5mu}{.277em}");
            defineMacro("\\enspace", "\\kern.5em ");
            defineMacro("\\enskip", "\\hskip.5em\\relax");
            defineMacro("\\quad", "\\hskip1em\\relax");
            defineMacro("\\qquad", "\\hskip2em\\relax");
            defineMacro("\\tag", "\\@ifstar\\tag@literal\\tag@paren");
            defineMacro("\\tag@paren", "\\tag@literal{({#1})}");
            defineMacro("\\tag@literal", function(context) {
              if (context.macros.get("\\df@tag")) {
                throw new src_ParseError("Multiple \\tag");
              }
              return "\\gdef\\df@tag{\\text{#1}}";
            });
            defineMacro("\\bmod", "\\mathchoice{\\mskip1mu}{\\mskip1mu}{\\mskip5mu}{\\mskip5mu}\\mathbin{\\rm mod}\\mathchoice{\\mskip1mu}{\\mskip1mu}{\\mskip5mu}{\\mskip5mu}");
            defineMacro("\\pod", "\\allowbreak\\mathchoice{\\mkern18mu}{\\mkern8mu}{\\mkern8mu}{\\mkern8mu}(#1)");
            defineMacro("\\pmod", "\\pod{{\\rm mod}\\mkern6mu#1}");
            defineMacro("\\mod", "\\allowbreak\\mathchoice{\\mkern18mu}{\\mkern12mu}{\\mkern12mu}{\\mkern12mu}{\\rm mod}\\,\\,#1");
            defineMacro("\\pmb", "\\html@mathml{\\@binrel{#1}{\\mathrlap{#1}\\kern0.5px#1}}{\\mathbf{#1}}");
            defineMacro("\\\\", "\\newline");
            defineMacro("\\TeX", "\\textrm{\\html@mathml{T\\kern-.1667em\\raisebox{-.5ex}{E}\\kern-.125emX}{TeX}}");
            var latexRaiseA = fontMetricsData["Main-Regular"]["T".charCodeAt(0)][1] - 0.7 * fontMetricsData["Main-Regular"]["A".charCodeAt(0)][1] + "em";
            defineMacro("\\LaTeX", "\\textrm{\\html@mathml{" + ("L\\kern-.36em\\raisebox{" + latexRaiseA + "}{\\scriptstyle A}") + "\\kern-.15em\\TeX}{LaTeX}}");
            defineMacro("\\KaTeX", "\\textrm{\\html@mathml{" + ("K\\kern-.17em\\raisebox{" + latexRaiseA + "}{\\scriptstyle A}") + "\\kern-.15em\\TeX}{KaTeX}}");
            defineMacro("\\hspace", "\\@ifstar\\@hspacer\\@hspace");
            defineMacro("\\@hspace", "\\hskip #1\\relax");
            defineMacro("\\@hspacer", "\\rule{0pt}{0pt}\\hskip #1\\relax");
            defineMacro("\\ordinarycolon", ":");
            defineMacro("\\vcentcolon", "\\mathrel{\\mathop\\ordinarycolon}");
            defineMacro("\\dblcolon", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-.9mu}\\vcentcolon}}{\\mathop{\\char"2237}}');
            defineMacro("\\coloneqq", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}=}}{\\mathop{\\char"2254}}');
            defineMacro("\\Coloneqq", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}=}}{\\mathop{\\char"2237\\char"3d}}');
            defineMacro("\\coloneq", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\mathrel{-}}}{\\mathop{\\char"3a\\char"2212}}');
            defineMacro("\\Coloneq", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\mathrel{-}}}{\\mathop{\\char"2237\\char"2212}}');
            defineMacro("\\eqqcolon", '\\html@mathml{\\mathrel{=\\mathrel{\\mkern-1.2mu}\\vcentcolon}}{\\mathop{\\char"2255}}');
            defineMacro("\\Eqqcolon", '\\html@mathml{\\mathrel{=\\mathrel{\\mkern-1.2mu}\\dblcolon}}{\\mathop{\\char"3d\\char"2237}}');
            defineMacro("\\eqcolon", '\\html@mathml{\\mathrel{\\mathrel{-}\\mathrel{\\mkern-1.2mu}\\vcentcolon}}{\\mathop{\\char"2239}}');
            defineMacro("\\Eqcolon", '\\html@mathml{\\mathrel{\\mathrel{-}\\mathrel{\\mkern-1.2mu}\\dblcolon}}{\\mathop{\\char"2212\\char"2237}}');
            defineMacro("\\colonapprox", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\approx}}{\\mathop{\\char"3a\\char"2248}}');
            defineMacro("\\Colonapprox", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\approx}}{\\mathop{\\char"2237\\char"2248}}');
            defineMacro("\\colonsim", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\sim}}{\\mathop{\\char"3a\\char"223c}}');
            defineMacro("\\Colonsim", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\sim}}{\\mathop{\\char"2237\\char"223c}}');
            defineMacro("∷", "\\dblcolon");
            defineMacro("∹", "\\eqcolon");
            defineMacro("≔", "\\coloneqq");
            defineMacro("≕", "\\eqqcolon");
            defineMacro("⩴", "\\Coloneqq");
            defineMacro("\\ratio", "\\vcentcolon");
            defineMacro("\\coloncolon", "\\dblcolon");
            defineMacro("\\colonequals", "\\coloneqq");
            defineMacro("\\coloncolonequals", "\\Coloneqq");
            defineMacro("\\equalscolon", "\\eqqcolon");
            defineMacro("\\equalscoloncolon", "\\Eqqcolon");
            defineMacro("\\colonminus", "\\coloneq");
            defineMacro("\\coloncolonminus", "\\Coloneq");
            defineMacro("\\minuscolon", "\\eqcolon");
            defineMacro("\\minuscoloncolon", "\\Eqcolon");
            defineMacro("\\coloncolonapprox", "\\Colonapprox");
            defineMacro("\\coloncolonsim", "\\Colonsim");
            defineMacro("\\simcolon", "\\mathrel{\\sim\\mathrel{\\mkern-1.2mu}\\vcentcolon}");
            defineMacro("\\simcoloncolon", "\\mathrel{\\sim\\mathrel{\\mkern-1.2mu}\\dblcolon}");
            defineMacro("\\approxcolon", "\\mathrel{\\approx\\mathrel{\\mkern-1.2mu}\\vcentcolon}");
            defineMacro("\\approxcoloncolon", "\\mathrel{\\approx\\mathrel{\\mkern-1.2mu}\\dblcolon}");
            defineMacro("\\notni", "\\html@mathml{\\not\\ni}{\\mathrel{\\char`∌}}");
            defineMacro("\\limsup", "\\DOTSB\\operatorname*{lim\\,sup}");
            defineMacro("\\liminf", "\\DOTSB\\operatorname*{lim\\,inf}");
            defineMacro("\\gvertneqq", "\\html@mathml{\\@gvertneqq}{≩}");
            defineMacro("\\lvertneqq", "\\html@mathml{\\@lvertneqq}{≨}");
            defineMacro("\\ngeqq", "\\html@mathml{\\@ngeqq}{≱}");
            defineMacro("\\ngeqslant", "\\html@mathml{\\@ngeqslant}{≱}");
            defineMacro("\\nleqq", "\\html@mathml{\\@nleqq}{≰}");
            defineMacro("\\nleqslant", "\\html@mathml{\\@nleqslant}{≰}");
            defineMacro("\\nshortmid", "\\html@mathml{\\@nshortmid}{∤}");
            defineMacro("\\nshortparallel", "\\html@mathml{\\@nshortparallel}{∦}");
            defineMacro("\\nsubseteqq", "\\html@mathml{\\@nsubseteqq}{⊈}");
            defineMacro("\\nsupseteqq", "\\html@mathml{\\@nsupseteqq}{⊉}");
            defineMacro("\\varsubsetneq", "\\html@mathml{\\@varsubsetneq}{⊊}");
            defineMacro("\\varsubsetneqq", "\\html@mathml{\\@varsubsetneqq}{⫋}");
            defineMacro("\\varsupsetneq", "\\html@mathml{\\@varsupsetneq}{⊋}");
            defineMacro("\\varsupsetneqq", "\\html@mathml{\\@varsupsetneqq}{⫌}");
            defineMacro("\\imath", "\\html@mathml{\\@imath}{ı}");
            defineMacro("\\jmath", "\\html@mathml{\\@jmath}{ȷ}");
            defineMacro("\\llbracket", "\\html@mathml{\\mathopen{[\\mkern-3.2mu[}}{\\mathopen{\\char`⟦}}");
            defineMacro("\\rrbracket", "\\html@mathml{\\mathclose{]\\mkern-3.2mu]}}{\\mathclose{\\char`⟧}}");
            defineMacro("⟦", "\\llbracket");
            defineMacro("⟧", "\\rrbracket");
            defineMacro("\\lBrace", "\\html@mathml{\\mathopen{\\{\\mkern-3.2mu[}}{\\mathopen{\\char`⦃}}");
            defineMacro("\\rBrace", "\\html@mathml{\\mathclose{]\\mkern-3.2mu\\}}}{\\mathclose{\\char`⦄}}");
            defineMacro("⦃", "\\lBrace");
            defineMacro("⦄", "\\rBrace");
            defineMacro("\\minuso", "\\mathbin{\\html@mathml{{\\mathrlap{\\mathchoice{\\kern{0.145em}}{\\kern{0.145em}}{\\kern{0.1015em}}{\\kern{0.0725em}}\\circ}{-}}}{\\char`⦵}}");
            defineMacro("⦵", "\\minuso");
            defineMacro("\\darr", "\\downarrow");
            defineMacro("\\dArr", "\\Downarrow");
            defineMacro("\\Darr", "\\Downarrow");
            defineMacro("\\lang", "\\langle");
            defineMacro("\\rang", "\\rangle");
            defineMacro("\\uarr", "\\uparrow");
            defineMacro("\\uArr", "\\Uparrow");
            defineMacro("\\Uarr", "\\Uparrow");
            defineMacro("\\N", "\\mathbb{N}");
            defineMacro("\\R", "\\mathbb{R}");
            defineMacro("\\Z", "\\mathbb{Z}");
            defineMacro("\\alef", "\\aleph");
            defineMacro("\\alefsym", "\\aleph");
            defineMacro("\\Alpha", "\\mathrm{A}");
            defineMacro("\\Beta", "\\mathrm{B}");
            defineMacro("\\bull", "\\bullet");
            defineMacro("\\Chi", "\\mathrm{X}");
            defineMacro("\\clubs", "\\clubsuit");
            defineMacro("\\cnums", "\\mathbb{C}");
            defineMacro("\\Complex", "\\mathbb{C}");
            defineMacro("\\Dagger", "\\ddagger");
            defineMacro("\\diamonds", "\\diamondsuit");
            defineMacro("\\empty", "\\emptyset");
            defineMacro("\\Epsilon", "\\mathrm{E}");
            defineMacro("\\Eta", "\\mathrm{H}");
            defineMacro("\\exist", "\\exists");
            defineMacro("\\harr", "\\leftrightarrow");
            defineMacro("\\hArr", "\\Leftrightarrow");
            defineMacro("\\Harr", "\\Leftrightarrow");
            defineMacro("\\hearts", "\\heartsuit");
            defineMacro("\\image", "\\Im");
            defineMacro("\\infin", "\\infty");
            defineMacro("\\Iota", "\\mathrm{I}");
            defineMacro("\\isin", "\\in");
            defineMacro("\\Kappa", "\\mathrm{K}");
            defineMacro("\\larr", "\\leftarrow");
            defineMacro("\\lArr", "\\Leftarrow");
            defineMacro("\\Larr", "\\Leftarrow");
            defineMacro("\\lrarr", "\\leftrightarrow");
            defineMacro("\\lrArr", "\\Leftrightarrow");
            defineMacro("\\Lrarr", "\\Leftrightarrow");
            defineMacro("\\Mu", "\\mathrm{M}");
            defineMacro("\\natnums", "\\mathbb{N}");
            defineMacro("\\Nu", "\\mathrm{N}");
            defineMacro("\\Omicron", "\\mathrm{O}");
            defineMacro("\\plusmn", "\\pm");
            defineMacro("\\rarr", "\\rightarrow");
            defineMacro("\\rArr", "\\Rightarrow");
            defineMacro("\\Rarr", "\\Rightarrow");
            defineMacro("\\real", "\\Re");
            defineMacro("\\reals", "\\mathbb{R}");
            defineMacro("\\Reals", "\\mathbb{R}");
            defineMacro("\\Rho", "\\mathrm{P}");
            defineMacro("\\sdot", "\\cdot");
            defineMacro("\\sect", "\\S");
            defineMacro("\\spades", "\\spadesuit");
            defineMacro("\\sub", "\\subset");
            defineMacro("\\sube", "\\subseteq");
            defineMacro("\\supe", "\\supseteq");
            defineMacro("\\Tau", "\\mathrm{T}");
            defineMacro("\\thetasym", "\\vartheta");
            defineMacro("\\weierp", "\\wp");
            defineMacro("\\Zeta", "\\mathrm{Z}");
            defineMacro("\\argmin", "\\DOTSB\\operatorname*{arg\\,min}");
            defineMacro("\\argmax", "\\DOTSB\\operatorname*{arg\\,max}");
            defineMacro("\\plim", "\\DOTSB\\mathop{\\operatorname{plim}}\\limits");
            defineMacro("\\bra", "\\mathinner{\\langle{#1}|}");
            defineMacro("\\ket", "\\mathinner{|{#1}\\rangle}");
            defineMacro("\\braket", "\\mathinner{\\langle{#1}\\rangle}");
            defineMacro("\\Bra", "\\left\\langle#1\\right|");
            defineMacro("\\Ket", "\\left|#1\\right\\rangle");
            defineMacro("\\blue", "\\textcolor{##6495ed}{#1}");
            defineMacro("\\orange", "\\textcolor{##ffa500}{#1}");
            defineMacro("\\pink", "\\textcolor{##ff00af}{#1}");
            defineMacro("\\red", "\\textcolor{##df0030}{#1}");
            defineMacro("\\green", "\\textcolor{##28ae7b}{#1}");
            defineMacro("\\gray", "\\textcolor{gray}{#1}");
            defineMacro("\\purple", "\\textcolor{##9d38bd}{#1}");
            defineMacro("\\blueA", "\\textcolor{##ccfaff}{#1}");
            defineMacro("\\blueB", "\\textcolor{##80f6ff}{#1}");
            defineMacro("\\blueC", "\\textcolor{##63d9ea}{#1}");
            defineMacro("\\blueD", "\\textcolor{##11accd}{#1}");
            defineMacro("\\blueE", "\\textcolor{##0c7f99}{#1}");
            defineMacro("\\tealA", "\\textcolor{##94fff5}{#1}");
            defineMacro("\\tealB", "\\textcolor{##26edd5}{#1}");
            defineMacro("\\tealC", "\\textcolor{##01d1c1}{#1}");
            defineMacro("\\tealD", "\\textcolor{##01a995}{#1}");
            defineMacro("\\tealE", "\\textcolor{##208170}{#1}");
            defineMacro("\\greenA", "\\textcolor{##b6ffb0}{#1}");
            defineMacro("\\greenB", "\\textcolor{##8af281}{#1}");
            defineMacro("\\greenC", "\\textcolor{##74cf70}{#1}");
            defineMacro("\\greenD", "\\textcolor{##1fab54}{#1}");
            defineMacro("\\greenE", "\\textcolor{##0d923f}{#1}");
            defineMacro("\\goldA", "\\textcolor{##ffd0a9}{#1}");
            defineMacro("\\goldB", "\\textcolor{##ffbb71}{#1}");
            defineMacro("\\goldC", "\\textcolor{##ff9c39}{#1}");
            defineMacro("\\goldD", "\\textcolor{##e07d10}{#1}");
            defineMacro("\\goldE", "\\textcolor{##a75a05}{#1}");
            defineMacro("\\redA", "\\textcolor{##fca9a9}{#1}");
            defineMacro("\\redB", "\\textcolor{##ff8482}{#1}");
            defineMacro("\\redC", "\\textcolor{##f9685d}{#1}");
            defineMacro("\\redD", "\\textcolor{##e84d39}{#1}");
            defineMacro("\\redE", "\\textcolor{##bc2612}{#1}");
            defineMacro("\\maroonA", "\\textcolor{##ffbde0}{#1}");
            defineMacro("\\maroonB", "\\textcolor{##ff92c6}{#1}");
            defineMacro("\\maroonC", "\\textcolor{##ed5fa6}{#1}");
            defineMacro("\\maroonD", "\\textcolor{##ca337c}{#1}");
            defineMacro("\\maroonE", "\\textcolor{##9e034e}{#1}");
            defineMacro("\\purpleA", "\\textcolor{##ddd7ff}{#1}");
            defineMacro("\\purpleB", "\\textcolor{##c6b9fc}{#1}");
            defineMacro("\\purpleC", "\\textcolor{##aa87ff}{#1}");
            defineMacro("\\purpleD", "\\textcolor{##7854ab}{#1}");
            defineMacro("\\purpleE", "\\textcolor{##543b78}{#1}");
            defineMacro("\\mintA", "\\textcolor{##f5f9e8}{#1}");
            defineMacro("\\mintB", "\\textcolor{##edf2df}{#1}");
            defineMacro("\\mintC", "\\textcolor{##e0e5cc}{#1}");
            defineMacro("\\grayA", "\\textcolor{##f6f7f7}{#1}");
            defineMacro("\\grayB", "\\textcolor{##f0f1f2}{#1}");
            defineMacro("\\grayC", "\\textcolor{##e3e5e6}{#1}");
            defineMacro("\\grayD", "\\textcolor{##d6d8da}{#1}");
            defineMacro("\\grayE", "\\textcolor{##babec2}{#1}");
            defineMacro("\\grayF", "\\textcolor{##888d93}{#1}");
            defineMacro("\\grayG", "\\textcolor{##626569}{#1}");
            defineMacro("\\grayH", "\\textcolor{##3b3e40}{#1}");
            defineMacro("\\grayI", "\\textcolor{##21242c}{#1}");
            defineMacro("\\kaBlue", "\\textcolor{##314453}{#1}");
            defineMacro("\\kaGreen", "\\textcolor{##71B307}{#1}");
            var implicitCommands = {
              "\\relax": true,
              // MacroExpander.js
              "^": true,
              // Parser.js
              "_": true,
              // Parser.js
              "\\limits": true,
              // Parser.js
              "\\nolimits": true
              // Parser.js
            };
            var MacroExpander_MacroExpander = function() {
              function MacroExpander(input, settings, mode) {
                this.settings = void 0;
                this.expansionCount = void 0;
                this.lexer = void 0;
                this.macros = void 0;
                this.stack = void 0;
                this.mode = void 0;
                this.settings = settings;
                this.expansionCount = 0;
                this.feed(input);
                this.macros = new Namespace_Namespace(macros, settings.macros);
                this.mode = mode;
                this.stack = [];
              }
              var _proto = MacroExpander.prototype;
              _proto.feed = function feed(input) {
                this.lexer = new Lexer_Lexer(input, this.settings);
              };
              _proto.switchMode = function switchMode(newMode) {
                this.mode = newMode;
              };
              _proto.beginGroup = function beginGroup() {
                this.macros.beginGroup();
              };
              _proto.endGroup = function endGroup() {
                this.macros.endGroup();
              };
              _proto.future = function future() {
                if (this.stack.length === 0) {
                  this.pushToken(this.lexer.lex());
                }
                return this.stack[this.stack.length - 1];
              };
              _proto.popToken = function popToken() {
                this.future();
                return this.stack.pop();
              };
              _proto.pushToken = function pushToken(token) {
                this.stack.push(token);
              };
              _proto.pushTokens = function pushTokens(tokens) {
                var _this$stack;
                (_this$stack = this.stack).push.apply(_this$stack, tokens);
              };
              _proto.consumeSpaces = function consumeSpaces() {
                for (; ; ) {
                  var token = this.future();
                  if (token.text === " ") {
                    this.stack.pop();
                  } else {
                    break;
                  }
                }
              };
              _proto.consumeArgs = function consumeArgs(numArgs) {
                var args = [];
                for (var i = 0; i < numArgs; ++i) {
                  this.consumeSpaces();
                  var startOfArg = this.popToken();
                  if (startOfArg.text === "{") {
                    var arg = [];
                    var depth = 1;
                    while (depth !== 0) {
                      var tok = this.popToken();
                      arg.push(tok);
                      if (tok.text === "{") {
                        ++depth;
                      } else if (tok.text === "}") {
                        --depth;
                      } else if (tok.text === "EOF") {
                        throw new src_ParseError("End of input in macro argument", startOfArg);
                      }
                    }
                    arg.pop();
                    arg.reverse();
                    args[i] = arg;
                  } else if (startOfArg.text === "EOF") {
                    throw new src_ParseError("End of input expecting macro argument");
                  } else {
                    args[i] = [startOfArg];
                  }
                }
                return args;
              };
              _proto.expandOnce = function expandOnce(expandableOnly) {
                var topToken = this.popToken();
                var name2 = topToken.text;
                var expansion = !topToken.noexpand ? this._getExpansion(name2) : null;
                if (expansion == null || expandableOnly && expansion.unexpandable) {
                  if (expandableOnly && expansion == null && name2[0] === "\\" && !this.isDefined(name2)) {
                    throw new src_ParseError("Undefined control sequence: " + name2);
                  }
                  this.pushToken(topToken);
                  return topToken;
                }
                this.expansionCount++;
                if (this.expansionCount > this.settings.maxExpand) {
                  throw new src_ParseError("Too many expansions: infinite loop or need to increase maxExpand setting");
                }
                var tokens = expansion.tokens;
                if (expansion.numArgs) {
                  var args = this.consumeArgs(expansion.numArgs);
                  tokens = tokens.slice();
                  for (var i = tokens.length - 1; i >= 0; --i) {
                    var tok = tokens[i];
                    if (tok.text === "#") {
                      if (i === 0) {
                        throw new src_ParseError("Incomplete placeholder at end of macro body", tok);
                      }
                      tok = tokens[--i];
                      if (tok.text === "#") {
                        tokens.splice(i + 1, 1);
                      } else if (/^[1-9]$/.test(tok.text)) {
                        var _tokens;
                        (_tokens = tokens).splice.apply(_tokens, [i, 2].concat(args[+tok.text - 1]));
                      } else {
                        throw new src_ParseError("Not a valid argument number", tok);
                      }
                    }
                  }
                }
                this.pushTokens(tokens);
                return tokens;
              };
              _proto.expandAfterFuture = function expandAfterFuture() {
                this.expandOnce();
                return this.future();
              };
              _proto.expandNextToken = function expandNextToken() {
                for (; ; ) {
                  var expanded = this.expandOnce();
                  if (expanded instanceof Token_Token) {
                    if (expanded.text === "\\relax" || expanded.treatAsRelax) {
                      this.stack.pop();
                    } else {
                      return this.stack.pop();
                    }
                  }
                }
                throw new Error();
              };
              _proto.expandMacro = function expandMacro(name2) {
                return this.macros.has(name2) ? this.expandTokens([new Token_Token(name2)]) : void 0;
              };
              _proto.expandTokens = function expandTokens(tokens) {
                var output = [];
                var oldStackLength = this.stack.length;
                this.pushTokens(tokens);
                while (this.stack.length > oldStackLength) {
                  var expanded = this.expandOnce(true);
                  if (expanded instanceof Token_Token) {
                    if (expanded.treatAsRelax) {
                      expanded.noexpand = false;
                      expanded.treatAsRelax = false;
                    }
                    output.push(this.stack.pop());
                  }
                }
                return output;
              };
              _proto.expandMacroAsText = function expandMacroAsText(name2) {
                var tokens = this.expandMacro(name2);
                if (tokens) {
                  return tokens.map(function(token) {
                    return token.text;
                  }).join("");
                } else {
                  return tokens;
                }
              };
              _proto._getExpansion = function _getExpansion(name2) {
                var definition = this.macros.get(name2);
                if (definition == null) {
                  return definition;
                }
                var expansion = typeof definition === "function" ? definition(this) : definition;
                if (typeof expansion === "string") {
                  var numArgs = 0;
                  if (expansion.indexOf("#") !== -1) {
                    var stripped = expansion.replace(/##/g, "");
                    while (stripped.indexOf("#" + (numArgs + 1)) !== -1) {
                      ++numArgs;
                    }
                  }
                  var bodyLexer = new Lexer_Lexer(expansion, this.settings);
                  var tokens = [];
                  var tok = bodyLexer.lex();
                  while (tok.text !== "EOF") {
                    tokens.push(tok);
                    tok = bodyLexer.lex();
                  }
                  tokens.reverse();
                  var expanded = {
                    tokens,
                    numArgs
                  };
                  return expanded;
                }
                return expansion;
              };
              _proto.isDefined = function isDefined(name2) {
                return this.macros.has(name2) || src_functions.hasOwnProperty(name2) || src_symbols.math.hasOwnProperty(name2) || src_symbols.text.hasOwnProperty(name2) || implicitCommands.hasOwnProperty(name2);
              };
              _proto.isExpandable = function isExpandable(name2) {
                var macro = this.macros.get(name2);
                return macro != null ? typeof macro === "string" || typeof macro === "function" || !macro.unexpandable : src_functions.hasOwnProperty(name2);
              };
              return MacroExpander;
            }();
            var unicodeAccents = {
              "́": {
                "text": "\\'",
                "math": "\\acute"
              },
              "̀": {
                "text": "\\`",
                "math": "\\grave"
              },
              "̈": {
                "text": '\\"',
                "math": "\\ddot"
              },
              "̃": {
                "text": "\\~",
                "math": "\\tilde"
              },
              "̄": {
                "text": "\\=",
                "math": "\\bar"
              },
              "̆": {
                "text": "\\u",
                "math": "\\breve"
              },
              "̌": {
                "text": "\\v",
                "math": "\\check"
              },
              "̂": {
                "text": "\\^",
                "math": "\\hat"
              },
              "̇": {
                "text": "\\.",
                "math": "\\dot"
              },
              "̊": {
                "text": "\\r",
                "math": "\\mathring"
              },
              "̋": {
                "text": "\\H"
              }
            };
            var unicodeSymbols = {
              "á": "á",
              "à": "à",
              "ä": "ä",
              "ǟ": "ǟ",
              "ã": "ã",
              "ā": "ā",
              "ă": "ă",
              "ắ": "ắ",
              "ằ": "ằ",
              "ẵ": "ẵ",
              "ǎ": "ǎ",
              "â": "â",
              "ấ": "ấ",
              "ầ": "ầ",
              "ẫ": "ẫ",
              "ȧ": "ȧ",
              "ǡ": "ǡ",
              "å": "å",
              "ǻ": "ǻ",
              "ḃ": "ḃ",
              "ć": "ć",
              "č": "č",
              "ĉ": "ĉ",
              "ċ": "ċ",
              "ď": "ď",
              "ḋ": "ḋ",
              "é": "é",
              "è": "è",
              "ë": "ë",
              "ẽ": "ẽ",
              "ē": "ē",
              "ḗ": "ḗ",
              "ḕ": "ḕ",
              "ĕ": "ĕ",
              "ě": "ě",
              "ê": "ê",
              "ế": "ế",
              "ề": "ề",
              "ễ": "ễ",
              "ė": "ė",
              "ḟ": "ḟ",
              "ǵ": "ǵ",
              "ḡ": "ḡ",
              "ğ": "ğ",
              "ǧ": "ǧ",
              "ĝ": "ĝ",
              "ġ": "ġ",
              "ḧ": "ḧ",
              "ȟ": "ȟ",
              "ĥ": "ĥ",
              "ḣ": "ḣ",
              "í": "í",
              "ì": "ì",
              "ï": "ï",
              "ḯ": "ḯ",
              "ĩ": "ĩ",
              "ī": "ī",
              "ĭ": "ĭ",
              "ǐ": "ǐ",
              "î": "î",
              "ǰ": "ǰ",
              "ĵ": "ĵ",
              "ḱ": "ḱ",
              "ǩ": "ǩ",
              "ĺ": "ĺ",
              "ľ": "ľ",
              "ḿ": "ḿ",
              "ṁ": "ṁ",
              "ń": "ń",
              "ǹ": "ǹ",
              "ñ": "ñ",
              "ň": "ň",
              "ṅ": "ṅ",
              "ó": "ó",
              "ò": "ò",
              "ö": "ö",
              "ȫ": "ȫ",
              "õ": "õ",
              "ṍ": "ṍ",
              "ṏ": "ṏ",
              "ȭ": "ȭ",
              "ō": "ō",
              "ṓ": "ṓ",
              "ṑ": "ṑ",
              "ŏ": "ŏ",
              "ǒ": "ǒ",
              "ô": "ô",
              "ố": "ố",
              "ồ": "ồ",
              "ỗ": "ỗ",
              "ȯ": "ȯ",
              "ȱ": "ȱ",
              "ő": "ő",
              "ṕ": "ṕ",
              "ṗ": "ṗ",
              "ŕ": "ŕ",
              "ř": "ř",
              "ṙ": "ṙ",
              "ś": "ś",
              "ṥ": "ṥ",
              "š": "š",
              "ṧ": "ṧ",
              "ŝ": "ŝ",
              "ṡ": "ṡ",
              "ẗ": "ẗ",
              "ť": "ť",
              "ṫ": "ṫ",
              "ú": "ú",
              "ù": "ù",
              "ü": "ü",
              "ǘ": "ǘ",
              "ǜ": "ǜ",
              "ǖ": "ǖ",
              "ǚ": "ǚ",
              "ũ": "ũ",
              "ṹ": "ṹ",
              "ū": "ū",
              "ṻ": "ṻ",
              "ŭ": "ŭ",
              "ǔ": "ǔ",
              "û": "û",
              "ů": "ů",
              "ű": "ű",
              "ṽ": "ṽ",
              "ẃ": "ẃ",
              "ẁ": "ẁ",
              "ẅ": "ẅ",
              "ŵ": "ŵ",
              "ẇ": "ẇ",
              "ẘ": "ẘ",
              "ẍ": "ẍ",
              "ẋ": "ẋ",
              "ý": "ý",
              "ỳ": "ỳ",
              "ÿ": "ÿ",
              "ỹ": "ỹ",
              "ȳ": "ȳ",
              "ŷ": "ŷ",
              "ẏ": "ẏ",
              "ẙ": "ẙ",
              "ź": "ź",
              "ž": "ž",
              "ẑ": "ẑ",
              "ż": "ż",
              "Á": "Á",
              "À": "À",
              "Ä": "Ä",
              "Ǟ": "Ǟ",
              "Ã": "Ã",
              "Ā": "Ā",
              "Ă": "Ă",
              "Ắ": "Ắ",
              "Ằ": "Ằ",
              "Ẵ": "Ẵ",
              "Ǎ": "Ǎ",
              "Â": "Â",
              "Ấ": "Ấ",
              "Ầ": "Ầ",
              "Ẫ": "Ẫ",
              "Ȧ": "Ȧ",
              "Ǡ": "Ǡ",
              "Å": "Å",
              "Ǻ": "Ǻ",
              "Ḃ": "Ḃ",
              "Ć": "Ć",
              "Č": "Č",
              "Ĉ": "Ĉ",
              "Ċ": "Ċ",
              "Ď": "Ď",
              "Ḋ": "Ḋ",
              "É": "É",
              "È": "È",
              "Ë": "Ë",
              "Ẽ": "Ẽ",
              "Ē": "Ē",
              "Ḗ": "Ḗ",
              "Ḕ": "Ḕ",
              "Ĕ": "Ĕ",
              "Ě": "Ě",
              "Ê": "Ê",
              "Ế": "Ế",
              "Ề": "Ề",
              "Ễ": "Ễ",
              "Ė": "Ė",
              "Ḟ": "Ḟ",
              "Ǵ": "Ǵ",
              "Ḡ": "Ḡ",
              "Ğ": "Ğ",
              "Ǧ": "Ǧ",
              "Ĝ": "Ĝ",
              "Ġ": "Ġ",
              "Ḧ": "Ḧ",
              "Ȟ": "Ȟ",
              "Ĥ": "Ĥ",
              "Ḣ": "Ḣ",
              "Í": "Í",
              "Ì": "Ì",
              "Ï": "Ï",
              "Ḯ": "Ḯ",
              "Ĩ": "Ĩ",
              "Ī": "Ī",
              "Ĭ": "Ĭ",
              "Ǐ": "Ǐ",
              "Î": "Î",
              "İ": "İ",
              "Ĵ": "Ĵ",
              "Ḱ": "Ḱ",
              "Ǩ": "Ǩ",
              "Ĺ": "Ĺ",
              "Ľ": "Ľ",
              "Ḿ": "Ḿ",
              "Ṁ": "Ṁ",
              "Ń": "Ń",
              "Ǹ": "Ǹ",
              "Ñ": "Ñ",
              "Ň": "Ň",
              "Ṅ": "Ṅ",
              "Ó": "Ó",
              "Ò": "Ò",
              "Ö": "Ö",
              "Ȫ": "Ȫ",
              "Õ": "Õ",
              "Ṍ": "Ṍ",
              "Ṏ": "Ṏ",
              "Ȭ": "Ȭ",
              "Ō": "Ō",
              "Ṓ": "Ṓ",
              "Ṑ": "Ṑ",
              "Ŏ": "Ŏ",
              "Ǒ": "Ǒ",
              "Ô": "Ô",
              "Ố": "Ố",
              "Ồ": "Ồ",
              "Ỗ": "Ỗ",
              "Ȯ": "Ȯ",
              "Ȱ": "Ȱ",
              "Ő": "Ő",
              "Ṕ": "Ṕ",
              "Ṗ": "Ṗ",
              "Ŕ": "Ŕ",
              "Ř": "Ř",
              "Ṙ": "Ṙ",
              "Ś": "Ś",
              "Ṥ": "Ṥ",
              "Š": "Š",
              "Ṧ": "Ṧ",
              "Ŝ": "Ŝ",
              "Ṡ": "Ṡ",
              "Ť": "Ť",
              "Ṫ": "Ṫ",
              "Ú": "Ú",
              "Ù": "Ù",
              "Ü": "Ü",
              "Ǘ": "Ǘ",
              "Ǜ": "Ǜ",
              "Ǖ": "Ǖ",
              "Ǚ": "Ǚ",
              "Ũ": "Ũ",
              "Ṹ": "Ṹ",
              "Ū": "Ū",
              "Ṻ": "Ṻ",
              "Ŭ": "Ŭ",
              "Ǔ": "Ǔ",
              "Û": "Û",
              "Ů": "Ů",
              "Ű": "Ű",
              "Ṽ": "Ṽ",
              "Ẃ": "Ẃ",
              "Ẁ": "Ẁ",
              "Ẅ": "Ẅ",
              "Ŵ": "Ŵ",
              "Ẇ": "Ẇ",
              "Ẍ": "Ẍ",
              "Ẋ": "Ẋ",
              "Ý": "Ý",
              "Ỳ": "Ỳ",
              "Ÿ": "Ÿ",
              "Ỹ": "Ỹ",
              "Ȳ": "Ȳ",
              "Ŷ": "Ŷ",
              "Ẏ": "Ẏ",
              "Ź": "Ź",
              "Ž": "Ž",
              "Ẑ": "Ẑ",
              "Ż": "Ż",
              "ά": "ά",
              "ὰ": "ὰ",
              "ᾱ": "ᾱ",
              "ᾰ": "ᾰ",
              "έ": "έ",
              "ὲ": "ὲ",
              "ή": "ή",
              "ὴ": "ὴ",
              "ί": "ί",
              "ὶ": "ὶ",
              "ϊ": "ϊ",
              "ΐ": "ΐ",
              "ῒ": "ῒ",
              "ῑ": "ῑ",
              "ῐ": "ῐ",
              "ό": "ό",
              "ὸ": "ὸ",
              "ύ": "ύ",
              "ὺ": "ὺ",
              "ϋ": "ϋ",
              "ΰ": "ΰ",
              "ῢ": "ῢ",
              "ῡ": "ῡ",
              "ῠ": "ῠ",
              "ώ": "ώ",
              "ὼ": "ὼ",
              "Ύ": "Ύ",
              "Ὺ": "Ὺ",
              "Ϋ": "Ϋ",
              "Ῡ": "Ῡ",
              "Ῠ": "Ῠ",
              "Ώ": "Ώ",
              "Ὼ": "Ὼ"
            };
            var Parser_Parser = function() {
              function Parser3(input, settings) {
                this.mode = void 0;
                this.gullet = void 0;
                this.settings = void 0;
                this.leftrightDepth = void 0;
                this.nextToken = void 0;
                this.mode = "math";
                this.gullet = new MacroExpander_MacroExpander(input, settings, this.mode);
                this.settings = settings;
                this.leftrightDepth = 0;
              }
              var _proto = Parser3.prototype;
              _proto.expect = function expect(text4, consume) {
                if (consume === void 0) {
                  consume = true;
                }
                if (this.fetch().text !== text4) {
                  throw new src_ParseError("Expected '" + text4 + "', got '" + this.fetch().text + "'", this.fetch());
                }
                if (consume) {
                  this.consume();
                }
              };
              _proto.consume = function consume() {
                this.nextToken = null;
              };
              _proto.fetch = function fetch2() {
                if (this.nextToken == null) {
                  this.nextToken = this.gullet.expandNextToken();
                }
                return this.nextToken;
              };
              _proto.switchMode = function switchMode(newMode) {
                this.mode = newMode;
                this.gullet.switchMode(newMode);
              };
              _proto.parse = function parse6() {
                if (!this.settings.globalGroup) {
                  this.gullet.beginGroup();
                }
                if (this.settings.colorIsTextColor) {
                  this.gullet.macros.set("\\color", "\\textcolor");
                }
                var parse7 = this.parseExpression(false);
                this.expect("EOF");
                if (!this.settings.globalGroup) {
                  this.gullet.endGroup();
                }
                return parse7;
              };
              _proto.parseExpression = function parseExpression(breakOnInfix, breakOnTokenText) {
                var body = [];
                while (true) {
                  if (this.mode === "math") {
                    this.consumeSpaces();
                  }
                  var lex = this.fetch();
                  if (Parser3.endOfExpression.indexOf(lex.text) !== -1) {
                    break;
                  }
                  if (breakOnTokenText && lex.text === breakOnTokenText) {
                    break;
                  }
                  if (breakOnInfix && src_functions[lex.text] && src_functions[lex.text].infix) {
                    break;
                  }
                  var atom = this.parseAtom(breakOnTokenText);
                  if (!atom) {
                    break;
                  } else if (atom.type === "internal") {
                    continue;
                  }
                  body.push(atom);
                }
                if (this.mode === "text") {
                  this.formLigatures(body);
                }
                return this.handleInfixNodes(body);
              };
              _proto.handleInfixNodes = function handleInfixNodes(body) {
                var overIndex = -1;
                var funcName;
                for (var i = 0; i < body.length; i++) {
                  if (body[i].type === "infix") {
                    if (overIndex !== -1) {
                      throw new src_ParseError("only one infix operator per group", body[i].token);
                    }
                    overIndex = i;
                    funcName = body[i].replaceWith;
                  }
                }
                if (overIndex !== -1 && funcName) {
                  var numerNode;
                  var denomNode;
                  var numerBody = body.slice(0, overIndex);
                  var denomBody = body.slice(overIndex + 1);
                  if (numerBody.length === 1 && numerBody[0].type === "ordgroup") {
                    numerNode = numerBody[0];
                  } else {
                    numerNode = {
                      type: "ordgroup",
                      mode: this.mode,
                      body: numerBody
                    };
                  }
                  if (denomBody.length === 1 && denomBody[0].type === "ordgroup") {
                    denomNode = denomBody[0];
                  } else {
                    denomNode = {
                      type: "ordgroup",
                      mode: this.mode,
                      body: denomBody
                    };
                  }
                  var node;
                  if (funcName === "\\\\abovefrac") {
                    node = this.callFunction(funcName, [numerNode, body[overIndex], denomNode], []);
                  } else {
                    node = this.callFunction(funcName, [numerNode, denomNode], []);
                  }
                  return [node];
                } else {
                  return body;
                }
              };
              _proto.handleSupSubscript = function handleSupSubscript(name2) {
                var symbolToken = this.fetch();
                var symbol = symbolToken.text;
                this.consume();
                var group = this.parseGroup(name2, false, Parser3.SUPSUB_GREEDINESS, void 0, void 0, true);
                if (!group) {
                  throw new src_ParseError("Expected group after '" + symbol + "'", symbolToken);
                }
                return group;
              };
              _proto.formatUnsupportedCmd = function formatUnsupportedCmd(text4) {
                var textordArray = [];
                for (var i = 0; i < text4.length; i++) {
                  textordArray.push({
                    type: "textord",
                    mode: "text",
                    text: text4[i]
                  });
                }
                var textNode = {
                  type: "text",
                  mode: this.mode,
                  body: textordArray
                };
                var colorNode = {
                  type: "color",
                  mode: this.mode,
                  color: this.settings.errorColor,
                  body: [textNode]
                };
                return colorNode;
              };
              _proto.parseAtom = function parseAtom(breakOnTokenText) {
                var base2 = this.parseGroup("atom", false, null, breakOnTokenText);
                if (this.mode === "text") {
                  return base2;
                }
                var superscript2;
                var subscript2;
                while (true) {
                  this.consumeSpaces();
                  var lex = this.fetch();
                  if (lex.text === "\\limits" || lex.text === "\\nolimits") {
                    if (base2 && base2.type === "op") {
                      var limits = lex.text === "\\limits";
                      base2.limits = limits;
                      base2.alwaysHandleSupSub = true;
                    } else if (base2 && base2.type === "operatorname" && base2.alwaysHandleSupSub) {
                      var _limits = lex.text === "\\limits";
                      base2.limits = _limits;
                    } else {
                      throw new src_ParseError("Limit controls must follow a math operator", lex);
                    }
                    this.consume();
                  } else if (lex.text === "^") {
                    if (superscript2) {
                      throw new src_ParseError("Double superscript", lex);
                    }
                    superscript2 = this.handleSupSubscript("superscript");
                  } else if (lex.text === "_") {
                    if (subscript2) {
                      throw new src_ParseError("Double subscript", lex);
                    }
                    subscript2 = this.handleSupSubscript("subscript");
                  } else if (lex.text === "'") {
                    if (superscript2) {
                      throw new src_ParseError("Double superscript", lex);
                    }
                    var prime = {
                      type: "textord",
                      mode: this.mode,
                      text: "\\prime"
                    };
                    var primes = [prime];
                    this.consume();
                    while (this.fetch().text === "'") {
                      primes.push(prime);
                      this.consume();
                    }
                    if (this.fetch().text === "^") {
                      primes.push(this.handleSupSubscript("superscript"));
                    }
                    superscript2 = {
                      type: "ordgroup",
                      mode: this.mode,
                      body: primes
                    };
                  } else {
                    break;
                  }
                }
                if (superscript2 || subscript2) {
                  return {
                    type: "supsub",
                    mode: this.mode,
                    base: base2,
                    sup: superscript2,
                    sub: subscript2
                  };
                } else {
                  return base2;
                }
              };
              _proto.parseFunction = function parseFunction(breakOnTokenText, name2, greediness) {
                var token = this.fetch();
                var func = token.text;
                var funcData = src_functions[func];
                if (!funcData) {
                  return null;
                }
                this.consume();
                if (greediness != null && funcData.greediness <= greediness) {
                  throw new src_ParseError("Got function '" + func + "' with no arguments" + (name2 ? " as " + name2 : ""), token);
                } else if (this.mode === "text" && !funcData.allowedInText) {
                  throw new src_ParseError("Can't use function '" + func + "' in text mode", token);
                } else if (this.mode === "math" && funcData.allowedInMath === false) {
                  throw new src_ParseError("Can't use function '" + func + "' in math mode", token);
                }
                var _this$parseArguments = this.parseArguments(func, funcData), args = _this$parseArguments.args, optArgs = _this$parseArguments.optArgs;
                return this.callFunction(func, args, optArgs, token, breakOnTokenText);
              };
              _proto.callFunction = function callFunction(name2, args, optArgs, token, breakOnTokenText) {
                var context = {
                  funcName: name2,
                  parser: this,
                  token,
                  breakOnTokenText
                };
                var func = src_functions[name2];
                if (func && func.handler) {
                  return func.handler(context, args, optArgs);
                } else {
                  throw new src_ParseError("No function handler for " + name2);
                }
              };
              _proto.parseArguments = function parseArguments(func, funcData) {
                var totalArgs = funcData.numArgs + funcData.numOptionalArgs;
                if (totalArgs === 0) {
                  return {
                    args: [],
                    optArgs: []
                  };
                }
                var baseGreediness = funcData.greediness;
                var args = [];
                var optArgs = [];
                for (var i = 0; i < totalArgs; i++) {
                  var argType = funcData.argTypes && funcData.argTypes[i];
                  var isOptional = i < funcData.numOptionalArgs;
                  var consumeSpaces = i > 0 && !isOptional || // Also consume leading spaces in math mode, as parseSymbol
                  // won't know what to do with them.  This can only happen with
                  // macros, e.g. \frac\foo\foo where \foo expands to a space symbol.
                  // In LaTeX, the \foo's get treated as (blank) arguments.
                  // In KaTeX, for now, both spaces will get consumed.
                  // TODO(edemaine)
                  i === 0 && !isOptional && this.mode === "math";
                  var arg = this.parseGroupOfType("argument to '" + func + "'", argType, isOptional, baseGreediness, consumeSpaces);
                  if (!arg) {
                    if (isOptional) {
                      optArgs.push(null);
                      continue;
                    }
                    throw new src_ParseError("Expected group after '" + func + "'", this.fetch());
                  }
                  (isOptional ? optArgs : args).push(arg);
                }
                return {
                  args,
                  optArgs
                };
              };
              _proto.parseGroupOfType = function parseGroupOfType(name2, type2, optional, greediness, consumeSpaces) {
                switch (type2) {
                  case "color":
                    if (consumeSpaces) {
                      this.consumeSpaces();
                    }
                    return this.parseColorGroup(optional);
                  case "size":
                    if (consumeSpaces) {
                      this.consumeSpaces();
                    }
                    return this.parseSizeGroup(optional);
                  case "url":
                    return this.parseUrlGroup(optional, consumeSpaces);
                  case "math":
                  case "text":
                    return this.parseGroup(name2, optional, greediness, void 0, type2, consumeSpaces);
                  case "hbox": {
                    var group = this.parseGroup(name2, optional, greediness, void 0, "text", consumeSpaces);
                    if (!group) {
                      return group;
                    }
                    var styledGroup = {
                      type: "styling",
                      mode: group.mode,
                      body: [group],
                      style: "text"
                      // simulate \textstyle
                    };
                    return styledGroup;
                  }
                  case "raw": {
                    if (consumeSpaces) {
                      this.consumeSpaces();
                    }
                    if (optional && this.fetch().text === "{") {
                      return null;
                    }
                    var token = this.parseStringGroup("raw", optional, true);
                    if (token) {
                      return {
                        type: "raw",
                        mode: "text",
                        string: token.text
                      };
                    } else {
                      throw new src_ParseError("Expected raw group", this.fetch());
                    }
                  }
                  case "original":
                  case null:
                  case void 0:
                    return this.parseGroup(name2, optional, greediness, void 0, void 0, consumeSpaces);
                  default:
                    throw new src_ParseError("Unknown group type as " + name2, this.fetch());
                }
              };
              _proto.consumeSpaces = function consumeSpaces() {
                while (this.fetch().text === " ") {
                  this.consume();
                }
              };
              _proto.parseStringGroup = function parseStringGroup(modeName, optional, raw) {
                var groupBegin = optional ? "[" : "{";
                var groupEnd = optional ? "]" : "}";
                var beginToken = this.fetch();
                if (beginToken.text !== groupBegin) {
                  if (optional) {
                    return null;
                  } else if (raw && beginToken.text !== "EOF" && /[^{}[\]]/.test(beginToken.text)) {
                    this.consume();
                    return beginToken;
                  }
                }
                var outerMode = this.mode;
                this.mode = "text";
                this.expect(groupBegin);
                var str2 = "";
                var firstToken = this.fetch();
                var nested = 0;
                var lastToken = firstToken;
                var nextToken;
                while ((nextToken = this.fetch()).text !== groupEnd || raw && nested > 0) {
                  switch (nextToken.text) {
                    case "EOF":
                      throw new src_ParseError("Unexpected end of input in " + modeName, firstToken.range(lastToken, str2));
                    case groupBegin:
                      nested++;
                      break;
                    case groupEnd:
                      nested--;
                      break;
                  }
                  lastToken = nextToken;
                  str2 += lastToken.text;
                  this.consume();
                }
                this.expect(groupEnd);
                this.mode = outerMode;
                return firstToken.range(lastToken, str2);
              };
              _proto.parseRegexGroup = function parseRegexGroup(regex, modeName) {
                var outerMode = this.mode;
                this.mode = "text";
                var firstToken = this.fetch();
                var lastToken = firstToken;
                var str2 = "";
                var nextToken;
                while ((nextToken = this.fetch()).text !== "EOF" && regex.test(str2 + nextToken.text)) {
                  lastToken = nextToken;
                  str2 += lastToken.text;
                  this.consume();
                }
                if (str2 === "") {
                  throw new src_ParseError("Invalid " + modeName + ": '" + firstToken.text + "'", firstToken);
                }
                this.mode = outerMode;
                return firstToken.range(lastToken, str2);
              };
              _proto.parseColorGroup = function parseColorGroup(optional) {
                var res = this.parseStringGroup("color", optional);
                if (!res) {
                  return null;
                }
                var match2 = /^(#[a-f0-9]{3}|#?[a-f0-9]{6}|[a-z]+)$/i.exec(res.text);
                if (!match2) {
                  throw new src_ParseError("Invalid color: '" + res.text + "'", res);
                }
                var color = match2[0];
                if (/^[0-9a-f]{6}$/i.test(color)) {
                  color = "#" + color;
                }
                return {
                  type: "color-token",
                  mode: this.mode,
                  color
                };
              };
              _proto.parseSizeGroup = function parseSizeGroup(optional) {
                var res;
                var isBlank = false;
                if (!optional && this.fetch().text !== "{") {
                  res = this.parseRegexGroup(/^[-+]? *(?:$|\d+|\d+\.\d*|\.\d*) *[a-z]{0,2} *$/, "size");
                } else {
                  res = this.parseStringGroup("size", optional);
                }
                if (!res) {
                  return null;
                }
                if (!optional && res.text.length === 0) {
                  res.text = "0pt";
                  isBlank = true;
                }
                var match2 = /([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/.exec(res.text);
                if (!match2) {
                  throw new src_ParseError("Invalid size: '" + res.text + "'", res);
                }
                var data2 = {
                  number: +(match2[1] + match2[2]),
                  // sign + magnitude, cast to number
                  unit: match2[3]
                };
                if (!validUnit(data2)) {
                  throw new src_ParseError("Invalid unit: '" + data2.unit + "'", res);
                }
                return {
                  type: "size",
                  mode: this.mode,
                  value: data2,
                  isBlank
                };
              };
              _proto.parseUrlGroup = function parseUrlGroup(optional, consumeSpaces) {
                this.gullet.lexer.setCatcode("%", 13);
                var res = this.parseStringGroup("url", optional, true);
                this.gullet.lexer.setCatcode("%", 14);
                if (!res) {
                  return null;
                }
                var url = res.text.replace(/\\([#$%&~_^{}])/g, "$1");
                return {
                  type: "url",
                  mode: this.mode,
                  url
                };
              };
              _proto.parseGroup = function parseGroup(name2, optional, greediness, breakOnTokenText, mode, consumeSpaces) {
                var outerMode = this.mode;
                if (mode) {
                  this.switchMode(mode);
                }
                if (consumeSpaces) {
                  this.consumeSpaces();
                }
                var firstToken = this.fetch();
                var text4 = firstToken.text;
                var result;
                if (optional ? text4 === "[" : text4 === "{" || text4 === "\\begingroup") {
                  this.consume();
                  var groupEnd = Parser3.endOfGroup[text4];
                  this.gullet.beginGroup();
                  var expression = this.parseExpression(false, groupEnd);
                  var lastToken = this.fetch();
                  this.expect(groupEnd);
                  this.gullet.endGroup();
                  result = {
                    type: "ordgroup",
                    mode: this.mode,
                    loc: SourceLocation.range(firstToken, lastToken),
                    body: expression,
                    // A group formed by \begingroup...\endgroup is a semi-simple group
                    // which doesn't affect spacing in math mode, i.e., is transparent.
                    // https://tex.stackexchange.com/questions/1930/when-should-one-
                    // use-begingroup-instead-of-bgroup
                    semisimple: text4 === "\\begingroup" || void 0
                  };
                } else if (optional) {
                  result = null;
                } else {
                  result = this.parseFunction(breakOnTokenText, name2, greediness) || this.parseSymbol();
                  if (result == null && text4[0] === "\\" && !implicitCommands.hasOwnProperty(text4)) {
                    if (this.settings.throwOnError) {
                      throw new src_ParseError("Undefined control sequence: " + text4, firstToken);
                    }
                    result = this.formatUnsupportedCmd(text4);
                    this.consume();
                  }
                }
                if (mode) {
                  this.switchMode(outerMode);
                }
                return result;
              };
              _proto.formLigatures = function formLigatures(group) {
                var n = group.length - 1;
                for (var i = 0; i < n; ++i) {
                  var a = group[i];
                  var v = a.text;
                  if (v === "-" && group[i + 1].text === "-") {
                    if (i + 1 < n && group[i + 2].text === "-") {
                      group.splice(i, 3, {
                        type: "textord",
                        mode: "text",
                        loc: SourceLocation.range(a, group[i + 2]),
                        text: "---"
                      });
                      n -= 2;
                    } else {
                      group.splice(i, 2, {
                        type: "textord",
                        mode: "text",
                        loc: SourceLocation.range(a, group[i + 1]),
                        text: "--"
                      });
                      n -= 1;
                    }
                  }
                  if ((v === "'" || v === "`") && group[i + 1].text === v) {
                    group.splice(i, 2, {
                      type: "textord",
                      mode: "text",
                      loc: SourceLocation.range(a, group[i + 1]),
                      text: v + v
                    });
                    n -= 1;
                  }
                }
              };
              _proto.parseSymbol = function parseSymbol() {
                var nucleus = this.fetch();
                var text4 = nucleus.text;
                if (/^\\verb[^a-zA-Z]/.test(text4)) {
                  this.consume();
                  var arg = text4.slice(5);
                  var star = arg.charAt(0) === "*";
                  if (star) {
                    arg = arg.slice(1);
                  }
                  if (arg.length < 2 || arg.charAt(0) !== arg.slice(-1)) {
                    throw new src_ParseError("\\verb assertion failed --\n                    please report what input caused this bug");
                  }
                  arg = arg.slice(1, -1);
                  return {
                    type: "verb",
                    mode: "text",
                    body: arg,
                    star
                  };
                }
                if (unicodeSymbols.hasOwnProperty(text4[0]) && !src_symbols[this.mode][text4[0]]) {
                  if (this.settings.strict && this.mode === "math") {
                    this.settings.reportNonstrict("unicodeTextInMathMode", 'Accented Unicode text character "' + text4[0] + '" used in math mode', nucleus);
                  }
                  text4 = unicodeSymbols[text4[0]] + text4.substr(1);
                }
                var match2 = combiningDiacriticalMarksEndRegex.exec(text4);
                if (match2) {
                  text4 = text4.substring(0, match2.index);
                  if (text4 === "i") {
                    text4 = "ı";
                  } else if (text4 === "j") {
                    text4 = "ȷ";
                  }
                }
                var symbol;
                if (src_symbols[this.mode][text4]) {
                  if (this.settings.strict && this.mode === "math" && extraLatin.indexOf(text4) >= 0) {
                    this.settings.reportNonstrict("unicodeTextInMathMode", 'Latin-1/Unicode text character "' + text4[0] + '" used in math mode', nucleus);
                  }
                  var group = src_symbols[this.mode][text4].group;
                  var loc = SourceLocation.range(nucleus);
                  var s;
                  if (ATOMS.hasOwnProperty(group)) {
                    var family = group;
                    s = {
                      type: "atom",
                      mode: this.mode,
                      family,
                      loc,
                      text: text4
                    };
                  } else {
                    s = {
                      type: group,
                      mode: this.mode,
                      loc,
                      text: text4
                    };
                  }
                  symbol = s;
                } else if (text4.charCodeAt(0) >= 128) {
                  if (this.settings.strict) {
                    if (!supportedCodepoint(text4.charCodeAt(0))) {
                      this.settings.reportNonstrict("unknownSymbol", 'Unrecognized Unicode character "' + text4[0] + '"' + (" (" + text4.charCodeAt(0) + ")"), nucleus);
                    } else if (this.mode === "math") {
                      this.settings.reportNonstrict("unicodeTextInMathMode", 'Unicode text character "' + text4[0] + '" used in math mode', nucleus);
                    }
                  }
                  symbol = {
                    type: "textord",
                    mode: "text",
                    loc: SourceLocation.range(nucleus),
                    text: text4
                  };
                } else {
                  return null;
                }
                this.consume();
                if (match2) {
                  for (var i = 0; i < match2[0].length; i++) {
                    var accent = match2[0][i];
                    if (!unicodeAccents[accent]) {
                      throw new src_ParseError("Unknown accent ' " + accent + "'", nucleus);
                    }
                    var command = unicodeAccents[accent][this.mode];
                    if (!command) {
                      throw new src_ParseError("Accent " + accent + " unsupported in " + this.mode + " mode", nucleus);
                    }
                    symbol = {
                      type: "accent",
                      mode: this.mode,
                      loc: SourceLocation.range(nucleus),
                      label: command,
                      isStretchy: false,
                      isShifty: true,
                      base: symbol
                    };
                  }
                }
                return symbol;
              };
              return Parser3;
            }();
            Parser_Parser.endOfExpression = ["}", "\\endgroup", "\\end", "\\right", "&"];
            Parser_Parser.endOfGroup = {
              "[": "]",
              "{": "}",
              "\\begingroup": "\\endgroup"
              /**
               * Parses an "expression", which is a list of atoms.
               *
               * `breakOnInfix`: Should the parsing stop when we hit infix nodes? This
               *                 happens when functions have higher precendence han infix
               *                 nodes in implicit parses.
               *
               * `breakOnTokenText`: The text of the token that the expression should end
               *                     with, or `null` if something else should end the
               *                     expression.
               */
            };
            Parser_Parser.SUPSUB_GREEDINESS = 1;
            var parseTree_parseTree = function parseTree(toParse, settings) {
              if (!(typeof toParse === "string" || toParse instanceof String)) {
                throw new TypeError("KaTeX can only parse string typed expression");
              }
              var parser = new Parser_Parser(toParse, settings);
              delete parser.gullet.macros.current["\\df@tag"];
              var tree = parser.parse();
              if (parser.gullet.macros.get("\\df@tag")) {
                if (!settings.displayMode) {
                  throw new src_ParseError("\\tag works only in display equations");
                }
                parser.gullet.feed("\\df@tag");
                tree = [{
                  type: "tag",
                  mode: "text",
                  body: tree,
                  tag: parser.parse()
                }];
              }
              return tree;
            };
            var src_parseTree = parseTree_parseTree;
            var katex_render = function render3(expression, baseNode, options) {
              baseNode.textContent = "";
              var node = katex_renderToDomTree(expression, options).toNode();
              baseNode.appendChild(node);
            };
            if (typeof document !== "undefined") {
              if (document.compatMode !== "CSS1Compat") {
                typeof console !== "undefined" && console.warn("Warning: KaTeX doesn't work in quirks mode. Make sure your website has a suitable doctype.");
                katex_render = function render3() {
                  throw new src_ParseError("KaTeX doesn't work in quirks mode.");
                };
              }
            }
            var renderToString = function renderToString2(expression, options) {
              var markup = katex_renderToDomTree(expression, options).toMarkup();
              return markup;
            };
            var katex_generateParseTree = function generateParseTree(expression, options) {
              var settings = new Settings_Settings(options);
              return src_parseTree(expression, settings);
            };
            var katex_renderError = function renderError(error2, expression, options) {
              if (options.throwOnError || !(error2 instanceof src_ParseError)) {
                throw error2;
              }
              var node = buildCommon.makeSpan(["katex-error"], [new domTree_SymbolNode(expression)]);
              node.setAttribute("title", error2.toString());
              node.setAttribute("style", "color:" + options.errorColor);
              return node;
            };
            var katex_renderToDomTree = function renderToDomTree(expression, options) {
              var settings = new Settings_Settings(options);
              try {
                var tree = src_parseTree(expression, settings);
                return buildTree_buildTree(tree, expression, settings);
              } catch (error2) {
                return katex_renderError(error2, expression, settings);
              }
            };
            var katex_renderToHTMLTree = function renderToHTMLTree(expression, options) {
              var settings = new Settings_Settings(options);
              try {
                var tree = src_parseTree(expression, settings);
                return buildTree_buildHTMLTree(tree, expression, settings);
              } catch (error2) {
                return katex_renderError(error2, expression, settings);
              }
            };
            var katex_0 = {
              /**
               * Current KaTeX version
               */
              version: "0.12.0",
              /**
               * Renders the given LaTeX into an HTML+MathML combination, and adds
               * it as a child to the specified DOM node.
               */
              render: katex_render,
              /**
               * Renders the given LaTeX into an HTML+MathML combination string,
               * for sending to the client.
               */
              renderToString,
              /**
               * KaTeX error, usually during parsing.
               */
              ParseError: src_ParseError,
              /**
               * Parses the given LaTeX into KaTeX's internal parse tree structure,
               * without rendering to HTML or MathML.
               *
               * NOTE: This method is not currently recommended for public use.
               * The internal tree representation is unstable and is very likely
               * to change. Use at your own risk.
               */
              __parse: katex_generateParseTree,
              /**
               * Renders the given LaTeX into an HTML+MathML internal DOM tree
               * representation, without flattening that representation to a string.
               *
               * NOTE: This method is not currently recommended for public use.
               * The internal tree representation is unstable and is very likely
               * to change. Use at your own risk.
               */
              __renderToDomTree: katex_renderToDomTree,
              /**
               * Renders the given LaTeX into an HTML internal DOM tree representation,
               * without MathML and without flattening that representation to a string.
               *
               * NOTE: This method is not currently recommended for public use.
               * The internal tree representation is unstable and is very likely
               * to change. Use at your own risk.
               */
              __renderToHTMLTree: katex_renderToHTMLTree,
              /**
               * extends internal font metrics object with a new object
               * each key in the new object represents a font name
              */
              __setFontMetrics: setFontMetrics,
              /**
               * adds a new symbol to builtin symbols table
               */
              __defineSymbol: defineSymbol,
              /**
               * adds a new macro to builtin macro list
               */
              __defineMacro: defineMacro,
              /**
               * Expose the dom tree node types, which can be useful for type checking nodes.
               *
               * NOTE: This method is not currently recommended for public use.
               * The internal tree representation is unstable and is very likely
               * to change. Use at your own risk.
               */
              __domTree: {
                Span: domTree_Span,
                Anchor: domTree_Anchor,
                SymbolNode: domTree_SymbolNode,
                SvgNode,
                PathNode: domTree_PathNode,
                LineNode
              }
            };
            var katex_webpack = __webpack_exports__["default"] = katex_0;
          }
          /******/
        ])["default"]
      );
    });
  }
});

// node_modules/.pnpm/@iktakahiro+markdown-it-katex@4.0.1/node_modules/@iktakahiro/markdown-it-katex/index.js
var require_markdown_it_katex = __commonJS({
  "node_modules/.pnpm/@iktakahiro+markdown-it-katex@4.0.1/node_modules/@iktakahiro/markdown-it-katex/index.js"(exports, module) {
    "use strict";
    var katex = require_katex();
    function isValidDelim(state, pos) {
      var prevChar, nextChar, max = state.posMax, can_open = true, can_close = true;
      prevChar = pos > 0 ? state.src.charCodeAt(pos - 1) : -1;
      nextChar = pos + 1 <= max ? state.src.charCodeAt(pos + 1) : -1;
      if (prevChar === 32 || prevChar === 9 || nextChar >= 48 && nextChar <= 57) {
        can_close = false;
      }
      if (nextChar === 32 || nextChar === 9) {
        can_open = false;
      }
      return {
        can_open,
        can_close
      };
    }
    function math_inline(state, silent) {
      var start, match2, token, res, pos, esc_count;
      if (state.src[state.pos] !== "$") {
        return false;
      }
      res = isValidDelim(state, state.pos);
      if (!res.can_open) {
        if (!silent) {
          state.pending += "$";
        }
        state.pos += 1;
        return true;
      }
      start = state.pos + 1;
      match2 = start;
      while ((match2 = state.src.indexOf("$", match2)) !== -1) {
        pos = match2 - 1;
        while (state.src[pos] === "\\") {
          pos -= 1;
        }
        if ((match2 - pos) % 2 == 1) {
          break;
        }
        match2 += 1;
      }
      if (match2 === -1) {
        if (!silent) {
          state.pending += "$";
        }
        state.pos = start;
        return true;
      }
      if (match2 - start === 0) {
        if (!silent) {
          state.pending += "$$";
        }
        state.pos = start + 1;
        return true;
      }
      res = isValidDelim(state, match2);
      if (!res.can_close) {
        if (!silent) {
          state.pending += "$";
        }
        state.pos = start;
        return true;
      }
      if (!silent) {
        token = state.push("math_inline", "math", 0);
        token.markup = "$";
        token.content = state.src.slice(start, match2);
      }
      state.pos = match2 + 1;
      return true;
    }
    function math_block(state, start, end2, silent) {
      var firstLine, lastLine, next2, lastPos, found = false, token, pos = state.bMarks[start] + state.tShift[start], max = state.eMarks[start];
      if (pos + 2 > max) {
        return false;
      }
      if (state.src.slice(pos, pos + 2) !== "$$") {
        return false;
      }
      pos += 2;
      firstLine = state.src.slice(pos, max);
      if (silent) {
        return true;
      }
      if (firstLine.trim().slice(-2) === "$$") {
        firstLine = firstLine.trim().slice(0, -2);
        found = true;
      }
      for (next2 = start; !found; ) {
        next2++;
        if (next2 >= end2) {
          break;
        }
        pos = state.bMarks[next2] + state.tShift[next2];
        max = state.eMarks[next2];
        if (pos < max && state.tShift[next2] < state.blkIndent) {
          break;
        }
        if (state.src.slice(pos, max).trim().slice(-2) === "$$") {
          lastPos = state.src.slice(0, max).lastIndexOf("$$");
          lastLine = state.src.slice(pos, lastPos);
          found = true;
        }
      }
      state.line = next2 + 1;
      token = state.push("math_block", "math", 0);
      token.block = true;
      token.content = (firstLine && firstLine.trim() ? firstLine + "\n" : "") + state.getLines(start + 1, next2, state.tShift[start], true) + (lastLine && lastLine.trim() ? lastLine : "");
      token.map = [start, state.line];
      token.markup = "$$";
      return true;
    }
    function escapeHtml2(unsafe) {
      return unsafe.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
    }
    module.exports = function math_plugin(md, options) {
      options = options || {};
      var katexInline = function(latex) {
        options.displayMode = false;
        try {
          return katex.renderToString(latex, options);
        } catch (error2) {
          if (options.throwOnError) {
            console.log(error2);
          }
          return `<span class='katex-error' title='${escapeHtml2(error2.toString())}'>${escapeHtml2(latex)}</span>`;
        }
      };
      var inlineRenderer = function(tokens, idx) {
        return katexInline(tokens[idx].content);
      };
      var katexBlock = function(latex) {
        options.displayMode = true;
        try {
          return "<p class='katex-block'>" + katex.renderToString(latex, options) + "</p>";
        } catch (error2) {
          if (options.throwOnError) {
            console.log(error2);
          }
          return `<p class='katex-block katex-error' title='${escapeHtml2(error2.toString())}'>${escapeHtml2(latex)}</p>`;
        }
      };
      var blockRenderer = function(tokens, idx) {
        return katexBlock(tokens[idx].content) + "\n";
      };
      md.inline.ruler.after("escape", "math_inline", math_inline);
      md.block.ruler.after("blockquote", "math_block", math_block, {
        alt: ["paragraph", "reference", "blockquote", "list"]
      });
      md.renderer.rules.math_inline = inlineRenderer;
      md.renderer.rules.math_block = blockRenderer;
    };
  }
});

// node_modules/.pnpm/cheerio@1.0.0-rc.12/node_modules/cheerio/lib/esm/options.js
var defaultOpts = {
  xml: false,
  decodeEntities: true
};
var options_default = defaultOpts;
var xmlModeDefault = {
  _useHtmlParser2: true,
  xmlMode: true
};
function flatten(options) {
  return (options === null || options === void 0 ? void 0 : options.xml) ? typeof options.xml === "boolean" ? xmlModeDefault : { ...xmlModeDefault, ...options.xml } : options !== null && options !== void 0 ? options : void 0;
}

// node_modules/.pnpm/cheerio@1.0.0-rc.12/node_modules/cheerio/lib/esm/static.js
var static_exports = {};
__export(static_exports, {
  contains: () => contains,
  html: () => html,
  merge: () => merge,
  parseHTML: () => parseHTML,
  root: () => root,
  text: () => text,
  xml: () => xml
});

// node_modules/.pnpm/domutils@3.1.0/node_modules/domutils/lib/esm/index.js
var esm_exports2 = {};
__export(esm_exports2, {
  DocumentPosition: () => DocumentPosition,
  append: () => append,
  appendChild: () => appendChild,
  compareDocumentPosition: () => compareDocumentPosition,
  existsOne: () => existsOne,
  filter: () => filter,
  find: () => find,
  findAll: () => findAll,
  findOne: () => findOne,
  findOneChild: () => findOneChild,
  getAttributeValue: () => getAttributeValue,
  getChildren: () => getChildren,
  getElementById: () => getElementById,
  getElements: () => getElements,
  getElementsByTagName: () => getElementsByTagName,
  getElementsByTagType: () => getElementsByTagType,
  getFeed: () => getFeed,
  getInnerHTML: () => getInnerHTML,
  getName: () => getName,
  getOuterHTML: () => getOuterHTML,
  getParent: () => getParent,
  getSiblings: () => getSiblings,
  getText: () => getText,
  hasAttrib: () => hasAttrib,
  hasChildren: () => hasChildren,
  innerText: () => innerText,
  isCDATA: () => isCDATA,
  isComment: () => isComment,
  isDocument: () => isDocument,
  isTag: () => isTag2,
  isText: () => isText,
  nextElementSibling: () => nextElementSibling,
  prepend: () => prepend,
  prependChild: () => prependChild,
  prevElementSibling: () => prevElementSibling,
  removeElement: () => removeElement,
  removeSubsets: () => removeSubsets,
  replaceElement: () => replaceElement,
  testElement: () => testElement,
  textContent: () => textContent,
  uniqueSort: () => uniqueSort
});

// node_modules/.pnpm/domelementtype@2.3.0/node_modules/domelementtype/lib/esm/index.js
var esm_exports = {};
__export(esm_exports, {
  CDATA: () => CDATA,
  Comment: () => Comment,
  Directive: () => Directive,
  Doctype: () => Doctype,
  ElementType: () => ElementType,
  Root: () => Root,
  Script: () => Script,
  Style: () => Style,
  Tag: () => Tag,
  Text: () => Text,
  isTag: () => isTag
});
var ElementType;
(function(ElementType2) {
  ElementType2["Root"] = "root";
  ElementType2["Text"] = "text";
  ElementType2["Directive"] = "directive";
  ElementType2["Comment"] = "comment";
  ElementType2["Script"] = "script";
  ElementType2["Style"] = "style";
  ElementType2["Tag"] = "tag";
  ElementType2["CDATA"] = "cdata";
  ElementType2["Doctype"] = "doctype";
})(ElementType || (ElementType = {}));
function isTag(elem) {
  return elem.type === ElementType.Tag || elem.type === ElementType.Script || elem.type === ElementType.Style;
}
var Root = ElementType.Root;
var Text = ElementType.Text;
var Directive = ElementType.Directive;
var Comment = ElementType.Comment;
var Script = ElementType.Script;
var Style = ElementType.Style;
var Tag = ElementType.Tag;
var CDATA = ElementType.CDATA;
var Doctype = ElementType.Doctype;

// node_modules/.pnpm/domhandler@5.0.3/node_modules/domhandler/lib/esm/node.js
var Node = class {
  constructor() {
    this.parent = null;
    this.prev = null;
    this.next = null;
    this.startIndex = null;
    this.endIndex = null;
  }
  // Read-write aliases for properties
  /**
   * Same as {@link parent}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get parentNode() {
    return this.parent;
  }
  set parentNode(parent2) {
    this.parent = parent2;
  }
  /**
   * Same as {@link prev}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get previousSibling() {
    return this.prev;
  }
  set previousSibling(prev2) {
    this.prev = prev2;
  }
  /**
   * Same as {@link next}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get nextSibling() {
    return this.next;
  }
  set nextSibling(next2) {
    this.next = next2;
  }
  /**
   * Clone this node, and optionally its children.
   *
   * @param recursive Clone child nodes as well.
   * @returns A clone of the node.
   */
  cloneNode(recursive = false) {
    return cloneNode(this, recursive);
  }
};
var DataNode = class extends Node {
  /**
   * @param data The content of the data node
   */
  constructor(data2) {
    super();
    this.data = data2;
  }
  /**
   * Same as {@link data}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get nodeValue() {
    return this.data;
  }
  set nodeValue(data2) {
    this.data = data2;
  }
};
var Text2 = class extends DataNode {
  constructor() {
    super(...arguments);
    this.type = ElementType.Text;
  }
  get nodeType() {
    return 3;
  }
};
var Comment2 = class extends DataNode {
  constructor() {
    super(...arguments);
    this.type = ElementType.Comment;
  }
  get nodeType() {
    return 8;
  }
};
var ProcessingInstruction = class extends DataNode {
  constructor(name2, data2) {
    super(data2);
    this.name = name2;
    this.type = ElementType.Directive;
  }
  get nodeType() {
    return 1;
  }
};
var NodeWithChildren = class extends Node {
  /**
   * @param children Children of the node. Only certain node types can have children.
   */
  constructor(children2) {
    super();
    this.children = children2;
  }
  // Aliases
  /** First child of the node. */
  get firstChild() {
    var _a2;
    return (_a2 = this.children[0]) !== null && _a2 !== void 0 ? _a2 : null;
  }
  /** Last child of the node. */
  get lastChild() {
    return this.children.length > 0 ? this.children[this.children.length - 1] : null;
  }
  /**
   * Same as {@link children}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get childNodes() {
    return this.children;
  }
  set childNodes(children2) {
    this.children = children2;
  }
};
var CDATA2 = class extends NodeWithChildren {
  constructor() {
    super(...arguments);
    this.type = ElementType.CDATA;
  }
  get nodeType() {
    return 4;
  }
};
var Document = class extends NodeWithChildren {
  constructor() {
    super(...arguments);
    this.type = ElementType.Root;
  }
  get nodeType() {
    return 9;
  }
};
var Element = class extends NodeWithChildren {
  /**
   * @param name Name of the tag, eg. `div`, `span`.
   * @param attribs Object mapping attribute names to attribute values.
   * @param children Children of the node.
   */
  constructor(name2, attribs, children2 = [], type2 = name2 === "script" ? ElementType.Script : name2 === "style" ? ElementType.Style : ElementType.Tag) {
    super(children2);
    this.name = name2;
    this.attribs = attribs;
    this.type = type2;
  }
  get nodeType() {
    return 1;
  }
  // DOM Level 1 aliases
  /**
   * Same as {@link name}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get tagName() {
    return this.name;
  }
  set tagName(name2) {
    this.name = name2;
  }
  get attributes() {
    return Object.keys(this.attribs).map((name2) => {
      var _a2, _b;
      return {
        name: name2,
        value: this.attribs[name2],
        namespace: (_a2 = this["x-attribsNamespace"]) === null || _a2 === void 0 ? void 0 : _a2[name2],
        prefix: (_b = this["x-attribsPrefix"]) === null || _b === void 0 ? void 0 : _b[name2]
      };
    });
  }
};
function isTag2(node) {
  return isTag(node);
}
function isCDATA(node) {
  return node.type === ElementType.CDATA;
}
function isText(node) {
  return node.type === ElementType.Text;
}
function isComment(node) {
  return node.type === ElementType.Comment;
}
function isDirective(node) {
  return node.type === ElementType.Directive;
}
function isDocument(node) {
  return node.type === ElementType.Root;
}
function hasChildren(node) {
  return Object.prototype.hasOwnProperty.call(node, "children");
}
function cloneNode(node, recursive = false) {
  let result;
  if (isText(node)) {
    result = new Text2(node.data);
  } else if (isComment(node)) {
    result = new Comment2(node.data);
  } else if (isTag2(node)) {
    const children2 = recursive ? cloneChildren(node.children) : [];
    const clone2 = new Element(node.name, { ...node.attribs }, children2);
    children2.forEach((child) => child.parent = clone2);
    if (node.namespace != null) {
      clone2.namespace = node.namespace;
    }
    if (node["x-attribsNamespace"]) {
      clone2["x-attribsNamespace"] = { ...node["x-attribsNamespace"] };
    }
    if (node["x-attribsPrefix"]) {
      clone2["x-attribsPrefix"] = { ...node["x-attribsPrefix"] };
    }
    result = clone2;
  } else if (isCDATA(node)) {
    const children2 = recursive ? cloneChildren(node.children) : [];
    const clone2 = new CDATA2(children2);
    children2.forEach((child) => child.parent = clone2);
    result = clone2;
  } else if (isDocument(node)) {
    const children2 = recursive ? cloneChildren(node.children) : [];
    const clone2 = new Document(children2);
    children2.forEach((child) => child.parent = clone2);
    if (node["x-mode"]) {
      clone2["x-mode"] = node["x-mode"];
    }
    result = clone2;
  } else if (isDirective(node)) {
    const instruction = new ProcessingInstruction(node.name, node.data);
    if (node["x-name"] != null) {
      instruction["x-name"] = node["x-name"];
      instruction["x-publicId"] = node["x-publicId"];
      instruction["x-systemId"] = node["x-systemId"];
    }
    result = instruction;
  } else {
    throw new Error(`Not implemented yet: ${node.type}`);
  }
  result.startIndex = node.startIndex;
  result.endIndex = node.endIndex;
  if (node.sourceCodeLocation != null) {
    result.sourceCodeLocation = node.sourceCodeLocation;
  }
  return result;
}
function cloneChildren(childs) {
  const children2 = childs.map((child) => cloneNode(child, true));
  for (let i = 1; i < children2.length; i++) {
    children2[i].prev = children2[i - 1];
    children2[i - 1].next = children2[i];
  }
  return children2;
}

// node_modules/.pnpm/domhandler@5.0.3/node_modules/domhandler/lib/esm/index.js
var defaultOpts2 = {
  withStartIndices: false,
  withEndIndices: false,
  xmlMode: false
};
var DomHandler = class {
  /**
   * @param callback Called once parsing has completed.
   * @param options Settings for the handler.
   * @param elementCB Callback whenever a tag is closed.
   */
  constructor(callback, options, elementCB) {
    this.dom = [];
    this.root = new Document(this.dom);
    this.done = false;
    this.tagStack = [this.root];
    this.lastNode = null;
    this.parser = null;
    if (typeof options === "function") {
      elementCB = options;
      options = defaultOpts2;
    }
    if (typeof callback === "object") {
      options = callback;
      callback = void 0;
    }
    this.callback = callback !== null && callback !== void 0 ? callback : null;
    this.options = options !== null && options !== void 0 ? options : defaultOpts2;
    this.elementCB = elementCB !== null && elementCB !== void 0 ? elementCB : null;
  }
  onparserinit(parser) {
    this.parser = parser;
  }
  // Resets the handler back to starting state
  onreset() {
    this.dom = [];
    this.root = new Document(this.dom);
    this.done = false;
    this.tagStack = [this.root];
    this.lastNode = null;
    this.parser = null;
  }
  // Signals the handler that parsing is done
  onend() {
    if (this.done)
      return;
    this.done = true;
    this.parser = null;
    this.handleCallback(null);
  }
  onerror(error2) {
    this.handleCallback(error2);
  }
  onclosetag() {
    this.lastNode = null;
    const elem = this.tagStack.pop();
    if (this.options.withEndIndices) {
      elem.endIndex = this.parser.endIndex;
    }
    if (this.elementCB)
      this.elementCB(elem);
  }
  onopentag(name2, attribs) {
    const type2 = this.options.xmlMode ? ElementType.Tag : void 0;
    const element = new Element(name2, attribs, void 0, type2);
    this.addNode(element);
    this.tagStack.push(element);
  }
  ontext(data2) {
    const { lastNode } = this;
    if (lastNode && lastNode.type === ElementType.Text) {
      lastNode.data += data2;
      if (this.options.withEndIndices) {
        lastNode.endIndex = this.parser.endIndex;
      }
    } else {
      const node = new Text2(data2);
      this.addNode(node);
      this.lastNode = node;
    }
  }
  oncomment(data2) {
    if (this.lastNode && this.lastNode.type === ElementType.Comment) {
      this.lastNode.data += data2;
      return;
    }
    const node = new Comment2(data2);
    this.addNode(node);
    this.lastNode = node;
  }
  oncommentend() {
    this.lastNode = null;
  }
  oncdatastart() {
    const text4 = new Text2("");
    const node = new CDATA2([text4]);
    this.addNode(node);
    text4.parent = node;
    this.lastNode = text4;
  }
  oncdataend() {
    this.lastNode = null;
  }
  onprocessinginstruction(name2, data2) {
    const node = new ProcessingInstruction(name2, data2);
    this.addNode(node);
  }
  handleCallback(error2) {
    if (typeof this.callback === "function") {
      this.callback(error2, this.dom);
    } else if (error2) {
      throw error2;
    }
  }
  addNode(node) {
    const parent2 = this.tagStack[this.tagStack.length - 1];
    const previousSibling = parent2.children[parent2.children.length - 1];
    if (this.options.withStartIndices) {
      node.startIndex = this.parser.startIndex;
    }
    if (this.options.withEndIndices) {
      node.endIndex = this.parser.endIndex;
    }
    parent2.children.push(node);
    if (previousSibling) {
      node.prev = previousSibling;
      previousSibling.next = node;
    }
    node.parent = parent2;
    this.lastNode = null;
  }
};

// node_modules/.pnpm/entities@4.5.0/node_modules/entities/lib/esm/generated/decode-data-html.js
var decode_data_html_default = new Uint16Array(
  // prettier-ignore
  'ᵁ<Õıʊҝջאٵ۞ޢߖࠏ੊ઑඡ๭༉༦჊ረዡᐕᒝᓃᓟᔥ\0\0\0\0\0\0ᕫᛍᦍᰒᷝ὾⁠↰⊍⏀⏻⑂⠤⤒ⴈ⹈⿎〖㊺㘹㞬㣾㨨㩱㫠㬮ࠀEMabcfglmnoprstu\\bfms¦³¹ÈÏlig耻Æ䃆P耻&䀦cute耻Á䃁reve;䄂Āiyx}rc耻Â䃂;䐐r;쀀𝔄rave耻À䃀pha;䎑acr;䄀d;橓Āgp¡on;䄄f;쀀𝔸plyFunction;恡ing耻Å䃅Ācs¾Ãr;쀀𝒜ign;扔ilde耻Ã䃃ml耻Ä䃄ЀaceforsuåûþėĜĢħĪĀcrêòkslash;或Ŷöø;櫧ed;挆y;䐑ƀcrtąċĔause;戵noullis;愬a;䎒r;쀀𝔅pf;쀀𝔹eve;䋘còēmpeq;扎܀HOacdefhilorsuōőŖƀƞƢƵƷƺǜȕɳɸɾcy;䐧PY耻©䂩ƀcpyŝŢźute;䄆Ā;iŧŨ拒talDifferentialD;慅leys;愭ȀaeioƉƎƔƘron;䄌dil耻Ç䃇rc;䄈nint;戰ot;䄊ĀdnƧƭilla;䂸terDot;䂷òſi;䎧rcleȀDMPTǇǋǑǖot;抙inus;抖lus;投imes;抗oĀcsǢǸkwiseContourIntegral;戲eCurlyĀDQȃȏoubleQuote;思uote;怙ȀlnpuȞȨɇɕonĀ;eȥȦ户;橴ƀgitȯȶȺruent;扡nt;戯ourIntegral;戮ĀfrɌɎ;愂oduct;成nterClockwiseContourIntegral;戳oss;樯cr;쀀𝒞pĀ;Cʄʅ拓ap;才րDJSZacefiosʠʬʰʴʸˋ˗ˡ˦̳ҍĀ;oŹʥtrahd;椑cy;䐂cy;䐅cy;䐏ƀgrsʿ˄ˇger;怡r;憡hv;櫤Āayː˕ron;䄎;䐔lĀ;t˝˞戇a;䎔r;쀀𝔇Āaf˫̧Ācm˰̢riticalȀADGT̖̜̀̆cute;䂴oŴ̋̍;䋙bleAcute;䋝rave;䁠ilde;䋜ond;拄ferentialD;慆Ѱ̽\0\0\0͔͂\0Ѕf;쀀𝔻ƀ;DE͈͉͍䂨ot;惜qual;扐blèCDLRUVͣͲ΂ϏϢϸontourIntegraìȹoɴ͹\0\0ͻ»͉nArrow;懓Āeo·ΤftƀARTΐΖΡrrow;懐ightArrow;懔eåˊngĀLRΫτeftĀARγιrrow;柸ightArrow;柺ightArrow;柹ightĀATϘϞrrow;懒ee;抨pɁϩ\0\0ϯrrow;懑ownArrow;懕erticalBar;戥ǹABLRTaВЪаўѿͼrrowƀ;BUНОТ憓ar;椓pArrow;懵reve;䌑eft˒к\0ц\0ѐightVector;楐eeVector;楞ectorĀ;Bљњ憽ar;楖ightǔѧ\0ѱeeVector;楟ectorĀ;BѺѻ懁ar;楗eeĀ;A҆҇护rrow;憧ĀctҒҗr;쀀𝒟rok;䄐ࠀNTacdfglmopqstuxҽӀӄӋӞӢӧӮӵԡԯԶՒ՝ՠեG;䅊H耻Ð䃐cute耻É䃉ƀaiyӒӗӜron;䄚rc耻Ê䃊;䐭ot;䄖r;쀀𝔈rave耻È䃈ement;戈ĀapӺӾcr;䄒tyɓԆ\0\0ԒmallSquare;旻erySmallSquare;斫ĀgpԦԪon;䄘f;쀀𝔼silon;䎕uĀaiԼՉlĀ;TՂՃ橵ilde;扂librium;懌Āci՗՚r;愰m;橳a;䎗ml耻Ë䃋Āipժկsts;戃onentialE;慇ʀcfiosօֈ֍ֲ׌y;䐤r;쀀𝔉lledɓ֗\0\0֣mallSquare;旼erySmallSquare;斪Ͱֺ\0ֿ\0\0ׄf;쀀𝔽All;戀riertrf;愱cò׋؀JTabcdfgorstר׬ׯ׺؀ؒؖ؛؝أ٬ٲcy;䐃耻>䀾mmaĀ;d׷׸䎓;䏜reve;䄞ƀeiy؇،ؐdil;䄢rc;䄜;䐓ot;䄠r;쀀𝔊;拙pf;쀀𝔾eater̀EFGLSTصلَٖٛ٦qualĀ;Lؾؿ扥ess;招ullEqual;执reater;檢ess;扷lantEqual;橾ilde;扳cr;쀀𝒢;扫ЀAacfiosuڅڋږڛڞڪھۊRDcy;䐪Āctڐڔek;䋇;䁞irc;䄤r;愌lbertSpace;愋ǰگ\0ڲf;愍izontalLine;攀Āctۃۅòکrok;䄦mpńېۘownHumðįqual;扏܀EJOacdfgmnostuۺ۾܃܇܎ܚܞܡܨ݄ݸދޏޕcy;䐕lig;䄲cy;䐁cute耻Í䃍Āiyܓܘrc耻Î䃎;䐘ot;䄰r;愑rave耻Ì䃌ƀ;apܠܯܿĀcgܴܷr;䄪inaryI;慈lieóϝǴ݉\0ݢĀ;eݍݎ戬Āgrݓݘral;戫section;拂isibleĀCTݬݲomma;恣imes;恢ƀgptݿރވon;䄮f;쀀𝕀a;䎙cr;愐ilde;䄨ǫޚ\0ޞcy;䐆l耻Ï䃏ʀcfosuެ޷޼߂ߐĀiyޱ޵rc;䄴;䐙r;쀀𝔍pf;쀀𝕁ǣ߇\0ߌr;쀀𝒥rcy;䐈kcy;䐄΀HJacfosߤߨ߽߬߱ࠂࠈcy;䐥cy;䐌ppa;䎚Āey߶߻dil;䄶;䐚r;쀀𝔎pf;쀀𝕂cr;쀀𝒦րJTaceflmostࠥࠩࠬࡐࡣ঳সে্਷ੇcy;䐉耻<䀼ʀcmnpr࠷࠼ࡁࡄࡍute;䄹bda;䎛g;柪lacetrf;愒r;憞ƀaeyࡗ࡜ࡡron;䄽dil;䄻;䐛Āfsࡨ॰tԀACDFRTUVarࡾࢩࢱࣦ࣠ࣼयज़ΐ४Ānrࢃ࢏gleBracket;柨rowƀ;BR࢙࢚࢞憐ar;懤ightArrow;懆eiling;挈oǵࢷ\0ࣃbleBracket;柦nǔࣈ\0࣒eeVector;楡ectorĀ;Bࣛࣜ懃ar;楙loor;挊ightĀAV࣯ࣵrrow;憔ector;楎Āerँगeƀ;AVउऊऐ抣rrow;憤ector;楚iangleƀ;BEतथऩ抲ar;槏qual;抴pƀDTVषूौownVector;楑eeVector;楠ectorĀ;Bॖॗ憿ar;楘ectorĀ;B॥०憼ar;楒ightáΜs̀EFGLSTॾঋকঝঢভqualGreater;拚ullEqual;扦reater;扶ess;檡lantEqual;橽ilde;扲r;쀀𝔏Ā;eঽা拘ftarrow;懚idot;䄿ƀnpw৔ਖਛgȀLRlr৞৷ਂਐeftĀAR০৬rrow;柵ightArrow;柷ightArrow;柶eftĀarγਊightáοightáϊf;쀀𝕃erĀLRਢਬeftArrow;憙ightArrow;憘ƀchtਾੀੂòࡌ;憰rok;䅁;扪Ѐacefiosuਗ਼੝੠੷੼અઋ઎p;椅y;䐜Ādl੥੯iumSpace;恟lintrf;愳r;쀀𝔐nusPlus;戓pf;쀀𝕄cò੶;䎜ҀJacefostuણધભીଔଙඑ඗ඞcy;䐊cute;䅃ƀaey઴હાron;䅇dil;䅅;䐝ƀgswે૰଎ativeƀMTV૓૟૨ediumSpace;怋hiĀcn૦૘ë૙eryThiî૙tedĀGL૸ଆreaterGreateòٳessLesóੈLine;䀊r;쀀𝔑ȀBnptଢନଷ଺reak;恠BreakingSpace;䂠f;愕ڀ;CDEGHLNPRSTV୕ୖ୪୼஡௫ఄ౞಄ದ೘ൡඅ櫬Āou୛୤ngruent;扢pCap;扭oubleVerticalBar;戦ƀlqxஃஊ஛ement;戉ualĀ;Tஒஓ扠ilde;쀀≂̸ists;戄reater΀;EFGLSTஶஷ஽௉௓௘௥扯qual;扱ullEqual;쀀≧̸reater;쀀≫̸ess;批lantEqual;쀀⩾̸ilde;扵umpń௲௽ownHump;쀀≎̸qual;쀀≏̸eĀfsఊధtTriangleƀ;BEచఛడ拪ar;쀀⧏̸qual;括s̀;EGLSTవశ఼ౄోౘ扮qual;扰reater;扸ess;쀀≪̸lantEqual;쀀⩽̸ilde;扴estedĀGL౨౹reaterGreater;쀀⪢̸essLess;쀀⪡̸recedesƀ;ESಒಓಛ技qual;쀀⪯̸lantEqual;拠ĀeiಫಹverseElement;戌ghtTriangleƀ;BEೋೌ೒拫ar;쀀⧐̸qual;拭ĀquೝഌuareSuĀbp೨೹setĀ;E೰ೳ쀀⊏̸qual;拢ersetĀ;Eഃആ쀀⊐̸qual;拣ƀbcpഓതൎsetĀ;Eഛഞ쀀⊂⃒qual;抈ceedsȀ;ESTലള഻െ抁qual;쀀⪰̸lantEqual;拡ilde;쀀≿̸ersetĀ;E൘൛쀀⊃⃒qual;抉ildeȀ;EFT൮൯൵ൿ扁qual;扄ullEqual;扇ilde;扉erticalBar;戤cr;쀀𝒩ilde耻Ñ䃑;䎝܀Eacdfgmoprstuvලෂ෉෕ෛ෠෧෼ขภยา฿ไlig;䅒cute耻Ó䃓Āiy෎ීrc耻Ô䃔;䐞blac;䅐r;쀀𝔒rave耻Ò䃒ƀaei෮ෲ෶cr;䅌ga;䎩cron;䎟pf;쀀𝕆enCurlyĀDQฎบoubleQuote;怜uote;怘;橔Āclวฬr;쀀𝒪ash耻Ø䃘iŬื฼de耻Õ䃕es;樷ml耻Ö䃖erĀBP๋๠Āar๐๓r;怾acĀek๚๜;揞et;掴arenthesis;揜Ҁacfhilors๿ງຊຏຒດຝະ໼rtialD;戂y;䐟r;쀀𝔓i;䎦;䎠usMinus;䂱Āipຢອncareplanåڝf;愙Ȁ;eio຺ູ໠໤檻cedesȀ;EST່້໏໚扺qual;檯lantEqual;扼ilde;找me;怳Ādp໩໮uct;戏ortionĀ;aȥ໹l;戝Āci༁༆r;쀀𝒫;䎨ȀUfos༑༖༛༟OT耻"䀢r;쀀𝔔pf;愚cr;쀀𝒬؀BEacefhiorsu༾གྷཇའཱིྦྷྪྭ႖ႩႴႾarr;椐G耻®䂮ƀcnrཎནབute;䅔g;柫rĀ;tཛྷཝ憠l;椖ƀaeyཧཬཱron;䅘dil;䅖;䐠Ā;vླྀཹ愜erseĀEUྂྙĀlq྇ྎement;戋uilibrium;懋pEquilibrium;楯r»ཹo;䎡ghtЀACDFTUVa࿁࿫࿳ဢဨၛႇϘĀnr࿆࿒gleBracket;柩rowƀ;BL࿜࿝࿡憒ar;懥eftArrow;懄eiling;按oǵ࿹\0စbleBracket;柧nǔည\0နeeVector;楝ectorĀ;Bဝသ懂ar;楕loor;挋Āerိ၃eƀ;AVဵံြ抢rrow;憦ector;楛iangleƀ;BEၐၑၕ抳ar;槐qual;抵pƀDTVၣၮၸownVector;楏eeVector;楜ectorĀ;Bႂႃ憾ar;楔ectorĀ;B႑႒懀ar;楓Āpuႛ႞f;愝ndImplies;楰ightarrow;懛ĀchႹႼr;愛;憱leDelayed;槴ڀHOacfhimoqstuფჱჷჽᄙᄞᅑᅖᅡᅧᆵᆻᆿĀCcჩხHcy;䐩y;䐨FTcy;䐬cute;䅚ʀ;aeiyᄈᄉᄎᄓᄗ檼ron;䅠dil;䅞rc;䅜;䐡r;쀀𝔖ortȀDLRUᄪᄴᄾᅉownArrow»ОeftArrow»࢚ightArrow»࿝pArrow;憑gma;䎣allCircle;战pf;쀀𝕊ɲᅭ\0\0ᅰt;戚areȀ;ISUᅻᅼᆉᆯ斡ntersection;抓uĀbpᆏᆞsetĀ;Eᆗᆘ抏qual;抑ersetĀ;Eᆨᆩ抐qual;抒nion;抔cr;쀀𝒮ar;拆ȀbcmpᇈᇛሉላĀ;sᇍᇎ拐etĀ;Eᇍᇕqual;抆ĀchᇠህeedsȀ;ESTᇭᇮᇴᇿ扻qual;檰lantEqual;扽ilde;承Tháྌ;我ƀ;esሒሓሣ拑rsetĀ;Eሜም抃qual;抇et»ሓրHRSacfhiorsሾቄ቉ቕ቞ቱቶኟዂወዑORN耻Þ䃞ADE;愢ĀHc቎ቒcy;䐋y;䐦Ābuቚቜ;䀉;䎤ƀaeyብቪቯron;䅤dil;䅢;䐢r;쀀𝔗Āeiቻ኉ǲኀ\0ኇefore;戴a;䎘Ācn኎ኘkSpace;쀀  Space;怉ldeȀ;EFTካኬኲኼ戼qual;扃ullEqual;扅ilde;扈pf;쀀𝕋ipleDot;惛Āctዖዛr;쀀𝒯rok;䅦ૡዷጎጚጦ\0ጬጱ\0\0\0\0\0ጸጽ፷ᎅ\0᏿ᐄᐊᐐĀcrዻጁute耻Ú䃚rĀ;oጇገ憟cir;楉rǣጓ\0጖y;䐎ve;䅬Āiyጞጣrc耻Û䃛;䐣blac;䅰r;쀀𝔘rave耻Ù䃙acr;䅪Ādiፁ፩erĀBPፈ፝Āarፍፐr;䁟acĀekፗፙ;揟et;掵arenthesis;揝onĀ;P፰፱拃lus;抎Āgp፻፿on;䅲f;쀀𝕌ЀADETadps᎕ᎮᎸᏄϨᏒᏗᏳrrowƀ;BDᅐᎠᎤar;椒ownArrow;懅ownArrow;憕quilibrium;楮eeĀ;AᏋᏌ报rrow;憥ownáϳerĀLRᏞᏨeftArrow;憖ightArrow;憗iĀ;lᏹᏺ䏒on;䎥ing;䅮cr;쀀𝒰ilde;䅨ml耻Ü䃜ҀDbcdefosvᐧᐬᐰᐳᐾᒅᒊᒐᒖash;披ar;櫫y;䐒ashĀ;lᐻᐼ抩;櫦Āerᑃᑅ;拁ƀbtyᑌᑐᑺar;怖Ā;iᑏᑕcalȀBLSTᑡᑥᑪᑴar;戣ine;䁼eparator;杘ilde;所ThinSpace;怊r;쀀𝔙pf;쀀𝕍cr;쀀𝒱dash;抪ʀcefosᒧᒬᒱᒶᒼirc;䅴dge;拀r;쀀𝔚pf;쀀𝕎cr;쀀𝒲Ȁfiosᓋᓐᓒᓘr;쀀𝔛;䎞pf;쀀𝕏cr;쀀𝒳ҀAIUacfosuᓱᓵᓹᓽᔄᔏᔔᔚᔠcy;䐯cy;䐇cy;䐮cute耻Ý䃝Āiyᔉᔍrc;䅶;䐫r;쀀𝔜pf;쀀𝕐cr;쀀𝒴ml;䅸ЀHacdefosᔵᔹᔿᕋᕏᕝᕠᕤcy;䐖cute;䅹Āayᕄᕉron;䅽;䐗ot;䅻ǲᕔ\0ᕛoWidtè૙a;䎖r;愨pf;愤cr;쀀𝒵௡ᖃᖊᖐ\0ᖰᖶᖿ\0\0\0\0ᗆᗛᗫᙟ᙭\0ᚕ᚛ᚲᚹ\0ᚾcute耻á䃡reve;䄃̀;Ediuyᖜᖝᖡᖣᖨᖭ戾;쀀∾̳;房rc耻â䃢te肻´̆;䐰lig耻æ䃦Ā;r²ᖺ;쀀𝔞rave耻à䃠ĀepᗊᗖĀfpᗏᗔsym;愵èᗓha;䎱ĀapᗟcĀclᗤᗧr;䄁g;樿ɤᗰ\0\0ᘊʀ;adsvᗺᗻᗿᘁᘇ戧nd;橕;橜lope;橘;橚΀;elmrszᘘᘙᘛᘞᘿᙏᙙ戠;榤e»ᘙsdĀ;aᘥᘦ戡ѡᘰᘲᘴᘶᘸᘺᘼᘾ;榨;榩;榪;榫;榬;榭;榮;榯tĀ;vᙅᙆ戟bĀ;dᙌᙍ抾;榝Āptᙔᙗh;戢»¹arr;捼Āgpᙣᙧon;䄅f;쀀𝕒΀;Eaeiop዁ᙻᙽᚂᚄᚇᚊ;橰cir;橯;扊d;手s;䀧roxĀ;e዁ᚒñᚃing耻å䃥ƀctyᚡᚦᚨr;쀀𝒶;䀪mpĀ;e዁ᚯñʈilde耻ã䃣ml耻ä䃤Āciᛂᛈoninôɲnt;樑ࠀNabcdefiklnoprsu᛭ᛱᜰ᜼ᝃᝈ᝸᝽០៦ᠹᡐᜍ᤽᥈ᥰot;櫭Ācrᛶ᜞kȀcepsᜀᜅᜍᜓong;扌psilon;䏶rime;怵imĀ;e᜚᜛戽q;拍Ŷᜢᜦee;抽edĀ;gᜬᜭ挅e»ᜭrkĀ;t፜᜷brk;掶Āoyᜁᝁ;䐱quo;怞ʀcmprtᝓ᝛ᝡᝤᝨausĀ;eĊĉptyv;榰séᜌnoõēƀahwᝯ᝱ᝳ;䎲;愶een;扬r;쀀𝔟g΀costuvwឍឝឳេ៕៛៞ƀaiuបពរðݠrc;旯p»፱ƀdptឤឨឭot;樀lus;樁imes;樂ɱឹ\0\0ើcup;樆ar;昅riangleĀdu៍្own;施p;斳plus;樄eåᑄåᒭarow;植ƀako៭ᠦᠵĀcn៲ᠣkƀlst៺֫᠂ozenge;槫riangleȀ;dlr᠒᠓᠘᠝斴own;斾eft;旂ight;斸k;搣Ʊᠫ\0ᠳƲᠯ\0ᠱ;斒;斑4;斓ck;斈ĀeoᠾᡍĀ;qᡃᡆ쀀=⃥uiv;쀀≡⃥t;挐Ȁptwxᡙᡞᡧᡬf;쀀𝕓Ā;tᏋᡣom»Ꮜtie;拈؀DHUVbdhmptuvᢅᢖᢪᢻᣗᣛᣬ᣿ᤅᤊᤐᤡȀLRlrᢎᢐᢒᢔ;敗;敔;敖;敓ʀ;DUduᢡᢢᢤᢦᢨ敐;敦;敩;敤;敧ȀLRlrᢳᢵᢷᢹ;敝;敚;敜;教΀;HLRhlrᣊᣋᣍᣏᣑᣓᣕ救;敬;散;敠;敫;敢;敟ox;槉ȀLRlrᣤᣦᣨᣪ;敕;敒;攐;攌ʀ;DUduڽ᣷᣹᣻᣽;敥;敨;攬;攴inus;抟lus;択imes;抠ȀLRlrᤙᤛᤝ᤟;敛;敘;攘;攔΀;HLRhlrᤰᤱᤳᤵᤷ᤻᤹攂;敪;敡;敞;攼;攤;攜Āevģ᥂bar耻¦䂦Ȁceioᥑᥖᥚᥠr;쀀𝒷mi;恏mĀ;e᜚᜜lƀ;bhᥨᥩᥫ䁜;槅sub;柈Ŭᥴ᥾lĀ;e᥹᥺怢t»᥺pƀ;Eeįᦅᦇ;檮Ā;qۜۛೡᦧ\0᧨ᨑᨕᨲ\0ᨷᩐ\0\0᪴\0\0᫁\0\0ᬡᬮ᭍᭒\0᯽\0ᰌƀcpr᦭ᦲ᧝ute;䄇̀;abcdsᦿᧀᧄ᧊᧕᧙戩nd;橄rcup;橉Āau᧏᧒p;橋p;橇ot;橀;쀀∩︀Āeo᧢᧥t;恁îړȀaeiu᧰᧻ᨁᨅǰ᧵\0᧸s;橍on;䄍dil耻ç䃧rc;䄉psĀ;sᨌᨍ橌m;橐ot;䄋ƀdmnᨛᨠᨦil肻¸ƭptyv;榲t脀¢;eᨭᨮ䂢räƲr;쀀𝔠ƀceiᨽᩀᩍy;䑇ckĀ;mᩇᩈ朓ark»ᩈ;䏇r΀;Ecefms᩟᩠ᩢᩫ᪤᪪᪮旋;槃ƀ;elᩩᩪᩭ䋆q;扗eɡᩴ\0\0᪈rrowĀlr᩼᪁eft;憺ight;憻ʀRSacd᪒᪔᪖᪚᪟»ཇ;擈st;抛irc;抚ash;抝nint;樐id;櫯cir;槂ubsĀ;u᪻᪼晣it»᪼ˬ᫇᫔᫺\0ᬊonĀ;eᫍᫎ䀺Ā;qÇÆɭ᫙\0\0᫢aĀ;t᫞᫟䀬;䁀ƀ;fl᫨᫩᫫戁îᅠeĀmx᫱᫶ent»᫩eóɍǧ᫾\0ᬇĀ;dኻᬂot;橭nôɆƀfryᬐᬔᬗ;쀀𝕔oäɔ脀©;sŕᬝr;愗Āaoᬥᬩrr;憵ss;朗Ācuᬲᬷr;쀀𝒸Ābpᬼ᭄Ā;eᭁᭂ櫏;櫑Ā;eᭉᭊ櫐;櫒dot;拯΀delprvw᭠᭬᭷ᮂᮬᯔ᯹arrĀlr᭨᭪;椸;椵ɰ᭲\0\0᭵r;拞c;拟arrĀ;p᭿ᮀ憶;椽̀;bcdosᮏᮐᮖᮡᮥᮨ截rcap;橈Āauᮛᮞp;橆p;橊ot;抍r;橅;쀀∪︀Ȁalrv᮵ᮿᯞᯣrrĀ;mᮼᮽ憷;椼yƀevwᯇᯔᯘqɰᯎ\0\0ᯒreã᭳uã᭵ee;拎edge;拏en耻¤䂤earrowĀlrᯮ᯳eft»ᮀight»ᮽeäᯝĀciᰁᰇoninôǷnt;戱lcty;挭ঀAHabcdefhijlorstuwz᰸᰻᰿ᱝᱩᱵᲊᲞᲬᲷ᳻᳿ᴍᵻᶑᶫᶻ᷆᷍rò΁ar;楥Ȁglrs᱈ᱍ᱒᱔ger;怠eth;愸òᄳhĀ;vᱚᱛ怐»ऊūᱡᱧarow;椏aã̕Āayᱮᱳron;䄏;䐴ƀ;ao̲ᱼᲄĀgrʿᲁr;懊tseq;橷ƀglmᲑᲔᲘ耻°䂰ta;䎴ptyv;榱ĀirᲣᲨsht;楿;쀀𝔡arĀlrᲳᲵ»ࣜ»သʀaegsv᳂͸᳖᳜᳠mƀ;oș᳊᳔ndĀ;ș᳑uit;晦amma;䏝in;拲ƀ;io᳧᳨᳸䃷de脀÷;o᳧ᳰntimes;拇nø᳷cy;䑒cɯᴆ\0\0ᴊrn;挞op;挍ʀlptuwᴘᴝᴢᵉᵕlar;䀤f;쀀𝕕ʀ;emps̋ᴭᴷᴽᵂqĀ;d͒ᴳot;扑inus;戸lus;戔quare;抡blebarwedgåúnƀadhᄮᵝᵧownarrowóᲃarpoonĀlrᵲᵶefôᲴighôᲶŢᵿᶅkaro÷གɯᶊ\0\0ᶎrn;挟op;挌ƀcotᶘᶣᶦĀryᶝᶡ;쀀𝒹;䑕l;槶rok;䄑Ādrᶰᶴot;拱iĀ;fᶺ᠖斿Āah᷀᷃ròЩaòྦangle;榦Āci᷒ᷕy;䑟grarr;柿ऀDacdefglmnopqrstuxḁḉḙḸոḼṉṡṾấắẽỡἪἷὄ὎὚ĀDoḆᴴoôᲉĀcsḎḔute耻é䃩ter;橮ȀaioyḢḧḱḶron;䄛rĀ;cḭḮ扖耻ê䃪lon;払;䑍ot;䄗ĀDrṁṅot;扒;쀀𝔢ƀ;rsṐṑṗ檚ave耻è䃨Ā;dṜṝ檖ot;檘Ȁ;ilsṪṫṲṴ檙nters;揧;愓Ā;dṹṺ檕ot;檗ƀapsẅẉẗcr;䄓tyƀ;svẒẓẕ戅et»ẓpĀ1;ẝẤĳạả;怄;怅怃ĀgsẪẬ;䅋p;怂ĀgpẴẸon;䄙f;쀀𝕖ƀalsỄỎỒrĀ;sỊị拕l;槣us;橱iƀ;lvỚớở䎵on»ớ;䏵ȀcsuvỪỳἋἣĀioữḱrc»Ḯɩỹ\0\0ỻíՈantĀglἂἆtr»ṝess»Ṻƀaeiἒ἖Ἒls;䀽st;扟vĀ;DȵἠD;橸parsl;槥ĀDaἯἳot;打rr;楱ƀcdiἾὁỸr;愯oô͒ĀahὉὋ;䎷耻ð䃰Āmrὓὗl耻ë䃫o;悬ƀcipὡὤὧl;䀡sôծĀeoὬὴctatioîՙnentialåչৡᾒ\0ᾞ\0ᾡᾧ\0\0ῆῌ\0ΐ\0ῦῪ \0 ⁚llingdotseñṄy;䑄male;晀ƀilrᾭᾳ῁lig;耀ﬃɩᾹ\0\0᾽g;耀ﬀig;耀ﬄ;쀀𝔣lig;耀ﬁlig;쀀fjƀaltῙ῜ῡt;晭ig;耀ﬂns;斱of;䆒ǰ΅\0ῳf;쀀𝕗ĀakֿῷĀ;vῼ´拔;櫙artint;樍Āao‌⁕Ācs‑⁒α‚‰‸⁅⁈\0⁐β•‥‧‪‬\0‮耻½䂽;慓耻¼䂼;慕;慙;慛Ƴ‴\0‶;慔;慖ʴ‾⁁\0\0⁃耻¾䂾;慗;慜5;慘ƶ⁌\0⁎;慚;慝8;慞l;恄wn;挢cr;쀀𝒻ࢀEabcdefgijlnorstv₂₉₟₥₰₴⃰⃵⃺⃿℃ℒℸ̗ℾ⅒↞Ā;lٍ₇;檌ƀcmpₐₕ₝ute;䇵maĀ;dₜ᳚䎳;檆reve;䄟Āiy₪₮rc;䄝;䐳ot;䄡Ȁ;lqsؾق₽⃉ƀ;qsؾٌ⃄lanô٥Ȁ;cdl٥⃒⃥⃕c;檩otĀ;o⃜⃝檀Ā;l⃢⃣檂;檄Ā;e⃪⃭쀀⋛︀s;檔r;쀀𝔤Ā;gٳ؛mel;愷cy;䑓Ȁ;Eajٚℌℎℐ;檒;檥;檤ȀEaesℛℝ℩ℴ;扩pĀ;p℣ℤ檊rox»ℤĀ;q℮ℯ檈Ā;q℮ℛim;拧pf;쀀𝕘Āci⅃ⅆr;愊mƀ;el٫ⅎ⅐;檎;檐茀>;cdlqr׮ⅠⅪⅮⅳⅹĀciⅥⅧ;檧r;橺ot;拗Par;榕uest;橼ʀadelsↄⅪ←ٖ↛ǰ↉\0↎proø₞r;楸qĀlqؿ↖lesó₈ií٫Āen↣↭rtneqq;쀀≩︀Å↪ԀAabcefkosy⇄⇇⇱⇵⇺∘∝∯≨≽ròΠȀilmr⇐⇔⇗⇛rsðᒄf»․ilôکĀdr⇠⇤cy;䑊ƀ;cwࣴ⇫⇯ir;楈;憭ar;意irc;䄥ƀalr∁∎∓rtsĀ;u∉∊晥it»∊lip;怦con;抹r;쀀𝔥sĀew∣∩arow;椥arow;椦ʀamopr∺∾≃≞≣rr;懿tht;戻kĀlr≉≓eftarrow;憩ightarrow;憪f;쀀𝕙bar;怕ƀclt≯≴≸r;쀀𝒽asè⇴rok;䄧Ābp⊂⊇ull;恃hen»ᱛૡ⊣\0⊪\0⊸⋅⋎\0⋕⋳\0\0⋸⌢⍧⍢⍿\0⎆⎪⎴cute耻í䃭ƀ;iyݱ⊰⊵rc耻î䃮;䐸Ācx⊼⊿y;䐵cl耻¡䂡ĀfrΟ⋉;쀀𝔦rave耻ì䃬Ȁ;inoܾ⋝⋩⋮Āin⋢⋦nt;樌t;戭fin;槜ta;愩lig;䄳ƀaop⋾⌚⌝ƀcgt⌅⌈⌗r;䄫ƀelpܟ⌏⌓inåގarôܠh;䄱f;抷ed;䆵ʀ;cfotӴ⌬⌱⌽⍁are;愅inĀ;t⌸⌹戞ie;槝doô⌙ʀ;celpݗ⍌⍐⍛⍡al;抺Āgr⍕⍙eróᕣã⍍arhk;樗rod;樼Ȁcgpt⍯⍲⍶⍻y;䑑on;䄯f;쀀𝕚a;䎹uest耻¿䂿Āci⎊⎏r;쀀𝒾nʀ;EdsvӴ⎛⎝⎡ӳ;拹ot;拵Ā;v⎦⎧拴;拳Ā;iݷ⎮lde;䄩ǫ⎸\0⎼cy;䑖l耻ï䃯̀cfmosu⏌⏗⏜⏡⏧⏵Āiy⏑⏕rc;䄵;䐹r;쀀𝔧ath;䈷pf;쀀𝕛ǣ⏬\0⏱r;쀀𝒿rcy;䑘kcy;䑔Ѐacfghjos␋␖␢␧␭␱␵␻ppaĀ;v␓␔䎺;䏰Āey␛␠dil;䄷;䐺r;쀀𝔨reen;䄸cy;䑅cy;䑜pf;쀀𝕜cr;쀀𝓀஀ABEHabcdefghjlmnoprstuv⑰⒁⒆⒍⒑┎┽╚▀♎♞♥♹♽⚚⚲⛘❝❨➋⟀⠁⠒ƀart⑷⑺⑼rò৆òΕail;椛arr;椎Ā;gঔ⒋;檋ar;楢ॣ⒥\0⒪\0⒱\0\0\0\0\0⒵Ⓔ\0ⓆⓈⓍ\0⓹ute;䄺mptyv;榴raîࡌbda;䎻gƀ;dlࢎⓁⓃ;榑åࢎ;檅uo耻«䂫rЀ;bfhlpst࢙ⓞⓦⓩ⓫⓮⓱⓵Ā;f࢝ⓣs;椟s;椝ë≒p;憫l;椹im;楳l;憢ƀ;ae⓿─┄檫il;椙Ā;s┉┊檭;쀀⪭︀ƀabr┕┙┝rr;椌rk;杲Āak┢┬cĀek┨┪;䁻;䁛Āes┱┳;榋lĀdu┹┻;榏;榍Ȁaeuy╆╋╖╘ron;䄾Ādi═╔il;䄼ìࢰâ┩;䐻Ȁcqrs╣╦╭╽a;椶uoĀ;rนᝆĀdu╲╷har;楧shar;楋h;憲ʀ;fgqs▋▌উ◳◿扤tʀahlrt▘▤▷◂◨rrowĀ;t࢙□aé⓶arpoonĀdu▯▴own»њp»०eftarrows;懇ightƀahs◍◖◞rrowĀ;sࣴࢧarpoonó྘quigarro÷⇰hreetimes;拋ƀ;qs▋ও◺lanôবʀ;cdgsব☊☍☝☨c;檨otĀ;o☔☕橿Ā;r☚☛檁;檃Ā;e☢☥쀀⋚︀s;檓ʀadegs☳☹☽♉♋pproøⓆot;拖qĀgq♃♅ôউgtò⒌ôছiíলƀilr♕࣡♚sht;楼;쀀𝔩Ā;Eজ♣;檑š♩♶rĀdu▲♮Ā;l॥♳;楪lk;斄cy;䑙ʀ;achtੈ⚈⚋⚑⚖rò◁orneòᴈard;楫ri;旺Āio⚟⚤dot;䅀ustĀ;a⚬⚭掰che»⚭ȀEaes⚻⚽⛉⛔;扨pĀ;p⛃⛄檉rox»⛄Ā;q⛎⛏檇Ā;q⛎⚻im;拦Ѐabnoptwz⛩⛴⛷✚✯❁❇❐Ānr⛮⛱g;柬r;懽rëࣁgƀlmr⛿✍✔eftĀar০✇ightá৲apsto;柼ightá৽parrowĀlr✥✩efô⓭ight;憬ƀafl✶✹✽r;榅;쀀𝕝us;樭imes;樴š❋❏st;戗áፎƀ;ef❗❘᠀旊nge»❘arĀ;l❤❥䀨t;榓ʀachmt❳❶❼➅➇ròࢨorneòᶌarĀ;d྘➃;業;怎ri;抿̀achiqt➘➝ੀ➢➮➻quo;怹r;쀀𝓁mƀ;egল➪➬;檍;檏Ābu┪➳oĀ;rฟ➹;怚rok;䅂萀<;cdhilqrࠫ⟒☹⟜⟠⟥⟪⟰Āci⟗⟙;檦r;橹reå◲mes;拉arr;楶uest;橻ĀPi⟵⟹ar;榖ƀ;ef⠀भ᠛旃rĀdu⠇⠍shar;楊har;楦Āen⠗⠡rtneqq;쀀≨︀Å⠞܀Dacdefhilnopsu⡀⡅⢂⢎⢓⢠⢥⢨⣚⣢⣤ઃ⣳⤂Dot;戺Ȁclpr⡎⡒⡣⡽r耻¯䂯Āet⡗⡙;時Ā;e⡞⡟朠se»⡟Ā;sျ⡨toȀ;dluျ⡳⡷⡻owîҌefôएðᏑker;斮Āoy⢇⢌mma;権;䐼ash;怔asuredangle»ᘦr;쀀𝔪o;愧ƀcdn⢯⢴⣉ro耻µ䂵Ȁ;acdᑤ⢽⣀⣄sôᚧir;櫰ot肻·Ƶusƀ;bd⣒ᤃ⣓戒Ā;uᴼ⣘;横ţ⣞⣡p;櫛ò−ðઁĀdp⣩⣮els;抧f;쀀𝕞Āct⣸⣽r;쀀𝓂pos»ᖝƀ;lm⤉⤊⤍䎼timap;抸ఀGLRVabcdefghijlmoprstuvw⥂⥓⥾⦉⦘⧚⧩⨕⨚⩘⩝⪃⪕⪤⪨⬄⬇⭄⭿⮮ⰴⱧⱼ⳩Āgt⥇⥋;쀀⋙̸Ā;v⥐௏쀀≫⃒ƀelt⥚⥲⥶ftĀar⥡⥧rrow;懍ightarrow;懎;쀀⋘̸Ā;v⥻ే쀀≪⃒ightarrow;懏ĀDd⦎⦓ash;抯ash;抮ʀbcnpt⦣⦧⦬⦱⧌la»˞ute;䅄g;쀀∠⃒ʀ;Eiop඄⦼⧀⧅⧈;쀀⩰̸d;쀀≋̸s;䅉roø඄urĀ;a⧓⧔普lĀ;s⧓ସǳ⧟\0⧣p肻 ଷmpĀ;e௹ఀʀaeouy⧴⧾⨃⨐⨓ǰ⧹\0⧻;橃on;䅈dil;䅆ngĀ;dൾ⨊ot;쀀⩭̸p;橂;䐽ash;怓΀;Aadqsxஒ⨩⨭⨻⩁⩅⩐rr;懗rĀhr⨳⨶k;椤Ā;oᏲᏰot;쀀≐̸uiöୣĀei⩊⩎ar;椨í஘istĀ;s஠டr;쀀𝔫ȀEest௅⩦⩹⩼ƀ;qs஼⩭௡ƀ;qs஼௅⩴lanô௢ií௪Ā;rஶ⪁»ஷƀAap⪊⪍⪑rò⥱rr;憮ar;櫲ƀ;svྍ⪜ྌĀ;d⪡⪢拼;拺cy;䑚΀AEadest⪷⪺⪾⫂⫅⫶⫹rò⥦;쀀≦̸rr;憚r;急Ȁ;fqs఻⫎⫣⫯tĀar⫔⫙rro÷⫁ightarro÷⪐ƀ;qs఻⪺⫪lanôౕĀ;sౕ⫴»శiíౝĀ;rవ⫾iĀ;eచథiäඐĀpt⬌⬑f;쀀𝕟膀¬;in⬙⬚⬶䂬nȀ;Edvஉ⬤⬨⬮;쀀⋹̸ot;쀀⋵̸ǡஉ⬳⬵;拷;拶iĀ;vಸ⬼ǡಸ⭁⭃;拾;拽ƀaor⭋⭣⭩rȀ;ast୻⭕⭚⭟lleì୻l;쀀⫽⃥;쀀∂̸lint;樔ƀ;ceಒ⭰⭳uåಥĀ;cಘ⭸Ā;eಒ⭽ñಘȀAait⮈⮋⮝⮧rò⦈rrƀ;cw⮔⮕⮙憛;쀀⤳̸;쀀↝̸ghtarrow»⮕riĀ;eೋೖ΀chimpqu⮽⯍⯙⬄୸⯤⯯Ȁ;cerല⯆ഷ⯉uå൅;쀀𝓃ortɭ⬅\0\0⯖ará⭖mĀ;e൮⯟Ā;q൴൳suĀbp⯫⯭å೸åഋƀbcp⯶ⰑⰙȀ;Ees⯿ⰀഢⰄ抄;쀀⫅̸etĀ;eഛⰋqĀ;qണⰀcĀ;eലⰗñസȀ;EesⰢⰣൟⰧ抅;쀀⫆̸etĀ;e൘ⰮqĀ;qൠⰣȀgilrⰽⰿⱅⱇìௗlde耻ñ䃱çృiangleĀlrⱒⱜeftĀ;eచⱚñదightĀ;eೋⱥñ೗Ā;mⱬⱭ䎽ƀ;esⱴⱵⱹ䀣ro;愖p;怇ҀDHadgilrsⲏⲔⲙⲞⲣⲰⲶⳓⳣash;抭arr;椄p;쀀≍⃒ash;抬ĀetⲨⲬ;쀀≥⃒;쀀>⃒nfin;槞ƀAetⲽⳁⳅrr;椂;쀀≤⃒Ā;rⳊⳍ쀀<⃒ie;쀀⊴⃒ĀAtⳘⳜrr;椃rie;쀀⊵⃒im;쀀∼⃒ƀAan⳰⳴ⴂrr;懖rĀhr⳺⳽k;椣Ā;oᏧᏥear;椧ቓ᪕\0\0\0\0\0\0\0\0\0\0\0\0\0ⴭ\0ⴸⵈⵠⵥ⵲ⶄᬇ\0\0ⶍⶫ\0ⷈⷎ\0ⷜ⸙⸫⸾⹃Ācsⴱ᪗ute耻ó䃳ĀiyⴼⵅrĀ;c᪞ⵂ耻ô䃴;䐾ʀabios᪠ⵒⵗǈⵚlac;䅑v;樸old;榼lig;䅓Ācr⵩⵭ir;榿;쀀𝔬ͯ⵹\0\0⵼\0ⶂn;䋛ave耻ò䃲;槁Ābmⶈ෴ar;榵Ȁacitⶕ⶘ⶥⶨrò᪀Āir⶝ⶠr;榾oss;榻nå๒;槀ƀaeiⶱⶵⶹcr;䅍ga;䏉ƀcdnⷀⷅǍron;䎿;榶pf;쀀𝕠ƀaelⷔ⷗ǒr;榷rp;榹΀;adiosvⷪⷫⷮ⸈⸍⸐⸖戨rò᪆Ȁ;efmⷷⷸ⸂⸅橝rĀ;oⷾⷿ愴f»ⷿ耻ª䂪耻º䂺gof;抶r;橖lope;橗;橛ƀclo⸟⸡⸧ò⸁ash耻ø䃸l;折iŬⸯ⸴de耻õ䃵esĀ;aǛ⸺s;樶ml耻ö䃶bar;挽ૡ⹞\0⹽\0⺀⺝\0⺢⺹\0\0⻋ຜ\0⼓\0\0⼫⾼\0⿈rȀ;astЃ⹧⹲຅脀¶;l⹭⹮䂶leìЃɩ⹸\0\0⹻m;櫳;櫽y;䐿rʀcimpt⺋⺏⺓ᡥ⺗nt;䀥od;䀮il;怰enk;怱r;쀀𝔭ƀimo⺨⺰⺴Ā;v⺭⺮䏆;䏕maô੶ne;明ƀ;tv⺿⻀⻈䏀chfork»´;䏖Āau⻏⻟nĀck⻕⻝kĀ;h⇴⻛;愎ö⇴sҀ;abcdemst⻳⻴ᤈ⻹⻽⼄⼆⼊⼎䀫cir;樣ir;樢Āouᵀ⼂;樥;橲n肻±ຝim;樦wo;樧ƀipu⼙⼠⼥ntint;樕f;쀀𝕡nd耻£䂣Ԁ;Eaceinosu່⼿⽁⽄⽇⾁⾉⾒⽾⾶;檳p;檷uå໙Ā;c໎⽌̀;acens່⽙⽟⽦⽨⽾pproø⽃urlyeñ໙ñ໎ƀaes⽯⽶⽺pprox;檹qq;檵im;拨iíໟmeĀ;s⾈ຮ怲ƀEas⽸⾐⽺ð⽵ƀdfp໬⾙⾯ƀals⾠⾥⾪lar;挮ine;挒urf;挓Ā;t໻⾴ï໻rel;抰Āci⿀⿅r;쀀𝓅;䏈ncsp;怈̀fiopsu⿚⋢⿟⿥⿫⿱r;쀀𝔮pf;쀀𝕢rime;恗cr;쀀𝓆ƀaeo⿸〉〓tĀei⿾々rnionóڰnt;樖stĀ;e【】䀿ñἙô༔઀ABHabcdefhilmnoprstux぀けさすムㄎㄫㅇㅢㅲㆎ㈆㈕㈤㈩㉘㉮㉲㊐㊰㊷ƀartぇおがròႳòϝail;検aròᱥar;楤΀cdenqrtとふへみわゔヌĀeuねぱ;쀀∽̱te;䅕iãᅮmptyv;榳gȀ;del࿑らるろ;榒;榥å࿑uo耻»䂻rր;abcfhlpstw࿜ガクシスゼゾダッデナp;極Ā;f࿠ゴs;椠;椳s;椞ë≝ð✮l;楅im;楴l;憣;憝Āaiパフil;椚oĀ;nホボ戶aló༞ƀabrョリヮrò៥rk;杳ĀakンヽcĀekヹ・;䁽;䁝Āes㄂㄄;榌lĀduㄊㄌ;榎;榐Ȁaeuyㄗㄜㄧㄩron;䅙Ādiㄡㄥil;䅗ì࿲âヺ;䑀Ȁclqsㄴㄷㄽㅄa;椷dhar;楩uoĀ;rȎȍh;憳ƀacgㅎㅟངlȀ;ipsླྀㅘㅛႜnåႻarôྩt;断ƀilrㅩဣㅮsht;楽;쀀𝔯ĀaoㅷㆆrĀduㅽㅿ»ѻĀ;l႑ㆄ;楬Ā;vㆋㆌ䏁;䏱ƀgns㆕ㇹㇼht̀ahlrstㆤㆰ㇂㇘㇤㇮rrowĀ;t࿜ㆭaéトarpoonĀduㆻㆿowîㅾp»႒eftĀah㇊㇐rrowó࿪arpoonóՑightarrows;應quigarro÷ニhreetimes;拌g;䋚ingdotseñἲƀahm㈍㈐㈓rò࿪aòՑ;怏oustĀ;a㈞㈟掱che»㈟mid;櫮Ȁabpt㈲㈽㉀㉒Ānr㈷㈺g;柭r;懾rëဃƀafl㉇㉊㉎r;榆;쀀𝕣us;樮imes;樵Āap㉝㉧rĀ;g㉣㉤䀩t;榔olint;樒arò㇣Ȁachq㉻㊀Ⴜ㊅quo;怺r;쀀𝓇Ābu・㊊oĀ;rȔȓƀhir㊗㊛㊠reåㇸmes;拊iȀ;efl㊪ၙᠡ㊫方tri;槎luhar;楨;愞ൡ㋕㋛㋟㌬㌸㍱\0㍺㎤\0\0㏬㏰\0㐨㑈㑚㒭㒱㓊㓱\0㘖\0\0㘳cute;䅛quï➺Ԁ;Eaceinpsyᇭ㋳㋵㋿㌂㌋㌏㌟㌦㌩;檴ǰ㋺\0㋼;檸on;䅡uåᇾĀ;dᇳ㌇il;䅟rc;䅝ƀEas㌖㌘㌛;檶p;檺im;择olint;樓iíሄ;䑁otƀ;be㌴ᵇ㌵担;橦΀Aacmstx㍆㍊㍗㍛㍞㍣㍭rr;懘rĀhr㍐㍒ë∨Ā;oਸ਼਴t耻§䂧i;䀻war;椩mĀin㍩ðnuóñt;朶rĀ;o㍶⁕쀀𝔰Ȁacoy㎂㎆㎑㎠rp;景Āhy㎋㎏cy;䑉;䑈rtɭ㎙\0\0㎜iäᑤaraì⹯耻­䂭Āgm㎨㎴maƀ;fv㎱㎲㎲䏃;䏂Ѐ;deglnprካ㏅㏉㏎㏖㏞㏡㏦ot;橪Ā;q኱ኰĀ;E㏓㏔檞;檠Ā;E㏛㏜檝;檟e;扆lus;樤arr;楲aròᄽȀaeit㏸㐈㐏㐗Āls㏽㐄lsetmé㍪hp;樳parsl;槤Ādlᑣ㐔e;挣Ā;e㐜㐝檪Ā;s㐢㐣檬;쀀⪬︀ƀflp㐮㐳㑂tcy;䑌Ā;b㐸㐹䀯Ā;a㐾㐿槄r;挿f;쀀𝕤aĀdr㑍ЂesĀ;u㑔㑕晠it»㑕ƀcsu㑠㑹㒟Āau㑥㑯pĀ;sᆈ㑫;쀀⊓︀pĀ;sᆴ㑵;쀀⊔︀uĀbp㑿㒏ƀ;esᆗᆜ㒆etĀ;eᆗ㒍ñᆝƀ;esᆨᆭ㒖etĀ;eᆨ㒝ñᆮƀ;afᅻ㒦ְrť㒫ֱ»ᅼaròᅈȀcemt㒹㒾㓂㓅r;쀀𝓈tmîñiì㐕aræᆾĀar㓎㓕rĀ;f㓔ឿ昆Āan㓚㓭ightĀep㓣㓪psiloîỠhé⺯s»⡒ʀbcmnp㓻㕞ሉ㖋㖎Ҁ;Edemnprs㔎㔏㔑㔕㔞㔣㔬㔱㔶抂;櫅ot;檽Ā;dᇚ㔚ot;櫃ult;櫁ĀEe㔨㔪;櫋;把lus;檿arr;楹ƀeiu㔽㕒㕕tƀ;en㔎㕅㕋qĀ;qᇚ㔏eqĀ;q㔫㔨m;櫇Ābp㕚㕜;櫕;櫓c̀;acensᇭ㕬㕲㕹㕻㌦pproø㋺urlyeñᇾñᇳƀaes㖂㖈㌛pproø㌚qñ㌗g;晪ڀ123;Edehlmnps㖩㖬㖯ሜ㖲㖴㗀㗉㗕㗚㗟㗨㗭耻¹䂹耻²䂲耻³䂳;櫆Āos㖹㖼t;檾ub;櫘Ā;dሢ㗅ot;櫄sĀou㗏㗒l;柉b;櫗arr;楻ult;櫂ĀEe㗤㗦;櫌;抋lus;櫀ƀeiu㗴㘉㘌tƀ;enሜ㗼㘂qĀ;qሢ㖲eqĀ;q㗧㗤m;櫈Ābp㘑㘓;櫔;櫖ƀAan㘜㘠㘭rr;懙rĀhr㘦㘨ë∮Ā;oਫ਩war;椪lig耻ß䃟௡㙑㙝㙠ዎ㙳㙹\0㙾㛂\0\0\0\0\0㛛㜃\0㜉㝬\0\0\0㞇ɲ㙖\0\0㙛get;挖;䏄rë๟ƀaey㙦㙫㙰ron;䅥dil;䅣;䑂lrec;挕r;쀀𝔱Ȁeiko㚆㚝㚵㚼ǲ㚋\0㚑eĀ4fኄኁaƀ;sv㚘㚙㚛䎸ym;䏑Ācn㚢㚲kĀas㚨㚮pproø዁im»ኬsðኞĀas㚺㚮ð዁rn耻þ䃾Ǭ̟㛆⋧es膀×;bd㛏㛐㛘䃗Ā;aᤏ㛕r;樱;樰ƀeps㛡㛣㜀á⩍Ȁ;bcf҆㛬㛰㛴ot;挶ir;櫱Ā;o㛹㛼쀀𝕥rk;櫚á㍢rime;怴ƀaip㜏㜒㝤dåቈ΀adempst㜡㝍㝀㝑㝗㝜㝟ngleʀ;dlqr㜰㜱㜶㝀㝂斵own»ᶻeftĀ;e⠀㜾ñम;扜ightĀ;e㊪㝋ñၚot;旬inus;樺lus;樹b;槍ime;樻ezium;揢ƀcht㝲㝽㞁Āry㝷㝻;쀀𝓉;䑆cy;䑛rok;䅧Āio㞋㞎xô᝷headĀlr㞗㞠eftarro÷ࡏightarrow»ཝऀAHabcdfghlmoprstuw㟐㟓㟗㟤㟰㟼㠎㠜㠣㠴㡑㡝㡫㢩㣌㣒㣪㣶ròϭar;楣Ācr㟜㟢ute耻ú䃺òᅐrǣ㟪\0㟭y;䑞ve;䅭Āiy㟵㟺rc耻û䃻;䑃ƀabh㠃㠆㠋ròᎭlac;䅱aòᏃĀir㠓㠘sht;楾;쀀𝔲rave耻ù䃹š㠧㠱rĀlr㠬㠮»ॗ»ႃlk;斀Āct㠹㡍ɯ㠿\0\0㡊rnĀ;e㡅㡆挜r»㡆op;挏ri;旸Āal㡖㡚cr;䅫肻¨͉Āgp㡢㡦on;䅳f;쀀𝕦̀adhlsuᅋ㡸㡽፲㢑㢠ownáᎳarpoonĀlr㢈㢌efô㠭ighô㠯iƀ;hl㢙㢚㢜䏅»ᏺon»㢚parrows;懈ƀcit㢰㣄㣈ɯ㢶\0\0㣁rnĀ;e㢼㢽挝r»㢽op;挎ng;䅯ri;旹cr;쀀𝓊ƀdir㣙㣝㣢ot;拰lde;䅩iĀ;f㜰㣨»᠓Āam㣯㣲rò㢨l耻ü䃼angle;榧ހABDacdeflnoprsz㤜㤟㤩㤭㦵㦸㦽㧟㧤㧨㧳㧹㧽㨁㨠ròϷarĀ;v㤦㤧櫨;櫩asèϡĀnr㤲㤷grt;榜΀eknprst㓣㥆㥋㥒㥝㥤㦖appá␕othinçẖƀhir㓫⻈㥙opô⾵Ā;hᎷ㥢ïㆍĀiu㥩㥭gmá㎳Ābp㥲㦄setneqĀ;q㥽㦀쀀⊊︀;쀀⫋︀setneqĀ;q㦏㦒쀀⊋︀;쀀⫌︀Āhr㦛㦟etá㚜iangleĀlr㦪㦯eft»थight»ၑy;䐲ash»ံƀelr㧄㧒㧗ƀ;beⷪ㧋㧏ar;抻q;扚lip;拮Ābt㧜ᑨaòᑩr;쀀𝔳tré㦮suĀbp㧯㧱»ജ»൙pf;쀀𝕧roð໻tré㦴Ācu㨆㨋r;쀀𝓋Ābp㨐㨘nĀEe㦀㨖»㥾nĀEe㦒㨞»㦐igzag;榚΀cefoprs㨶㨻㩖㩛㩔㩡㩪irc;䅵Ādi㩀㩑Ābg㩅㩉ar;機eĀ;qᗺ㩏;扙erp;愘r;쀀𝔴pf;쀀𝕨Ā;eᑹ㩦atèᑹcr;쀀𝓌ૣណ㪇\0㪋\0㪐㪛\0\0㪝㪨㪫㪯\0\0㫃㫎\0㫘ៜ៟tré៑r;쀀𝔵ĀAa㪔㪗ròσrò৶;䎾ĀAa㪡㪤ròθrò৫að✓is;拻ƀdptឤ㪵㪾Āfl㪺ឩ;쀀𝕩imåឲĀAa㫇㫊ròώròਁĀcq㫒ីr;쀀𝓍Āpt៖㫜ré។Ѐacefiosu㫰㫽㬈㬌㬑㬕㬛㬡cĀuy㫶㫻te耻ý䃽;䑏Āiy㬂㬆rc;䅷;䑋n耻¥䂥r;쀀𝔶cy;䑗pf;쀀𝕪cr;쀀𝓎Ācm㬦㬩y;䑎l耻ÿ䃿Ԁacdefhiosw㭂㭈㭔㭘㭤㭩㭭㭴㭺㮀cute;䅺Āay㭍㭒ron;䅾;䐷ot;䅼Āet㭝㭡træᕟa;䎶r;쀀𝔷cy;䐶grarr;懝pf;쀀𝕫cr;쀀𝓏Ājn㮅㮇;怍j;怌'.split("").map((c) => c.charCodeAt(0))
);

// node_modules/.pnpm/entities@4.5.0/node_modules/entities/lib/esm/generated/decode-data-xml.js
var decode_data_xml_default = new Uint16Array(
  // prettier-ignore
  "Ȁaglq	\x1Bɭ\0\0p;䀦os;䀧t;䀾t;䀼uot;䀢".split("").map((c) => c.charCodeAt(0))
);

// node_modules/.pnpm/entities@4.5.0/node_modules/entities/lib/esm/decode_codepoint.js
var _a;
var decodeMap = /* @__PURE__ */ new Map([
  [0, 65533],
  // C1 Unicode control character reference replacements
  [128, 8364],
  [130, 8218],
  [131, 402],
  [132, 8222],
  [133, 8230],
  [134, 8224],
  [135, 8225],
  [136, 710],
  [137, 8240],
  [138, 352],
  [139, 8249],
  [140, 338],
  [142, 381],
  [145, 8216],
  [146, 8217],
  [147, 8220],
  [148, 8221],
  [149, 8226],
  [150, 8211],
  [151, 8212],
  [152, 732],
  [153, 8482],
  [154, 353],
  [155, 8250],
  [156, 339],
  [158, 382],
  [159, 376]
]);
var fromCodePoint = (
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, node/no-unsupported-features/es-builtins
  (_a = String.fromCodePoint) !== null && _a !== void 0 ? _a : function(codePoint) {
    let output = "";
    if (codePoint > 65535) {
      codePoint -= 65536;
      output += String.fromCharCode(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    output += String.fromCharCode(codePoint);
    return output;
  }
);
function replaceCodePoint(codePoint) {
  var _a2;
  if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
    return 65533;
  }
  return (_a2 = decodeMap.get(codePoint)) !== null && _a2 !== void 0 ? _a2 : codePoint;
}

// node_modules/.pnpm/entities@4.5.0/node_modules/entities/lib/esm/decode.js
var CharCodes;
(function(CharCodes3) {
  CharCodes3[CharCodes3["NUM"] = 35] = "NUM";
  CharCodes3[CharCodes3["SEMI"] = 59] = "SEMI";
  CharCodes3[CharCodes3["EQUALS"] = 61] = "EQUALS";
  CharCodes3[CharCodes3["ZERO"] = 48] = "ZERO";
  CharCodes3[CharCodes3["NINE"] = 57] = "NINE";
  CharCodes3[CharCodes3["LOWER_A"] = 97] = "LOWER_A";
  CharCodes3[CharCodes3["LOWER_F"] = 102] = "LOWER_F";
  CharCodes3[CharCodes3["LOWER_X"] = 120] = "LOWER_X";
  CharCodes3[CharCodes3["LOWER_Z"] = 122] = "LOWER_Z";
  CharCodes3[CharCodes3["UPPER_A"] = 65] = "UPPER_A";
  CharCodes3[CharCodes3["UPPER_F"] = 70] = "UPPER_F";
  CharCodes3[CharCodes3["UPPER_Z"] = 90] = "UPPER_Z";
})(CharCodes || (CharCodes = {}));
var TO_LOWER_BIT = 32;
var BinTrieFlags;
(function(BinTrieFlags2) {
  BinTrieFlags2[BinTrieFlags2["VALUE_LENGTH"] = 49152] = "VALUE_LENGTH";
  BinTrieFlags2[BinTrieFlags2["BRANCH_LENGTH"] = 16256] = "BRANCH_LENGTH";
  BinTrieFlags2[BinTrieFlags2["JUMP_TABLE"] = 127] = "JUMP_TABLE";
})(BinTrieFlags || (BinTrieFlags = {}));
function isNumber(code2) {
  return code2 >= CharCodes.ZERO && code2 <= CharCodes.NINE;
}
function isHexadecimalCharacter(code2) {
  return code2 >= CharCodes.UPPER_A && code2 <= CharCodes.UPPER_F || code2 >= CharCodes.LOWER_A && code2 <= CharCodes.LOWER_F;
}
function isAsciiAlphaNumeric(code2) {
  return code2 >= CharCodes.UPPER_A && code2 <= CharCodes.UPPER_Z || code2 >= CharCodes.LOWER_A && code2 <= CharCodes.LOWER_Z || isNumber(code2);
}
function isEntityInAttributeInvalidEnd(code2) {
  return code2 === CharCodes.EQUALS || isAsciiAlphaNumeric(code2);
}
var EntityDecoderState;
(function(EntityDecoderState2) {
  EntityDecoderState2[EntityDecoderState2["EntityStart"] = 0] = "EntityStart";
  EntityDecoderState2[EntityDecoderState2["NumericStart"] = 1] = "NumericStart";
  EntityDecoderState2[EntityDecoderState2["NumericDecimal"] = 2] = "NumericDecimal";
  EntityDecoderState2[EntityDecoderState2["NumericHex"] = 3] = "NumericHex";
  EntityDecoderState2[EntityDecoderState2["NamedEntity"] = 4] = "NamedEntity";
})(EntityDecoderState || (EntityDecoderState = {}));
var DecodingMode;
(function(DecodingMode2) {
  DecodingMode2[DecodingMode2["Legacy"] = 0] = "Legacy";
  DecodingMode2[DecodingMode2["Strict"] = 1] = "Strict";
  DecodingMode2[DecodingMode2["Attribute"] = 2] = "Attribute";
})(DecodingMode || (DecodingMode = {}));
var EntityDecoder = class {
  constructor(decodeTree, emitCodePoint, errors2) {
    this.decodeTree = decodeTree;
    this.emitCodePoint = emitCodePoint;
    this.errors = errors2;
    this.state = EntityDecoderState.EntityStart;
    this.consumed = 1;
    this.result = 0;
    this.treeIndex = 0;
    this.excess = 1;
    this.decodeMode = DecodingMode.Strict;
  }
  /** Resets the instance to make it reusable. */
  startEntity(decodeMode) {
    this.decodeMode = decodeMode;
    this.state = EntityDecoderState.EntityStart;
    this.result = 0;
    this.treeIndex = 0;
    this.excess = 1;
    this.consumed = 1;
  }
  /**
   * Write an entity to the decoder. This can be called multiple times with partial entities.
   * If the entity is incomplete, the decoder will return -1.
   *
   * Mirrors the implementation of `getDecoder`, but with the ability to stop decoding if the
   * entity is incomplete, and resume when the next string is written.
   *
   * @param string The string containing the entity (or a continuation of the entity).
   * @param offset The offset at which the entity begins. Should be 0 if this is not the first call.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  write(str2, offset) {
    switch (this.state) {
      case EntityDecoderState.EntityStart: {
        if (str2.charCodeAt(offset) === CharCodes.NUM) {
          this.state = EntityDecoderState.NumericStart;
          this.consumed += 1;
          return this.stateNumericStart(str2, offset + 1);
        }
        this.state = EntityDecoderState.NamedEntity;
        return this.stateNamedEntity(str2, offset);
      }
      case EntityDecoderState.NumericStart: {
        return this.stateNumericStart(str2, offset);
      }
      case EntityDecoderState.NumericDecimal: {
        return this.stateNumericDecimal(str2, offset);
      }
      case EntityDecoderState.NumericHex: {
        return this.stateNumericHex(str2, offset);
      }
      case EntityDecoderState.NamedEntity: {
        return this.stateNamedEntity(str2, offset);
      }
    }
  }
  /**
   * Switches between the numeric decimal and hexadecimal states.
   *
   * Equivalent to the `Numeric character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericStart(str2, offset) {
    if (offset >= str2.length) {
      return -1;
    }
    if ((str2.charCodeAt(offset) | TO_LOWER_BIT) === CharCodes.LOWER_X) {
      this.state = EntityDecoderState.NumericHex;
      this.consumed += 1;
      return this.stateNumericHex(str2, offset + 1);
    }
    this.state = EntityDecoderState.NumericDecimal;
    return this.stateNumericDecimal(str2, offset);
  }
  addToNumericResult(str2, start, end2, base2) {
    if (start !== end2) {
      const digitCount = end2 - start;
      this.result = this.result * Math.pow(base2, digitCount) + parseInt(str2.substr(start, digitCount), base2);
      this.consumed += digitCount;
    }
  }
  /**
   * Parses a hexadecimal numeric entity.
   *
   * Equivalent to the `Hexademical character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericHex(str2, offset) {
    const startIdx = offset;
    while (offset < str2.length) {
      const char = str2.charCodeAt(offset);
      if (isNumber(char) || isHexadecimalCharacter(char)) {
        offset += 1;
      } else {
        this.addToNumericResult(str2, startIdx, offset, 16);
        return this.emitNumericEntity(char, 3);
      }
    }
    this.addToNumericResult(str2, startIdx, offset, 16);
    return -1;
  }
  /**
   * Parses a decimal numeric entity.
   *
   * Equivalent to the `Decimal character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericDecimal(str2, offset) {
    const startIdx = offset;
    while (offset < str2.length) {
      const char = str2.charCodeAt(offset);
      if (isNumber(char)) {
        offset += 1;
      } else {
        this.addToNumericResult(str2, startIdx, offset, 10);
        return this.emitNumericEntity(char, 2);
      }
    }
    this.addToNumericResult(str2, startIdx, offset, 10);
    return -1;
  }
  /**
   * Validate and emit a numeric entity.
   *
   * Implements the logic from the `Hexademical character reference start
   * state` and `Numeric character reference end state` in the HTML spec.
   *
   * @param lastCp The last code point of the entity. Used to see if the
   *               entity was terminated with a semicolon.
   * @param expectedLength The minimum number of characters that should be
   *                       consumed. Used to validate that at least one digit
   *                       was consumed.
   * @returns The number of characters that were consumed.
   */
  emitNumericEntity(lastCp, expectedLength) {
    var _a2;
    if (this.consumed <= expectedLength) {
      (_a2 = this.errors) === null || _a2 === void 0 ? void 0 : _a2.absenceOfDigitsInNumericCharacterReference(this.consumed);
      return 0;
    }
    if (lastCp === CharCodes.SEMI) {
      this.consumed += 1;
    } else if (this.decodeMode === DecodingMode.Strict) {
      return 0;
    }
    this.emitCodePoint(replaceCodePoint(this.result), this.consumed);
    if (this.errors) {
      if (lastCp !== CharCodes.SEMI) {
        this.errors.missingSemicolonAfterCharacterReference();
      }
      this.errors.validateNumericCharacterReference(this.result);
    }
    return this.consumed;
  }
  /**
   * Parses a named entity.
   *
   * Equivalent to the `Named character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNamedEntity(str2, offset) {
    const { decodeTree } = this;
    let current = decodeTree[this.treeIndex];
    let valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
    for (; offset < str2.length; offset++, this.excess++) {
      const char = str2.charCodeAt(offset);
      this.treeIndex = determineBranch(decodeTree, current, this.treeIndex + Math.max(1, valueLength), char);
      if (this.treeIndex < 0) {
        return this.result === 0 || // If we are parsing an attribute
        this.decodeMode === DecodingMode.Attribute && // We shouldn't have consumed any characters after the entity,
        (valueLength === 0 || // And there should be no invalid characters.
        isEntityInAttributeInvalidEnd(char)) ? 0 : this.emitNotTerminatedNamedEntity();
      }
      current = decodeTree[this.treeIndex];
      valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
      if (valueLength !== 0) {
        if (char === CharCodes.SEMI) {
          return this.emitNamedEntityData(this.treeIndex, valueLength, this.consumed + this.excess);
        }
        if (this.decodeMode !== DecodingMode.Strict) {
          this.result = this.treeIndex;
          this.consumed += this.excess;
          this.excess = 0;
        }
      }
    }
    return -1;
  }
  /**
   * Emit a named entity that was not terminated with a semicolon.
   *
   * @returns The number of characters consumed.
   */
  emitNotTerminatedNamedEntity() {
    var _a2;
    const { result, decodeTree } = this;
    const valueLength = (decodeTree[result] & BinTrieFlags.VALUE_LENGTH) >> 14;
    this.emitNamedEntityData(result, valueLength, this.consumed);
    (_a2 = this.errors) === null || _a2 === void 0 ? void 0 : _a2.missingSemicolonAfterCharacterReference();
    return this.consumed;
  }
  /**
   * Emit a named entity.
   *
   * @param result The index of the entity in the decode tree.
   * @param valueLength The number of bytes in the entity.
   * @param consumed The number of characters consumed.
   *
   * @returns The number of characters consumed.
   */
  emitNamedEntityData(result, valueLength, consumed) {
    const { decodeTree } = this;
    this.emitCodePoint(valueLength === 1 ? decodeTree[result] & ~BinTrieFlags.VALUE_LENGTH : decodeTree[result + 1], consumed);
    if (valueLength === 3) {
      this.emitCodePoint(decodeTree[result + 2], consumed);
    }
    return consumed;
  }
  /**
   * Signal to the parser that the end of the input was reached.
   *
   * Remaining data will be emitted and relevant errors will be produced.
   *
   * @returns The number of characters consumed.
   */
  end() {
    var _a2;
    switch (this.state) {
      case EntityDecoderState.NamedEntity: {
        return this.result !== 0 && (this.decodeMode !== DecodingMode.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
      }
      case EntityDecoderState.NumericDecimal: {
        return this.emitNumericEntity(0, 2);
      }
      case EntityDecoderState.NumericHex: {
        return this.emitNumericEntity(0, 3);
      }
      case EntityDecoderState.NumericStart: {
        (_a2 = this.errors) === null || _a2 === void 0 ? void 0 : _a2.absenceOfDigitsInNumericCharacterReference(this.consumed);
        return 0;
      }
      case EntityDecoderState.EntityStart: {
        return 0;
      }
    }
  }
};
function getDecoder(decodeTree) {
  let ret = "";
  const decoder = new EntityDecoder(decodeTree, (str2) => ret += fromCodePoint(str2));
  return function decodeWithTrie(str2, decodeMode) {
    let lastIndex = 0;
    let offset = 0;
    while ((offset = str2.indexOf("&", offset)) >= 0) {
      ret += str2.slice(lastIndex, offset);
      decoder.startEntity(decodeMode);
      const len = decoder.write(
        str2,
        // Skip the "&"
        offset + 1
      );
      if (len < 0) {
        lastIndex = offset + decoder.end();
        break;
      }
      lastIndex = offset + len;
      offset = len === 0 ? lastIndex + 1 : lastIndex;
    }
    const result = ret + str2.slice(lastIndex);
    ret = "";
    return result;
  };
}
function determineBranch(decodeTree, current, nodeIdx, char) {
  const branchCount = (current & BinTrieFlags.BRANCH_LENGTH) >> 7;
  const jumpOffset = current & BinTrieFlags.JUMP_TABLE;
  if (branchCount === 0) {
    return jumpOffset !== 0 && char === jumpOffset ? nodeIdx : -1;
  }
  if (jumpOffset) {
    const value = char - jumpOffset;
    return value < 0 || value >= branchCount ? -1 : decodeTree[nodeIdx + value] - 1;
  }
  let lo = nodeIdx;
  let hi = lo + branchCount - 1;
  while (lo <= hi) {
    const mid = lo + hi >>> 1;
    const midVal = decodeTree[mid];
    if (midVal < char) {
      lo = mid + 1;
    } else if (midVal > char) {
      hi = mid - 1;
    } else {
      return decodeTree[mid + branchCount];
    }
  }
  return -1;
}
var htmlDecoder = getDecoder(decode_data_html_default);
var xmlDecoder = getDecoder(decode_data_xml_default);
function decodeHTML(str2, mode = DecodingMode.Legacy) {
  return htmlDecoder(str2, mode);
}

// node_modules/.pnpm/entities@4.5.0/node_modules/entities/lib/esm/generated/encode-html.js
function restoreDiff(arr) {
  for (let i = 1; i < arr.length; i++) {
    arr[i][0] += arr[i - 1][0] + 1;
  }
  return arr;
}
var encode_html_default = new Map(restoreDiff([[9, "&Tab;"], [0, "&NewLine;"], [22, "&excl;"], [0, "&quot;"], [0, "&num;"], [0, "&dollar;"], [0, "&percnt;"], [0, "&amp;"], [0, "&apos;"], [0, "&lpar;"], [0, "&rpar;"], [0, "&ast;"], [0, "&plus;"], [0, "&comma;"], [1, "&period;"], [0, "&sol;"], [10, "&colon;"], [0, "&semi;"], [0, { v: "&lt;", n: 8402, o: "&nvlt;" }], [0, { v: "&equals;", n: 8421, o: "&bne;" }], [0, { v: "&gt;", n: 8402, o: "&nvgt;" }], [0, "&quest;"], [0, "&commat;"], [26, "&lbrack;"], [0, "&bsol;"], [0, "&rbrack;"], [0, "&Hat;"], [0, "&lowbar;"], [0, "&DiacriticalGrave;"], [5, { n: 106, o: "&fjlig;" }], [20, "&lbrace;"], [0, "&verbar;"], [0, "&rbrace;"], [34, "&nbsp;"], [0, "&iexcl;"], [0, "&cent;"], [0, "&pound;"], [0, "&curren;"], [0, "&yen;"], [0, "&brvbar;"], [0, "&sect;"], [0, "&die;"], [0, "&copy;"], [0, "&ordf;"], [0, "&laquo;"], [0, "&not;"], [0, "&shy;"], [0, "&circledR;"], [0, "&macr;"], [0, "&deg;"], [0, "&PlusMinus;"], [0, "&sup2;"], [0, "&sup3;"], [0, "&acute;"], [0, "&micro;"], [0, "&para;"], [0, "&centerdot;"], [0, "&cedil;"], [0, "&sup1;"], [0, "&ordm;"], [0, "&raquo;"], [0, "&frac14;"], [0, "&frac12;"], [0, "&frac34;"], [0, "&iquest;"], [0, "&Agrave;"], [0, "&Aacute;"], [0, "&Acirc;"], [0, "&Atilde;"], [0, "&Auml;"], [0, "&angst;"], [0, "&AElig;"], [0, "&Ccedil;"], [0, "&Egrave;"], [0, "&Eacute;"], [0, "&Ecirc;"], [0, "&Euml;"], [0, "&Igrave;"], [0, "&Iacute;"], [0, "&Icirc;"], [0, "&Iuml;"], [0, "&ETH;"], [0, "&Ntilde;"], [0, "&Ograve;"], [0, "&Oacute;"], [0, "&Ocirc;"], [0, "&Otilde;"], [0, "&Ouml;"], [0, "&times;"], [0, "&Oslash;"], [0, "&Ugrave;"], [0, "&Uacute;"], [0, "&Ucirc;"], [0, "&Uuml;"], [0, "&Yacute;"], [0, "&THORN;"], [0, "&szlig;"], [0, "&agrave;"], [0, "&aacute;"], [0, "&acirc;"], [0, "&atilde;"], [0, "&auml;"], [0, "&aring;"], [0, "&aelig;"], [0, "&ccedil;"], [0, "&egrave;"], [0, "&eacute;"], [0, "&ecirc;"], [0, "&euml;"], [0, "&igrave;"], [0, "&iacute;"], [0, "&icirc;"], [0, "&iuml;"], [0, "&eth;"], [0, "&ntilde;"], [0, "&ograve;"], [0, "&oacute;"], [0, "&ocirc;"], [0, "&otilde;"], [0, "&ouml;"], [0, "&div;"], [0, "&oslash;"], [0, "&ugrave;"], [0, "&uacute;"], [0, "&ucirc;"], [0, "&uuml;"], [0, "&yacute;"], [0, "&thorn;"], [0, "&yuml;"], [0, "&Amacr;"], [0, "&amacr;"], [0, "&Abreve;"], [0, "&abreve;"], [0, "&Aogon;"], [0, "&aogon;"], [0, "&Cacute;"], [0, "&cacute;"], [0, "&Ccirc;"], [0, "&ccirc;"], [0, "&Cdot;"], [0, "&cdot;"], [0, "&Ccaron;"], [0, "&ccaron;"], [0, "&Dcaron;"], [0, "&dcaron;"], [0, "&Dstrok;"], [0, "&dstrok;"], [0, "&Emacr;"], [0, "&emacr;"], [2, "&Edot;"], [0, "&edot;"], [0, "&Eogon;"], [0, "&eogon;"], [0, "&Ecaron;"], [0, "&ecaron;"], [0, "&Gcirc;"], [0, "&gcirc;"], [0, "&Gbreve;"], [0, "&gbreve;"], [0, "&Gdot;"], [0, "&gdot;"], [0, "&Gcedil;"], [1, "&Hcirc;"], [0, "&hcirc;"], [0, "&Hstrok;"], [0, "&hstrok;"], [0, "&Itilde;"], [0, "&itilde;"], [0, "&Imacr;"], [0, "&imacr;"], [2, "&Iogon;"], [0, "&iogon;"], [0, "&Idot;"], [0, "&imath;"], [0, "&IJlig;"], [0, "&ijlig;"], [0, "&Jcirc;"], [0, "&jcirc;"], [0, "&Kcedil;"], [0, "&kcedil;"], [0, "&kgreen;"], [0, "&Lacute;"], [0, "&lacute;"], [0, "&Lcedil;"], [0, "&lcedil;"], [0, "&Lcaron;"], [0, "&lcaron;"], [0, "&Lmidot;"], [0, "&lmidot;"], [0, "&Lstrok;"], [0, "&lstrok;"], [0, "&Nacute;"], [0, "&nacute;"], [0, "&Ncedil;"], [0, "&ncedil;"], [0, "&Ncaron;"], [0, "&ncaron;"], [0, "&napos;"], [0, "&ENG;"], [0, "&eng;"], [0, "&Omacr;"], [0, "&omacr;"], [2, "&Odblac;"], [0, "&odblac;"], [0, "&OElig;"], [0, "&oelig;"], [0, "&Racute;"], [0, "&racute;"], [0, "&Rcedil;"], [0, "&rcedil;"], [0, "&Rcaron;"], [0, "&rcaron;"], [0, "&Sacute;"], [0, "&sacute;"], [0, "&Scirc;"], [0, "&scirc;"], [0, "&Scedil;"], [0, "&scedil;"], [0, "&Scaron;"], [0, "&scaron;"], [0, "&Tcedil;"], [0, "&tcedil;"], [0, "&Tcaron;"], [0, "&tcaron;"], [0, "&Tstrok;"], [0, "&tstrok;"], [0, "&Utilde;"], [0, "&utilde;"], [0, "&Umacr;"], [0, "&umacr;"], [0, "&Ubreve;"], [0, "&ubreve;"], [0, "&Uring;"], [0, "&uring;"], [0, "&Udblac;"], [0, "&udblac;"], [0, "&Uogon;"], [0, "&uogon;"], [0, "&Wcirc;"], [0, "&wcirc;"], [0, "&Ycirc;"], [0, "&ycirc;"], [0, "&Yuml;"], [0, "&Zacute;"], [0, "&zacute;"], [0, "&Zdot;"], [0, "&zdot;"], [0, "&Zcaron;"], [0, "&zcaron;"], [19, "&fnof;"], [34, "&imped;"], [63, "&gacute;"], [65, "&jmath;"], [142, "&circ;"], [0, "&caron;"], [16, "&breve;"], [0, "&DiacriticalDot;"], [0, "&ring;"], [0, "&ogon;"], [0, "&DiacriticalTilde;"], [0, "&dblac;"], [51, "&DownBreve;"], [127, "&Alpha;"], [0, "&Beta;"], [0, "&Gamma;"], [0, "&Delta;"], [0, "&Epsilon;"], [0, "&Zeta;"], [0, "&Eta;"], [0, "&Theta;"], [0, "&Iota;"], [0, "&Kappa;"], [0, "&Lambda;"], [0, "&Mu;"], [0, "&Nu;"], [0, "&Xi;"], [0, "&Omicron;"], [0, "&Pi;"], [0, "&Rho;"], [1, "&Sigma;"], [0, "&Tau;"], [0, "&Upsilon;"], [0, "&Phi;"], [0, "&Chi;"], [0, "&Psi;"], [0, "&ohm;"], [7, "&alpha;"], [0, "&beta;"], [0, "&gamma;"], [0, "&delta;"], [0, "&epsi;"], [0, "&zeta;"], [0, "&eta;"], [0, "&theta;"], [0, "&iota;"], [0, "&kappa;"], [0, "&lambda;"], [0, "&mu;"], [0, "&nu;"], [0, "&xi;"], [0, "&omicron;"], [0, "&pi;"], [0, "&rho;"], [0, "&sigmaf;"], [0, "&sigma;"], [0, "&tau;"], [0, "&upsi;"], [0, "&phi;"], [0, "&chi;"], [0, "&psi;"], [0, "&omega;"], [7, "&thetasym;"], [0, "&Upsi;"], [2, "&phiv;"], [0, "&piv;"], [5, "&Gammad;"], [0, "&digamma;"], [18, "&kappav;"], [0, "&rhov;"], [3, "&epsiv;"], [0, "&backepsilon;"], [10, "&IOcy;"], [0, "&DJcy;"], [0, "&GJcy;"], [0, "&Jukcy;"], [0, "&DScy;"], [0, "&Iukcy;"], [0, "&YIcy;"], [0, "&Jsercy;"], [0, "&LJcy;"], [0, "&NJcy;"], [0, "&TSHcy;"], [0, "&KJcy;"], [1, "&Ubrcy;"], [0, "&DZcy;"], [0, "&Acy;"], [0, "&Bcy;"], [0, "&Vcy;"], [0, "&Gcy;"], [0, "&Dcy;"], [0, "&IEcy;"], [0, "&ZHcy;"], [0, "&Zcy;"], [0, "&Icy;"], [0, "&Jcy;"], [0, "&Kcy;"], [0, "&Lcy;"], [0, "&Mcy;"], [0, "&Ncy;"], [0, "&Ocy;"], [0, "&Pcy;"], [0, "&Rcy;"], [0, "&Scy;"], [0, "&Tcy;"], [0, "&Ucy;"], [0, "&Fcy;"], [0, "&KHcy;"], [0, "&TScy;"], [0, "&CHcy;"], [0, "&SHcy;"], [0, "&SHCHcy;"], [0, "&HARDcy;"], [0, "&Ycy;"], [0, "&SOFTcy;"], [0, "&Ecy;"], [0, "&YUcy;"], [0, "&YAcy;"], [0, "&acy;"], [0, "&bcy;"], [0, "&vcy;"], [0, "&gcy;"], [0, "&dcy;"], [0, "&iecy;"], [0, "&zhcy;"], [0, "&zcy;"], [0, "&icy;"], [0, "&jcy;"], [0, "&kcy;"], [0, "&lcy;"], [0, "&mcy;"], [0, "&ncy;"], [0, "&ocy;"], [0, "&pcy;"], [0, "&rcy;"], [0, "&scy;"], [0, "&tcy;"], [0, "&ucy;"], [0, "&fcy;"], [0, "&khcy;"], [0, "&tscy;"], [0, "&chcy;"], [0, "&shcy;"], [0, "&shchcy;"], [0, "&hardcy;"], [0, "&ycy;"], [0, "&softcy;"], [0, "&ecy;"], [0, "&yucy;"], [0, "&yacy;"], [1, "&iocy;"], [0, "&djcy;"], [0, "&gjcy;"], [0, "&jukcy;"], [0, "&dscy;"], [0, "&iukcy;"], [0, "&yicy;"], [0, "&jsercy;"], [0, "&ljcy;"], [0, "&njcy;"], [0, "&tshcy;"], [0, "&kjcy;"], [1, "&ubrcy;"], [0, "&dzcy;"], [7074, "&ensp;"], [0, "&emsp;"], [0, "&emsp13;"], [0, "&emsp14;"], [1, "&numsp;"], [0, "&puncsp;"], [0, "&ThinSpace;"], [0, "&hairsp;"], [0, "&NegativeMediumSpace;"], [0, "&zwnj;"], [0, "&zwj;"], [0, "&lrm;"], [0, "&rlm;"], [0, "&dash;"], [2, "&ndash;"], [0, "&mdash;"], [0, "&horbar;"], [0, "&Verbar;"], [1, "&lsquo;"], [0, "&CloseCurlyQuote;"], [0, "&lsquor;"], [1, "&ldquo;"], [0, "&CloseCurlyDoubleQuote;"], [0, "&bdquo;"], [1, "&dagger;"], [0, "&Dagger;"], [0, "&bull;"], [2, "&nldr;"], [0, "&hellip;"], [9, "&permil;"], [0, "&pertenk;"], [0, "&prime;"], [0, "&Prime;"], [0, "&tprime;"], [0, "&backprime;"], [3, "&lsaquo;"], [0, "&rsaquo;"], [3, "&oline;"], [2, "&caret;"], [1, "&hybull;"], [0, "&frasl;"], [10, "&bsemi;"], [7, "&qprime;"], [7, { v: "&MediumSpace;", n: 8202, o: "&ThickSpace;" }], [0, "&NoBreak;"], [0, "&af;"], [0, "&InvisibleTimes;"], [0, "&ic;"], [72, "&euro;"], [46, "&tdot;"], [0, "&DotDot;"], [37, "&complexes;"], [2, "&incare;"], [4, "&gscr;"], [0, "&hamilt;"], [0, "&Hfr;"], [0, "&Hopf;"], [0, "&planckh;"], [0, "&hbar;"], [0, "&imagline;"], [0, "&Ifr;"], [0, "&lagran;"], [0, "&ell;"], [1, "&naturals;"], [0, "&numero;"], [0, "&copysr;"], [0, "&weierp;"], [0, "&Popf;"], [0, "&Qopf;"], [0, "&realine;"], [0, "&real;"], [0, "&reals;"], [0, "&rx;"], [3, "&trade;"], [1, "&integers;"], [2, "&mho;"], [0, "&zeetrf;"], [0, "&iiota;"], [2, "&bernou;"], [0, "&Cayleys;"], [1, "&escr;"], [0, "&Escr;"], [0, "&Fouriertrf;"], [1, "&Mellintrf;"], [0, "&order;"], [0, "&alefsym;"], [0, "&beth;"], [0, "&gimel;"], [0, "&daleth;"], [12, "&CapitalDifferentialD;"], [0, "&dd;"], [0, "&ee;"], [0, "&ii;"], [10, "&frac13;"], [0, "&frac23;"], [0, "&frac15;"], [0, "&frac25;"], [0, "&frac35;"], [0, "&frac45;"], [0, "&frac16;"], [0, "&frac56;"], [0, "&frac18;"], [0, "&frac38;"], [0, "&frac58;"], [0, "&frac78;"], [49, "&larr;"], [0, "&ShortUpArrow;"], [0, "&rarr;"], [0, "&darr;"], [0, "&harr;"], [0, "&updownarrow;"], [0, "&nwarr;"], [0, "&nearr;"], [0, "&LowerRightArrow;"], [0, "&LowerLeftArrow;"], [0, "&nlarr;"], [0, "&nrarr;"], [1, { v: "&rarrw;", n: 824, o: "&nrarrw;" }], [0, "&Larr;"], [0, "&Uarr;"], [0, "&Rarr;"], [0, "&Darr;"], [0, "&larrtl;"], [0, "&rarrtl;"], [0, "&LeftTeeArrow;"], [0, "&mapstoup;"], [0, "&map;"], [0, "&DownTeeArrow;"], [1, "&hookleftarrow;"], [0, "&hookrightarrow;"], [0, "&larrlp;"], [0, "&looparrowright;"], [0, "&harrw;"], [0, "&nharr;"], [1, "&lsh;"], [0, "&rsh;"], [0, "&ldsh;"], [0, "&rdsh;"], [1, "&crarr;"], [0, "&cularr;"], [0, "&curarr;"], [2, "&circlearrowleft;"], [0, "&circlearrowright;"], [0, "&leftharpoonup;"], [0, "&DownLeftVector;"], [0, "&RightUpVector;"], [0, "&LeftUpVector;"], [0, "&rharu;"], [0, "&DownRightVector;"], [0, "&dharr;"], [0, "&dharl;"], [0, "&RightArrowLeftArrow;"], [0, "&udarr;"], [0, "&LeftArrowRightArrow;"], [0, "&leftleftarrows;"], [0, "&upuparrows;"], [0, "&rightrightarrows;"], [0, "&ddarr;"], [0, "&leftrightharpoons;"], [0, "&Equilibrium;"], [0, "&nlArr;"], [0, "&nhArr;"], [0, "&nrArr;"], [0, "&DoubleLeftArrow;"], [0, "&DoubleUpArrow;"], [0, "&DoubleRightArrow;"], [0, "&dArr;"], [0, "&DoubleLeftRightArrow;"], [0, "&DoubleUpDownArrow;"], [0, "&nwArr;"], [0, "&neArr;"], [0, "&seArr;"], [0, "&swArr;"], [0, "&lAarr;"], [0, "&rAarr;"], [1, "&zigrarr;"], [6, "&larrb;"], [0, "&rarrb;"], [15, "&DownArrowUpArrow;"], [7, "&loarr;"], [0, "&roarr;"], [0, "&hoarr;"], [0, "&forall;"], [0, "&comp;"], [0, { v: "&part;", n: 824, o: "&npart;" }], [0, "&exist;"], [0, "&nexist;"], [0, "&empty;"], [1, "&Del;"], [0, "&Element;"], [0, "&NotElement;"], [1, "&ni;"], [0, "&notni;"], [2, "&prod;"], [0, "&coprod;"], [0, "&sum;"], [0, "&minus;"], [0, "&MinusPlus;"], [0, "&dotplus;"], [1, "&Backslash;"], [0, "&lowast;"], [0, "&compfn;"], [1, "&radic;"], [2, "&prop;"], [0, "&infin;"], [0, "&angrt;"], [0, { v: "&ang;", n: 8402, o: "&nang;" }], [0, "&angmsd;"], [0, "&angsph;"], [0, "&mid;"], [0, "&nmid;"], [0, "&DoubleVerticalBar;"], [0, "&NotDoubleVerticalBar;"], [0, "&and;"], [0, "&or;"], [0, { v: "&cap;", n: 65024, o: "&caps;" }], [0, { v: "&cup;", n: 65024, o: "&cups;" }], [0, "&int;"], [0, "&Int;"], [0, "&iiint;"], [0, "&conint;"], [0, "&Conint;"], [0, "&Cconint;"], [0, "&cwint;"], [0, "&ClockwiseContourIntegral;"], [0, "&awconint;"], [0, "&there4;"], [0, "&becaus;"], [0, "&ratio;"], [0, "&Colon;"], [0, "&dotminus;"], [1, "&mDDot;"], [0, "&homtht;"], [0, { v: "&sim;", n: 8402, o: "&nvsim;" }], [0, { v: "&backsim;", n: 817, o: "&race;" }], [0, { v: "&ac;", n: 819, o: "&acE;" }], [0, "&acd;"], [0, "&VerticalTilde;"], [0, "&NotTilde;"], [0, { v: "&eqsim;", n: 824, o: "&nesim;" }], [0, "&sime;"], [0, "&NotTildeEqual;"], [0, "&cong;"], [0, "&simne;"], [0, "&ncong;"], [0, "&ap;"], [0, "&nap;"], [0, "&ape;"], [0, { v: "&apid;", n: 824, o: "&napid;" }], [0, "&backcong;"], [0, { v: "&asympeq;", n: 8402, o: "&nvap;" }], [0, { v: "&bump;", n: 824, o: "&nbump;" }], [0, { v: "&bumpe;", n: 824, o: "&nbumpe;" }], [0, { v: "&doteq;", n: 824, o: "&nedot;" }], [0, "&doteqdot;"], [0, "&efDot;"], [0, "&erDot;"], [0, "&Assign;"], [0, "&ecolon;"], [0, "&ecir;"], [0, "&circeq;"], [1, "&wedgeq;"], [0, "&veeeq;"], [1, "&triangleq;"], [2, "&equest;"], [0, "&ne;"], [0, { v: "&Congruent;", n: 8421, o: "&bnequiv;" }], [0, "&nequiv;"], [1, { v: "&le;", n: 8402, o: "&nvle;" }], [0, { v: "&ge;", n: 8402, o: "&nvge;" }], [0, { v: "&lE;", n: 824, o: "&nlE;" }], [0, { v: "&gE;", n: 824, o: "&ngE;" }], [0, { v: "&lnE;", n: 65024, o: "&lvertneqq;" }], [0, { v: "&gnE;", n: 65024, o: "&gvertneqq;" }], [0, { v: "&ll;", n: new Map(restoreDiff([[824, "&nLtv;"], [7577, "&nLt;"]])) }], [0, { v: "&gg;", n: new Map(restoreDiff([[824, "&nGtv;"], [7577, "&nGt;"]])) }], [0, "&between;"], [0, "&NotCupCap;"], [0, "&nless;"], [0, "&ngt;"], [0, "&nle;"], [0, "&nge;"], [0, "&lesssim;"], [0, "&GreaterTilde;"], [0, "&nlsim;"], [0, "&ngsim;"], [0, "&LessGreater;"], [0, "&gl;"], [0, "&NotLessGreater;"], [0, "&NotGreaterLess;"], [0, "&pr;"], [0, "&sc;"], [0, "&prcue;"], [0, "&sccue;"], [0, "&PrecedesTilde;"], [0, { v: "&scsim;", n: 824, o: "&NotSucceedsTilde;" }], [0, "&NotPrecedes;"], [0, "&NotSucceeds;"], [0, { v: "&sub;", n: 8402, o: "&NotSubset;" }], [0, { v: "&sup;", n: 8402, o: "&NotSuperset;" }], [0, "&nsub;"], [0, "&nsup;"], [0, "&sube;"], [0, "&supe;"], [0, "&NotSubsetEqual;"], [0, "&NotSupersetEqual;"], [0, { v: "&subne;", n: 65024, o: "&varsubsetneq;" }], [0, { v: "&supne;", n: 65024, o: "&varsupsetneq;" }], [1, "&cupdot;"], [0, "&UnionPlus;"], [0, { v: "&sqsub;", n: 824, o: "&NotSquareSubset;" }], [0, { v: "&sqsup;", n: 824, o: "&NotSquareSuperset;" }], [0, "&sqsube;"], [0, "&sqsupe;"], [0, { v: "&sqcap;", n: 65024, o: "&sqcaps;" }], [0, { v: "&sqcup;", n: 65024, o: "&sqcups;" }], [0, "&CirclePlus;"], [0, "&CircleMinus;"], [0, "&CircleTimes;"], [0, "&osol;"], [0, "&CircleDot;"], [0, "&circledcirc;"], [0, "&circledast;"], [1, "&circleddash;"], [0, "&boxplus;"], [0, "&boxminus;"], [0, "&boxtimes;"], [0, "&dotsquare;"], [0, "&RightTee;"], [0, "&dashv;"], [0, "&DownTee;"], [0, "&bot;"], [1, "&models;"], [0, "&DoubleRightTee;"], [0, "&Vdash;"], [0, "&Vvdash;"], [0, "&VDash;"], [0, "&nvdash;"], [0, "&nvDash;"], [0, "&nVdash;"], [0, "&nVDash;"], [0, "&prurel;"], [1, "&LeftTriangle;"], [0, "&RightTriangle;"], [0, { v: "&LeftTriangleEqual;", n: 8402, o: "&nvltrie;" }], [0, { v: "&RightTriangleEqual;", n: 8402, o: "&nvrtrie;" }], [0, "&origof;"], [0, "&imof;"], [0, "&multimap;"], [0, "&hercon;"], [0, "&intcal;"], [0, "&veebar;"], [1, "&barvee;"], [0, "&angrtvb;"], [0, "&lrtri;"], [0, "&bigwedge;"], [0, "&bigvee;"], [0, "&bigcap;"], [0, "&bigcup;"], [0, "&diam;"], [0, "&sdot;"], [0, "&sstarf;"], [0, "&divideontimes;"], [0, "&bowtie;"], [0, "&ltimes;"], [0, "&rtimes;"], [0, "&leftthreetimes;"], [0, "&rightthreetimes;"], [0, "&backsimeq;"], [0, "&curlyvee;"], [0, "&curlywedge;"], [0, "&Sub;"], [0, "&Sup;"], [0, "&Cap;"], [0, "&Cup;"], [0, "&fork;"], [0, "&epar;"], [0, "&lessdot;"], [0, "&gtdot;"], [0, { v: "&Ll;", n: 824, o: "&nLl;" }], [0, { v: "&Gg;", n: 824, o: "&nGg;" }], [0, { v: "&leg;", n: 65024, o: "&lesg;" }], [0, { v: "&gel;", n: 65024, o: "&gesl;" }], [2, "&cuepr;"], [0, "&cuesc;"], [0, "&NotPrecedesSlantEqual;"], [0, "&NotSucceedsSlantEqual;"], [0, "&NotSquareSubsetEqual;"], [0, "&NotSquareSupersetEqual;"], [2, "&lnsim;"], [0, "&gnsim;"], [0, "&precnsim;"], [0, "&scnsim;"], [0, "&nltri;"], [0, "&NotRightTriangle;"], [0, "&nltrie;"], [0, "&NotRightTriangleEqual;"], [0, "&vellip;"], [0, "&ctdot;"], [0, "&utdot;"], [0, "&dtdot;"], [0, "&disin;"], [0, "&isinsv;"], [0, "&isins;"], [0, { v: "&isindot;", n: 824, o: "&notindot;" }], [0, "&notinvc;"], [0, "&notinvb;"], [1, { v: "&isinE;", n: 824, o: "&notinE;" }], [0, "&nisd;"], [0, "&xnis;"], [0, "&nis;"], [0, "&notnivc;"], [0, "&notnivb;"], [6, "&barwed;"], [0, "&Barwed;"], [1, "&lceil;"], [0, "&rceil;"], [0, "&LeftFloor;"], [0, "&rfloor;"], [0, "&drcrop;"], [0, "&dlcrop;"], [0, "&urcrop;"], [0, "&ulcrop;"], [0, "&bnot;"], [1, "&profline;"], [0, "&profsurf;"], [1, "&telrec;"], [0, "&target;"], [5, "&ulcorn;"], [0, "&urcorn;"], [0, "&dlcorn;"], [0, "&drcorn;"], [2, "&frown;"], [0, "&smile;"], [9, "&cylcty;"], [0, "&profalar;"], [7, "&topbot;"], [6, "&ovbar;"], [1, "&solbar;"], [60, "&angzarr;"], [51, "&lmoustache;"], [0, "&rmoustache;"], [2, "&OverBracket;"], [0, "&bbrk;"], [0, "&bbrktbrk;"], [37, "&OverParenthesis;"], [0, "&UnderParenthesis;"], [0, "&OverBrace;"], [0, "&UnderBrace;"], [2, "&trpezium;"], [4, "&elinters;"], [59, "&blank;"], [164, "&circledS;"], [55, "&boxh;"], [1, "&boxv;"], [9, "&boxdr;"], [3, "&boxdl;"], [3, "&boxur;"], [3, "&boxul;"], [3, "&boxvr;"], [7, "&boxvl;"], [7, "&boxhd;"], [7, "&boxhu;"], [7, "&boxvh;"], [19, "&boxH;"], [0, "&boxV;"], [0, "&boxdR;"], [0, "&boxDr;"], [0, "&boxDR;"], [0, "&boxdL;"], [0, "&boxDl;"], [0, "&boxDL;"], [0, "&boxuR;"], [0, "&boxUr;"], [0, "&boxUR;"], [0, "&boxuL;"], [0, "&boxUl;"], [0, "&boxUL;"], [0, "&boxvR;"], [0, "&boxVr;"], [0, "&boxVR;"], [0, "&boxvL;"], [0, "&boxVl;"], [0, "&boxVL;"], [0, "&boxHd;"], [0, "&boxhD;"], [0, "&boxHD;"], [0, "&boxHu;"], [0, "&boxhU;"], [0, "&boxHU;"], [0, "&boxvH;"], [0, "&boxVh;"], [0, "&boxVH;"], [19, "&uhblk;"], [3, "&lhblk;"], [3, "&block;"], [8, "&blk14;"], [0, "&blk12;"], [0, "&blk34;"], [13, "&square;"], [8, "&blacksquare;"], [0, "&EmptyVerySmallSquare;"], [1, "&rect;"], [0, "&marker;"], [2, "&fltns;"], [1, "&bigtriangleup;"], [0, "&blacktriangle;"], [0, "&triangle;"], [2, "&blacktriangleright;"], [0, "&rtri;"], [3, "&bigtriangledown;"], [0, "&blacktriangledown;"], [0, "&dtri;"], [2, "&blacktriangleleft;"], [0, "&ltri;"], [6, "&loz;"], [0, "&cir;"], [32, "&tridot;"], [2, "&bigcirc;"], [8, "&ultri;"], [0, "&urtri;"], [0, "&lltri;"], [0, "&EmptySmallSquare;"], [0, "&FilledSmallSquare;"], [8, "&bigstar;"], [0, "&star;"], [7, "&phone;"], [49, "&female;"], [1, "&male;"], [29, "&spades;"], [2, "&clubs;"], [1, "&hearts;"], [0, "&diamondsuit;"], [3, "&sung;"], [2, "&flat;"], [0, "&natural;"], [0, "&sharp;"], [163, "&check;"], [3, "&cross;"], [8, "&malt;"], [21, "&sext;"], [33, "&VerticalSeparator;"], [25, "&lbbrk;"], [0, "&rbbrk;"], [84, "&bsolhsub;"], [0, "&suphsol;"], [28, "&LeftDoubleBracket;"], [0, "&RightDoubleBracket;"], [0, "&lang;"], [0, "&rang;"], [0, "&Lang;"], [0, "&Rang;"], [0, "&loang;"], [0, "&roang;"], [7, "&longleftarrow;"], [0, "&longrightarrow;"], [0, "&longleftrightarrow;"], [0, "&DoubleLongLeftArrow;"], [0, "&DoubleLongRightArrow;"], [0, "&DoubleLongLeftRightArrow;"], [1, "&longmapsto;"], [2, "&dzigrarr;"], [258, "&nvlArr;"], [0, "&nvrArr;"], [0, "&nvHarr;"], [0, "&Map;"], [6, "&lbarr;"], [0, "&bkarow;"], [0, "&lBarr;"], [0, "&dbkarow;"], [0, "&drbkarow;"], [0, "&DDotrahd;"], [0, "&UpArrowBar;"], [0, "&DownArrowBar;"], [2, "&Rarrtl;"], [2, "&latail;"], [0, "&ratail;"], [0, "&lAtail;"], [0, "&rAtail;"], [0, "&larrfs;"], [0, "&rarrfs;"], [0, "&larrbfs;"], [0, "&rarrbfs;"], [2, "&nwarhk;"], [0, "&nearhk;"], [0, "&hksearow;"], [0, "&hkswarow;"], [0, "&nwnear;"], [0, "&nesear;"], [0, "&seswar;"], [0, "&swnwar;"], [8, { v: "&rarrc;", n: 824, o: "&nrarrc;" }], [1, "&cudarrr;"], [0, "&ldca;"], [0, "&rdca;"], [0, "&cudarrl;"], [0, "&larrpl;"], [2, "&curarrm;"], [0, "&cularrp;"], [7, "&rarrpl;"], [2, "&harrcir;"], [0, "&Uarrocir;"], [0, "&lurdshar;"], [0, "&ldrushar;"], [2, "&LeftRightVector;"], [0, "&RightUpDownVector;"], [0, "&DownLeftRightVector;"], [0, "&LeftUpDownVector;"], [0, "&LeftVectorBar;"], [0, "&RightVectorBar;"], [0, "&RightUpVectorBar;"], [0, "&RightDownVectorBar;"], [0, "&DownLeftVectorBar;"], [0, "&DownRightVectorBar;"], [0, "&LeftUpVectorBar;"], [0, "&LeftDownVectorBar;"], [0, "&LeftTeeVector;"], [0, "&RightTeeVector;"], [0, "&RightUpTeeVector;"], [0, "&RightDownTeeVector;"], [0, "&DownLeftTeeVector;"], [0, "&DownRightTeeVector;"], [0, "&LeftUpTeeVector;"], [0, "&LeftDownTeeVector;"], [0, "&lHar;"], [0, "&uHar;"], [0, "&rHar;"], [0, "&dHar;"], [0, "&luruhar;"], [0, "&ldrdhar;"], [0, "&ruluhar;"], [0, "&rdldhar;"], [0, "&lharul;"], [0, "&llhard;"], [0, "&rharul;"], [0, "&lrhard;"], [0, "&udhar;"], [0, "&duhar;"], [0, "&RoundImplies;"], [0, "&erarr;"], [0, "&simrarr;"], [0, "&larrsim;"], [0, "&rarrsim;"], [0, "&rarrap;"], [0, "&ltlarr;"], [1, "&gtrarr;"], [0, "&subrarr;"], [1, "&suplarr;"], [0, "&lfisht;"], [0, "&rfisht;"], [0, "&ufisht;"], [0, "&dfisht;"], [5, "&lopar;"], [0, "&ropar;"], [4, "&lbrke;"], [0, "&rbrke;"], [0, "&lbrkslu;"], [0, "&rbrksld;"], [0, "&lbrksld;"], [0, "&rbrkslu;"], [0, "&langd;"], [0, "&rangd;"], [0, "&lparlt;"], [0, "&rpargt;"], [0, "&gtlPar;"], [0, "&ltrPar;"], [3, "&vzigzag;"], [1, "&vangrt;"], [0, "&angrtvbd;"], [6, "&ange;"], [0, "&range;"], [0, "&dwangle;"], [0, "&uwangle;"], [0, "&angmsdaa;"], [0, "&angmsdab;"], [0, "&angmsdac;"], [0, "&angmsdad;"], [0, "&angmsdae;"], [0, "&angmsdaf;"], [0, "&angmsdag;"], [0, "&angmsdah;"], [0, "&bemptyv;"], [0, "&demptyv;"], [0, "&cemptyv;"], [0, "&raemptyv;"], [0, "&laemptyv;"], [0, "&ohbar;"], [0, "&omid;"], [0, "&opar;"], [1, "&operp;"], [1, "&olcross;"], [0, "&odsold;"], [1, "&olcir;"], [0, "&ofcir;"], [0, "&olt;"], [0, "&ogt;"], [0, "&cirscir;"], [0, "&cirE;"], [0, "&solb;"], [0, "&bsolb;"], [3, "&boxbox;"], [3, "&trisb;"], [0, "&rtriltri;"], [0, { v: "&LeftTriangleBar;", n: 824, o: "&NotLeftTriangleBar;" }], [0, { v: "&RightTriangleBar;", n: 824, o: "&NotRightTriangleBar;" }], [11, "&iinfin;"], [0, "&infintie;"], [0, "&nvinfin;"], [4, "&eparsl;"], [0, "&smeparsl;"], [0, "&eqvparsl;"], [5, "&blacklozenge;"], [8, "&RuleDelayed;"], [1, "&dsol;"], [9, "&bigodot;"], [0, "&bigoplus;"], [0, "&bigotimes;"], [1, "&biguplus;"], [1, "&bigsqcup;"], [5, "&iiiint;"], [0, "&fpartint;"], [2, "&cirfnint;"], [0, "&awint;"], [0, "&rppolint;"], [0, "&scpolint;"], [0, "&npolint;"], [0, "&pointint;"], [0, "&quatint;"], [0, "&intlarhk;"], [10, "&pluscir;"], [0, "&plusacir;"], [0, "&simplus;"], [0, "&plusdu;"], [0, "&plussim;"], [0, "&plustwo;"], [1, "&mcomma;"], [0, "&minusdu;"], [2, "&loplus;"], [0, "&roplus;"], [0, "&Cross;"], [0, "&timesd;"], [0, "&timesbar;"], [1, "&smashp;"], [0, "&lotimes;"], [0, "&rotimes;"], [0, "&otimesas;"], [0, "&Otimes;"], [0, "&odiv;"], [0, "&triplus;"], [0, "&triminus;"], [0, "&tritime;"], [0, "&intprod;"], [2, "&amalg;"], [0, "&capdot;"], [1, "&ncup;"], [0, "&ncap;"], [0, "&capand;"], [0, "&cupor;"], [0, "&cupcap;"], [0, "&capcup;"], [0, "&cupbrcap;"], [0, "&capbrcup;"], [0, "&cupcup;"], [0, "&capcap;"], [0, "&ccups;"], [0, "&ccaps;"], [2, "&ccupssm;"], [2, "&And;"], [0, "&Or;"], [0, "&andand;"], [0, "&oror;"], [0, "&orslope;"], [0, "&andslope;"], [1, "&andv;"], [0, "&orv;"], [0, "&andd;"], [0, "&ord;"], [1, "&wedbar;"], [6, "&sdote;"], [3, "&simdot;"], [2, { v: "&congdot;", n: 824, o: "&ncongdot;" }], [0, "&easter;"], [0, "&apacir;"], [0, { v: "&apE;", n: 824, o: "&napE;" }], [0, "&eplus;"], [0, "&pluse;"], [0, "&Esim;"], [0, "&Colone;"], [0, "&Equal;"], [1, "&ddotseq;"], [0, "&equivDD;"], [0, "&ltcir;"], [0, "&gtcir;"], [0, "&ltquest;"], [0, "&gtquest;"], [0, { v: "&leqslant;", n: 824, o: "&nleqslant;" }], [0, { v: "&geqslant;", n: 824, o: "&ngeqslant;" }], [0, "&lesdot;"], [0, "&gesdot;"], [0, "&lesdoto;"], [0, "&gesdoto;"], [0, "&lesdotor;"], [0, "&gesdotol;"], [0, "&lap;"], [0, "&gap;"], [0, "&lne;"], [0, "&gne;"], [0, "&lnap;"], [0, "&gnap;"], [0, "&lEg;"], [0, "&gEl;"], [0, "&lsime;"], [0, "&gsime;"], [0, "&lsimg;"], [0, "&gsiml;"], [0, "&lgE;"], [0, "&glE;"], [0, "&lesges;"], [0, "&gesles;"], [0, "&els;"], [0, "&egs;"], [0, "&elsdot;"], [0, "&egsdot;"], [0, "&el;"], [0, "&eg;"], [2, "&siml;"], [0, "&simg;"], [0, "&simlE;"], [0, "&simgE;"], [0, { v: "&LessLess;", n: 824, o: "&NotNestedLessLess;" }], [0, { v: "&GreaterGreater;", n: 824, o: "&NotNestedGreaterGreater;" }], [1, "&glj;"], [0, "&gla;"], [0, "&ltcc;"], [0, "&gtcc;"], [0, "&lescc;"], [0, "&gescc;"], [0, "&smt;"], [0, "&lat;"], [0, { v: "&smte;", n: 65024, o: "&smtes;" }], [0, { v: "&late;", n: 65024, o: "&lates;" }], [0, "&bumpE;"], [0, { v: "&PrecedesEqual;", n: 824, o: "&NotPrecedesEqual;" }], [0, { v: "&sce;", n: 824, o: "&NotSucceedsEqual;" }], [2, "&prE;"], [0, "&scE;"], [0, "&precneqq;"], [0, "&scnE;"], [0, "&prap;"], [0, "&scap;"], [0, "&precnapprox;"], [0, "&scnap;"], [0, "&Pr;"], [0, "&Sc;"], [0, "&subdot;"], [0, "&supdot;"], [0, "&subplus;"], [0, "&supplus;"], [0, "&submult;"], [0, "&supmult;"], [0, "&subedot;"], [0, "&supedot;"], [0, { v: "&subE;", n: 824, o: "&nsubE;" }], [0, { v: "&supE;", n: 824, o: "&nsupE;" }], [0, "&subsim;"], [0, "&supsim;"], [2, { v: "&subnE;", n: 65024, o: "&varsubsetneqq;" }], [0, { v: "&supnE;", n: 65024, o: "&varsupsetneqq;" }], [2, "&csub;"], [0, "&csup;"], [0, "&csube;"], [0, "&csupe;"], [0, "&subsup;"], [0, "&supsub;"], [0, "&subsub;"], [0, "&supsup;"], [0, "&suphsub;"], [0, "&supdsub;"], [0, "&forkv;"], [0, "&topfork;"], [0, "&mlcp;"], [8, "&Dashv;"], [1, "&Vdashl;"], [0, "&Barv;"], [0, "&vBar;"], [0, "&vBarv;"], [1, "&Vbar;"], [0, "&Not;"], [0, "&bNot;"], [0, "&rnmid;"], [0, "&cirmid;"], [0, "&midcir;"], [0, "&topcir;"], [0, "&nhpar;"], [0, "&parsim;"], [9, { v: "&parsl;", n: 8421, o: "&nparsl;" }], [44343, { n: new Map(restoreDiff([[56476, "&Ascr;"], [1, "&Cscr;"], [0, "&Dscr;"], [2, "&Gscr;"], [2, "&Jscr;"], [0, "&Kscr;"], [2, "&Nscr;"], [0, "&Oscr;"], [0, "&Pscr;"], [0, "&Qscr;"], [1, "&Sscr;"], [0, "&Tscr;"], [0, "&Uscr;"], [0, "&Vscr;"], [0, "&Wscr;"], [0, "&Xscr;"], [0, "&Yscr;"], [0, "&Zscr;"], [0, "&ascr;"], [0, "&bscr;"], [0, "&cscr;"], [0, "&dscr;"], [1, "&fscr;"], [1, "&hscr;"], [0, "&iscr;"], [0, "&jscr;"], [0, "&kscr;"], [0, "&lscr;"], [0, "&mscr;"], [0, "&nscr;"], [1, "&pscr;"], [0, "&qscr;"], [0, "&rscr;"], [0, "&sscr;"], [0, "&tscr;"], [0, "&uscr;"], [0, "&vscr;"], [0, "&wscr;"], [0, "&xscr;"], [0, "&yscr;"], [0, "&zscr;"], [52, "&Afr;"], [0, "&Bfr;"], [1, "&Dfr;"], [0, "&Efr;"], [0, "&Ffr;"], [0, "&Gfr;"], [2, "&Jfr;"], [0, "&Kfr;"], [0, "&Lfr;"], [0, "&Mfr;"], [0, "&Nfr;"], [0, "&Ofr;"], [0, "&Pfr;"], [0, "&Qfr;"], [1, "&Sfr;"], [0, "&Tfr;"], [0, "&Ufr;"], [0, "&Vfr;"], [0, "&Wfr;"], [0, "&Xfr;"], [0, "&Yfr;"], [1, "&afr;"], [0, "&bfr;"], [0, "&cfr;"], [0, "&dfr;"], [0, "&efr;"], [0, "&ffr;"], [0, "&gfr;"], [0, "&hfr;"], [0, "&ifr;"], [0, "&jfr;"], [0, "&kfr;"], [0, "&lfr;"], [0, "&mfr;"], [0, "&nfr;"], [0, "&ofr;"], [0, "&pfr;"], [0, "&qfr;"], [0, "&rfr;"], [0, "&sfr;"], [0, "&tfr;"], [0, "&ufr;"], [0, "&vfr;"], [0, "&wfr;"], [0, "&xfr;"], [0, "&yfr;"], [0, "&zfr;"], [0, "&Aopf;"], [0, "&Bopf;"], [1, "&Dopf;"], [0, "&Eopf;"], [0, "&Fopf;"], [0, "&Gopf;"], [1, "&Iopf;"], [0, "&Jopf;"], [0, "&Kopf;"], [0, "&Lopf;"], [0, "&Mopf;"], [1, "&Oopf;"], [3, "&Sopf;"], [0, "&Topf;"], [0, "&Uopf;"], [0, "&Vopf;"], [0, "&Wopf;"], [0, "&Xopf;"], [0, "&Yopf;"], [1, "&aopf;"], [0, "&bopf;"], [0, "&copf;"], [0, "&dopf;"], [0, "&eopf;"], [0, "&fopf;"], [0, "&gopf;"], [0, "&hopf;"], [0, "&iopf;"], [0, "&jopf;"], [0, "&kopf;"], [0, "&lopf;"], [0, "&mopf;"], [0, "&nopf;"], [0, "&oopf;"], [0, "&popf;"], [0, "&qopf;"], [0, "&ropf;"], [0, "&sopf;"], [0, "&topf;"], [0, "&uopf;"], [0, "&vopf;"], [0, "&wopf;"], [0, "&xopf;"], [0, "&yopf;"], [0, "&zopf;"]])) }], [8906, "&fflig;"], [0, "&filig;"], [0, "&fllig;"], [0, "&ffilig;"], [0, "&ffllig;"]]));

// node_modules/.pnpm/entities@4.5.0/node_modules/entities/lib/esm/escape.js
var xmlReplacer = /["&'<>$\x80-\uFFFF]/g;
var xmlCodeMap = /* @__PURE__ */ new Map([
  [34, "&quot;"],
  [38, "&amp;"],
  [39, "&apos;"],
  [60, "&lt;"],
  [62, "&gt;"]
]);
var getCodePoint = (
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  String.prototype.codePointAt != null ? (str2, index2) => str2.codePointAt(index2) : (
    // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
    (c, index2) => (c.charCodeAt(index2) & 64512) === 55296 ? (c.charCodeAt(index2) - 55296) * 1024 + c.charCodeAt(index2 + 1) - 56320 + 65536 : c.charCodeAt(index2)
  )
);
function encodeXML(str2) {
  let ret = "";
  let lastIdx = 0;
  let match2;
  while ((match2 = xmlReplacer.exec(str2)) !== null) {
    const i = match2.index;
    const char = str2.charCodeAt(i);
    const next2 = xmlCodeMap.get(char);
    if (next2 !== void 0) {
      ret += str2.substring(lastIdx, i) + next2;
      lastIdx = i + 1;
    } else {
      ret += `${str2.substring(lastIdx, i)}&#x${getCodePoint(str2, i).toString(16)};`;
      lastIdx = xmlReplacer.lastIndex += Number((char & 64512) === 55296);
    }
  }
  return ret + str2.substr(lastIdx);
}
function getEscaper(regex, map4) {
  return function escape3(data2) {
    let match2;
    let lastIdx = 0;
    let result = "";
    while (match2 = regex.exec(data2)) {
      if (lastIdx !== match2.index) {
        result += data2.substring(lastIdx, match2.index);
      }
      result += map4.get(match2[0].charCodeAt(0));
      lastIdx = match2.index + 1;
    }
    return result + data2.substring(lastIdx);
  };
}
var escapeUTF8 = getEscaper(/[&<>'"]/g, xmlCodeMap);
var escapeAttribute = getEscaper(/["&\u00A0]/g, /* @__PURE__ */ new Map([
  [34, "&quot;"],
  [38, "&amp;"],
  [160, "&nbsp;"]
]));
var escapeText = getEscaper(/[&<>\u00A0]/g, /* @__PURE__ */ new Map([
  [38, "&amp;"],
  [60, "&lt;"],
  [62, "&gt;"],
  [160, "&nbsp;"]
]));

// node_modules/.pnpm/entities@4.5.0/node_modules/entities/lib/esm/index.js
var EntityLevel;
(function(EntityLevel2) {
  EntityLevel2[EntityLevel2["XML"] = 0] = "XML";
  EntityLevel2[EntityLevel2["HTML"] = 1] = "HTML";
})(EntityLevel || (EntityLevel = {}));
var EncodingMode;
(function(EncodingMode2) {
  EncodingMode2[EncodingMode2["UTF8"] = 0] = "UTF8";
  EncodingMode2[EncodingMode2["ASCII"] = 1] = "ASCII";
  EncodingMode2[EncodingMode2["Extensive"] = 2] = "Extensive";
  EncodingMode2[EncodingMode2["Attribute"] = 3] = "Attribute";
  EncodingMode2[EncodingMode2["Text"] = 4] = "Text";
})(EncodingMode || (EncodingMode = {}));

// node_modules/.pnpm/dom-serializer@2.0.0/node_modules/dom-serializer/lib/esm/foreignNames.js
var elementNames = new Map([
  "altGlyph",
  "altGlyphDef",
  "altGlyphItem",
  "animateColor",
  "animateMotion",
  "animateTransform",
  "clipPath",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feDistantLight",
  "feDropShadow",
  "feFlood",
  "feFuncA",
  "feFuncB",
  "feFuncG",
  "feFuncR",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMergeNode",
  "feMorphology",
  "feOffset",
  "fePointLight",
  "feSpecularLighting",
  "feSpotLight",
  "feTile",
  "feTurbulence",
  "foreignObject",
  "glyphRef",
  "linearGradient",
  "radialGradient",
  "textPath"
].map((val2) => [val2.toLowerCase(), val2]));
var attributeNames = new Map([
  "definitionURL",
  "attributeName",
  "attributeType",
  "baseFrequency",
  "baseProfile",
  "calcMode",
  "clipPathUnits",
  "diffuseConstant",
  "edgeMode",
  "filterUnits",
  "glyphRef",
  "gradientTransform",
  "gradientUnits",
  "kernelMatrix",
  "kernelUnitLength",
  "keyPoints",
  "keySplines",
  "keyTimes",
  "lengthAdjust",
  "limitingConeAngle",
  "markerHeight",
  "markerUnits",
  "markerWidth",
  "maskContentUnits",
  "maskUnits",
  "numOctaves",
  "pathLength",
  "patternContentUnits",
  "patternTransform",
  "patternUnits",
  "pointsAtX",
  "pointsAtY",
  "pointsAtZ",
  "preserveAlpha",
  "preserveAspectRatio",
  "primitiveUnits",
  "refX",
  "refY",
  "repeatCount",
  "repeatDur",
  "requiredExtensions",
  "requiredFeatures",
  "specularConstant",
  "specularExponent",
  "spreadMethod",
  "startOffset",
  "stdDeviation",
  "stitchTiles",
  "surfaceScale",
  "systemLanguage",
  "tableValues",
  "targetX",
  "targetY",
  "textLength",
  "viewBox",
  "viewTarget",
  "xChannelSelector",
  "yChannelSelector",
  "zoomAndPan"
].map((val2) => [val2.toLowerCase(), val2]));

// node_modules/.pnpm/dom-serializer@2.0.0/node_modules/dom-serializer/lib/esm/index.js
var unencodedElements = /* @__PURE__ */ new Set([
  "style",
  "script",
  "xmp",
  "iframe",
  "noembed",
  "noframes",
  "plaintext",
  "noscript"
]);
function replaceQuotes(value) {
  return value.replace(/"/g, "&quot;");
}
function formatAttributes(attributes2, opts) {
  var _a2;
  if (!attributes2)
    return;
  const encode3 = ((_a2 = opts.encodeEntities) !== null && _a2 !== void 0 ? _a2 : opts.decodeEntities) === false ? replaceQuotes : opts.xmlMode || opts.encodeEntities !== "utf8" ? encodeXML : escapeAttribute;
  return Object.keys(attributes2).map((key) => {
    var _a3, _b;
    const value = (_a3 = attributes2[key]) !== null && _a3 !== void 0 ? _a3 : "";
    if (opts.xmlMode === "foreign") {
      key = (_b = attributeNames.get(key)) !== null && _b !== void 0 ? _b : key;
    }
    if (!opts.emptyAttrs && !opts.xmlMode && value === "") {
      return key;
    }
    return `${key}="${encode3(value)}"`;
  }).join(" ");
}
var singleTag = /* @__PURE__ */ new Set([
  "area",
  "base",
  "basefont",
  "br",
  "col",
  "command",
  "embed",
  "frame",
  "hr",
  "img",
  "input",
  "isindex",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
]);
function render(node, options = {}) {
  const nodes = "length" in node ? node : [node];
  let output = "";
  for (let i = 0; i < nodes.length; i++) {
    output += renderNode(nodes[i], options);
  }
  return output;
}
var esm_default = render;
function renderNode(node, options) {
  switch (node.type) {
    case Root:
      return render(node.children, options);
    case Doctype:
    case Directive:
      return renderDirective(node);
    case Comment:
      return renderComment(node);
    case CDATA:
      return renderCdata(node);
    case Script:
    case Style:
    case Tag:
      return renderTag(node, options);
    case Text:
      return renderText(node, options);
  }
}
var foreignModeIntegrationPoints = /* @__PURE__ */ new Set([
  "mi",
  "mo",
  "mn",
  "ms",
  "mtext",
  "annotation-xml",
  "foreignObject",
  "desc",
  "title"
]);
var foreignElements = /* @__PURE__ */ new Set(["svg", "math"]);
function renderTag(elem, opts) {
  var _a2;
  if (opts.xmlMode === "foreign") {
    elem.name = (_a2 = elementNames.get(elem.name)) !== null && _a2 !== void 0 ? _a2 : elem.name;
    if (elem.parent && foreignModeIntegrationPoints.has(elem.parent.name)) {
      opts = { ...opts, xmlMode: false };
    }
  }
  if (!opts.xmlMode && foreignElements.has(elem.name)) {
    opts = { ...opts, xmlMode: "foreign" };
  }
  let tag = `<${elem.name}`;
  const attribs = formatAttributes(elem.attribs, opts);
  if (attribs) {
    tag += ` ${attribs}`;
  }
  if (elem.children.length === 0 && (opts.xmlMode ? (
    // In XML mode or foreign mode, and user hasn't explicitly turned off self-closing tags
    opts.selfClosingTags !== false
  ) : (
    // User explicitly asked for self-closing tags, even in HTML mode
    opts.selfClosingTags && singleTag.has(elem.name)
  ))) {
    if (!opts.xmlMode)
      tag += " ";
    tag += "/>";
  } else {
    tag += ">";
    if (elem.children.length > 0) {
      tag += render(elem.children, opts);
    }
    if (opts.xmlMode || !singleTag.has(elem.name)) {
      tag += `</${elem.name}>`;
    }
  }
  return tag;
}
function renderDirective(elem) {
  return `<${elem.data}>`;
}
function renderText(elem, opts) {
  var _a2;
  let data2 = elem.data || "";
  if (((_a2 = opts.encodeEntities) !== null && _a2 !== void 0 ? _a2 : opts.decodeEntities) !== false && !(!opts.xmlMode && elem.parent && unencodedElements.has(elem.parent.name))) {
    data2 = opts.xmlMode || opts.encodeEntities !== "utf8" ? encodeXML(data2) : escapeText(data2);
  }
  return data2;
}
function renderCdata(elem) {
  return `<![CDATA[${elem.children[0].data}]]>`;
}
function renderComment(elem) {
  return `<!--${elem.data}-->`;
}

// node_modules/.pnpm/domutils@3.1.0/node_modules/domutils/lib/esm/stringify.js
function getOuterHTML(node, options) {
  return esm_default(node, options);
}
function getInnerHTML(node, options) {
  return hasChildren(node) ? node.children.map((node2) => getOuterHTML(node2, options)).join("") : "";
}
function getText(node) {
  if (Array.isArray(node))
    return node.map(getText).join("");
  if (isTag2(node))
    return node.name === "br" ? "\n" : getText(node.children);
  if (isCDATA(node))
    return getText(node.children);
  if (isText(node))
    return node.data;
  return "";
}
function textContent(node) {
  if (Array.isArray(node))
    return node.map(textContent).join("");
  if (hasChildren(node) && !isComment(node)) {
    return textContent(node.children);
  }
  if (isText(node))
    return node.data;
  return "";
}
function innerText(node) {
  if (Array.isArray(node))
    return node.map(innerText).join("");
  if (hasChildren(node) && (node.type === ElementType.Tag || isCDATA(node))) {
    return innerText(node.children);
  }
  if (isText(node))
    return node.data;
  return "";
}

// node_modules/.pnpm/domutils@3.1.0/node_modules/domutils/lib/esm/traversal.js
function getChildren(elem) {
  return hasChildren(elem) ? elem.children : [];
}
function getParent(elem) {
  return elem.parent || null;
}
function getSiblings(elem) {
  const parent2 = getParent(elem);
  if (parent2 != null)
    return getChildren(parent2);
  const siblings2 = [elem];
  let { prev: prev2, next: next2 } = elem;
  while (prev2 != null) {
    siblings2.unshift(prev2);
    ({ prev: prev2 } = prev2);
  }
  while (next2 != null) {
    siblings2.push(next2);
    ({ next: next2 } = next2);
  }
  return siblings2;
}
function getAttributeValue(elem, name2) {
  var _a2;
  return (_a2 = elem.attribs) === null || _a2 === void 0 ? void 0 : _a2[name2];
}
function hasAttrib(elem, name2) {
  return elem.attribs != null && Object.prototype.hasOwnProperty.call(elem.attribs, name2) && elem.attribs[name2] != null;
}
function getName(elem) {
  return elem.name;
}
function nextElementSibling(elem) {
  let { next: next2 } = elem;
  while (next2 !== null && !isTag2(next2))
    ({ next: next2 } = next2);
  return next2;
}
function prevElementSibling(elem) {
  let { prev: prev2 } = elem;
  while (prev2 !== null && !isTag2(prev2))
    ({ prev: prev2 } = prev2);
  return prev2;
}

// node_modules/.pnpm/domutils@3.1.0/node_modules/domutils/lib/esm/manipulation.js
function removeElement(elem) {
  if (elem.prev)
    elem.prev.next = elem.next;
  if (elem.next)
    elem.next.prev = elem.prev;
  if (elem.parent) {
    const childs = elem.parent.children;
    const childsIndex = childs.lastIndexOf(elem);
    if (childsIndex >= 0) {
      childs.splice(childsIndex, 1);
    }
  }
  elem.next = null;
  elem.prev = null;
  elem.parent = null;
}
function replaceElement(elem, replacement) {
  const prev2 = replacement.prev = elem.prev;
  if (prev2) {
    prev2.next = replacement;
  }
  const next2 = replacement.next = elem.next;
  if (next2) {
    next2.prev = replacement;
  }
  const parent2 = replacement.parent = elem.parent;
  if (parent2) {
    const childs = parent2.children;
    childs[childs.lastIndexOf(elem)] = replacement;
    elem.parent = null;
  }
}
function appendChild(parent2, child) {
  removeElement(child);
  child.next = null;
  child.parent = parent2;
  if (parent2.children.push(child) > 1) {
    const sibling = parent2.children[parent2.children.length - 2];
    sibling.next = child;
    child.prev = sibling;
  } else {
    child.prev = null;
  }
}
function append(elem, next2) {
  removeElement(next2);
  const { parent: parent2 } = elem;
  const currNext = elem.next;
  next2.next = currNext;
  next2.prev = elem;
  elem.next = next2;
  next2.parent = parent2;
  if (currNext) {
    currNext.prev = next2;
    if (parent2) {
      const childs = parent2.children;
      childs.splice(childs.lastIndexOf(currNext), 0, next2);
    }
  } else if (parent2) {
    parent2.children.push(next2);
  }
}
function prependChild(parent2, child) {
  removeElement(child);
  child.parent = parent2;
  child.prev = null;
  if (parent2.children.unshift(child) !== 1) {
    const sibling = parent2.children[1];
    sibling.prev = child;
    child.next = sibling;
  } else {
    child.next = null;
  }
}
function prepend(elem, prev2) {
  removeElement(prev2);
  const { parent: parent2 } = elem;
  if (parent2) {
    const childs = parent2.children;
    childs.splice(childs.indexOf(elem), 0, prev2);
  }
  if (elem.prev) {
    elem.prev.next = prev2;
  }
  prev2.parent = parent2;
  prev2.prev = elem.prev;
  prev2.next = elem;
  elem.prev = prev2;
}

// node_modules/.pnpm/domutils@3.1.0/node_modules/domutils/lib/esm/querying.js
function filter(test2, node, recurse = true, limit = Infinity) {
  return find(test2, Array.isArray(node) ? node : [node], recurse, limit);
}
function find(test2, nodes, recurse, limit) {
  const result = [];
  const nodeStack = [nodes];
  const indexStack = [0];
  for (; ; ) {
    if (indexStack[0] >= nodeStack[0].length) {
      if (indexStack.length === 1) {
        return result;
      }
      nodeStack.shift();
      indexStack.shift();
      continue;
    }
    const elem = nodeStack[0][indexStack[0]++];
    if (test2(elem)) {
      result.push(elem);
      if (--limit <= 0)
        return result;
    }
    if (recurse && hasChildren(elem) && elem.children.length > 0) {
      indexStack.unshift(0);
      nodeStack.unshift(elem.children);
    }
  }
}
function findOneChild(test2, nodes) {
  return nodes.find(test2);
}
function findOne(test2, nodes, recurse = true) {
  let elem = null;
  for (let i = 0; i < nodes.length && !elem; i++) {
    const node = nodes[i];
    if (!isTag2(node)) {
      continue;
    } else if (test2(node)) {
      elem = node;
    } else if (recurse && node.children.length > 0) {
      elem = findOne(test2, node.children, true);
    }
  }
  return elem;
}
function existsOne(test2, nodes) {
  return nodes.some((checked) => isTag2(checked) && (test2(checked) || existsOne(test2, checked.children)));
}
function findAll(test2, nodes) {
  const result = [];
  const nodeStack = [nodes];
  const indexStack = [0];
  for (; ; ) {
    if (indexStack[0] >= nodeStack[0].length) {
      if (nodeStack.length === 1) {
        return result;
      }
      nodeStack.shift();
      indexStack.shift();
      continue;
    }
    const elem = nodeStack[0][indexStack[0]++];
    if (!isTag2(elem))
      continue;
    if (test2(elem))
      result.push(elem);
    if (elem.children.length > 0) {
      indexStack.unshift(0);
      nodeStack.unshift(elem.children);
    }
  }
}

// node_modules/.pnpm/domutils@3.1.0/node_modules/domutils/lib/esm/legacy.js
var Checks = {
  tag_name(name2) {
    if (typeof name2 === "function") {
      return (elem) => isTag2(elem) && name2(elem.name);
    } else if (name2 === "*") {
      return isTag2;
    }
    return (elem) => isTag2(elem) && elem.name === name2;
  },
  tag_type(type2) {
    if (typeof type2 === "function") {
      return (elem) => type2(elem.type);
    }
    return (elem) => elem.type === type2;
  },
  tag_contains(data2) {
    if (typeof data2 === "function") {
      return (elem) => isText(elem) && data2(elem.data);
    }
    return (elem) => isText(elem) && elem.data === data2;
  }
};
function getAttribCheck(attrib, value) {
  if (typeof value === "function") {
    return (elem) => isTag2(elem) && value(elem.attribs[attrib]);
  }
  return (elem) => isTag2(elem) && elem.attribs[attrib] === value;
}
function combineFuncs(a, b) {
  return (elem) => a(elem) || b(elem);
}
function compileTest(options) {
  const funcs = Object.keys(options).map((key) => {
    const value = options[key];
    return Object.prototype.hasOwnProperty.call(Checks, key) ? Checks[key](value) : getAttribCheck(key, value);
  });
  return funcs.length === 0 ? null : funcs.reduce(combineFuncs);
}
function testElement(options, node) {
  const test2 = compileTest(options);
  return test2 ? test2(node) : true;
}
function getElements(options, nodes, recurse, limit = Infinity) {
  const test2 = compileTest(options);
  return test2 ? filter(test2, nodes, recurse, limit) : [];
}
function getElementById(id, nodes, recurse = true) {
  if (!Array.isArray(nodes))
    nodes = [nodes];
  return findOne(getAttribCheck("id", id), nodes, recurse);
}
function getElementsByTagName(tagName, nodes, recurse = true, limit = Infinity) {
  return filter(Checks["tag_name"](tagName), nodes, recurse, limit);
}
function getElementsByTagType(type2, nodes, recurse = true, limit = Infinity) {
  return filter(Checks["tag_type"](type2), nodes, recurse, limit);
}

// node_modules/.pnpm/domutils@3.1.0/node_modules/domutils/lib/esm/helpers.js
function removeSubsets(nodes) {
  let idx = nodes.length;
  while (--idx >= 0) {
    const node = nodes[idx];
    if (idx > 0 && nodes.lastIndexOf(node, idx - 1) >= 0) {
      nodes.splice(idx, 1);
      continue;
    }
    for (let ancestor = node.parent; ancestor; ancestor = ancestor.parent) {
      if (nodes.includes(ancestor)) {
        nodes.splice(idx, 1);
        break;
      }
    }
  }
  return nodes;
}
var DocumentPosition;
(function(DocumentPosition2) {
  DocumentPosition2[DocumentPosition2["DISCONNECTED"] = 1] = "DISCONNECTED";
  DocumentPosition2[DocumentPosition2["PRECEDING"] = 2] = "PRECEDING";
  DocumentPosition2[DocumentPosition2["FOLLOWING"] = 4] = "FOLLOWING";
  DocumentPosition2[DocumentPosition2["CONTAINS"] = 8] = "CONTAINS";
  DocumentPosition2[DocumentPosition2["CONTAINED_BY"] = 16] = "CONTAINED_BY";
})(DocumentPosition || (DocumentPosition = {}));
function compareDocumentPosition(nodeA, nodeB) {
  const aParents = [];
  const bParents = [];
  if (nodeA === nodeB) {
    return 0;
  }
  let current = hasChildren(nodeA) ? nodeA : nodeA.parent;
  while (current) {
    aParents.unshift(current);
    current = current.parent;
  }
  current = hasChildren(nodeB) ? nodeB : nodeB.parent;
  while (current) {
    bParents.unshift(current);
    current = current.parent;
  }
  const maxIdx = Math.min(aParents.length, bParents.length);
  let idx = 0;
  while (idx < maxIdx && aParents[idx] === bParents[idx]) {
    idx++;
  }
  if (idx === 0) {
    return DocumentPosition.DISCONNECTED;
  }
  const sharedParent = aParents[idx - 1];
  const siblings2 = sharedParent.children;
  const aSibling = aParents[idx];
  const bSibling = bParents[idx];
  if (siblings2.indexOf(aSibling) > siblings2.indexOf(bSibling)) {
    if (sharedParent === nodeB) {
      return DocumentPosition.FOLLOWING | DocumentPosition.CONTAINED_BY;
    }
    return DocumentPosition.FOLLOWING;
  }
  if (sharedParent === nodeA) {
    return DocumentPosition.PRECEDING | DocumentPosition.CONTAINS;
  }
  return DocumentPosition.PRECEDING;
}
function uniqueSort(nodes) {
  nodes = nodes.filter((node, i, arr) => !arr.includes(node, i + 1));
  nodes.sort((a, b) => {
    const relative = compareDocumentPosition(a, b);
    if (relative & DocumentPosition.PRECEDING) {
      return -1;
    } else if (relative & DocumentPosition.FOLLOWING) {
      return 1;
    }
    return 0;
  });
  return nodes;
}

// node_modules/.pnpm/domutils@3.1.0/node_modules/domutils/lib/esm/feeds.js
function getFeed(doc) {
  const feedRoot = getOneElement(isValidFeed, doc);
  return !feedRoot ? null : feedRoot.name === "feed" ? getAtomFeed(feedRoot) : getRssFeed(feedRoot);
}
function getAtomFeed(feedRoot) {
  var _a2;
  const childs = feedRoot.children;
  const feed = {
    type: "atom",
    items: getElementsByTagName("entry", childs).map((item) => {
      var _a3;
      const { children: children2 } = item;
      const entry = { media: getMediaElements(children2) };
      addConditionally(entry, "id", "id", children2);
      addConditionally(entry, "title", "title", children2);
      const href2 = (_a3 = getOneElement("link", children2)) === null || _a3 === void 0 ? void 0 : _a3.attribs["href"];
      if (href2) {
        entry.link = href2;
      }
      const description = fetch("summary", children2) || fetch("content", children2);
      if (description) {
        entry.description = description;
      }
      const pubDate = fetch("updated", children2);
      if (pubDate) {
        entry.pubDate = new Date(pubDate);
      }
      return entry;
    })
  };
  addConditionally(feed, "id", "id", childs);
  addConditionally(feed, "title", "title", childs);
  const href = (_a2 = getOneElement("link", childs)) === null || _a2 === void 0 ? void 0 : _a2.attribs["href"];
  if (href) {
    feed.link = href;
  }
  addConditionally(feed, "description", "subtitle", childs);
  const updated = fetch("updated", childs);
  if (updated) {
    feed.updated = new Date(updated);
  }
  addConditionally(feed, "author", "email", childs, true);
  return feed;
}
function getRssFeed(feedRoot) {
  var _a2, _b;
  const childs = (_b = (_a2 = getOneElement("channel", feedRoot.children)) === null || _a2 === void 0 ? void 0 : _a2.children) !== null && _b !== void 0 ? _b : [];
  const feed = {
    type: feedRoot.name.substr(0, 3),
    id: "",
    items: getElementsByTagName("item", feedRoot.children).map((item) => {
      const { children: children2 } = item;
      const entry = { media: getMediaElements(children2) };
      addConditionally(entry, "id", "guid", children2);
      addConditionally(entry, "title", "title", children2);
      addConditionally(entry, "link", "link", children2);
      addConditionally(entry, "description", "description", children2);
      const pubDate = fetch("pubDate", children2) || fetch("dc:date", children2);
      if (pubDate)
        entry.pubDate = new Date(pubDate);
      return entry;
    })
  };
  addConditionally(feed, "title", "title", childs);
  addConditionally(feed, "link", "link", childs);
  addConditionally(feed, "description", "description", childs);
  const updated = fetch("lastBuildDate", childs);
  if (updated) {
    feed.updated = new Date(updated);
  }
  addConditionally(feed, "author", "managingEditor", childs, true);
  return feed;
}
var MEDIA_KEYS_STRING = ["url", "type", "lang"];
var MEDIA_KEYS_INT = [
  "fileSize",
  "bitrate",
  "framerate",
  "samplingrate",
  "channels",
  "duration",
  "height",
  "width"
];
function getMediaElements(where) {
  return getElementsByTagName("media:content", where).map((elem) => {
    const { attribs } = elem;
    const media = {
      medium: attribs["medium"],
      isDefault: !!attribs["isDefault"]
    };
    for (const attrib of MEDIA_KEYS_STRING) {
      if (attribs[attrib]) {
        media[attrib] = attribs[attrib];
      }
    }
    for (const attrib of MEDIA_KEYS_INT) {
      if (attribs[attrib]) {
        media[attrib] = parseInt(attribs[attrib], 10);
      }
    }
    if (attribs["expression"]) {
      media.expression = attribs["expression"];
    }
    return media;
  });
}
function getOneElement(tagName, node) {
  return getElementsByTagName(tagName, node, true, 1)[0];
}
function fetch(tagName, where, recurse = false) {
  return textContent(getElementsByTagName(tagName, where, recurse, 1)).trim();
}
function addConditionally(obj, prop2, tagName, where, recurse = false) {
  const val2 = fetch(tagName, where, recurse);
  if (val2)
    obj[prop2] = val2;
}
function isValidFeed(value) {
  return value === "rss" || value === "feed" || value === "rdf:RDF";
}

// node_modules/.pnpm/cheerio@1.0.0-rc.12/node_modules/cheerio/lib/esm/static.js
function render2(that, dom, options) {
  if (!that)
    return "";
  return that(dom !== null && dom !== void 0 ? dom : that._root.children, null, void 0, options).toString();
}
function isOptions(dom, options) {
  return !options && typeof dom === "object" && dom != null && !("length" in dom) && !("type" in dom);
}
function html(dom, options) {
  const toRender = isOptions(dom) ? (options = dom, void 0) : dom;
  const opts = {
    ...options_default,
    ...this === null || this === void 0 ? void 0 : this._options,
    ...flatten(options !== null && options !== void 0 ? options : {})
  };
  return render2(this, toRender, opts);
}
function xml(dom) {
  const options = { ...this._options, xmlMode: true };
  return render2(this, dom, options);
}
function text(elements) {
  const elems = elements ? elements : this ? this.root() : [];
  let ret = "";
  for (let i = 0; i < elems.length; i++) {
    ret += textContent(elems[i]);
  }
  return ret;
}
function parseHTML(data2, context, keepScripts = typeof context === "boolean" ? context : false) {
  if (!data2 || typeof data2 !== "string") {
    return null;
  }
  if (typeof context === "boolean") {
    keepScripts = context;
  }
  const parsed = this.load(data2, options_default, false);
  if (!keepScripts) {
    parsed("script").remove();
  }
  return parsed.root()[0].children.slice();
}
function root() {
  return this(this._root);
}
function contains(container, contained) {
  if (contained === container) {
    return false;
  }
  let next2 = contained;
  while (next2 && next2 !== next2.parent) {
    next2 = next2.parent;
    if (next2 === container) {
      return true;
    }
  }
  return false;
}
function merge(arr1, arr2) {
  if (!isArrayLike(arr1) || !isArrayLike(arr2)) {
    return;
  }
  let newLength = arr1.length;
  const len = +arr2.length;
  for (let i = 0; i < len; i++) {
    arr1[newLength++] = arr2[i];
  }
  arr1.length = newLength;
  return arr1;
}
function isArrayLike(item) {
  if (Array.isArray(item)) {
    return true;
  }
  if (typeof item !== "object" || !Object.prototype.hasOwnProperty.call(item, "length") || typeof item.length !== "number" || item.length < 0) {
    return false;
  }
  for (let i = 0; i < item.length; i++) {
    if (!(i in item)) {
      return false;
    }
  }
  return true;
}

// node_modules/.pnpm/cheerio@1.0.0-rc.12/node_modules/cheerio/lib/esm/api/attributes.js
var attributes_exports = {};
__export(attributes_exports, {
  addClass: () => addClass,
  attr: () => attr,
  data: () => data,
  hasClass: () => hasClass,
  prop: () => prop,
  removeAttr: () => removeAttr,
  removeClass: () => removeClass,
  toggleClass: () => toggleClass,
  val: () => val
});

// node_modules/.pnpm/cheerio@1.0.0-rc.12/node_modules/cheerio/lib/esm/utils.js
function isCheerio(maybeCheerio) {
  return maybeCheerio.cheerio != null;
}
function camelCase(str2) {
  return str2.replace(/[_.-](\w|$)/g, (_, x) => x.toUpperCase());
}
function cssCase(str2) {
  return str2.replace(/[A-Z]/g, "-$&").toLowerCase();
}
function domEach(array, fn) {
  const len = array.length;
  for (let i = 0; i < len; i++)
    fn(array[i], i);
  return array;
}
function cloneDom(dom) {
  const clone2 = "length" in dom ? Array.prototype.map.call(dom, (el) => cloneNode(el, true)) : [cloneNode(dom, true)];
  const root3 = new Document(clone2);
  clone2.forEach((node) => {
    node.parent = root3;
  });
  return clone2;
}
var CharacterCodes;
(function(CharacterCodes2) {
  CharacterCodes2[CharacterCodes2["LowerA"] = 97] = "LowerA";
  CharacterCodes2[CharacterCodes2["LowerZ"] = 122] = "LowerZ";
  CharacterCodes2[CharacterCodes2["UpperA"] = 65] = "UpperA";
  CharacterCodes2[CharacterCodes2["UpperZ"] = 90] = "UpperZ";
  CharacterCodes2[CharacterCodes2["Exclamation"] = 33] = "Exclamation";
})(CharacterCodes || (CharacterCodes = {}));
function isHtml(str2) {
  const tagStart = str2.indexOf("<");
  if (tagStart < 0 || tagStart > str2.length - 3)
    return false;
  const tagChar = str2.charCodeAt(tagStart + 1);
  return (tagChar >= CharacterCodes.LowerA && tagChar <= CharacterCodes.LowerZ || tagChar >= CharacterCodes.UpperA && tagChar <= CharacterCodes.UpperZ || tagChar === CharacterCodes.Exclamation) && str2.includes(">", tagStart + 2);
}

// node_modules/.pnpm/cheerio@1.0.0-rc.12/node_modules/cheerio/lib/esm/api/attributes.js
var hasOwn = Object.prototype.hasOwnProperty;
var rspace = /\s+/;
var dataAttrPrefix = "data-";
var primitives = {
  null: null,
  true: true,
  false: false
};
var rboolean = /^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i;
var rbrace = /^{[^]*}$|^\[[^]*]$/;
function getAttr(elem, name2, xmlMode) {
  var _a2;
  if (!elem || !isTag2(elem))
    return void 0;
  (_a2 = elem.attribs) !== null && _a2 !== void 0 ? _a2 : elem.attribs = {};
  if (!name2) {
    return elem.attribs;
  }
  if (hasOwn.call(elem.attribs, name2)) {
    return !xmlMode && rboolean.test(name2) ? name2 : elem.attribs[name2];
  }
  if (elem.name === "option" && name2 === "value") {
    return text(elem.children);
  }
  if (elem.name === "input" && (elem.attribs["type"] === "radio" || elem.attribs["type"] === "checkbox") && name2 === "value") {
    return "on";
  }
  return void 0;
}
function setAttr(el, name2, value) {
  if (value === null) {
    removeAttribute(el, name2);
  } else {
    el.attribs[name2] = `${value}`;
  }
}
function attr(name2, value) {
  if (typeof name2 === "object" || value !== void 0) {
    if (typeof value === "function") {
      if (typeof name2 !== "string") {
        {
          throw new Error("Bad combination of arguments.");
        }
      }
      return domEach(this, (el, i) => {
        if (isTag2(el))
          setAttr(el, name2, value.call(el, i, el.attribs[name2]));
      });
    }
    return domEach(this, (el) => {
      if (!isTag2(el))
        return;
      if (typeof name2 === "object") {
        Object.keys(name2).forEach((objName) => {
          const objValue = name2[objName];
          setAttr(el, objName, objValue);
        });
      } else {
        setAttr(el, name2, value);
      }
    });
  }
  return arguments.length > 1 ? this : getAttr(this[0], name2, this.options.xmlMode);
}
function getProp(el, name2, xmlMode) {
  return name2 in el ? (
    // @ts-expect-error TS doesn't like us accessing the value directly here.
    el[name2]
  ) : !xmlMode && rboolean.test(name2) ? getAttr(el, name2, false) !== void 0 : getAttr(el, name2, xmlMode);
}
function setProp(el, name2, value, xmlMode) {
  if (name2 in el) {
    el[name2] = value;
  } else {
    setAttr(el, name2, !xmlMode && rboolean.test(name2) ? value ? "" : null : `${value}`);
  }
}
function prop(name2, value) {
  var _a2;
  if (typeof name2 === "string" && value === void 0) {
    const el = this[0];
    if (!el || !isTag2(el))
      return void 0;
    switch (name2) {
      case "style": {
        const property = this.css();
        const keys = Object.keys(property);
        keys.forEach((p, i) => {
          property[i] = p;
        });
        property.length = keys.length;
        return property;
      }
      case "tagName":
      case "nodeName": {
        return el.name.toUpperCase();
      }
      case "href":
      case "src": {
        const prop2 = (_a2 = el.attribs) === null || _a2 === void 0 ? void 0 : _a2[name2];
        if (typeof URL !== "undefined" && (name2 === "href" && (el.tagName === "a" || el.name === "link") || name2 === "src" && (el.tagName === "img" || el.tagName === "iframe" || el.tagName === "audio" || el.tagName === "video" || el.tagName === "source")) && prop2 !== void 0 && this.options.baseURI) {
          return new URL(prop2, this.options.baseURI).href;
        }
        return prop2;
      }
      case "innerText": {
        return innerText(el);
      }
      case "textContent": {
        return textContent(el);
      }
      case "outerHTML":
        return this.clone().wrap("<container />").parent().html();
      case "innerHTML":
        return this.html();
      default:
        return getProp(el, name2, this.options.xmlMode);
    }
  }
  if (typeof name2 === "object" || value !== void 0) {
    if (typeof value === "function") {
      if (typeof name2 === "object") {
        throw new Error("Bad combination of arguments.");
      }
      return domEach(this, (el, i) => {
        if (isTag2(el)) {
          setProp(el, name2, value.call(el, i, getProp(el, name2, this.options.xmlMode)), this.options.xmlMode);
        }
      });
    }
    return domEach(this, (el) => {
      if (!isTag2(el))
        return;
      if (typeof name2 === "object") {
        Object.keys(name2).forEach((key) => {
          const val2 = name2[key];
          setProp(el, key, val2, this.options.xmlMode);
        });
      } else {
        setProp(el, name2, value, this.options.xmlMode);
      }
    });
  }
  return void 0;
}
function setData(el, name2, value) {
  var _a2;
  const elem = el;
  (_a2 = elem.data) !== null && _a2 !== void 0 ? _a2 : elem.data = {};
  if (typeof name2 === "object")
    Object.assign(elem.data, name2);
  else if (typeof name2 === "string" && value !== void 0) {
    elem.data[name2] = value;
  }
}
function readData(el, name2) {
  let domNames;
  let jsNames;
  let value;
  if (name2 == null) {
    domNames = Object.keys(el.attribs).filter((attrName) => attrName.startsWith(dataAttrPrefix));
    jsNames = domNames.map((domName) => camelCase(domName.slice(dataAttrPrefix.length)));
  } else {
    domNames = [dataAttrPrefix + cssCase(name2)];
    jsNames = [name2];
  }
  for (let idx = 0; idx < domNames.length; ++idx) {
    const domName = domNames[idx];
    const jsName = jsNames[idx];
    if (hasOwn.call(el.attribs, domName) && !hasOwn.call(el.data, jsName)) {
      value = el.attribs[domName];
      if (hasOwn.call(primitives, value)) {
        value = primitives[value];
      } else if (value === String(Number(value))) {
        value = Number(value);
      } else if (rbrace.test(value)) {
        try {
          value = JSON.parse(value);
        } catch (e) {
        }
      }
      el.data[jsName] = value;
    }
  }
  return name2 == null ? el.data : value;
}
function data(name2, value) {
  var _a2;
  const elem = this[0];
  if (!elem || !isTag2(elem))
    return;
  const dataEl = elem;
  (_a2 = dataEl.data) !== null && _a2 !== void 0 ? _a2 : dataEl.data = {};
  if (!name2) {
    return readData(dataEl);
  }
  if (typeof name2 === "object" || value !== void 0) {
    domEach(this, (el) => {
      if (isTag2(el)) {
        if (typeof name2 === "object")
          setData(el, name2);
        else
          setData(el, name2, value);
      }
    });
    return this;
  }
  if (hasOwn.call(dataEl.data, name2)) {
    return dataEl.data[name2];
  }
  return readData(dataEl, name2);
}
function val(value) {
  const querying = arguments.length === 0;
  const element = this[0];
  if (!element || !isTag2(element))
    return querying ? void 0 : this;
  switch (element.name) {
    case "textarea":
      return this.text(value);
    case "select": {
      const option = this.find("option:selected");
      if (!querying) {
        if (this.attr("multiple") == null && typeof value === "object") {
          return this;
        }
        this.find("option").removeAttr("selected");
        const values = typeof value !== "object" ? [value] : value;
        for (let i = 0; i < values.length; i++) {
          this.find(`option[value="${values[i]}"]`).attr("selected", "");
        }
        return this;
      }
      return this.attr("multiple") ? option.toArray().map((el) => text(el.children)) : option.attr("value");
    }
    case "input":
    case "option":
      return querying ? this.attr("value") : this.attr("value", value);
  }
  return void 0;
}
function removeAttribute(elem, name2) {
  if (!elem.attribs || !hasOwn.call(elem.attribs, name2))
    return;
  delete elem.attribs[name2];
}
function splitNames(names) {
  return names ? names.trim().split(rspace) : [];
}
function removeAttr(name2) {
  const attrNames = splitNames(name2);
  for (let i = 0; i < attrNames.length; i++) {
    domEach(this, (elem) => {
      if (isTag2(elem))
        removeAttribute(elem, attrNames[i]);
    });
  }
  return this;
}
function hasClass(className) {
  return this.toArray().some((elem) => {
    const clazz = isTag2(elem) && elem.attribs["class"];
    let idx = -1;
    if (clazz && className.length) {
      while ((idx = clazz.indexOf(className, idx + 1)) > -1) {
        const end2 = idx + className.length;
        if ((idx === 0 || rspace.test(clazz[idx - 1])) && (end2 === clazz.length || rspace.test(clazz[end2]))) {
          return true;
        }
      }
    }
    return false;
  });
}
function addClass(value) {
  if (typeof value === "function") {
    return domEach(this, (el, i) => {
      if (isTag2(el)) {
        const className = el.attribs["class"] || "";
        addClass.call([el], value.call(el, i, className));
      }
    });
  }
  if (!value || typeof value !== "string")
    return this;
  const classNames = value.split(rspace);
  const numElements = this.length;
  for (let i = 0; i < numElements; i++) {
    const el = this[i];
    if (!isTag2(el))
      continue;
    const className = getAttr(el, "class", false);
    if (!className) {
      setAttr(el, "class", classNames.join(" ").trim());
    } else {
      let setClass = ` ${className} `;
      for (let j = 0; j < classNames.length; j++) {
        const appendClass = `${classNames[j]} `;
        if (!setClass.includes(` ${appendClass}`))
          setClass += appendClass;
      }
      setAttr(el, "class", setClass.trim());
    }
  }
  return this;
}
function removeClass(name2) {
  if (typeof name2 === "function") {
    return domEach(this, (el, i) => {
      if (isTag2(el)) {
        removeClass.call([el], name2.call(el, i, el.attribs["class"] || ""));
      }
    });
  }
  const classes = splitNames(name2);
  const numClasses = classes.length;
  const removeAll = arguments.length === 0;
  return domEach(this, (el) => {
    if (!isTag2(el))
      return;
    if (removeAll) {
      el.attribs["class"] = "";
    } else {
      const elClasses = splitNames(el.attribs["class"]);
      let changed = false;
      for (let j = 0; j < numClasses; j++) {
        const index2 = elClasses.indexOf(classes[j]);
        if (index2 >= 0) {
          elClasses.splice(index2, 1);
          changed = true;
          j--;
        }
      }
      if (changed) {
        el.attribs["class"] = elClasses.join(" ");
      }
    }
  });
}
function toggleClass(value, stateVal) {
  if (typeof value === "function") {
    return domEach(this, (el, i) => {
      if (isTag2(el)) {
        toggleClass.call([el], value.call(el, i, el.attribs["class"] || "", stateVal), stateVal);
      }
    });
  }
  if (!value || typeof value !== "string")
    return this;
  const classNames = value.split(rspace);
  const numClasses = classNames.length;
  const state = typeof stateVal === "boolean" ? stateVal ? 1 : -1 : 0;
  const numElements = this.length;
  for (let i = 0; i < numElements; i++) {
    const el = this[i];
    if (!isTag2(el))
      continue;
    const elementClasses = splitNames(el.attribs["class"]);
    for (let j = 0; j < numClasses; j++) {
      const index2 = elementClasses.indexOf(classNames[j]);
      if (state >= 0 && index2 < 0) {
        elementClasses.push(classNames[j]);
      } else if (state <= 0 && index2 >= 0) {
        elementClasses.splice(index2, 1);
      }
    }
    el.attribs["class"] = elementClasses.join(" ");
  }
  return this;
}

// node_modules/.pnpm/cheerio@1.0.0-rc.12/node_modules/cheerio/lib/esm/api/traversing.js
var traversing_exports = {};
__export(traversing_exports, {
  add: () => add,
  addBack: () => addBack,
  children: () => children,
  closest: () => closest,
  contents: () => contents,
  each: () => each,
  end: () => end,
  eq: () => eq,
  filter: () => filter3,
  filterArray: () => filterArray,
  find: () => find3,
  first: () => first,
  get: () => get,
  has: () => has,
  index: () => index,
  is: () => is3,
  last: () => last,
  map: () => map,
  next: () => next,
  nextAll: () => nextAll,
  nextUntil: () => nextUntil,
  not: () => not,
  parent: () => parent,
  parents: () => parents,
  parentsUntil: () => parentsUntil,
  prev: () => prev,
  prevAll: () => prevAll,
  prevUntil: () => prevUntil,
  siblings: () => siblings,
  slice: () => slice,
  toArray: () => toArray
});

// node_modules/.pnpm/css-what@6.1.0/node_modules/css-what/lib/es/types.js
var SelectorType;
(function(SelectorType2) {
  SelectorType2["Attribute"] = "attribute";
  SelectorType2["Pseudo"] = "pseudo";
  SelectorType2["PseudoElement"] = "pseudo-element";
  SelectorType2["Tag"] = "tag";
  SelectorType2["Universal"] = "universal";
  SelectorType2["Adjacent"] = "adjacent";
  SelectorType2["Child"] = "child";
  SelectorType2["Descendant"] = "descendant";
  SelectorType2["Parent"] = "parent";
  SelectorType2["Sibling"] = "sibling";
  SelectorType2["ColumnCombinator"] = "column-combinator";
})(SelectorType || (SelectorType = {}));
var AttributeAction;
(function(AttributeAction2) {
  AttributeAction2["Any"] = "any";
  AttributeAction2["Element"] = "element";
  AttributeAction2["End"] = "end";
  AttributeAction2["Equals"] = "equals";
  AttributeAction2["Exists"] = "exists";
  AttributeAction2["Hyphen"] = "hyphen";
  AttributeAction2["Not"] = "not";
  AttributeAction2["Start"] = "start";
})(AttributeAction || (AttributeAction = {}));

// node_modules/.pnpm/css-what@6.1.0/node_modules/css-what/lib/es/parse.js
var reName = /^[^\\#]?(?:\\(?:[\da-f]{1,6}\s?|.)|[\w\-\u00b0-\uFFFF])+/;
var reEscape = /\\([\da-f]{1,6}\s?|(\s)|.)/gi;
var actionTypes = /* @__PURE__ */ new Map([
  [126, AttributeAction.Element],
  [94, AttributeAction.Start],
  [36, AttributeAction.End],
  [42, AttributeAction.Any],
  [33, AttributeAction.Not],
  [124, AttributeAction.Hyphen]
]);
var unpackPseudos = /* @__PURE__ */ new Set([
  "has",
  "not",
  "matches",
  "is",
  "where",
  "host",
  "host-context"
]);
function isTraversal(selector) {
  switch (selector.type) {
    case SelectorType.Adjacent:
    case SelectorType.Child:
    case SelectorType.Descendant:
    case SelectorType.Parent:
    case SelectorType.Sibling:
    case SelectorType.ColumnCombinator:
      return true;
    default:
      return false;
  }
}
var stripQuotesFromPseudos = /* @__PURE__ */ new Set(["contains", "icontains"]);
function funescape(_, escaped, escapedWhitespace) {
  const high = parseInt(escaped, 16) - 65536;
  return high !== high || escapedWhitespace ? escaped : high < 0 ? (
    // BMP codepoint
    String.fromCharCode(high + 65536)
  ) : (
    // Supplemental Plane codepoint (surrogate pair)
    String.fromCharCode(high >> 10 | 55296, high & 1023 | 56320)
  );
}
function unescapeCSS(str2) {
  return str2.replace(reEscape, funescape);
}
function isQuote(c) {
  return c === 39 || c === 34;
}
function isWhitespace(c) {
  return c === 32 || c === 9 || c === 10 || c === 12 || c === 13;
}
function parse(selector) {
  const subselects2 = [];
  const endIndex = parseSelector(subselects2, `${selector}`, 0);
  if (endIndex < selector.length) {
    throw new Error(`Unmatched selector: ${selector.slice(endIndex)}`);
  }
  return subselects2;
}
function parseSelector(subselects2, selector, selectorIndex) {
  let tokens = [];
  function getName2(offset) {
    const match2 = selector.slice(selectorIndex + offset).match(reName);
    if (!match2) {
      throw new Error(`Expected name, found ${selector.slice(selectorIndex)}`);
    }
    const [name2] = match2;
    selectorIndex += offset + name2.length;
    return unescapeCSS(name2);
  }
  function stripWhitespace(offset) {
    selectorIndex += offset;
    while (selectorIndex < selector.length && isWhitespace(selector.charCodeAt(selectorIndex))) {
      selectorIndex++;
    }
  }
  function readValueWithParenthesis() {
    selectorIndex += 1;
    const start = selectorIndex;
    let counter = 1;
    for (; counter > 0 && selectorIndex < selector.length; selectorIndex++) {
      if (selector.charCodeAt(selectorIndex) === 40 && !isEscaped(selectorIndex)) {
        counter++;
      } else if (selector.charCodeAt(selectorIndex) === 41 && !isEscaped(selectorIndex)) {
        counter--;
      }
    }
    if (counter) {
      throw new Error("Parenthesis not matched");
    }
    return unescapeCSS(selector.slice(start, selectorIndex - 1));
  }
  function isEscaped(pos) {
    let slashCount = 0;
    while (selector.charCodeAt(--pos) === 92)
      slashCount++;
    return (slashCount & 1) === 1;
  }
  function ensureNotTraversal() {
    if (tokens.length > 0 && isTraversal(tokens[tokens.length - 1])) {
      throw new Error("Did not expect successive traversals.");
    }
  }
  function addTraversal(type2) {
    if (tokens.length > 0 && tokens[tokens.length - 1].type === SelectorType.Descendant) {
      tokens[tokens.length - 1].type = type2;
      return;
    }
    ensureNotTraversal();
    tokens.push({ type: type2 });
  }
  function addSpecialAttribute(name2, action) {
    tokens.push({
      type: SelectorType.Attribute,
      name: name2,
      action,
      value: getName2(1),
      namespace: null,
      ignoreCase: "quirks"
    });
  }
  function finalizeSubselector() {
    if (tokens.length && tokens[tokens.length - 1].type === SelectorType.Descendant) {
      tokens.pop();
    }
    if (tokens.length === 0) {
      throw new Error("Empty sub-selector");
    }
    subselects2.push(tokens);
  }
  stripWhitespace(0);
  if (selector.length === selectorIndex) {
    return selectorIndex;
  }
  loop:
    while (selectorIndex < selector.length) {
      const firstChar = selector.charCodeAt(selectorIndex);
      switch (firstChar) {
        case 32:
        case 9:
        case 10:
        case 12:
        case 13: {
          if (tokens.length === 0 || tokens[0].type !== SelectorType.Descendant) {
            ensureNotTraversal();
            tokens.push({ type: SelectorType.Descendant });
          }
          stripWhitespace(1);
          break;
        }
        case 62: {
          addTraversal(SelectorType.Child);
          stripWhitespace(1);
          break;
        }
        case 60: {
          addTraversal(SelectorType.Parent);
          stripWhitespace(1);
          break;
        }
        case 126: {
          addTraversal(SelectorType.Sibling);
          stripWhitespace(1);
          break;
        }
        case 43: {
          addTraversal(SelectorType.Adjacent);
          stripWhitespace(1);
          break;
        }
        case 46: {
          addSpecialAttribute("class", AttributeAction.Element);
          break;
        }
        case 35: {
          addSpecialAttribute("id", AttributeAction.Equals);
          break;
        }
        case 91: {
          stripWhitespace(1);
          let name2;
          let namespace = null;
          if (selector.charCodeAt(selectorIndex) === 124) {
            name2 = getName2(1);
          } else if (selector.startsWith("*|", selectorIndex)) {
            namespace = "*";
            name2 = getName2(2);
          } else {
            name2 = getName2(0);
            if (selector.charCodeAt(selectorIndex) === 124 && selector.charCodeAt(selectorIndex + 1) !== 61) {
              namespace = name2;
              name2 = getName2(1);
            }
          }
          stripWhitespace(0);
          let action = AttributeAction.Exists;
          const possibleAction = actionTypes.get(selector.charCodeAt(selectorIndex));
          if (possibleAction) {
            action = possibleAction;
            if (selector.charCodeAt(selectorIndex + 1) !== 61) {
              throw new Error("Expected `=`");
            }
            stripWhitespace(2);
          } else if (selector.charCodeAt(selectorIndex) === 61) {
            action = AttributeAction.Equals;
            stripWhitespace(1);
          }
          let value = "";
          let ignoreCase = null;
          if (action !== "exists") {
            if (isQuote(selector.charCodeAt(selectorIndex))) {
              const quote = selector.charCodeAt(selectorIndex);
              let sectionEnd = selectorIndex + 1;
              while (sectionEnd < selector.length && (selector.charCodeAt(sectionEnd) !== quote || isEscaped(sectionEnd))) {
                sectionEnd += 1;
              }
              if (selector.charCodeAt(sectionEnd) !== quote) {
                throw new Error("Attribute value didn't end");
              }
              value = unescapeCSS(selector.slice(selectorIndex + 1, sectionEnd));
              selectorIndex = sectionEnd + 1;
            } else {
              const valueStart = selectorIndex;
              while (selectorIndex < selector.length && (!isWhitespace(selector.charCodeAt(selectorIndex)) && selector.charCodeAt(selectorIndex) !== 93 || isEscaped(selectorIndex))) {
                selectorIndex += 1;
              }
              value = unescapeCSS(selector.slice(valueStart, selectorIndex));
            }
            stripWhitespace(0);
            const forceIgnore = selector.charCodeAt(selectorIndex) | 32;
            if (forceIgnore === 115) {
              ignoreCase = false;
              stripWhitespace(1);
            } else if (forceIgnore === 105) {
              ignoreCase = true;
              stripWhitespace(1);
            }
          }
          if (selector.charCodeAt(selectorIndex) !== 93) {
            throw new Error("Attribute selector didn't terminate");
          }
          selectorIndex += 1;
          const attributeSelector = {
            type: SelectorType.Attribute,
            name: name2,
            action,
            value,
            namespace,
            ignoreCase
          };
          tokens.push(attributeSelector);
          break;
        }
        case 58: {
          if (selector.charCodeAt(selectorIndex + 1) === 58) {
            tokens.push({
              type: SelectorType.PseudoElement,
              name: getName2(2).toLowerCase(),
              data: selector.charCodeAt(selectorIndex) === 40 ? readValueWithParenthesis() : null
            });
            continue;
          }
          const name2 = getName2(1).toLowerCase();
          let data2 = null;
          if (selector.charCodeAt(selectorIndex) === 40) {
            if (unpackPseudos.has(name2)) {
              if (isQuote(selector.charCodeAt(selectorIndex + 1))) {
                throw new Error(`Pseudo-selector ${name2} cannot be quoted`);
              }
              data2 = [];
              selectorIndex = parseSelector(data2, selector, selectorIndex + 1);
              if (selector.charCodeAt(selectorIndex) !== 41) {
                throw new Error(`Missing closing parenthesis in :${name2} (${selector})`);
              }
              selectorIndex += 1;
            } else {
              data2 = readValueWithParenthesis();
              if (stripQuotesFromPseudos.has(name2)) {
                const quot = data2.charCodeAt(0);
                if (quot === data2.charCodeAt(data2.length - 1) && isQuote(quot)) {
                  data2 = data2.slice(1, -1);
                }
              }
              data2 = unescapeCSS(data2);
            }
          }
          tokens.push({ type: SelectorType.Pseudo, name: name2, data: data2 });
          break;
        }
        case 44: {
          finalizeSubselector();
          tokens = [];
          stripWhitespace(1);
          break;
        }
        default: {
          if (selector.startsWith("/*", selectorIndex)) {
            const endIndex = selector.indexOf("*/", selectorIndex + 2);
            if (endIndex < 0) {
              throw new Error("Comment was not terminated");
            }
            selectorIndex = endIndex + 2;
            if (tokens.length === 0) {
              stripWhitespace(0);
            }
            break;
          }
          let namespace = null;
          let name2;
          if (firstChar === 42) {
            selectorIndex += 1;
            name2 = "*";
          } else if (firstChar === 124) {
            name2 = "";
            if (selector.charCodeAt(selectorIndex + 1) === 124) {
              addTraversal(SelectorType.ColumnCombinator);
              stripWhitespace(2);
              break;
            }
          } else if (reName.test(selector.slice(selectorIndex))) {
            name2 = getName2(0);
          } else {
            break loop;
          }
          if (selector.charCodeAt(selectorIndex) === 124 && selector.charCodeAt(selectorIndex + 1) !== 124) {
            namespace = name2;
            if (selector.charCodeAt(selectorIndex + 1) === 42) {
              name2 = "*";
              selectorIndex += 2;
            } else {
              name2 = getName2(1);
            }
          }
          tokens.push(name2 === "*" ? { type: SelectorType.Universal, namespace } : { type: SelectorType.Tag, name: name2, namespace });
        }
      }
    }
  finalizeSubselector();
  return selectorIndex;
}

// node_modules/.pnpm/css-what@6.1.0/node_modules/css-what/lib/es/stringify.js
var attribValChars = ["\\", '"'];
var pseudoValChars = [...attribValChars, "(", ")"];
var charsToEscapeInAttributeValue = new Set(attribValChars.map((c) => c.charCodeAt(0)));
var charsToEscapeInPseudoValue = new Set(pseudoValChars.map((c) => c.charCodeAt(0)));
var charsToEscapeInName = new Set([
  ...pseudoValChars,
  "~",
  "^",
  "$",
  "*",
  "+",
  "!",
  "|",
  ":",
  "[",
  "]",
  " ",
  "."
].map((c) => c.charCodeAt(0)));

// node_modules/.pnpm/css-select@5.1.0/node_modules/css-select/lib/esm/index.js
var import_boolbase6 = __toESM(require_boolbase());

// node_modules/.pnpm/css-select@5.1.0/node_modules/css-select/lib/esm/compile.js
var import_boolbase5 = __toESM(require_boolbase(), 1);

// node_modules/.pnpm/css-select@5.1.0/node_modules/css-select/lib/esm/sort.js
var procedure = /* @__PURE__ */ new Map([
  [SelectorType.Universal, 50],
  [SelectorType.Tag, 30],
  [SelectorType.Attribute, 1],
  [SelectorType.Pseudo, 0]
]);
function isTraversal2(token) {
  return !procedure.has(token.type);
}
var attributes = /* @__PURE__ */ new Map([
  [AttributeAction.Exists, 10],
  [AttributeAction.Equals, 8],
  [AttributeAction.Not, 7],
  [AttributeAction.Start, 6],
  [AttributeAction.End, 6],
  [AttributeAction.Any, 5]
]);
function sortByProcedure(arr) {
  const procs = arr.map(getProcedure);
  for (let i = 1; i < arr.length; i++) {
    const procNew = procs[i];
    if (procNew < 0)
      continue;
    for (let j = i - 1; j >= 0 && procNew < procs[j]; j--) {
      const token = arr[j + 1];
      arr[j + 1] = arr[j];
      arr[j] = token;
      procs[j + 1] = procs[j];
      procs[j] = procNew;
    }
  }
}
function getProcedure(token) {
  var _a2, _b;
  let proc = (_a2 = procedure.get(token.type)) !== null && _a2 !== void 0 ? _a2 : -1;
  if (token.type === SelectorType.Attribute) {
    proc = (_b = attributes.get(token.action)) !== null && _b !== void 0 ? _b : 4;
    if (token.action === AttributeAction.Equals && token.name === "id") {
      proc = 9;
    }
    if (token.ignoreCase) {
      proc >>= 1;
    }
  } else if (token.type === SelectorType.Pseudo) {
    if (!token.data) {
      proc = 3;
    } else if (token.name === "has" || token.name === "contains") {
      proc = 0;
    } else if (Array.isArray(token.data)) {
      proc = Math.min(...token.data.map((d) => Math.min(...d.map(getProcedure))));
      if (proc < 0) {
        proc = 0;
      }
    } else {
      proc = 2;
    }
  }
  return proc;
}

// node_modules/.pnpm/css-select@5.1.0/node_modules/css-select/lib/esm/attributes.js
var import_boolbase = __toESM(require_boolbase(), 1);
var reChars = /[-[\]{}()*+?.,\\^$|#\s]/g;
function escapeRegex(value) {
  return value.replace(reChars, "\\$&");
}
var caseInsensitiveAttributes = /* @__PURE__ */ new Set([
  "accept",
  "accept-charset",
  "align",
  "alink",
  "axis",
  "bgcolor",
  "charset",
  "checked",
  "clear",
  "codetype",
  "color",
  "compact",
  "declare",
  "defer",
  "dir",
  "direction",
  "disabled",
  "enctype",
  "face",
  "frame",
  "hreflang",
  "http-equiv",
  "lang",
  "language",
  "link",
  "media",
  "method",
  "multiple",
  "nohref",
  "noresize",
  "noshade",
  "nowrap",
  "readonly",
  "rel",
  "rev",
  "rules",
  "scope",
  "scrolling",
  "selected",
  "shape",
  "target",
  "text",
  "type",
  "valign",
  "valuetype",
  "vlink"
]);
function shouldIgnoreCase(selector, options) {
  return typeof selector.ignoreCase === "boolean" ? selector.ignoreCase : selector.ignoreCase === "quirks" ? !!options.quirksMode : !options.xmlMode && caseInsensitiveAttributes.has(selector.name);
}
var attributeRules = {
  equals(next2, data2, options) {
    const { adapter: adapter2 } = options;
    const { name: name2 } = data2;
    let { value } = data2;
    if (shouldIgnoreCase(data2, options)) {
      value = value.toLowerCase();
      return (elem) => {
        const attr2 = adapter2.getAttributeValue(elem, name2);
        return attr2 != null && attr2.length === value.length && attr2.toLowerCase() === value && next2(elem);
      };
    }
    return (elem) => adapter2.getAttributeValue(elem, name2) === value && next2(elem);
  },
  hyphen(next2, data2, options) {
    const { adapter: adapter2 } = options;
    const { name: name2 } = data2;
    let { value } = data2;
    const len = value.length;
    if (shouldIgnoreCase(data2, options)) {
      value = value.toLowerCase();
      return function hyphenIC(elem) {
        const attr2 = adapter2.getAttributeValue(elem, name2);
        return attr2 != null && (attr2.length === len || attr2.charAt(len) === "-") && attr2.substr(0, len).toLowerCase() === value && next2(elem);
      };
    }
    return function hyphen(elem) {
      const attr2 = adapter2.getAttributeValue(elem, name2);
      return attr2 != null && (attr2.length === len || attr2.charAt(len) === "-") && attr2.substr(0, len) === value && next2(elem);
    };
  },
  element(next2, data2, options) {
    const { adapter: adapter2 } = options;
    const { name: name2, value } = data2;
    if (/\s/.test(value)) {
      return import_boolbase.default.falseFunc;
    }
    const regex = new RegExp(`(?:^|\\s)${escapeRegex(value)}(?:$|\\s)`, shouldIgnoreCase(data2, options) ? "i" : "");
    return function element(elem) {
      const attr2 = adapter2.getAttributeValue(elem, name2);
      return attr2 != null && attr2.length >= value.length && regex.test(attr2) && next2(elem);
    };
  },
  exists(next2, { name: name2 }, { adapter: adapter2 }) {
    return (elem) => adapter2.hasAttrib(elem, name2) && next2(elem);
  },
  start(next2, data2, options) {
    const { adapter: adapter2 } = options;
    const { name: name2 } = data2;
    let { value } = data2;
    const len = value.length;
    if (len === 0) {
      return import_boolbase.default.falseFunc;
    }
    if (shouldIgnoreCase(data2, options)) {
      value = value.toLowerCase();
      return (elem) => {
        const attr2 = adapter2.getAttributeValue(elem, name2);
        return attr2 != null && attr2.length >= len && attr2.substr(0, len).toLowerCase() === value && next2(elem);
      };
    }
    return (elem) => {
      var _a2;
      return !!((_a2 = adapter2.getAttributeValue(elem, name2)) === null || _a2 === void 0 ? void 0 : _a2.startsWith(value)) && next2(elem);
    };
  },
  end(next2, data2, options) {
    const { adapter: adapter2 } = options;
    const { name: name2 } = data2;
    let { value } = data2;
    const len = -value.length;
    if (len === 0) {
      return import_boolbase.default.falseFunc;
    }
    if (shouldIgnoreCase(data2, options)) {
      value = value.toLowerCase();
      return (elem) => {
        var _a2;
        return ((_a2 = adapter2.getAttributeValue(elem, name2)) === null || _a2 === void 0 ? void 0 : _a2.substr(len).toLowerCase()) === value && next2(elem);
      };
    }
    return (elem) => {
      var _a2;
      return !!((_a2 = adapter2.getAttributeValue(elem, name2)) === null || _a2 === void 0 ? void 0 : _a2.endsWith(value)) && next2(elem);
    };
  },
  any(next2, data2, options) {
    const { adapter: adapter2 } = options;
    const { name: name2, value } = data2;
    if (value === "") {
      return import_boolbase.default.falseFunc;
    }
    if (shouldIgnoreCase(data2, options)) {
      const regex = new RegExp(escapeRegex(value), "i");
      return function anyIC(elem) {
        const attr2 = adapter2.getAttributeValue(elem, name2);
        return attr2 != null && attr2.length >= value.length && regex.test(attr2) && next2(elem);
      };
    }
    return (elem) => {
      var _a2;
      return !!((_a2 = adapter2.getAttributeValue(elem, name2)) === null || _a2 === void 0 ? void 0 : _a2.includes(value)) && next2(elem);
    };
  },
  not(next2, data2, options) {
    const { adapter: adapter2 } = options;
    const { name: name2 } = data2;
    let { value } = data2;
    if (value === "") {
      return (elem) => !!adapter2.getAttributeValue(elem, name2) && next2(elem);
    } else if (shouldIgnoreCase(data2, options)) {
      value = value.toLowerCase();
      return (elem) => {
        const attr2 = adapter2.getAttributeValue(elem, name2);
        return (attr2 == null || attr2.length !== value.length || attr2.toLowerCase() !== value) && next2(elem);
      };
    }
    return (elem) => adapter2.getAttributeValue(elem, name2) !== value && next2(elem);
  }
};

// node_modules/.pnpm/nth-check@2.1.1/node_modules/nth-check/lib/esm/parse.js
var whitespace = /* @__PURE__ */ new Set([9, 10, 12, 13, 32]);
var ZERO = "0".charCodeAt(0);
var NINE = "9".charCodeAt(0);
function parse2(formula) {
  formula = formula.trim().toLowerCase();
  if (formula === "even") {
    return [2, 0];
  } else if (formula === "odd") {
    return [2, 1];
  }
  let idx = 0;
  let a = 0;
  let sign = readSign();
  let number = readNumber();
  if (idx < formula.length && formula.charAt(idx) === "n") {
    idx++;
    a = sign * (number !== null && number !== void 0 ? number : 1);
    skipWhitespace();
    if (idx < formula.length) {
      sign = readSign();
      skipWhitespace();
      number = readNumber();
    } else {
      sign = number = 0;
    }
  }
  if (number === null || idx < formula.length) {
    throw new Error(`n-th rule couldn't be parsed ('${formula}')`);
  }
  return [a, sign * number];
  function readSign() {
    if (formula.charAt(idx) === "-") {
      idx++;
      return -1;
    }
    if (formula.charAt(idx) === "+") {
      idx++;
    }
    return 1;
  }
  function readNumber() {
    const start = idx;
    let value = 0;
    while (idx < formula.length && formula.charCodeAt(idx) >= ZERO && formula.charCodeAt(idx) <= NINE) {
      value = value * 10 + (formula.charCodeAt(idx) - ZERO);
      idx++;
    }
    return idx === start ? null : value;
  }
  function skipWhitespace() {
    while (idx < formula.length && whitespace.has(formula.charCodeAt(idx))) {
      idx++;
    }
  }
}

// node_modules/.pnpm/nth-check@2.1.1/node_modules/nth-check/lib/esm/compile.js
var import_boolbase2 = __toESM(require_boolbase(), 1);
function compile(parsed) {
  const a = parsed[0];
  const b = parsed[1] - 1;
  if (b < 0 && a <= 0)
    return import_boolbase2.default.falseFunc;
  if (a === -1)
    return (index2) => index2 <= b;
  if (a === 0)
    return (index2) => index2 === b;
  if (a === 1)
    return b < 0 ? import_boolbase2.default.trueFunc : (index2) => index2 >= b;
  const absA = Math.abs(a);
  const bMod = (b % absA + absA) % absA;
  return a > 1 ? (index2) => index2 >= b && index2 % absA === bMod : (index2) => index2 <= b && index2 % absA === bMod;
}

// node_modules/.pnpm/nth-check@2.1.1/node_modules/nth-check/lib/esm/index.js
function nthCheck(formula) {
  return compile(parse2(formula));
}

// node_modules/.pnpm/css-select@5.1.0/node_modules/css-select/lib/esm/pseudo-selectors/filters.js
var import_boolbase3 = __toESM(require_boolbase(), 1);
function getChildFunc(next2, adapter2) {
  return (elem) => {
    const parent2 = adapter2.getParent(elem);
    return parent2 != null && adapter2.isTag(parent2) && next2(elem);
  };
}
var filters = {
  contains(next2, text4, { adapter: adapter2 }) {
    return function contains3(elem) {
      return next2(elem) && adapter2.getText(elem).includes(text4);
    };
  },
  icontains(next2, text4, { adapter: adapter2 }) {
    const itext = text4.toLowerCase();
    return function icontains(elem) {
      return next2(elem) && adapter2.getText(elem).toLowerCase().includes(itext);
    };
  },
  // Location specific methods
  "nth-child"(next2, rule, { adapter: adapter2, equals }) {
    const func = nthCheck(rule);
    if (func === import_boolbase3.default.falseFunc)
      return import_boolbase3.default.falseFunc;
    if (func === import_boolbase3.default.trueFunc)
      return getChildFunc(next2, adapter2);
    return function nthChild(elem) {
      const siblings2 = adapter2.getSiblings(elem);
      let pos = 0;
      for (let i = 0; i < siblings2.length; i++) {
        if (equals(elem, siblings2[i]))
          break;
        if (adapter2.isTag(siblings2[i])) {
          pos++;
        }
      }
      return func(pos) && next2(elem);
    };
  },
  "nth-last-child"(next2, rule, { adapter: adapter2, equals }) {
    const func = nthCheck(rule);
    if (func === import_boolbase3.default.falseFunc)
      return import_boolbase3.default.falseFunc;
    if (func === import_boolbase3.default.trueFunc)
      return getChildFunc(next2, adapter2);
    return function nthLastChild(elem) {
      const siblings2 = adapter2.getSiblings(elem);
      let pos = 0;
      for (let i = siblings2.length - 1; i >= 0; i--) {
        if (equals(elem, siblings2[i]))
          break;
        if (adapter2.isTag(siblings2[i])) {
          pos++;
        }
      }
      return func(pos) && next2(elem);
    };
  },
  "nth-of-type"(next2, rule, { adapter: adapter2, equals }) {
    const func = nthCheck(rule);
    if (func === import_boolbase3.default.falseFunc)
      return import_boolbase3.default.falseFunc;
    if (func === import_boolbase3.default.trueFunc)
      return getChildFunc(next2, adapter2);
    return function nthOfType(elem) {
      const siblings2 = adapter2.getSiblings(elem);
      let pos = 0;
      for (let i = 0; i < siblings2.length; i++) {
        const currentSibling = siblings2[i];
        if (equals(elem, currentSibling))
          break;
        if (adapter2.isTag(currentSibling) && adapter2.getName(currentSibling) === adapter2.getName(elem)) {
          pos++;
        }
      }
      return func(pos) && next2(elem);
    };
  },
  "nth-last-of-type"(next2, rule, { adapter: adapter2, equals }) {
    const func = nthCheck(rule);
    if (func === import_boolbase3.default.falseFunc)
      return import_boolbase3.default.falseFunc;
    if (func === import_boolbase3.default.trueFunc)
      return getChildFunc(next2, adapter2);
    return function nthLastOfType(elem) {
      const siblings2 = adapter2.getSiblings(elem);
      let pos = 0;
      for (let i = siblings2.length - 1; i >= 0; i--) {
        const currentSibling = siblings2[i];
        if (equals(elem, currentSibling))
          break;
        if (adapter2.isTag(currentSibling) && adapter2.getName(currentSibling) === adapter2.getName(elem)) {
          pos++;
        }
      }
      return func(pos) && next2(elem);
    };
  },
  // TODO determine the actual root element
  root(next2, _rule, { adapter: adapter2 }) {
    return (elem) => {
      const parent2 = adapter2.getParent(elem);
      return (parent2 == null || !adapter2.isTag(parent2)) && next2(elem);
    };
  },
  scope(next2, rule, options, context) {
    const { equals } = options;
    if (!context || context.length === 0) {
      return filters["root"](next2, rule, options);
    }
    if (context.length === 1) {
      return (elem) => equals(context[0], elem) && next2(elem);
    }
    return (elem) => context.includes(elem) && next2(elem);
  },
  hover: dynamicStatePseudo("isHovered"),
  visited: dynamicStatePseudo("isVisited"),
  active: dynamicStatePseudo("isActive")
};
function dynamicStatePseudo(name2) {
  return function dynamicPseudo(next2, _rule, { adapter: adapter2 }) {
    const func = adapter2[name2];
    if (typeof func !== "function") {
      return import_boolbase3.default.falseFunc;
    }
    return function active(elem) {
      return func(elem) && next2(elem);
    };
  };
}

// node_modules/.pnpm/css-select@5.1.0/node_modules/css-select/lib/esm/pseudo-selectors/pseudos.js
var pseudos = {
  empty(elem, { adapter: adapter2 }) {
    return !adapter2.getChildren(elem).some((elem2) => (
      // FIXME: `getText` call is potentially expensive.
      adapter2.isTag(elem2) || adapter2.getText(elem2) !== ""
    ));
  },
  "first-child"(elem, { adapter: adapter2, equals }) {
    if (adapter2.prevElementSibling) {
      return adapter2.prevElementSibling(elem) == null;
    }
    const firstChild = adapter2.getSiblings(elem).find((elem2) => adapter2.isTag(elem2));
    return firstChild != null && equals(elem, firstChild);
  },
  "last-child"(elem, { adapter: adapter2, equals }) {
    const siblings2 = adapter2.getSiblings(elem);
    for (let i = siblings2.length - 1; i >= 0; i--) {
      if (equals(elem, siblings2[i]))
        return true;
      if (adapter2.isTag(siblings2[i]))
        break;
    }
    return false;
  },
  "first-of-type"(elem, { adapter: adapter2, equals }) {
    const siblings2 = adapter2.getSiblings(elem);
    const elemName = adapter2.getName(elem);
    for (let i = 0; i < siblings2.length; i++) {
      const currentSibling = siblings2[i];
      if (equals(elem, currentSibling))
        return true;
      if (adapter2.isTag(currentSibling) && adapter2.getName(currentSibling) === elemName) {
        break;
      }
    }
    return false;
  },
  "last-of-type"(elem, { adapter: adapter2, equals }) {
    const siblings2 = adapter2.getSiblings(elem);
    const elemName = adapter2.getName(elem);
    for (let i = siblings2.length - 1; i >= 0; i--) {
      const currentSibling = siblings2[i];
      if (equals(elem, currentSibling))
        return true;
      if (adapter2.isTag(currentSibling) && adapter2.getName(currentSibling) === elemName) {
        break;
      }
    }
    return false;
  },
  "only-of-type"(elem, { adapter: adapter2, equals }) {
    const elemName = adapter2.getName(elem);
    return adapter2.getSiblings(elem).every((sibling) => equals(elem, sibling) || !adapter2.isTag(sibling) || adapter2.getName(sibling) !== elemName);
  },
  "only-child"(elem, { adapter: adapter2, equals }) {
    return adapter2.getSiblings(elem).every((sibling) => equals(elem, sibling) || !adapter2.isTag(sibling));
  }
};
function verifyPseudoArgs(func, name2, subselect, argIndex) {
  if (subselect === null) {
    if (func.length > argIndex) {
      throw new Error(`Pseudo-class :${name2} requires an argument`);
    }
  } else if (func.length === argIndex) {
    throw new Error(`Pseudo-class :${name2} doesn't have any arguments`);
  }
}

// node_modules/.pnpm/css-select@5.1.0/node_modules/css-select/lib/esm/pseudo-selectors/aliases.js
var aliases = {
  // Links
  "any-link": ":is(a, area, link)[href]",
  link: ":any-link:not(:visited)",
  // Forms
  // https://html.spec.whatwg.org/multipage/scripting.html#disabled-elements
  disabled: `:is(
        :is(button, input, select, textarea, optgroup, option)[disabled],
        optgroup[disabled] > option,
        fieldset[disabled]:not(fieldset[disabled] legend:first-of-type *)
    )`,
  enabled: ":not(:disabled)",
  checked: ":is(:is(input[type=radio], input[type=checkbox])[checked], option:selected)",
  required: ":is(input, select, textarea)[required]",
  optional: ":is(input, select, textarea):not([required])",
  // JQuery extensions
  // https://html.spec.whatwg.org/multipage/form-elements.html#concept-option-selectedness
  selected: "option:is([selected], select:not([multiple]):not(:has(> option[selected])) > :first-of-type)",
  checkbox: "[type=checkbox]",
  file: "[type=file]",
  password: "[type=password]",
  radio: "[type=radio]",
  reset: "[type=reset]",
  image: "[type=image]",
  submit: "[type=submit]",
  parent: ":not(:empty)",
  header: ":is(h1, h2, h3, h4, h5, h6)",
  button: ":is(button, input[type=button])",
  input: ":is(input, textarea, select, button)",
  text: "input:is(:not([type!='']), [type=text])"
};

// node_modules/.pnpm/css-select@5.1.0/node_modules/css-select/lib/esm/pseudo-selectors/subselects.js
var import_boolbase4 = __toESM(require_boolbase(), 1);
var PLACEHOLDER_ELEMENT = {};
function ensureIsTag(next2, adapter2) {
  if (next2 === import_boolbase4.default.falseFunc)
    return import_boolbase4.default.falseFunc;
  return (elem) => adapter2.isTag(elem) && next2(elem);
}
function getNextSiblings(elem, adapter2) {
  const siblings2 = adapter2.getSiblings(elem);
  if (siblings2.length <= 1)
    return [];
  const elemIndex = siblings2.indexOf(elem);
  if (elemIndex < 0 || elemIndex === siblings2.length - 1)
    return [];
  return siblings2.slice(elemIndex + 1).filter(adapter2.isTag);
}
function copyOptions(options) {
  return {
    xmlMode: !!options.xmlMode,
    lowerCaseAttributeNames: !!options.lowerCaseAttributeNames,
    lowerCaseTags: !!options.lowerCaseTags,
    quirksMode: !!options.quirksMode,
    cacheResults: !!options.cacheResults,
    pseudos: options.pseudos,
    adapter: options.adapter,
    equals: options.equals
  };
}
var is = (next2, token, options, context, compileToken2) => {
  const func = compileToken2(token, copyOptions(options), context);
  return func === import_boolbase4.default.trueFunc ? next2 : func === import_boolbase4.default.falseFunc ? import_boolbase4.default.falseFunc : (elem) => func(elem) && next2(elem);
};
var subselects = {
  is,
  /**
   * `:matches` and `:where` are aliases for `:is`.
   */
  matches: is,
  where: is,
  not(next2, token, options, context, compileToken2) {
    const func = compileToken2(token, copyOptions(options), context);
    return func === import_boolbase4.default.falseFunc ? next2 : func === import_boolbase4.default.trueFunc ? import_boolbase4.default.falseFunc : (elem) => !func(elem) && next2(elem);
  },
  has(next2, subselect, options, _context, compileToken2) {
    const { adapter: adapter2 } = options;
    const opts = copyOptions(options);
    opts.relativeSelector = true;
    const context = subselect.some((s) => s.some(isTraversal2)) ? (
      // Used as a placeholder. Will be replaced with the actual element.
      [PLACEHOLDER_ELEMENT]
    ) : void 0;
    const compiled = compileToken2(subselect, opts, context);
    if (compiled === import_boolbase4.default.falseFunc)
      return import_boolbase4.default.falseFunc;
    const hasElement = ensureIsTag(compiled, adapter2);
    if (context && compiled !== import_boolbase4.default.trueFunc) {
      const { shouldTestNextSiblings = false } = compiled;
      return (elem) => {
        if (!next2(elem))
          return false;
        context[0] = elem;
        const childs = adapter2.getChildren(elem);
        const nextElements = shouldTestNextSiblings ? [...childs, ...getNextSiblings(elem, adapter2)] : childs;
        return adapter2.existsOne(hasElement, nextElements);
      };
    }
    return (elem) => next2(elem) && adapter2.existsOne(hasElement, adapter2.getChildren(elem));
  }
};

// node_modules/.pnpm/css-select@5.1.0/node_modules/css-select/lib/esm/pseudo-selectors/index.js
function compilePseudoSelector(next2, selector, options, context, compileToken2) {
  var _a2;
  const { name: name2, data: data2 } = selector;
  if (Array.isArray(data2)) {
    if (!(name2 in subselects)) {
      throw new Error(`Unknown pseudo-class :${name2}(${data2})`);
    }
    return subselects[name2](next2, data2, options, context, compileToken2);
  }
  const userPseudo = (_a2 = options.pseudos) === null || _a2 === void 0 ? void 0 : _a2[name2];
  const stringPseudo = typeof userPseudo === "string" ? userPseudo : aliases[name2];
  if (typeof stringPseudo === "string") {
    if (data2 != null) {
      throw new Error(`Pseudo ${name2} doesn't have any arguments`);
    }
    const alias = parse(stringPseudo);
    return subselects["is"](next2, alias, options, context, compileToken2);
  }
  if (typeof userPseudo === "function") {
    verifyPseudoArgs(userPseudo, name2, data2, 1);
    return (elem) => userPseudo(elem, data2) && next2(elem);
  }
  if (name2 in filters) {
    return filters[name2](next2, data2, options, context);
  }
  if (name2 in pseudos) {
    const pseudo = pseudos[name2];
    verifyPseudoArgs(pseudo, name2, data2, 2);
    return (elem) => pseudo(elem, options, data2) && next2(elem);
  }
  throw new Error(`Unknown pseudo-class :${name2}`);
}

// node_modules/.pnpm/css-select@5.1.0/node_modules/css-select/lib/esm/general.js
function getElementParent(node, adapter2) {
  const parent2 = adapter2.getParent(node);
  if (parent2 && adapter2.isTag(parent2)) {
    return parent2;
  }
  return null;
}
function compileGeneralSelector(next2, selector, options, context, compileToken2) {
  const { adapter: adapter2, equals } = options;
  switch (selector.type) {
    case SelectorType.PseudoElement: {
      throw new Error("Pseudo-elements are not supported by css-select");
    }
    case SelectorType.ColumnCombinator: {
      throw new Error("Column combinators are not yet supported by css-select");
    }
    case SelectorType.Attribute: {
      if (selector.namespace != null) {
        throw new Error("Namespaced attributes are not yet supported by css-select");
      }
      if (!options.xmlMode || options.lowerCaseAttributeNames) {
        selector.name = selector.name.toLowerCase();
      }
      return attributeRules[selector.action](next2, selector, options);
    }
    case SelectorType.Pseudo: {
      return compilePseudoSelector(next2, selector, options, context, compileToken2);
    }
    case SelectorType.Tag: {
      if (selector.namespace != null) {
        throw new Error("Namespaced tag names are not yet supported by css-select");
      }
      let { name: name2 } = selector;
      if (!options.xmlMode || options.lowerCaseTags) {
        name2 = name2.toLowerCase();
      }
      return function tag(elem) {
        return adapter2.getName(elem) === name2 && next2(elem);
      };
    }
    case SelectorType.Descendant: {
      if (options.cacheResults === false || typeof WeakSet === "undefined") {
        return function descendant(elem) {
          let current = elem;
          while (current = getElementParent(current, adapter2)) {
            if (next2(current)) {
              return true;
            }
          }
          return false;
        };
      }
      const isFalseCache = /* @__PURE__ */ new WeakSet();
      return function cachedDescendant(elem) {
        let current = elem;
        while (current = getElementParent(current, adapter2)) {
          if (!isFalseCache.has(current)) {
            if (adapter2.isTag(current) && next2(current)) {
              return true;
            }
            isFalseCache.add(current);
          }
        }
        return false;
      };
    }
    case "_flexibleDescendant": {
      return function flexibleDescendant(elem) {
        let current = elem;
        do {
          if (next2(current))
            return true;
        } while (current = getElementParent(current, adapter2));
        return false;
      };
    }
    case SelectorType.Parent: {
      return function parent2(elem) {
        return adapter2.getChildren(elem).some((elem2) => adapter2.isTag(elem2) && next2(elem2));
      };
    }
    case SelectorType.Child: {
      return function child(elem) {
        const parent2 = adapter2.getParent(elem);
        return parent2 != null && adapter2.isTag(parent2) && next2(parent2);
      };
    }
    case SelectorType.Sibling: {
      return function sibling(elem) {
        const siblings2 = adapter2.getSiblings(elem);
        for (let i = 0; i < siblings2.length; i++) {
          const currentSibling = siblings2[i];
          if (equals(elem, currentSibling))
            break;
          if (adapter2.isTag(currentSibling) && next2(currentSibling)) {
            return true;
          }
        }
        return false;
      };
    }
    case SelectorType.Adjacent: {
      if (adapter2.prevElementSibling) {
        return function adjacent(elem) {
          const previous = adapter2.prevElementSibling(elem);
          return previous != null && next2(previous);
        };
      }
      return function adjacent(elem) {
        const siblings2 = adapter2.getSiblings(elem);
        let lastElement;
        for (let i = 0; i < siblings2.length; i++) {
          const currentSibling = siblings2[i];
          if (equals(elem, currentSibling))
            break;
          if (adapter2.isTag(currentSibling)) {
            lastElement = currentSibling;
          }
        }
        return !!lastElement && next2(lastElement);
      };
    }
    case SelectorType.Universal: {
      if (selector.namespace != null && selector.namespace !== "*") {
        throw new Error("Namespaced universal selectors are not yet supported by css-select");
      }
      return next2;
    }
  }
}

// node_modules/.pnpm/css-select@5.1.0/node_modules/css-select/lib/esm/compile.js
function compile2(selector, options, context) {
  const next2 = compileUnsafe(selector, options, context);
  return ensureIsTag(next2, options.adapter);
}
function compileUnsafe(selector, options, context) {
  const token = typeof selector === "string" ? parse(selector) : selector;
  return compileToken(token, options, context);
}
function includesScopePseudo(t) {
  return t.type === SelectorType.Pseudo && (t.name === "scope" || Array.isArray(t.data) && t.data.some((data2) => data2.some(includesScopePseudo)));
}
var DESCENDANT_TOKEN = { type: SelectorType.Descendant };
var FLEXIBLE_DESCENDANT_TOKEN = {
  type: "_flexibleDescendant"
};
var SCOPE_TOKEN = {
  type: SelectorType.Pseudo,
  name: "scope",
  data: null
};
function absolutize(token, { adapter: adapter2 }, context) {
  const hasContext = !!(context === null || context === void 0 ? void 0 : context.every((e) => {
    const parent2 = adapter2.isTag(e) && adapter2.getParent(e);
    return e === PLACEHOLDER_ELEMENT || parent2 && adapter2.isTag(parent2);
  }));
  for (const t of token) {
    if (t.length > 0 && isTraversal2(t[0]) && t[0].type !== SelectorType.Descendant) {
    } else if (hasContext && !t.some(includesScopePseudo)) {
      t.unshift(DESCENDANT_TOKEN);
    } else {
      continue;
    }
    t.unshift(SCOPE_TOKEN);
  }
}
function compileToken(token, options, context) {
  var _a2;
  token.forEach(sortByProcedure);
  context = (_a2 = options.context) !== null && _a2 !== void 0 ? _a2 : context;
  const isArrayContext = Array.isArray(context);
  const finalContext = context && (Array.isArray(context) ? context : [context]);
  if (options.relativeSelector !== false) {
    absolutize(token, options, finalContext);
  } else if (token.some((t) => t.length > 0 && isTraversal2(t[0]))) {
    throw new Error("Relative selectors are not allowed when the `relativeSelector` option is disabled");
  }
  let shouldTestNextSiblings = false;
  const query = token.map((rules) => {
    if (rules.length >= 2) {
      const [first2, second] = rules;
      if (first2.type !== SelectorType.Pseudo || first2.name !== "scope") {
      } else if (isArrayContext && second.type === SelectorType.Descendant) {
        rules[1] = FLEXIBLE_DESCENDANT_TOKEN;
      } else if (second.type === SelectorType.Adjacent || second.type === SelectorType.Sibling) {
        shouldTestNextSiblings = true;
      }
    }
    return compileRules(rules, options, finalContext);
  }).reduce(reduceRules, import_boolbase5.default.falseFunc);
  query.shouldTestNextSiblings = shouldTestNextSiblings;
  return query;
}
function compileRules(rules, options, context) {
  var _a2;
  return rules.reduce((previous, rule) => previous === import_boolbase5.default.falseFunc ? import_boolbase5.default.falseFunc : compileGeneralSelector(previous, rule, options, context, compileToken), (_a2 = options.rootFunc) !== null && _a2 !== void 0 ? _a2 : import_boolbase5.default.trueFunc);
}
function reduceRules(a, b) {
  if (b === import_boolbase5.default.falseFunc || a === import_boolbase5.default.trueFunc) {
    return a;
  }
  if (a === import_boolbase5.default.falseFunc || b === import_boolbase5.default.trueFunc) {
    return b;
  }
  return function combine(elem) {
    return a(elem) || b(elem);
  };
}

// node_modules/.pnpm/css-select@5.1.0/node_modules/css-select/lib/esm/index.js
var defaultEquals = (a, b) => a === b;
var defaultOptions = {
  adapter: esm_exports2,
  equals: defaultEquals
};
function convertOptionFormats(options) {
  var _a2, _b, _c, _d;
  const opts = options !== null && options !== void 0 ? options : defaultOptions;
  (_a2 = opts.adapter) !== null && _a2 !== void 0 ? _a2 : opts.adapter = esm_exports2;
  (_b = opts.equals) !== null && _b !== void 0 ? _b : opts.equals = (_d = (_c = opts.adapter) === null || _c === void 0 ? void 0 : _c.equals) !== null && _d !== void 0 ? _d : defaultEquals;
  return opts;
}
function wrapCompile(func) {
  return function addAdapter(selector, options, context) {
    const opts = convertOptionFormats(options);
    return func(selector, opts, context);
  };
}
var compile3 = wrapCompile(compile2);
var _compileUnsafe = wrapCompile(compileUnsafe);
var _compileToken = wrapCompile(compileToken);
function getSelectorFunc(searchFunc) {
  return function select2(query, elements, options) {
    const opts = convertOptionFormats(options);
    if (typeof query !== "function") {
      query = compileUnsafe(query, opts, elements);
    }
    const filteredElements = prepareContext(elements, opts.adapter, query.shouldTestNextSiblings);
    return searchFunc(query, filteredElements, opts);
  };
}
function prepareContext(elems, adapter2, shouldTestNextSiblings = false) {
  if (shouldTestNextSiblings) {
    elems = appendNextSiblings(elems, adapter2);
  }
  return Array.isArray(elems) ? adapter2.removeSubsets(elems) : adapter2.getChildren(elems);
}
function appendNextSiblings(elem, adapter2) {
  const elems = Array.isArray(elem) ? elem.slice(0) : [elem];
  const elemsLength = elems.length;
  for (let i = 0; i < elemsLength; i++) {
    const nextSiblings = getNextSiblings(elems[i], adapter2);
    elems.push(...nextSiblings);
  }
  return elems;
}
var selectAll = getSelectorFunc((query, elems, options) => query === import_boolbase6.default.falseFunc || !elems || elems.length === 0 ? [] : options.adapter.findAll(query, elems));
var selectOne = getSelectorFunc((query, elems, options) => query === import_boolbase6.default.falseFunc || !elems || elems.length === 0 ? null : options.adapter.findOne(query, elems));

// node_modules/.pnpm/cheerio-select@2.1.0/node_modules/cheerio-select/lib/esm/index.js
var boolbase7 = __toESM(require_boolbase());

// node_modules/.pnpm/cheerio-select@2.1.0/node_modules/cheerio-select/lib/esm/positionals.js
var filterNames = /* @__PURE__ */ new Set([
  "first",
  "last",
  "eq",
  "gt",
  "nth",
  "lt",
  "even",
  "odd"
]);
function isFilter(s) {
  if (s.type !== "pseudo")
    return false;
  if (filterNames.has(s.name))
    return true;
  if (s.name === "not" && Array.isArray(s.data)) {
    return s.data.some((s2) => s2.some(isFilter));
  }
  return false;
}
function getLimit(filter4, data2, partLimit) {
  const num = data2 != null ? parseInt(data2, 10) : NaN;
  switch (filter4) {
    case "first":
      return 1;
    case "nth":
    case "eq":
      return isFinite(num) ? num >= 0 ? num + 1 : Infinity : 0;
    case "lt":
      return isFinite(num) ? num >= 0 ? Math.min(num, partLimit) : Infinity : 0;
    case "gt":
      return isFinite(num) ? Infinity : 0;
    case "odd":
      return 2 * partLimit;
    case "even":
      return 2 * partLimit - 1;
    case "last":
    case "not":
      return Infinity;
  }
}

// node_modules/.pnpm/cheerio-select@2.1.0/node_modules/cheerio-select/lib/esm/helpers.js
function getDocumentRoot(node) {
  while (node.parent)
    node = node.parent;
  return node;
}
function groupSelectors(selectors) {
  const filteredSelectors = [];
  const plainSelectors = [];
  for (const selector of selectors) {
    if (selector.some(isFilter)) {
      filteredSelectors.push(selector);
    } else {
      plainSelectors.push(selector);
    }
  }
  return [plainSelectors, filteredSelectors];
}

// node_modules/.pnpm/cheerio-select@2.1.0/node_modules/cheerio-select/lib/esm/index.js
var UNIVERSAL_SELECTOR = {
  type: SelectorType.Universal,
  namespace: null
};
var SCOPE_PSEUDO = {
  type: SelectorType.Pseudo,
  name: "scope",
  data: null
};
function is2(element, selector, options = {}) {
  return some([element], selector, options);
}
function some(elements, selector, options = {}) {
  if (typeof selector === "function")
    return elements.some(selector);
  const [plain, filtered] = groupSelectors(parse(selector));
  return plain.length > 0 && elements.some(_compileToken(plain, options)) || filtered.some((sel) => filterBySelector(sel, elements, options).length > 0);
}
function filterByPosition(filter4, elems, data2, options) {
  const num = typeof data2 === "string" ? parseInt(data2, 10) : NaN;
  switch (filter4) {
    case "first":
    case "lt":
      return elems;
    case "last":
      return elems.length > 0 ? [elems[elems.length - 1]] : elems;
    case "nth":
    case "eq":
      return isFinite(num) && Math.abs(num) < elems.length ? [num < 0 ? elems[elems.length + num] : elems[num]] : [];
    case "gt":
      return isFinite(num) ? elems.slice(num + 1) : [];
    case "even":
      return elems.filter((_, i) => i % 2 === 0);
    case "odd":
      return elems.filter((_, i) => i % 2 === 1);
    case "not": {
      const filtered = new Set(filterParsed(data2, elems, options));
      return elems.filter((e) => !filtered.has(e));
    }
  }
}
function filter2(selector, elements, options = {}) {
  return filterParsed(parse(selector), elements, options);
}
function filterParsed(selector, elements, options) {
  if (elements.length === 0)
    return [];
  const [plainSelectors, filteredSelectors] = groupSelectors(selector);
  let found;
  if (plainSelectors.length) {
    const filtered = filterElements(elements, plainSelectors, options);
    if (filteredSelectors.length === 0) {
      return filtered;
    }
    if (filtered.length) {
      found = new Set(filtered);
    }
  }
  for (let i = 0; i < filteredSelectors.length && (found === null || found === void 0 ? void 0 : found.size) !== elements.length; i++) {
    const filteredSelector = filteredSelectors[i];
    const missing = found ? elements.filter((e) => isTag2(e) && !found.has(e)) : elements;
    if (missing.length === 0)
      break;
    const filtered = filterBySelector(filteredSelector, elements, options);
    if (filtered.length) {
      if (!found) {
        if (i === filteredSelectors.length - 1) {
          return filtered;
        }
        found = new Set(filtered);
      } else {
        filtered.forEach((el) => found.add(el));
      }
    }
  }
  return typeof found !== "undefined" ? found.size === elements.length ? elements : (
    // Filter elements to preserve order
    elements.filter((el) => found.has(el))
  ) : [];
}
function filterBySelector(selector, elements, options) {
  var _a2;
  if (selector.some(isTraversal)) {
    const root3 = (_a2 = options.root) !== null && _a2 !== void 0 ? _a2 : getDocumentRoot(elements[0]);
    const opts = { ...options, context: elements, relativeSelector: false };
    selector.push(SCOPE_PSEUDO);
    return findFilterElements(root3, selector, opts, true, elements.length);
  }
  return findFilterElements(elements, selector, options, false, elements.length);
}
function select(selector, root3, options = {}, limit = Infinity) {
  if (typeof selector === "function") {
    return find2(root3, selector);
  }
  const [plain, filtered] = groupSelectors(parse(selector));
  const results = filtered.map((sel) => findFilterElements(root3, sel, options, true, limit));
  if (plain.length) {
    results.push(findElements(root3, plain, options, limit));
  }
  if (results.length === 0) {
    return [];
  }
  if (results.length === 1) {
    return results[0];
  }
  return uniqueSort(results.reduce((a, b) => [...a, ...b]));
}
function findFilterElements(root3, selector, options, queryForSelector, totalLimit) {
  const filterIndex = selector.findIndex(isFilter);
  const sub = selector.slice(0, filterIndex);
  const filter4 = selector[filterIndex];
  const partLimit = selector.length - 1 === filterIndex ? totalLimit : Infinity;
  const limit = getLimit(filter4.name, filter4.data, partLimit);
  if (limit === 0)
    return [];
  const elemsNoLimit = sub.length === 0 && !Array.isArray(root3) ? getChildren(root3).filter(isTag2) : sub.length === 0 ? (Array.isArray(root3) ? root3 : [root3]).filter(isTag2) : queryForSelector || sub.some(isTraversal) ? findElements(root3, [sub], options, limit) : filterElements(root3, [sub], options);
  const elems = elemsNoLimit.slice(0, limit);
  let result = filterByPosition(filter4.name, elems, filter4.data, options);
  if (result.length === 0 || selector.length === filterIndex + 1) {
    return result;
  }
  const remainingSelector = selector.slice(filterIndex + 1);
  const remainingHasTraversal = remainingSelector.some(isTraversal);
  if (remainingHasTraversal) {
    if (isTraversal(remainingSelector[0])) {
      const { type: type2 } = remainingSelector[0];
      if (type2 === SelectorType.Sibling || type2 === SelectorType.Adjacent) {
        result = prepareContext(result, esm_exports2, true);
      }
      remainingSelector.unshift(UNIVERSAL_SELECTOR);
    }
    options = {
      ...options,
      // Avoid absolutizing the selector
      relativeSelector: false,
      /*
       * Add a custom root func, to make sure traversals don't match elements
       * that aren't a part of the considered tree.
       */
      rootFunc: (el) => result.includes(el)
    };
  } else if (options.rootFunc && options.rootFunc !== boolbase7.trueFunc) {
    options = { ...options, rootFunc: boolbase7.trueFunc };
  }
  return remainingSelector.some(isFilter) ? findFilterElements(result, remainingSelector, options, false, totalLimit) : remainingHasTraversal ? (
    // Query existing elements to resolve traversal.
    findElements(result, [remainingSelector], options, totalLimit)
  ) : (
    // If we don't have any more traversals, simply filter elements.
    filterElements(result, [remainingSelector], options)
  );
}
function findElements(root3, sel, options, limit) {
  const query = _compileToken(sel, options, root3);
  return find2(root3, query, limit);
}
function find2(root3, query, limit = Infinity) {
  const elems = prepareContext(root3, esm_exports2, query.shouldTestNextSiblings);
  return find((node) => isTag2(node) && query(node), elems, true, limit);
}
function filterElements(elements, sel, options) {
  const els = (Array.isArray(elements) ? elements : [elements]).filter(isTag2);
  if (els.length === 0)
    return els;
  const query = _compileToken(sel, options);
  return query === boolbase7.trueFunc ? els : els.filter(query);
}

// node_modules/.pnpm/cheerio@1.0.0-rc.12/node_modules/cheerio/lib/esm/api/traversing.js
var reSiblingSelector = /^\s*[~+]/;
function find3(selectorOrHaystack) {
  var _a2;
  if (!selectorOrHaystack) {
    return this._make([]);
  }
  const context = this.toArray();
  if (typeof selectorOrHaystack !== "string") {
    const haystack = isCheerio(selectorOrHaystack) ? selectorOrHaystack.toArray() : [selectorOrHaystack];
    return this._make(haystack.filter((elem) => context.some((node) => contains(node, elem))));
  }
  const elems = reSiblingSelector.test(selectorOrHaystack) ? context : this.children().toArray();
  const options = {
    context,
    root: (_a2 = this._root) === null || _a2 === void 0 ? void 0 : _a2[0],
    // Pass options that are recognized by `cheerio-select`
    xmlMode: this.options.xmlMode,
    lowerCaseTags: this.options.lowerCaseTags,
    lowerCaseAttributeNames: this.options.lowerCaseAttributeNames,
    pseudos: this.options.pseudos,
    quirksMode: this.options.quirksMode
  };
  return this._make(select(selectorOrHaystack, elems, options));
}
function _getMatcher(matchMap) {
  return function(fn, ...postFns) {
    return function(selector) {
      var _a2;
      let matched = matchMap(fn, this);
      if (selector) {
        matched = filterArray(matched, selector, this.options.xmlMode, (_a2 = this._root) === null || _a2 === void 0 ? void 0 : _a2[0]);
      }
      return this._make(
        // Post processing is only necessary if there is more than one element.
        this.length > 1 && matched.length > 1 ? postFns.reduce((elems, fn2) => fn2(elems), matched) : matched
      );
    };
  };
}
var _matcher = _getMatcher((fn, elems) => {
  const ret = [];
  for (let i = 0; i < elems.length; i++) {
    const value = fn(elems[i]);
    ret.push(value);
  }
  return new Array().concat(...ret);
});
var _singleMatcher = _getMatcher((fn, elems) => {
  const ret = [];
  for (let i = 0; i < elems.length; i++) {
    const value = fn(elems[i]);
    if (value !== null) {
      ret.push(value);
    }
  }
  return ret;
});
function _matchUntil(nextElem, ...postFns) {
  let matches = null;
  const innerMatcher = _getMatcher((nextElem2, elems) => {
    const matched = [];
    domEach(elems, (elem) => {
      for (let next2; next2 = nextElem2(elem); elem = next2) {
        if (matches === null || matches === void 0 ? void 0 : matches(next2, matched.length))
          break;
        matched.push(next2);
      }
    });
    return matched;
  })(nextElem, ...postFns);
  return function(selector, filterSelector) {
    matches = typeof selector === "string" ? (elem) => is2(elem, selector, this.options) : selector ? getFilterFn(selector) : null;
    const ret = innerMatcher.call(this, filterSelector);
    matches = null;
    return ret;
  };
}
function _removeDuplicates(elems) {
  return Array.from(new Set(elems));
}
var parent = _singleMatcher(({ parent: parent2 }) => parent2 && !isDocument(parent2) ? parent2 : null, _removeDuplicates);
var parents = _matcher((elem) => {
  const matched = [];
  while (elem.parent && !isDocument(elem.parent)) {
    matched.push(elem.parent);
    elem = elem.parent;
  }
  return matched;
}, uniqueSort, (elems) => elems.reverse());
var parentsUntil = _matchUntil(({ parent: parent2 }) => parent2 && !isDocument(parent2) ? parent2 : null, uniqueSort, (elems) => elems.reverse());
function closest(selector) {
  var _a2;
  const set3 = [];
  if (!selector) {
    return this._make(set3);
  }
  const selectOpts = {
    xmlMode: this.options.xmlMode,
    root: (_a2 = this._root) === null || _a2 === void 0 ? void 0 : _a2[0]
  };
  const selectFn = typeof selector === "string" ? (elem) => is2(elem, selector, selectOpts) : getFilterFn(selector);
  domEach(this, (elem) => {
    while (elem && isTag2(elem)) {
      if (selectFn(elem, 0)) {
        if (!set3.includes(elem)) {
          set3.push(elem);
        }
        break;
      }
      elem = elem.parent;
    }
  });
  return this._make(set3);
}
var next = _singleMatcher((elem) => nextElementSibling(elem));
var nextAll = _matcher((elem) => {
  const matched = [];
  while (elem.next) {
    elem = elem.next;
    if (isTag2(elem))
      matched.push(elem);
  }
  return matched;
}, _removeDuplicates);
var nextUntil = _matchUntil((el) => nextElementSibling(el), _removeDuplicates);
var prev = _singleMatcher((elem) => prevElementSibling(elem));
var prevAll = _matcher((elem) => {
  const matched = [];
  while (elem.prev) {
    elem = elem.prev;
    if (isTag2(elem))
      matched.push(elem);
  }
  return matched;
}, _removeDuplicates);
var prevUntil = _matchUntil((el) => prevElementSibling(el), _removeDuplicates);
var siblings = _matcher((elem) => getSiblings(elem).filter((el) => isTag2(el) && el !== elem), uniqueSort);
var children = _matcher((elem) => getChildren(elem).filter(isTag2), _removeDuplicates);
function contents() {
  const elems = this.toArray().reduce((newElems, elem) => hasChildren(elem) ? newElems.concat(elem.children) : newElems, []);
  return this._make(elems);
}
function each(fn) {
  let i = 0;
  const len = this.length;
  while (i < len && fn.call(this[i], i, this[i]) !== false)
    ++i;
  return this;
}
function map(fn) {
  let elems = [];
  for (let i = 0; i < this.length; i++) {
    const el = this[i];
    const val2 = fn.call(el, i, el);
    if (val2 != null) {
      elems = elems.concat(val2);
    }
  }
  return this._make(elems);
}
function getFilterFn(match2) {
  if (typeof match2 === "function") {
    return (el, i) => match2.call(el, i, el);
  }
  if (isCheerio(match2)) {
    return (el) => Array.prototype.includes.call(match2, el);
  }
  return function(el) {
    return match2 === el;
  };
}
function filter3(match2) {
  var _a2;
  return this._make(filterArray(this.toArray(), match2, this.options.xmlMode, (_a2 = this._root) === null || _a2 === void 0 ? void 0 : _a2[0]));
}
function filterArray(nodes, match2, xmlMode, root3) {
  return typeof match2 === "string" ? filter2(match2, nodes, { xmlMode, root: root3 }) : nodes.filter(getFilterFn(match2));
}
function is3(selector) {
  const nodes = this.toArray();
  return typeof selector === "string" ? some(nodes.filter(isTag2), selector, this.options) : selector ? nodes.some(getFilterFn(selector)) : false;
}
function not(match2) {
  let nodes = this.toArray();
  if (typeof match2 === "string") {
    const matches = new Set(filter2(match2, nodes, this.options));
    nodes = nodes.filter((el) => !matches.has(el));
  } else {
    const filterFn = getFilterFn(match2);
    nodes = nodes.filter((el, i) => !filterFn(el, i));
  }
  return this._make(nodes);
}
function has(selectorOrHaystack) {
  return this.filter(typeof selectorOrHaystack === "string" ? (
    // Using the `:has` selector here short-circuits searches.
    `:has(${selectorOrHaystack})`
  ) : (_, el) => this._make(el).find(selectorOrHaystack).length > 0);
}
function first() {
  return this.length > 1 ? this._make(this[0]) : this;
}
function last() {
  return this.length > 0 ? this._make(this[this.length - 1]) : this;
}
function eq(i) {
  var _a2;
  i = +i;
  if (i === 0 && this.length <= 1)
    return this;
  if (i < 0)
    i = this.length + i;
  return this._make((_a2 = this[i]) !== null && _a2 !== void 0 ? _a2 : []);
}
function get(i) {
  if (i == null) {
    return this.toArray();
  }
  return this[i < 0 ? this.length + i : i];
}
function toArray() {
  return Array.prototype.slice.call(this);
}
function index(selectorOrNeedle) {
  let $haystack;
  let needle;
  if (selectorOrNeedle == null) {
    $haystack = this.parent().children();
    needle = this[0];
  } else if (typeof selectorOrNeedle === "string") {
    $haystack = this._make(selectorOrNeedle);
    needle = this[0];
  } else {
    $haystack = this;
    needle = isCheerio(selectorOrNeedle) ? selectorOrNeedle[0] : selectorOrNeedle;
  }
  return Array.prototype.indexOf.call($haystack, needle);
}
function slice(start, end2) {
  return this._make(Array.prototype.slice.call(this, start, end2));
}
function end() {
  var _a2;
  return (_a2 = this.prevObject) !== null && _a2 !== void 0 ? _a2 : this._make([]);
}
function add(other, context) {
  const selection = this._make(other, context);
  const contents2 = uniqueSort([...this.get(), ...selection.get()]);
  return this._make(contents2);
}
function addBack(selector) {
  return this.prevObject ? this.add(selector ? this.prevObject.filter(selector) : this.prevObject) : this;
}

// node_modules/.pnpm/cheerio@1.0.0-rc.12/node_modules/cheerio/lib/esm/api/manipulation.js
var manipulation_exports = {};
__export(manipulation_exports, {
  _makeDomArray: () => _makeDomArray,
  after: () => after,
  append: () => append2,
  appendTo: () => appendTo,
  before: () => before,
  clone: () => clone,
  empty: () => empty,
  html: () => html2,
  insertAfter: () => insertAfter,
  insertBefore: () => insertBefore,
  prepend: () => prepend2,
  prependTo: () => prependTo,
  remove: () => remove,
  replaceWith: () => replaceWith,
  text: () => text2,
  toString: () => toString,
  unwrap: () => unwrap,
  wrap: () => wrap,
  wrapAll: () => wrapAll,
  wrapInner: () => wrapInner
});

// node_modules/.pnpm/cheerio@1.0.0-rc.12/node_modules/cheerio/lib/esm/parse.js
function getParse(parser) {
  return function parse6(content, options, isDocument2, context) {
    if (typeof Buffer !== "undefined" && Buffer.isBuffer(content)) {
      content = content.toString();
    }
    if (typeof content === "string") {
      return parser(content, options, isDocument2, context);
    }
    const doc = content;
    if (!Array.isArray(doc) && isDocument(doc)) {
      return doc;
    }
    const root3 = new Document([]);
    update(doc, root3);
    return root3;
  };
}
function update(newChilds, parent2) {
  const arr = Array.isArray(newChilds) ? newChilds : [newChilds];
  if (parent2) {
    parent2.children = arr;
  } else {
    parent2 = null;
  }
  for (let i = 0; i < arr.length; i++) {
    const node = arr[i];
    if (node.parent && node.parent.children !== arr) {
      removeElement(node);
    }
    if (parent2) {
      node.prev = arr[i - 1] || null;
      node.next = arr[i + 1] || null;
    } else {
      node.prev = node.next = null;
    }
    node.parent = parent2;
  }
  return parent2;
}

// node_modules/.pnpm/cheerio@1.0.0-rc.12/node_modules/cheerio/lib/esm/api/manipulation.js
function _makeDomArray(elem, clone2) {
  if (elem == null) {
    return [];
  }
  if (isCheerio(elem)) {
    return clone2 ? cloneDom(elem.get()) : elem.get();
  }
  if (Array.isArray(elem)) {
    return elem.reduce((newElems, el) => newElems.concat(this._makeDomArray(el, clone2)), []);
  }
  if (typeof elem === "string") {
    return this._parse(elem, this.options, false, null).children;
  }
  return clone2 ? cloneDom([elem]) : [elem];
}
function _insert(concatenator) {
  return function(...elems) {
    const lastIdx = this.length - 1;
    return domEach(this, (el, i) => {
      if (!hasChildren(el))
        return;
      const domSrc = typeof elems[0] === "function" ? elems[0].call(el, i, this._render(el.children)) : elems;
      const dom = this._makeDomArray(domSrc, i < lastIdx);
      concatenator(dom, el.children, el);
    });
  };
}
function uniqueSplice(array, spliceIdx, spliceCount, newElems, parent2) {
  var _a2, _b;
  const spliceArgs = [
    spliceIdx,
    spliceCount,
    ...newElems
  ];
  const prev2 = spliceIdx === 0 ? null : array[spliceIdx - 1];
  const next2 = spliceIdx + spliceCount >= array.length ? null : array[spliceIdx + spliceCount];
  for (let idx = 0; idx < newElems.length; ++idx) {
    const node = newElems[idx];
    const oldParent = node.parent;
    if (oldParent) {
      const oldSiblings = oldParent.children;
      const prevIdx = oldSiblings.indexOf(node);
      if (prevIdx > -1) {
        oldParent.children.splice(prevIdx, 1);
        if (parent2 === oldParent && spliceIdx > prevIdx) {
          spliceArgs[0]--;
        }
      }
    }
    node.parent = parent2;
    if (node.prev) {
      node.prev.next = (_a2 = node.next) !== null && _a2 !== void 0 ? _a2 : null;
    }
    if (node.next) {
      node.next.prev = (_b = node.prev) !== null && _b !== void 0 ? _b : null;
    }
    node.prev = idx === 0 ? prev2 : newElems[idx - 1];
    node.next = idx === newElems.length - 1 ? next2 : newElems[idx + 1];
  }
  if (prev2) {
    prev2.next = newElems[0];
  }
  if (next2) {
    next2.prev = newElems[newElems.length - 1];
  }
  return array.splice(...spliceArgs);
}
function appendTo(target) {
  const appendTarget = isCheerio(target) ? target : this._make(target);
  appendTarget.append(this);
  return this;
}
function prependTo(target) {
  const prependTarget = isCheerio(target) ? target : this._make(target);
  prependTarget.prepend(this);
  return this;
}
var append2 = _insert((dom, children2, parent2) => {
  uniqueSplice(children2, children2.length, 0, dom, parent2);
});
var prepend2 = _insert((dom, children2, parent2) => {
  uniqueSplice(children2, 0, 0, dom, parent2);
});
function _wrap(insert) {
  return function(wrapper) {
    const lastIdx = this.length - 1;
    const lastParent = this.parents().last();
    for (let i = 0; i < this.length; i++) {
      const el = this[i];
      const wrap2 = typeof wrapper === "function" ? wrapper.call(el, i, el) : typeof wrapper === "string" && !isHtml(wrapper) ? lastParent.find(wrapper).clone() : wrapper;
      const [wrapperDom] = this._makeDomArray(wrap2, i < lastIdx);
      if (!wrapperDom || !hasChildren(wrapperDom))
        continue;
      let elInsertLocation = wrapperDom;
      let j = 0;
      while (j < elInsertLocation.children.length) {
        const child = elInsertLocation.children[j];
        if (isTag2(child)) {
          elInsertLocation = child;
          j = 0;
        } else {
          j++;
        }
      }
      insert(el, elInsertLocation, [wrapperDom]);
    }
    return this;
  };
}
var wrap = _wrap((el, elInsertLocation, wrapperDom) => {
  const { parent: parent2 } = el;
  if (!parent2)
    return;
  const siblings2 = parent2.children;
  const index2 = siblings2.indexOf(el);
  update([el], elInsertLocation);
  uniqueSplice(siblings2, index2, 0, wrapperDom, parent2);
});
var wrapInner = _wrap((el, elInsertLocation, wrapperDom) => {
  if (!hasChildren(el))
    return;
  update(el.children, elInsertLocation);
  update(wrapperDom, el);
});
function unwrap(selector) {
  this.parent(selector).not("body").each((_, el) => {
    this._make(el).replaceWith(el.children);
  });
  return this;
}
function wrapAll(wrapper) {
  const el = this[0];
  if (el) {
    const wrap2 = this._make(typeof wrapper === "function" ? wrapper.call(el, 0, el) : wrapper).insertBefore(el);
    let elInsertLocation;
    for (let i = 0; i < wrap2.length; i++) {
      if (wrap2[i].type === "tag")
        elInsertLocation = wrap2[i];
    }
    let j = 0;
    while (elInsertLocation && j < elInsertLocation.children.length) {
      const child = elInsertLocation.children[j];
      if (child.type === "tag") {
        elInsertLocation = child;
        j = 0;
      } else {
        j++;
      }
    }
    if (elInsertLocation)
      this._make(elInsertLocation).append(this);
  }
  return this;
}
function after(...elems) {
  const lastIdx = this.length - 1;
  return domEach(this, (el, i) => {
    const { parent: parent2 } = el;
    if (!hasChildren(el) || !parent2) {
      return;
    }
    const siblings2 = parent2.children;
    const index2 = siblings2.indexOf(el);
    if (index2 < 0)
      return;
    const domSrc = typeof elems[0] === "function" ? elems[0].call(el, i, this._render(el.children)) : elems;
    const dom = this._makeDomArray(domSrc, i < lastIdx);
    uniqueSplice(siblings2, index2 + 1, 0, dom, parent2);
  });
}
function insertAfter(target) {
  if (typeof target === "string") {
    target = this._make(target);
  }
  this.remove();
  const clones = [];
  this._makeDomArray(target).forEach((el) => {
    const clonedSelf = this.clone().toArray();
    const { parent: parent2 } = el;
    if (!parent2) {
      return;
    }
    const siblings2 = parent2.children;
    const index2 = siblings2.indexOf(el);
    if (index2 < 0)
      return;
    uniqueSplice(siblings2, index2 + 1, 0, clonedSelf, parent2);
    clones.push(...clonedSelf);
  });
  return this._make(clones);
}
function before(...elems) {
  const lastIdx = this.length - 1;
  return domEach(this, (el, i) => {
    const { parent: parent2 } = el;
    if (!hasChildren(el) || !parent2) {
      return;
    }
    const siblings2 = parent2.children;
    const index2 = siblings2.indexOf(el);
    if (index2 < 0)
      return;
    const domSrc = typeof elems[0] === "function" ? elems[0].call(el, i, this._render(el.children)) : elems;
    const dom = this._makeDomArray(domSrc, i < lastIdx);
    uniqueSplice(siblings2, index2, 0, dom, parent2);
  });
}
function insertBefore(target) {
  const targetArr = this._make(target);
  this.remove();
  const clones = [];
  domEach(targetArr, (el) => {
    const clonedSelf = this.clone().toArray();
    const { parent: parent2 } = el;
    if (!parent2) {
      return;
    }
    const siblings2 = parent2.children;
    const index2 = siblings2.indexOf(el);
    if (index2 < 0)
      return;
    uniqueSplice(siblings2, index2, 0, clonedSelf, parent2);
    clones.push(...clonedSelf);
  });
  return this._make(clones);
}
function remove(selector) {
  const elems = selector ? this.filter(selector) : this;
  domEach(elems, (el) => {
    removeElement(el);
    el.prev = el.next = el.parent = null;
  });
  return this;
}
function replaceWith(content) {
  return domEach(this, (el, i) => {
    const { parent: parent2 } = el;
    if (!parent2) {
      return;
    }
    const siblings2 = parent2.children;
    const cont = typeof content === "function" ? content.call(el, i, el) : content;
    const dom = this._makeDomArray(cont);
    update(dom, null);
    const index2 = siblings2.indexOf(el);
    uniqueSplice(siblings2, index2, 1, dom, parent2);
    if (!dom.includes(el)) {
      el.parent = el.prev = el.next = null;
    }
  });
}
function empty() {
  return domEach(this, (el) => {
    if (!hasChildren(el))
      return;
    el.children.forEach((child) => {
      child.next = child.prev = child.parent = null;
    });
    el.children.length = 0;
  });
}
function html2(str2) {
  if (str2 === void 0) {
    const el = this[0];
    if (!el || !hasChildren(el))
      return null;
    return this._render(el.children);
  }
  return domEach(this, (el) => {
    if (!hasChildren(el))
      return;
    el.children.forEach((child) => {
      child.next = child.prev = child.parent = null;
    });
    const content = isCheerio(str2) ? str2.toArray() : this._parse(`${str2}`, this.options, false, el).children;
    update(content, el);
  });
}
function toString() {
  return this._render(this);
}
function text2(str2) {
  if (str2 === void 0) {
    return text(this);
  }
  if (typeof str2 === "function") {
    return domEach(this, (el, i) => this._make(el).text(str2.call(el, i, text([el]))));
  }
  return domEach(this, (el) => {
    if (!hasChildren(el))
      return;
    el.children.forEach((child) => {
      child.next = child.prev = child.parent = null;
    });
    const textNode = new Text2(`${str2}`);
    update(textNode, el);
  });
}
function clone() {
  return this._make(cloneDom(this.get()));
}

// node_modules/.pnpm/cheerio@1.0.0-rc.12/node_modules/cheerio/lib/esm/api/css.js
var css_exports = {};
__export(css_exports, {
  css: () => css
});
function css(prop2, val2) {
  if (prop2 != null && val2 != null || // When `prop` is a "plain" object
  typeof prop2 === "object" && !Array.isArray(prop2)) {
    return domEach(this, (el, i) => {
      if (isTag2(el)) {
        setCss(el, prop2, val2, i);
      }
    });
  }
  if (this.length === 0) {
    return void 0;
  }
  return getCss(this[0], prop2);
}
function setCss(el, prop2, value, idx) {
  if (typeof prop2 === "string") {
    const styles2 = getCss(el);
    const val2 = typeof value === "function" ? value.call(el, idx, styles2[prop2]) : value;
    if (val2 === "") {
      delete styles2[prop2];
    } else if (val2 != null) {
      styles2[prop2] = val2;
    }
    el.attribs["style"] = stringify2(styles2);
  } else if (typeof prop2 === "object") {
    Object.keys(prop2).forEach((k, i) => {
      setCss(el, k, prop2[k], i);
    });
  }
}
function getCss(el, prop2) {
  if (!el || !isTag2(el))
    return;
  const styles2 = parse3(el.attribs["style"]);
  if (typeof prop2 === "string") {
    return styles2[prop2];
  }
  if (Array.isArray(prop2)) {
    const newStyles = {};
    prop2.forEach((item) => {
      if (styles2[item] != null) {
        newStyles[item] = styles2[item];
      }
    });
    return newStyles;
  }
  return styles2;
}
function stringify2(obj) {
  return Object.keys(obj).reduce((str2, prop2) => `${str2}${str2 ? " " : ""}${prop2}: ${obj[prop2]};`, "");
}
function parse3(styles2) {
  styles2 = (styles2 || "").trim();
  if (!styles2)
    return {};
  const obj = {};
  let key;
  for (const str2 of styles2.split(";")) {
    const n = str2.indexOf(":");
    if (n < 1 || n === str2.length - 1) {
      const trimmed = str2.trimEnd();
      if (trimmed.length > 0 && key !== void 0) {
        obj[key] += `;${trimmed}`;
      }
    } else {
      key = str2.slice(0, n).trim();
      obj[key] = str2.slice(n + 1).trim();
    }
  }
  return obj;
}

// node_modules/.pnpm/cheerio@1.0.0-rc.12/node_modules/cheerio/lib/esm/api/forms.js
var forms_exports = {};
__export(forms_exports, {
  serialize: () => serialize,
  serializeArray: () => serializeArray
});
var submittableSelector = "input,select,textarea,keygen";
var r20 = /%20/g;
var rCRLF = /\r?\n/g;
function serialize() {
  const arr = this.serializeArray();
  const retArr = arr.map((data2) => `${encodeURIComponent(data2.name)}=${encodeURIComponent(data2.value)}`);
  return retArr.join("&").replace(r20, "+");
}
function serializeArray() {
  return this.map((_, elem) => {
    const $elem = this._make(elem);
    if (isTag2(elem) && elem.name === "form") {
      return $elem.find(submittableSelector).toArray();
    }
    return $elem.filter(submittableSelector).toArray();
  }).filter(
    // Verify elements have a name (`attr.name`) and are not disabled (`:enabled`)
    '[name!=""]:enabled:not(:submit, :button, :image, :reset, :file):matches([checked], :not(:checkbox, :radio))'
    // Convert each of the elements to its value(s)
  ).map((_, elem) => {
    var _a2;
    const $elem = this._make(elem);
    const name2 = $elem.attr("name");
    const value = (_a2 = $elem.val()) !== null && _a2 !== void 0 ? _a2 : "";
    if (Array.isArray(value)) {
      return value.map((val2) => (
        /*
         * We trim replace any line endings (e.g. `\r` or `\r\n` with `\r\n`) to guarantee consistency across platforms
         * These can occur inside of `<textarea>'s`
         */
        { name: name2, value: val2.replace(rCRLF, "\r\n") }
      ));
    }
    return { name: name2, value: value.replace(rCRLF, "\r\n") };
  }).toArray();
}

// node_modules/.pnpm/cheerio@1.0.0-rc.12/node_modules/cheerio/lib/esm/cheerio.js
var Cheerio = class {
  /**
   * Instance of cheerio. Methods are specified in the modules. Usage of this
   * constructor is not recommended. Please use `$.load` instead.
   *
   * @private
   * @param elements - The new selection.
   * @param root - Sets the root node.
   * @param options - Options for the instance.
   */
  constructor(elements, root3, options) {
    this.length = 0;
    this.options = options;
    this._root = root3;
    if (elements) {
      for (let idx = 0; idx < elements.length; idx++) {
        this[idx] = elements[idx];
      }
      this.length = elements.length;
    }
  }
};
Cheerio.prototype.cheerio = "[cheerio object]";
Cheerio.prototype.splice = Array.prototype.splice;
Cheerio.prototype[Symbol.iterator] = Array.prototype[Symbol.iterator];
Object.assign(Cheerio.prototype, attributes_exports, traversing_exports, manipulation_exports, css_exports, forms_exports);

// node_modules/.pnpm/cheerio@1.0.0-rc.12/node_modules/cheerio/lib/esm/load.js
function getLoad(parse6, render3) {
  return function load3(content, options, isDocument2 = true) {
    if (content == null) {
      throw new Error("cheerio.load() expects a string");
    }
    const internalOpts = { ...options_default, ...flatten(options) };
    const initialRoot = parse6(content, internalOpts, isDocument2, null);
    class LoadedCheerio extends Cheerio {
      _make(selector, context) {
        const cheerio = initialize(selector, context);
        cheerio.prevObject = this;
        return cheerio;
      }
      _parse(content2, options2, isDocument3, context) {
        return parse6(content2, options2, isDocument3, context);
      }
      _render(dom) {
        return render3(dom, this.options);
      }
    }
    function initialize(selector, context, root3 = initialRoot, opts) {
      if (selector && isCheerio(selector))
        return selector;
      const options2 = {
        ...internalOpts,
        ...flatten(opts)
      };
      const r = typeof root3 === "string" ? [parse6(root3, options2, false, null)] : "length" in root3 ? root3 : [root3];
      const rootInstance = isCheerio(r) ? r : new LoadedCheerio(r, null, options2);
      rootInstance._root = rootInstance;
      if (!selector) {
        return new LoadedCheerio(void 0, rootInstance, options2);
      }
      const elements = typeof selector === "string" && isHtml(selector) ? (
        // $(<html>)
        parse6(selector, options2, false, null).children
      ) : isNode(selector) ? (
        // $(dom)
        [selector]
      ) : Array.isArray(selector) ? (
        // $([dom])
        selector
      ) : void 0;
      const instance = new LoadedCheerio(elements, rootInstance, options2);
      if (elements) {
        return instance;
      }
      if (typeof selector !== "string") {
        throw new Error("Unexpected type of selector");
      }
      let search = selector;
      const searchContext = !context ? (
        // If we don't have a context, maybe we have a root, from loading
        rootInstance
      ) : typeof context === "string" ? isHtml(context) ? (
        // $('li', '<ul>...</ul>')
        new LoadedCheerio([parse6(context, options2, false, null)], rootInstance, options2)
      ) : (
        // $('li', 'ul')
        (search = `${context} ${search}`, rootInstance)
      ) : isCheerio(context) ? (
        // $('li', $)
        context
      ) : (
        // $('li', node), $('li', [nodes])
        new LoadedCheerio(Array.isArray(context) ? context : [context], rootInstance, options2)
      );
      if (!searchContext)
        return instance;
      return searchContext.find(search);
    }
    Object.assign(initialize, static_exports, {
      load: load3,
      // `_root` and `_options` are used in static methods.
      _root: initialRoot,
      _options: internalOpts,
      // Add `fn` for plugins
      fn: LoadedCheerio.prototype,
      // Add the prototype here to maintain `instanceof` behavior.
      prototype: LoadedCheerio.prototype
    });
    return initialize;
  };
}
function isNode(obj) {
  return !!obj.name || obj.type === "root" || obj.type === "text" || obj.type === "comment";
}

// node_modules/.pnpm/parse5@7.1.2/node_modules/parse5/dist/common/unicode.js
var UNDEFINED_CODE_POINTS = /* @__PURE__ */ new Set([
  65534,
  65535,
  131070,
  131071,
  196606,
  196607,
  262142,
  262143,
  327678,
  327679,
  393214,
  393215,
  458750,
  458751,
  524286,
  524287,
  589822,
  589823,
  655358,
  655359,
  720894,
  720895,
  786430,
  786431,
  851966,
  851967,
  917502,
  917503,
  983038,
  983039,
  1048574,
  1048575,
  1114110,
  1114111
]);
var REPLACEMENT_CHARACTER = "�";
var CODE_POINTS;
(function(CODE_POINTS2) {
  CODE_POINTS2[CODE_POINTS2["EOF"] = -1] = "EOF";
  CODE_POINTS2[CODE_POINTS2["NULL"] = 0] = "NULL";
  CODE_POINTS2[CODE_POINTS2["TABULATION"] = 9] = "TABULATION";
  CODE_POINTS2[CODE_POINTS2["CARRIAGE_RETURN"] = 13] = "CARRIAGE_RETURN";
  CODE_POINTS2[CODE_POINTS2["LINE_FEED"] = 10] = "LINE_FEED";
  CODE_POINTS2[CODE_POINTS2["FORM_FEED"] = 12] = "FORM_FEED";
  CODE_POINTS2[CODE_POINTS2["SPACE"] = 32] = "SPACE";
  CODE_POINTS2[CODE_POINTS2["EXCLAMATION_MARK"] = 33] = "EXCLAMATION_MARK";
  CODE_POINTS2[CODE_POINTS2["QUOTATION_MARK"] = 34] = "QUOTATION_MARK";
  CODE_POINTS2[CODE_POINTS2["NUMBER_SIGN"] = 35] = "NUMBER_SIGN";
  CODE_POINTS2[CODE_POINTS2["AMPERSAND"] = 38] = "AMPERSAND";
  CODE_POINTS2[CODE_POINTS2["APOSTROPHE"] = 39] = "APOSTROPHE";
  CODE_POINTS2[CODE_POINTS2["HYPHEN_MINUS"] = 45] = "HYPHEN_MINUS";
  CODE_POINTS2[CODE_POINTS2["SOLIDUS"] = 47] = "SOLIDUS";
  CODE_POINTS2[CODE_POINTS2["DIGIT_0"] = 48] = "DIGIT_0";
  CODE_POINTS2[CODE_POINTS2["DIGIT_9"] = 57] = "DIGIT_9";
  CODE_POINTS2[CODE_POINTS2["SEMICOLON"] = 59] = "SEMICOLON";
  CODE_POINTS2[CODE_POINTS2["LESS_THAN_SIGN"] = 60] = "LESS_THAN_SIGN";
  CODE_POINTS2[CODE_POINTS2["EQUALS_SIGN"] = 61] = "EQUALS_SIGN";
  CODE_POINTS2[CODE_POINTS2["GREATER_THAN_SIGN"] = 62] = "GREATER_THAN_SIGN";
  CODE_POINTS2[CODE_POINTS2["QUESTION_MARK"] = 63] = "QUESTION_MARK";
  CODE_POINTS2[CODE_POINTS2["LATIN_CAPITAL_A"] = 65] = "LATIN_CAPITAL_A";
  CODE_POINTS2[CODE_POINTS2["LATIN_CAPITAL_F"] = 70] = "LATIN_CAPITAL_F";
  CODE_POINTS2[CODE_POINTS2["LATIN_CAPITAL_X"] = 88] = "LATIN_CAPITAL_X";
  CODE_POINTS2[CODE_POINTS2["LATIN_CAPITAL_Z"] = 90] = "LATIN_CAPITAL_Z";
  CODE_POINTS2[CODE_POINTS2["RIGHT_SQUARE_BRACKET"] = 93] = "RIGHT_SQUARE_BRACKET";
  CODE_POINTS2[CODE_POINTS2["GRAVE_ACCENT"] = 96] = "GRAVE_ACCENT";
  CODE_POINTS2[CODE_POINTS2["LATIN_SMALL_A"] = 97] = "LATIN_SMALL_A";
  CODE_POINTS2[CODE_POINTS2["LATIN_SMALL_F"] = 102] = "LATIN_SMALL_F";
  CODE_POINTS2[CODE_POINTS2["LATIN_SMALL_X"] = 120] = "LATIN_SMALL_X";
  CODE_POINTS2[CODE_POINTS2["LATIN_SMALL_Z"] = 122] = "LATIN_SMALL_Z";
  CODE_POINTS2[CODE_POINTS2["REPLACEMENT_CHARACTER"] = 65533] = "REPLACEMENT_CHARACTER";
})(CODE_POINTS = CODE_POINTS || (CODE_POINTS = {}));
var SEQUENCES = {
  DASH_DASH: "--",
  CDATA_START: "[CDATA[",
  DOCTYPE: "doctype",
  SCRIPT: "script",
  PUBLIC: "public",
  SYSTEM: "system"
};
function isSurrogate(cp) {
  return cp >= 55296 && cp <= 57343;
}
function isSurrogatePair(cp) {
  return cp >= 56320 && cp <= 57343;
}
function getSurrogatePairCodePoint(cp1, cp2) {
  return (cp1 - 55296) * 1024 + 9216 + cp2;
}
function isControlCodePoint(cp) {
  return cp !== 32 && cp !== 10 && cp !== 13 && cp !== 9 && cp !== 12 && cp >= 1 && cp <= 31 || cp >= 127 && cp <= 159;
}
function isUndefinedCodePoint(cp) {
  return cp >= 64976 && cp <= 65007 || UNDEFINED_CODE_POINTS.has(cp);
}

// node_modules/.pnpm/parse5@7.1.2/node_modules/parse5/dist/common/error-codes.js
var ERR;
(function(ERR2) {
  ERR2["controlCharacterInInputStream"] = "control-character-in-input-stream";
  ERR2["noncharacterInInputStream"] = "noncharacter-in-input-stream";
  ERR2["surrogateInInputStream"] = "surrogate-in-input-stream";
  ERR2["nonVoidHtmlElementStartTagWithTrailingSolidus"] = "non-void-html-element-start-tag-with-trailing-solidus";
  ERR2["endTagWithAttributes"] = "end-tag-with-attributes";
  ERR2["endTagWithTrailingSolidus"] = "end-tag-with-trailing-solidus";
  ERR2["unexpectedSolidusInTag"] = "unexpected-solidus-in-tag";
  ERR2["unexpectedNullCharacter"] = "unexpected-null-character";
  ERR2["unexpectedQuestionMarkInsteadOfTagName"] = "unexpected-question-mark-instead-of-tag-name";
  ERR2["invalidFirstCharacterOfTagName"] = "invalid-first-character-of-tag-name";
  ERR2["unexpectedEqualsSignBeforeAttributeName"] = "unexpected-equals-sign-before-attribute-name";
  ERR2["missingEndTagName"] = "missing-end-tag-name";
  ERR2["unexpectedCharacterInAttributeName"] = "unexpected-character-in-attribute-name";
  ERR2["unknownNamedCharacterReference"] = "unknown-named-character-reference";
  ERR2["missingSemicolonAfterCharacterReference"] = "missing-semicolon-after-character-reference";
  ERR2["unexpectedCharacterAfterDoctypeSystemIdentifier"] = "unexpected-character-after-doctype-system-identifier";
  ERR2["unexpectedCharacterInUnquotedAttributeValue"] = "unexpected-character-in-unquoted-attribute-value";
  ERR2["eofBeforeTagName"] = "eof-before-tag-name";
  ERR2["eofInTag"] = "eof-in-tag";
  ERR2["missingAttributeValue"] = "missing-attribute-value";
  ERR2["missingWhitespaceBetweenAttributes"] = "missing-whitespace-between-attributes";
  ERR2["missingWhitespaceAfterDoctypePublicKeyword"] = "missing-whitespace-after-doctype-public-keyword";
  ERR2["missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers"] = "missing-whitespace-between-doctype-public-and-system-identifiers";
  ERR2["missingWhitespaceAfterDoctypeSystemKeyword"] = "missing-whitespace-after-doctype-system-keyword";
  ERR2["missingQuoteBeforeDoctypePublicIdentifier"] = "missing-quote-before-doctype-public-identifier";
  ERR2["missingQuoteBeforeDoctypeSystemIdentifier"] = "missing-quote-before-doctype-system-identifier";
  ERR2["missingDoctypePublicIdentifier"] = "missing-doctype-public-identifier";
  ERR2["missingDoctypeSystemIdentifier"] = "missing-doctype-system-identifier";
  ERR2["abruptDoctypePublicIdentifier"] = "abrupt-doctype-public-identifier";
  ERR2["abruptDoctypeSystemIdentifier"] = "abrupt-doctype-system-identifier";
  ERR2["cdataInHtmlContent"] = "cdata-in-html-content";
  ERR2["incorrectlyOpenedComment"] = "incorrectly-opened-comment";
  ERR2["eofInScriptHtmlCommentLikeText"] = "eof-in-script-html-comment-like-text";
  ERR2["eofInDoctype"] = "eof-in-doctype";
  ERR2["nestedComment"] = "nested-comment";
  ERR2["abruptClosingOfEmptyComment"] = "abrupt-closing-of-empty-comment";
  ERR2["eofInComment"] = "eof-in-comment";
  ERR2["incorrectlyClosedComment"] = "incorrectly-closed-comment";
  ERR2["eofInCdata"] = "eof-in-cdata";
  ERR2["absenceOfDigitsInNumericCharacterReference"] = "absence-of-digits-in-numeric-character-reference";
  ERR2["nullCharacterReference"] = "null-character-reference";
  ERR2["surrogateCharacterReference"] = "surrogate-character-reference";
  ERR2["characterReferenceOutsideUnicodeRange"] = "character-reference-outside-unicode-range";
  ERR2["controlCharacterReference"] = "control-character-reference";
  ERR2["noncharacterCharacterReference"] = "noncharacter-character-reference";
  ERR2["missingWhitespaceBeforeDoctypeName"] = "missing-whitespace-before-doctype-name";
  ERR2["missingDoctypeName"] = "missing-doctype-name";
  ERR2["invalidCharacterSequenceAfterDoctypeName"] = "invalid-character-sequence-after-doctype-name";
  ERR2["duplicateAttribute"] = "duplicate-attribute";
  ERR2["nonConformingDoctype"] = "non-conforming-doctype";
  ERR2["missingDoctype"] = "missing-doctype";
  ERR2["misplacedDoctype"] = "misplaced-doctype";
  ERR2["endTagWithoutMatchingOpenElement"] = "end-tag-without-matching-open-element";
  ERR2["closingOfElementWithOpenChildElements"] = "closing-of-element-with-open-child-elements";
  ERR2["disallowedContentInNoscriptInHead"] = "disallowed-content-in-noscript-in-head";
  ERR2["openElementsLeftAfterEof"] = "open-elements-left-after-eof";
  ERR2["abandonedHeadElementChild"] = "abandoned-head-element-child";
  ERR2["misplacedStartTagForHeadElement"] = "misplaced-start-tag-for-head-element";
  ERR2["nestedNoscriptInHead"] = "nested-noscript-in-head";
  ERR2["eofInElementThatCanContainOnlyText"] = "eof-in-element-that-can-contain-only-text";
})(ERR = ERR || (ERR = {}));

// node_modules/.pnpm/parse5@7.1.2/node_modules/parse5/dist/tokenizer/preprocessor.js
var DEFAULT_BUFFER_WATERLINE = 1 << 16;
var Preprocessor = class {
  constructor(handler) {
    this.handler = handler;
    this.html = "";
    this.pos = -1;
    this.lastGapPos = -2;
    this.gapStack = [];
    this.skipNextNewLine = false;
    this.lastChunkWritten = false;
    this.endOfChunkHit = false;
    this.bufferWaterline = DEFAULT_BUFFER_WATERLINE;
    this.isEol = false;
    this.lineStartPos = 0;
    this.droppedBufferSize = 0;
    this.line = 1;
    this.lastErrOffset = -1;
  }
  /** The column on the current line. If we just saw a gap (eg. a surrogate pair), return the index before. */
  get col() {
    return this.pos - this.lineStartPos + Number(this.lastGapPos !== this.pos);
  }
  get offset() {
    return this.droppedBufferSize + this.pos;
  }
  getError(code2) {
    const { line, col, offset } = this;
    return {
      code: code2,
      startLine: line,
      endLine: line,
      startCol: col,
      endCol: col,
      startOffset: offset,
      endOffset: offset
    };
  }
  _err(code2) {
    if (this.handler.onParseError && this.lastErrOffset !== this.offset) {
      this.lastErrOffset = this.offset;
      this.handler.onParseError(this.getError(code2));
    }
  }
  _addGap() {
    this.gapStack.push(this.lastGapPos);
    this.lastGapPos = this.pos;
  }
  _processSurrogate(cp) {
    if (this.pos !== this.html.length - 1) {
      const nextCp = this.html.charCodeAt(this.pos + 1);
      if (isSurrogatePair(nextCp)) {
        this.pos++;
        this._addGap();
        return getSurrogatePairCodePoint(cp, nextCp);
      }
    } else if (!this.lastChunkWritten) {
      this.endOfChunkHit = true;
      return CODE_POINTS.EOF;
    }
    this._err(ERR.surrogateInInputStream);
    return cp;
  }
  willDropParsedChunk() {
    return this.pos > this.bufferWaterline;
  }
  dropParsedChunk() {
    if (this.willDropParsedChunk()) {
      this.html = this.html.substring(this.pos);
      this.lineStartPos -= this.pos;
      this.droppedBufferSize += this.pos;
      this.pos = 0;
      this.lastGapPos = -2;
      this.gapStack.length = 0;
    }
  }
  write(chunk, isLastChunk) {
    if (this.html.length > 0) {
      this.html += chunk;
    } else {
      this.html = chunk;
    }
    this.endOfChunkHit = false;
    this.lastChunkWritten = isLastChunk;
  }
  insertHtmlAtCurrentPos(chunk) {
    this.html = this.html.substring(0, this.pos + 1) + chunk + this.html.substring(this.pos + 1);
    this.endOfChunkHit = false;
  }
  startsWith(pattern, caseSensitive) {
    if (this.pos + pattern.length > this.html.length) {
      this.endOfChunkHit = !this.lastChunkWritten;
      return false;
    }
    if (caseSensitive) {
      return this.html.startsWith(pattern, this.pos);
    }
    for (let i = 0; i < pattern.length; i++) {
      const cp = this.html.charCodeAt(this.pos + i) | 32;
      if (cp !== pattern.charCodeAt(i)) {
        return false;
      }
    }
    return true;
  }
  peek(offset) {
    const pos = this.pos + offset;
    if (pos >= this.html.length) {
      this.endOfChunkHit = !this.lastChunkWritten;
      return CODE_POINTS.EOF;
    }
    const code2 = this.html.charCodeAt(pos);
    return code2 === CODE_POINTS.CARRIAGE_RETURN ? CODE_POINTS.LINE_FEED : code2;
  }
  advance() {
    this.pos++;
    if (this.isEol) {
      this.isEol = false;
      this.line++;
      this.lineStartPos = this.pos;
    }
    if (this.pos >= this.html.length) {
      this.endOfChunkHit = !this.lastChunkWritten;
      return CODE_POINTS.EOF;
    }
    let cp = this.html.charCodeAt(this.pos);
    if (cp === CODE_POINTS.CARRIAGE_RETURN) {
      this.isEol = true;
      this.skipNextNewLine = true;
      return CODE_POINTS.LINE_FEED;
    }
    if (cp === CODE_POINTS.LINE_FEED) {
      this.isEol = true;
      if (this.skipNextNewLine) {
        this.line--;
        this.skipNextNewLine = false;
        this._addGap();
        return this.advance();
      }
    }
    this.skipNextNewLine = false;
    if (isSurrogate(cp)) {
      cp = this._processSurrogate(cp);
    }
    const isCommonValidRange = this.handler.onParseError === null || cp > 31 && cp < 127 || cp === CODE_POINTS.LINE_FEED || cp === CODE_POINTS.CARRIAGE_RETURN || cp > 159 && cp < 64976;
    if (!isCommonValidRange) {
      this._checkForProblematicCharacters(cp);
    }
    return cp;
  }
  _checkForProblematicCharacters(cp) {
    if (isControlCodePoint(cp)) {
      this._err(ERR.controlCharacterInInputStream);
    } else if (isUndefinedCodePoint(cp)) {
      this._err(ERR.noncharacterInInputStream);
    }
  }
  retreat(count) {
    this.pos -= count;
    while (this.pos < this.lastGapPos) {
      this.lastGapPos = this.gapStack.pop();
      this.pos--;
    }
    this.isEol = false;
  }
};

// node_modules/.pnpm/parse5@7.1.2/node_modules/parse5/dist/common/token.js
var token_exports = {};
__export(token_exports, {
  TokenType: () => TokenType,
  getTokenAttr: () => getTokenAttr
});
var TokenType;
(function(TokenType2) {
  TokenType2[TokenType2["CHARACTER"] = 0] = "CHARACTER";
  TokenType2[TokenType2["NULL_CHARACTER"] = 1] = "NULL_CHARACTER";
  TokenType2[TokenType2["WHITESPACE_CHARACTER"] = 2] = "WHITESPACE_CHARACTER";
  TokenType2[TokenType2["START_TAG"] = 3] = "START_TAG";
  TokenType2[TokenType2["END_TAG"] = 4] = "END_TAG";
  TokenType2[TokenType2["COMMENT"] = 5] = "COMMENT";
  TokenType2[TokenType2["DOCTYPE"] = 6] = "DOCTYPE";
  TokenType2[TokenType2["EOF"] = 7] = "EOF";
  TokenType2[TokenType2["HIBERNATION"] = 8] = "HIBERNATION";
})(TokenType = TokenType || (TokenType = {}));
function getTokenAttr(token, attrName) {
  for (let i = token.attrs.length - 1; i >= 0; i--) {
    if (token.attrs[i].name === attrName) {
      return token.attrs[i].value;
    }
  }
  return null;
}

// node_modules/.pnpm/parse5@7.1.2/node_modules/parse5/dist/common/html.js
var html_exports = {};
__export(html_exports, {
  ATTRS: () => ATTRS,
  DOCUMENT_MODE: () => DOCUMENT_MODE,
  NS: () => NS,
  SPECIAL_ELEMENTS: () => SPECIAL_ELEMENTS,
  TAG_ID: () => TAG_ID,
  TAG_NAMES: () => TAG_NAMES,
  getTagID: () => getTagID,
  hasUnescapedText: () => hasUnescapedText,
  isNumberedHeader: () => isNumberedHeader
});
var NS;
(function(NS2) {
  NS2["HTML"] = "http://www.w3.org/1999/xhtml";
  NS2["MATHML"] = "http://www.w3.org/1998/Math/MathML";
  NS2["SVG"] = "http://www.w3.org/2000/svg";
  NS2["XLINK"] = "http://www.w3.org/1999/xlink";
  NS2["XML"] = "http://www.w3.org/XML/1998/namespace";
  NS2["XMLNS"] = "http://www.w3.org/2000/xmlns/";
})(NS = NS || (NS = {}));
var ATTRS;
(function(ATTRS2) {
  ATTRS2["TYPE"] = "type";
  ATTRS2["ACTION"] = "action";
  ATTRS2["ENCODING"] = "encoding";
  ATTRS2["PROMPT"] = "prompt";
  ATTRS2["NAME"] = "name";
  ATTRS2["COLOR"] = "color";
  ATTRS2["FACE"] = "face";
  ATTRS2["SIZE"] = "size";
})(ATTRS = ATTRS || (ATTRS = {}));
var DOCUMENT_MODE;
(function(DOCUMENT_MODE2) {
  DOCUMENT_MODE2["NO_QUIRKS"] = "no-quirks";
  DOCUMENT_MODE2["QUIRKS"] = "quirks";
  DOCUMENT_MODE2["LIMITED_QUIRKS"] = "limited-quirks";
})(DOCUMENT_MODE = DOCUMENT_MODE || (DOCUMENT_MODE = {}));
var TAG_NAMES;
(function(TAG_NAMES2) {
  TAG_NAMES2["A"] = "a";
  TAG_NAMES2["ADDRESS"] = "address";
  TAG_NAMES2["ANNOTATION_XML"] = "annotation-xml";
  TAG_NAMES2["APPLET"] = "applet";
  TAG_NAMES2["AREA"] = "area";
  TAG_NAMES2["ARTICLE"] = "article";
  TAG_NAMES2["ASIDE"] = "aside";
  TAG_NAMES2["B"] = "b";
  TAG_NAMES2["BASE"] = "base";
  TAG_NAMES2["BASEFONT"] = "basefont";
  TAG_NAMES2["BGSOUND"] = "bgsound";
  TAG_NAMES2["BIG"] = "big";
  TAG_NAMES2["BLOCKQUOTE"] = "blockquote";
  TAG_NAMES2["BODY"] = "body";
  TAG_NAMES2["BR"] = "br";
  TAG_NAMES2["BUTTON"] = "button";
  TAG_NAMES2["CAPTION"] = "caption";
  TAG_NAMES2["CENTER"] = "center";
  TAG_NAMES2["CODE"] = "code";
  TAG_NAMES2["COL"] = "col";
  TAG_NAMES2["COLGROUP"] = "colgroup";
  TAG_NAMES2["DD"] = "dd";
  TAG_NAMES2["DESC"] = "desc";
  TAG_NAMES2["DETAILS"] = "details";
  TAG_NAMES2["DIALOG"] = "dialog";
  TAG_NAMES2["DIR"] = "dir";
  TAG_NAMES2["DIV"] = "div";
  TAG_NAMES2["DL"] = "dl";
  TAG_NAMES2["DT"] = "dt";
  TAG_NAMES2["EM"] = "em";
  TAG_NAMES2["EMBED"] = "embed";
  TAG_NAMES2["FIELDSET"] = "fieldset";
  TAG_NAMES2["FIGCAPTION"] = "figcaption";
  TAG_NAMES2["FIGURE"] = "figure";
  TAG_NAMES2["FONT"] = "font";
  TAG_NAMES2["FOOTER"] = "footer";
  TAG_NAMES2["FOREIGN_OBJECT"] = "foreignObject";
  TAG_NAMES2["FORM"] = "form";
  TAG_NAMES2["FRAME"] = "frame";
  TAG_NAMES2["FRAMESET"] = "frameset";
  TAG_NAMES2["H1"] = "h1";
  TAG_NAMES2["H2"] = "h2";
  TAG_NAMES2["H3"] = "h3";
  TAG_NAMES2["H4"] = "h4";
  TAG_NAMES2["H5"] = "h5";
  TAG_NAMES2["H6"] = "h6";
  TAG_NAMES2["HEAD"] = "head";
  TAG_NAMES2["HEADER"] = "header";
  TAG_NAMES2["HGROUP"] = "hgroup";
  TAG_NAMES2["HR"] = "hr";
  TAG_NAMES2["HTML"] = "html";
  TAG_NAMES2["I"] = "i";
  TAG_NAMES2["IMG"] = "img";
  TAG_NAMES2["IMAGE"] = "image";
  TAG_NAMES2["INPUT"] = "input";
  TAG_NAMES2["IFRAME"] = "iframe";
  TAG_NAMES2["KEYGEN"] = "keygen";
  TAG_NAMES2["LABEL"] = "label";
  TAG_NAMES2["LI"] = "li";
  TAG_NAMES2["LINK"] = "link";
  TAG_NAMES2["LISTING"] = "listing";
  TAG_NAMES2["MAIN"] = "main";
  TAG_NAMES2["MALIGNMARK"] = "malignmark";
  TAG_NAMES2["MARQUEE"] = "marquee";
  TAG_NAMES2["MATH"] = "math";
  TAG_NAMES2["MENU"] = "menu";
  TAG_NAMES2["META"] = "meta";
  TAG_NAMES2["MGLYPH"] = "mglyph";
  TAG_NAMES2["MI"] = "mi";
  TAG_NAMES2["MO"] = "mo";
  TAG_NAMES2["MN"] = "mn";
  TAG_NAMES2["MS"] = "ms";
  TAG_NAMES2["MTEXT"] = "mtext";
  TAG_NAMES2["NAV"] = "nav";
  TAG_NAMES2["NOBR"] = "nobr";
  TAG_NAMES2["NOFRAMES"] = "noframes";
  TAG_NAMES2["NOEMBED"] = "noembed";
  TAG_NAMES2["NOSCRIPT"] = "noscript";
  TAG_NAMES2["OBJECT"] = "object";
  TAG_NAMES2["OL"] = "ol";
  TAG_NAMES2["OPTGROUP"] = "optgroup";
  TAG_NAMES2["OPTION"] = "option";
  TAG_NAMES2["P"] = "p";
  TAG_NAMES2["PARAM"] = "param";
  TAG_NAMES2["PLAINTEXT"] = "plaintext";
  TAG_NAMES2["PRE"] = "pre";
  TAG_NAMES2["RB"] = "rb";
  TAG_NAMES2["RP"] = "rp";
  TAG_NAMES2["RT"] = "rt";
  TAG_NAMES2["RTC"] = "rtc";
  TAG_NAMES2["RUBY"] = "ruby";
  TAG_NAMES2["S"] = "s";
  TAG_NAMES2["SCRIPT"] = "script";
  TAG_NAMES2["SECTION"] = "section";
  TAG_NAMES2["SELECT"] = "select";
  TAG_NAMES2["SOURCE"] = "source";
  TAG_NAMES2["SMALL"] = "small";
  TAG_NAMES2["SPAN"] = "span";
  TAG_NAMES2["STRIKE"] = "strike";
  TAG_NAMES2["STRONG"] = "strong";
  TAG_NAMES2["STYLE"] = "style";
  TAG_NAMES2["SUB"] = "sub";
  TAG_NAMES2["SUMMARY"] = "summary";
  TAG_NAMES2["SUP"] = "sup";
  TAG_NAMES2["TABLE"] = "table";
  TAG_NAMES2["TBODY"] = "tbody";
  TAG_NAMES2["TEMPLATE"] = "template";
  TAG_NAMES2["TEXTAREA"] = "textarea";
  TAG_NAMES2["TFOOT"] = "tfoot";
  TAG_NAMES2["TD"] = "td";
  TAG_NAMES2["TH"] = "th";
  TAG_NAMES2["THEAD"] = "thead";
  TAG_NAMES2["TITLE"] = "title";
  TAG_NAMES2["TR"] = "tr";
  TAG_NAMES2["TRACK"] = "track";
  TAG_NAMES2["TT"] = "tt";
  TAG_NAMES2["U"] = "u";
  TAG_NAMES2["UL"] = "ul";
  TAG_NAMES2["SVG"] = "svg";
  TAG_NAMES2["VAR"] = "var";
  TAG_NAMES2["WBR"] = "wbr";
  TAG_NAMES2["XMP"] = "xmp";
})(TAG_NAMES = TAG_NAMES || (TAG_NAMES = {}));
var TAG_ID;
(function(TAG_ID2) {
  TAG_ID2[TAG_ID2["UNKNOWN"] = 0] = "UNKNOWN";
  TAG_ID2[TAG_ID2["A"] = 1] = "A";
  TAG_ID2[TAG_ID2["ADDRESS"] = 2] = "ADDRESS";
  TAG_ID2[TAG_ID2["ANNOTATION_XML"] = 3] = "ANNOTATION_XML";
  TAG_ID2[TAG_ID2["APPLET"] = 4] = "APPLET";
  TAG_ID2[TAG_ID2["AREA"] = 5] = "AREA";
  TAG_ID2[TAG_ID2["ARTICLE"] = 6] = "ARTICLE";
  TAG_ID2[TAG_ID2["ASIDE"] = 7] = "ASIDE";
  TAG_ID2[TAG_ID2["B"] = 8] = "B";
  TAG_ID2[TAG_ID2["BASE"] = 9] = "BASE";
  TAG_ID2[TAG_ID2["BASEFONT"] = 10] = "BASEFONT";
  TAG_ID2[TAG_ID2["BGSOUND"] = 11] = "BGSOUND";
  TAG_ID2[TAG_ID2["BIG"] = 12] = "BIG";
  TAG_ID2[TAG_ID2["BLOCKQUOTE"] = 13] = "BLOCKQUOTE";
  TAG_ID2[TAG_ID2["BODY"] = 14] = "BODY";
  TAG_ID2[TAG_ID2["BR"] = 15] = "BR";
  TAG_ID2[TAG_ID2["BUTTON"] = 16] = "BUTTON";
  TAG_ID2[TAG_ID2["CAPTION"] = 17] = "CAPTION";
  TAG_ID2[TAG_ID2["CENTER"] = 18] = "CENTER";
  TAG_ID2[TAG_ID2["CODE"] = 19] = "CODE";
  TAG_ID2[TAG_ID2["COL"] = 20] = "COL";
  TAG_ID2[TAG_ID2["COLGROUP"] = 21] = "COLGROUP";
  TAG_ID2[TAG_ID2["DD"] = 22] = "DD";
  TAG_ID2[TAG_ID2["DESC"] = 23] = "DESC";
  TAG_ID2[TAG_ID2["DETAILS"] = 24] = "DETAILS";
  TAG_ID2[TAG_ID2["DIALOG"] = 25] = "DIALOG";
  TAG_ID2[TAG_ID2["DIR"] = 26] = "DIR";
  TAG_ID2[TAG_ID2["DIV"] = 27] = "DIV";
  TAG_ID2[TAG_ID2["DL"] = 28] = "DL";
  TAG_ID2[TAG_ID2["DT"] = 29] = "DT";
  TAG_ID2[TAG_ID2["EM"] = 30] = "EM";
  TAG_ID2[TAG_ID2["EMBED"] = 31] = "EMBED";
  TAG_ID2[TAG_ID2["FIELDSET"] = 32] = "FIELDSET";
  TAG_ID2[TAG_ID2["FIGCAPTION"] = 33] = "FIGCAPTION";
  TAG_ID2[TAG_ID2["FIGURE"] = 34] = "FIGURE";
  TAG_ID2[TAG_ID2["FONT"] = 35] = "FONT";
  TAG_ID2[TAG_ID2["FOOTER"] = 36] = "FOOTER";
  TAG_ID2[TAG_ID2["FOREIGN_OBJECT"] = 37] = "FOREIGN_OBJECT";
  TAG_ID2[TAG_ID2["FORM"] = 38] = "FORM";
  TAG_ID2[TAG_ID2["FRAME"] = 39] = "FRAME";
  TAG_ID2[TAG_ID2["FRAMESET"] = 40] = "FRAMESET";
  TAG_ID2[TAG_ID2["H1"] = 41] = "H1";
  TAG_ID2[TAG_ID2["H2"] = 42] = "H2";
  TAG_ID2[TAG_ID2["H3"] = 43] = "H3";
  TAG_ID2[TAG_ID2["H4"] = 44] = "H4";
  TAG_ID2[TAG_ID2["H5"] = 45] = "H5";
  TAG_ID2[TAG_ID2["H6"] = 46] = "H6";
  TAG_ID2[TAG_ID2["HEAD"] = 47] = "HEAD";
  TAG_ID2[TAG_ID2["HEADER"] = 48] = "HEADER";
  TAG_ID2[TAG_ID2["HGROUP"] = 49] = "HGROUP";
  TAG_ID2[TAG_ID2["HR"] = 50] = "HR";
  TAG_ID2[TAG_ID2["HTML"] = 51] = "HTML";
  TAG_ID2[TAG_ID2["I"] = 52] = "I";
  TAG_ID2[TAG_ID2["IMG"] = 53] = "IMG";
  TAG_ID2[TAG_ID2["IMAGE"] = 54] = "IMAGE";
  TAG_ID2[TAG_ID2["INPUT"] = 55] = "INPUT";
  TAG_ID2[TAG_ID2["IFRAME"] = 56] = "IFRAME";
  TAG_ID2[TAG_ID2["KEYGEN"] = 57] = "KEYGEN";
  TAG_ID2[TAG_ID2["LABEL"] = 58] = "LABEL";
  TAG_ID2[TAG_ID2["LI"] = 59] = "LI";
  TAG_ID2[TAG_ID2["LINK"] = 60] = "LINK";
  TAG_ID2[TAG_ID2["LISTING"] = 61] = "LISTING";
  TAG_ID2[TAG_ID2["MAIN"] = 62] = "MAIN";
  TAG_ID2[TAG_ID2["MALIGNMARK"] = 63] = "MALIGNMARK";
  TAG_ID2[TAG_ID2["MARQUEE"] = 64] = "MARQUEE";
  TAG_ID2[TAG_ID2["MATH"] = 65] = "MATH";
  TAG_ID2[TAG_ID2["MENU"] = 66] = "MENU";
  TAG_ID2[TAG_ID2["META"] = 67] = "META";
  TAG_ID2[TAG_ID2["MGLYPH"] = 68] = "MGLYPH";
  TAG_ID2[TAG_ID2["MI"] = 69] = "MI";
  TAG_ID2[TAG_ID2["MO"] = 70] = "MO";
  TAG_ID2[TAG_ID2["MN"] = 71] = "MN";
  TAG_ID2[TAG_ID2["MS"] = 72] = "MS";
  TAG_ID2[TAG_ID2["MTEXT"] = 73] = "MTEXT";
  TAG_ID2[TAG_ID2["NAV"] = 74] = "NAV";
  TAG_ID2[TAG_ID2["NOBR"] = 75] = "NOBR";
  TAG_ID2[TAG_ID2["NOFRAMES"] = 76] = "NOFRAMES";
  TAG_ID2[TAG_ID2["NOEMBED"] = 77] = "NOEMBED";
  TAG_ID2[TAG_ID2["NOSCRIPT"] = 78] = "NOSCRIPT";
  TAG_ID2[TAG_ID2["OBJECT"] = 79] = "OBJECT";
  TAG_ID2[TAG_ID2["OL"] = 80] = "OL";
  TAG_ID2[TAG_ID2["OPTGROUP"] = 81] = "OPTGROUP";
  TAG_ID2[TAG_ID2["OPTION"] = 82] = "OPTION";
  TAG_ID2[TAG_ID2["P"] = 83] = "P";
  TAG_ID2[TAG_ID2["PARAM"] = 84] = "PARAM";
  TAG_ID2[TAG_ID2["PLAINTEXT"] = 85] = "PLAINTEXT";
  TAG_ID2[TAG_ID2["PRE"] = 86] = "PRE";
  TAG_ID2[TAG_ID2["RB"] = 87] = "RB";
  TAG_ID2[TAG_ID2["RP"] = 88] = "RP";
  TAG_ID2[TAG_ID2["RT"] = 89] = "RT";
  TAG_ID2[TAG_ID2["RTC"] = 90] = "RTC";
  TAG_ID2[TAG_ID2["RUBY"] = 91] = "RUBY";
  TAG_ID2[TAG_ID2["S"] = 92] = "S";
  TAG_ID2[TAG_ID2["SCRIPT"] = 93] = "SCRIPT";
  TAG_ID2[TAG_ID2["SECTION"] = 94] = "SECTION";
  TAG_ID2[TAG_ID2["SELECT"] = 95] = "SELECT";
  TAG_ID2[TAG_ID2["SOURCE"] = 96] = "SOURCE";
  TAG_ID2[TAG_ID2["SMALL"] = 97] = "SMALL";
  TAG_ID2[TAG_ID2["SPAN"] = 98] = "SPAN";
  TAG_ID2[TAG_ID2["STRIKE"] = 99] = "STRIKE";
  TAG_ID2[TAG_ID2["STRONG"] = 100] = "STRONG";
  TAG_ID2[TAG_ID2["STYLE"] = 101] = "STYLE";
  TAG_ID2[TAG_ID2["SUB"] = 102] = "SUB";
  TAG_ID2[TAG_ID2["SUMMARY"] = 103] = "SUMMARY";
  TAG_ID2[TAG_ID2["SUP"] = 104] = "SUP";
  TAG_ID2[TAG_ID2["TABLE"] = 105] = "TABLE";
  TAG_ID2[TAG_ID2["TBODY"] = 106] = "TBODY";
  TAG_ID2[TAG_ID2["TEMPLATE"] = 107] = "TEMPLATE";
  TAG_ID2[TAG_ID2["TEXTAREA"] = 108] = "TEXTAREA";
  TAG_ID2[TAG_ID2["TFOOT"] = 109] = "TFOOT";
  TAG_ID2[TAG_ID2["TD"] = 110] = "TD";
  TAG_ID2[TAG_ID2["TH"] = 111] = "TH";
  TAG_ID2[TAG_ID2["THEAD"] = 112] = "THEAD";
  TAG_ID2[TAG_ID2["TITLE"] = 113] = "TITLE";
  TAG_ID2[TAG_ID2["TR"] = 114] = "TR";
  TAG_ID2[TAG_ID2["TRACK"] = 115] = "TRACK";
  TAG_ID2[TAG_ID2["TT"] = 116] = "TT";
  TAG_ID2[TAG_ID2["U"] = 117] = "U";
  TAG_ID2[TAG_ID2["UL"] = 118] = "UL";
  TAG_ID2[TAG_ID2["SVG"] = 119] = "SVG";
  TAG_ID2[TAG_ID2["VAR"] = 120] = "VAR";
  TAG_ID2[TAG_ID2["WBR"] = 121] = "WBR";
  TAG_ID2[TAG_ID2["XMP"] = 122] = "XMP";
})(TAG_ID = TAG_ID || (TAG_ID = {}));
var TAG_NAME_TO_ID = /* @__PURE__ */ new Map([
  [TAG_NAMES.A, TAG_ID.A],
  [TAG_NAMES.ADDRESS, TAG_ID.ADDRESS],
  [TAG_NAMES.ANNOTATION_XML, TAG_ID.ANNOTATION_XML],
  [TAG_NAMES.APPLET, TAG_ID.APPLET],
  [TAG_NAMES.AREA, TAG_ID.AREA],
  [TAG_NAMES.ARTICLE, TAG_ID.ARTICLE],
  [TAG_NAMES.ASIDE, TAG_ID.ASIDE],
  [TAG_NAMES.B, TAG_ID.B],
  [TAG_NAMES.BASE, TAG_ID.BASE],
  [TAG_NAMES.BASEFONT, TAG_ID.BASEFONT],
  [TAG_NAMES.BGSOUND, TAG_ID.BGSOUND],
  [TAG_NAMES.BIG, TAG_ID.BIG],
  [TAG_NAMES.BLOCKQUOTE, TAG_ID.BLOCKQUOTE],
  [TAG_NAMES.BODY, TAG_ID.BODY],
  [TAG_NAMES.BR, TAG_ID.BR],
  [TAG_NAMES.BUTTON, TAG_ID.BUTTON],
  [TAG_NAMES.CAPTION, TAG_ID.CAPTION],
  [TAG_NAMES.CENTER, TAG_ID.CENTER],
  [TAG_NAMES.CODE, TAG_ID.CODE],
  [TAG_NAMES.COL, TAG_ID.COL],
  [TAG_NAMES.COLGROUP, TAG_ID.COLGROUP],
  [TAG_NAMES.DD, TAG_ID.DD],
  [TAG_NAMES.DESC, TAG_ID.DESC],
  [TAG_NAMES.DETAILS, TAG_ID.DETAILS],
  [TAG_NAMES.DIALOG, TAG_ID.DIALOG],
  [TAG_NAMES.DIR, TAG_ID.DIR],
  [TAG_NAMES.DIV, TAG_ID.DIV],
  [TAG_NAMES.DL, TAG_ID.DL],
  [TAG_NAMES.DT, TAG_ID.DT],
  [TAG_NAMES.EM, TAG_ID.EM],
  [TAG_NAMES.EMBED, TAG_ID.EMBED],
  [TAG_NAMES.FIELDSET, TAG_ID.FIELDSET],
  [TAG_NAMES.FIGCAPTION, TAG_ID.FIGCAPTION],
  [TAG_NAMES.FIGURE, TAG_ID.FIGURE],
  [TAG_NAMES.FONT, TAG_ID.FONT],
  [TAG_NAMES.FOOTER, TAG_ID.FOOTER],
  [TAG_NAMES.FOREIGN_OBJECT, TAG_ID.FOREIGN_OBJECT],
  [TAG_NAMES.FORM, TAG_ID.FORM],
  [TAG_NAMES.FRAME, TAG_ID.FRAME],
  [TAG_NAMES.FRAMESET, TAG_ID.FRAMESET],
  [TAG_NAMES.H1, TAG_ID.H1],
  [TAG_NAMES.H2, TAG_ID.H2],
  [TAG_NAMES.H3, TAG_ID.H3],
  [TAG_NAMES.H4, TAG_ID.H4],
  [TAG_NAMES.H5, TAG_ID.H5],
  [TAG_NAMES.H6, TAG_ID.H6],
  [TAG_NAMES.HEAD, TAG_ID.HEAD],
  [TAG_NAMES.HEADER, TAG_ID.HEADER],
  [TAG_NAMES.HGROUP, TAG_ID.HGROUP],
  [TAG_NAMES.HR, TAG_ID.HR],
  [TAG_NAMES.HTML, TAG_ID.HTML],
  [TAG_NAMES.I, TAG_ID.I],
  [TAG_NAMES.IMG, TAG_ID.IMG],
  [TAG_NAMES.IMAGE, TAG_ID.IMAGE],
  [TAG_NAMES.INPUT, TAG_ID.INPUT],
  [TAG_NAMES.IFRAME, TAG_ID.IFRAME],
  [TAG_NAMES.KEYGEN, TAG_ID.KEYGEN],
  [TAG_NAMES.LABEL, TAG_ID.LABEL],
  [TAG_NAMES.LI, TAG_ID.LI],
  [TAG_NAMES.LINK, TAG_ID.LINK],
  [TAG_NAMES.LISTING, TAG_ID.LISTING],
  [TAG_NAMES.MAIN, TAG_ID.MAIN],
  [TAG_NAMES.MALIGNMARK, TAG_ID.MALIGNMARK],
  [TAG_NAMES.MARQUEE, TAG_ID.MARQUEE],
  [TAG_NAMES.MATH, TAG_ID.MATH],
  [TAG_NAMES.MENU, TAG_ID.MENU],
  [TAG_NAMES.META, TAG_ID.META],
  [TAG_NAMES.MGLYPH, TAG_ID.MGLYPH],
  [TAG_NAMES.MI, TAG_ID.MI],
  [TAG_NAMES.MO, TAG_ID.MO],
  [TAG_NAMES.MN, TAG_ID.MN],
  [TAG_NAMES.MS, TAG_ID.MS],
  [TAG_NAMES.MTEXT, TAG_ID.MTEXT],
  [TAG_NAMES.NAV, TAG_ID.NAV],
  [TAG_NAMES.NOBR, TAG_ID.NOBR],
  [TAG_NAMES.NOFRAMES, TAG_ID.NOFRAMES],
  [TAG_NAMES.NOEMBED, TAG_ID.NOEMBED],
  [TAG_NAMES.NOSCRIPT, TAG_ID.NOSCRIPT],
  [TAG_NAMES.OBJECT, TAG_ID.OBJECT],
  [TAG_NAMES.OL, TAG_ID.OL],
  [TAG_NAMES.OPTGROUP, TAG_ID.OPTGROUP],
  [TAG_NAMES.OPTION, TAG_ID.OPTION],
  [TAG_NAMES.P, TAG_ID.P],
  [TAG_NAMES.PARAM, TAG_ID.PARAM],
  [TAG_NAMES.PLAINTEXT, TAG_ID.PLAINTEXT],
  [TAG_NAMES.PRE, TAG_ID.PRE],
  [TAG_NAMES.RB, TAG_ID.RB],
  [TAG_NAMES.RP, TAG_ID.RP],
  [TAG_NAMES.RT, TAG_ID.RT],
  [TAG_NAMES.RTC, TAG_ID.RTC],
  [TAG_NAMES.RUBY, TAG_ID.RUBY],
  [TAG_NAMES.S, TAG_ID.S],
  [TAG_NAMES.SCRIPT, TAG_ID.SCRIPT],
  [TAG_NAMES.SECTION, TAG_ID.SECTION],
  [TAG_NAMES.SELECT, TAG_ID.SELECT],
  [TAG_NAMES.SOURCE, TAG_ID.SOURCE],
  [TAG_NAMES.SMALL, TAG_ID.SMALL],
  [TAG_NAMES.SPAN, TAG_ID.SPAN],
  [TAG_NAMES.STRIKE, TAG_ID.STRIKE],
  [TAG_NAMES.STRONG, TAG_ID.STRONG],
  [TAG_NAMES.STYLE, TAG_ID.STYLE],
  [TAG_NAMES.SUB, TAG_ID.SUB],
  [TAG_NAMES.SUMMARY, TAG_ID.SUMMARY],
  [TAG_NAMES.SUP, TAG_ID.SUP],
  [TAG_NAMES.TABLE, TAG_ID.TABLE],
  [TAG_NAMES.TBODY, TAG_ID.TBODY],
  [TAG_NAMES.TEMPLATE, TAG_ID.TEMPLATE],
  [TAG_NAMES.TEXTAREA, TAG_ID.TEXTAREA],
  [TAG_NAMES.TFOOT, TAG_ID.TFOOT],
  [TAG_NAMES.TD, TAG_ID.TD],
  [TAG_NAMES.TH, TAG_ID.TH],
  [TAG_NAMES.THEAD, TAG_ID.THEAD],
  [TAG_NAMES.TITLE, TAG_ID.TITLE],
  [TAG_NAMES.TR, TAG_ID.TR],
  [TAG_NAMES.TRACK, TAG_ID.TRACK],
  [TAG_NAMES.TT, TAG_ID.TT],
  [TAG_NAMES.U, TAG_ID.U],
  [TAG_NAMES.UL, TAG_ID.UL],
  [TAG_NAMES.SVG, TAG_ID.SVG],
  [TAG_NAMES.VAR, TAG_ID.VAR],
  [TAG_NAMES.WBR, TAG_ID.WBR],
  [TAG_NAMES.XMP, TAG_ID.XMP]
]);
function getTagID(tagName) {
  var _a2;
  return (_a2 = TAG_NAME_TO_ID.get(tagName)) !== null && _a2 !== void 0 ? _a2 : TAG_ID.UNKNOWN;
}
var $ = TAG_ID;
var SPECIAL_ELEMENTS = {
  [NS.HTML]: /* @__PURE__ */ new Set([
    $.ADDRESS,
    $.APPLET,
    $.AREA,
    $.ARTICLE,
    $.ASIDE,
    $.BASE,
    $.BASEFONT,
    $.BGSOUND,
    $.BLOCKQUOTE,
    $.BODY,
    $.BR,
    $.BUTTON,
    $.CAPTION,
    $.CENTER,
    $.COL,
    $.COLGROUP,
    $.DD,
    $.DETAILS,
    $.DIR,
    $.DIV,
    $.DL,
    $.DT,
    $.EMBED,
    $.FIELDSET,
    $.FIGCAPTION,
    $.FIGURE,
    $.FOOTER,
    $.FORM,
    $.FRAME,
    $.FRAMESET,
    $.H1,
    $.H2,
    $.H3,
    $.H4,
    $.H5,
    $.H6,
    $.HEAD,
    $.HEADER,
    $.HGROUP,
    $.HR,
    $.HTML,
    $.IFRAME,
    $.IMG,
    $.INPUT,
    $.LI,
    $.LINK,
    $.LISTING,
    $.MAIN,
    $.MARQUEE,
    $.MENU,
    $.META,
    $.NAV,
    $.NOEMBED,
    $.NOFRAMES,
    $.NOSCRIPT,
    $.OBJECT,
    $.OL,
    $.P,
    $.PARAM,
    $.PLAINTEXT,
    $.PRE,
    $.SCRIPT,
    $.SECTION,
    $.SELECT,
    $.SOURCE,
    $.STYLE,
    $.SUMMARY,
    $.TABLE,
    $.TBODY,
    $.TD,
    $.TEMPLATE,
    $.TEXTAREA,
    $.TFOOT,
    $.TH,
    $.THEAD,
    $.TITLE,
    $.TR,
    $.TRACK,
    $.UL,
    $.WBR,
    $.XMP
  ]),
  [NS.MATHML]: /* @__PURE__ */ new Set([$.MI, $.MO, $.MN, $.MS, $.MTEXT, $.ANNOTATION_XML]),
  [NS.SVG]: /* @__PURE__ */ new Set([$.TITLE, $.FOREIGN_OBJECT, $.DESC]),
  [NS.XLINK]: /* @__PURE__ */ new Set(),
  [NS.XML]: /* @__PURE__ */ new Set(),
  [NS.XMLNS]: /* @__PURE__ */ new Set()
};
function isNumberedHeader(tn) {
  return tn === $.H1 || tn === $.H2 || tn === $.H3 || tn === $.H4 || tn === $.H5 || tn === $.H6;
}
var UNESCAPED_TEXT = /* @__PURE__ */ new Set([
  TAG_NAMES.STYLE,
  TAG_NAMES.SCRIPT,
  TAG_NAMES.XMP,
  TAG_NAMES.IFRAME,
  TAG_NAMES.NOEMBED,
  TAG_NAMES.NOFRAMES,
  TAG_NAMES.PLAINTEXT
]);
function hasUnescapedText(tn, scriptingEnabled) {
  return UNESCAPED_TEXT.has(tn) || scriptingEnabled && tn === TAG_NAMES.NOSCRIPT;
}

// node_modules/.pnpm/parse5@7.1.2/node_modules/parse5/dist/tokenizer/index.js
var C1_CONTROLS_REFERENCE_REPLACEMENTS = /* @__PURE__ */ new Map([
  [128, 8364],
  [130, 8218],
  [131, 402],
  [132, 8222],
  [133, 8230],
  [134, 8224],
  [135, 8225],
  [136, 710],
  [137, 8240],
  [138, 352],
  [139, 8249],
  [140, 338],
  [142, 381],
  [145, 8216],
  [146, 8217],
  [147, 8220],
  [148, 8221],
  [149, 8226],
  [150, 8211],
  [151, 8212],
  [152, 732],
  [153, 8482],
  [154, 353],
  [155, 8250],
  [156, 339],
  [158, 382],
  [159, 376]
]);
var State;
(function(State4) {
  State4[State4["DATA"] = 0] = "DATA";
  State4[State4["RCDATA"] = 1] = "RCDATA";
  State4[State4["RAWTEXT"] = 2] = "RAWTEXT";
  State4[State4["SCRIPT_DATA"] = 3] = "SCRIPT_DATA";
  State4[State4["PLAINTEXT"] = 4] = "PLAINTEXT";
  State4[State4["TAG_OPEN"] = 5] = "TAG_OPEN";
  State4[State4["END_TAG_OPEN"] = 6] = "END_TAG_OPEN";
  State4[State4["TAG_NAME"] = 7] = "TAG_NAME";
  State4[State4["RCDATA_LESS_THAN_SIGN"] = 8] = "RCDATA_LESS_THAN_SIGN";
  State4[State4["RCDATA_END_TAG_OPEN"] = 9] = "RCDATA_END_TAG_OPEN";
  State4[State4["RCDATA_END_TAG_NAME"] = 10] = "RCDATA_END_TAG_NAME";
  State4[State4["RAWTEXT_LESS_THAN_SIGN"] = 11] = "RAWTEXT_LESS_THAN_SIGN";
  State4[State4["RAWTEXT_END_TAG_OPEN"] = 12] = "RAWTEXT_END_TAG_OPEN";
  State4[State4["RAWTEXT_END_TAG_NAME"] = 13] = "RAWTEXT_END_TAG_NAME";
  State4[State4["SCRIPT_DATA_LESS_THAN_SIGN"] = 14] = "SCRIPT_DATA_LESS_THAN_SIGN";
  State4[State4["SCRIPT_DATA_END_TAG_OPEN"] = 15] = "SCRIPT_DATA_END_TAG_OPEN";
  State4[State4["SCRIPT_DATA_END_TAG_NAME"] = 16] = "SCRIPT_DATA_END_TAG_NAME";
  State4[State4["SCRIPT_DATA_ESCAPE_START"] = 17] = "SCRIPT_DATA_ESCAPE_START";
  State4[State4["SCRIPT_DATA_ESCAPE_START_DASH"] = 18] = "SCRIPT_DATA_ESCAPE_START_DASH";
  State4[State4["SCRIPT_DATA_ESCAPED"] = 19] = "SCRIPT_DATA_ESCAPED";
  State4[State4["SCRIPT_DATA_ESCAPED_DASH"] = 20] = "SCRIPT_DATA_ESCAPED_DASH";
  State4[State4["SCRIPT_DATA_ESCAPED_DASH_DASH"] = 21] = "SCRIPT_DATA_ESCAPED_DASH_DASH";
  State4[State4["SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN"] = 22] = "SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN";
  State4[State4["SCRIPT_DATA_ESCAPED_END_TAG_OPEN"] = 23] = "SCRIPT_DATA_ESCAPED_END_TAG_OPEN";
  State4[State4["SCRIPT_DATA_ESCAPED_END_TAG_NAME"] = 24] = "SCRIPT_DATA_ESCAPED_END_TAG_NAME";
  State4[State4["SCRIPT_DATA_DOUBLE_ESCAPE_START"] = 25] = "SCRIPT_DATA_DOUBLE_ESCAPE_START";
  State4[State4["SCRIPT_DATA_DOUBLE_ESCAPED"] = 26] = "SCRIPT_DATA_DOUBLE_ESCAPED";
  State4[State4["SCRIPT_DATA_DOUBLE_ESCAPED_DASH"] = 27] = "SCRIPT_DATA_DOUBLE_ESCAPED_DASH";
  State4[State4["SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH"] = 28] = "SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH";
  State4[State4["SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN"] = 29] = "SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN";
  State4[State4["SCRIPT_DATA_DOUBLE_ESCAPE_END"] = 30] = "SCRIPT_DATA_DOUBLE_ESCAPE_END";
  State4[State4["BEFORE_ATTRIBUTE_NAME"] = 31] = "BEFORE_ATTRIBUTE_NAME";
  State4[State4["ATTRIBUTE_NAME"] = 32] = "ATTRIBUTE_NAME";
  State4[State4["AFTER_ATTRIBUTE_NAME"] = 33] = "AFTER_ATTRIBUTE_NAME";
  State4[State4["BEFORE_ATTRIBUTE_VALUE"] = 34] = "BEFORE_ATTRIBUTE_VALUE";
  State4[State4["ATTRIBUTE_VALUE_DOUBLE_QUOTED"] = 35] = "ATTRIBUTE_VALUE_DOUBLE_QUOTED";
  State4[State4["ATTRIBUTE_VALUE_SINGLE_QUOTED"] = 36] = "ATTRIBUTE_VALUE_SINGLE_QUOTED";
  State4[State4["ATTRIBUTE_VALUE_UNQUOTED"] = 37] = "ATTRIBUTE_VALUE_UNQUOTED";
  State4[State4["AFTER_ATTRIBUTE_VALUE_QUOTED"] = 38] = "AFTER_ATTRIBUTE_VALUE_QUOTED";
  State4[State4["SELF_CLOSING_START_TAG"] = 39] = "SELF_CLOSING_START_TAG";
  State4[State4["BOGUS_COMMENT"] = 40] = "BOGUS_COMMENT";
  State4[State4["MARKUP_DECLARATION_OPEN"] = 41] = "MARKUP_DECLARATION_OPEN";
  State4[State4["COMMENT_START"] = 42] = "COMMENT_START";
  State4[State4["COMMENT_START_DASH"] = 43] = "COMMENT_START_DASH";
  State4[State4["COMMENT"] = 44] = "COMMENT";
  State4[State4["COMMENT_LESS_THAN_SIGN"] = 45] = "COMMENT_LESS_THAN_SIGN";
  State4[State4["COMMENT_LESS_THAN_SIGN_BANG"] = 46] = "COMMENT_LESS_THAN_SIGN_BANG";
  State4[State4["COMMENT_LESS_THAN_SIGN_BANG_DASH"] = 47] = "COMMENT_LESS_THAN_SIGN_BANG_DASH";
  State4[State4["COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH"] = 48] = "COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH";
  State4[State4["COMMENT_END_DASH"] = 49] = "COMMENT_END_DASH";
  State4[State4["COMMENT_END"] = 50] = "COMMENT_END";
  State4[State4["COMMENT_END_BANG"] = 51] = "COMMENT_END_BANG";
  State4[State4["DOCTYPE"] = 52] = "DOCTYPE";
  State4[State4["BEFORE_DOCTYPE_NAME"] = 53] = "BEFORE_DOCTYPE_NAME";
  State4[State4["DOCTYPE_NAME"] = 54] = "DOCTYPE_NAME";
  State4[State4["AFTER_DOCTYPE_NAME"] = 55] = "AFTER_DOCTYPE_NAME";
  State4[State4["AFTER_DOCTYPE_PUBLIC_KEYWORD"] = 56] = "AFTER_DOCTYPE_PUBLIC_KEYWORD";
  State4[State4["BEFORE_DOCTYPE_PUBLIC_IDENTIFIER"] = 57] = "BEFORE_DOCTYPE_PUBLIC_IDENTIFIER";
  State4[State4["DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED"] = 58] = "DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED";
  State4[State4["DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED"] = 59] = "DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED";
  State4[State4["AFTER_DOCTYPE_PUBLIC_IDENTIFIER"] = 60] = "AFTER_DOCTYPE_PUBLIC_IDENTIFIER";
  State4[State4["BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS"] = 61] = "BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS";
  State4[State4["AFTER_DOCTYPE_SYSTEM_KEYWORD"] = 62] = "AFTER_DOCTYPE_SYSTEM_KEYWORD";
  State4[State4["BEFORE_DOCTYPE_SYSTEM_IDENTIFIER"] = 63] = "BEFORE_DOCTYPE_SYSTEM_IDENTIFIER";
  State4[State4["DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED"] = 64] = "DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED";
  State4[State4["DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED"] = 65] = "DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED";
  State4[State4["AFTER_DOCTYPE_SYSTEM_IDENTIFIER"] = 66] = "AFTER_DOCTYPE_SYSTEM_IDENTIFIER";
  State4[State4["BOGUS_DOCTYPE"] = 67] = "BOGUS_DOCTYPE";
  State4[State4["CDATA_SECTION"] = 68] = "CDATA_SECTION";
  State4[State4["CDATA_SECTION_BRACKET"] = 69] = "CDATA_SECTION_BRACKET";
  State4[State4["CDATA_SECTION_END"] = 70] = "CDATA_SECTION_END";
  State4[State4["CHARACTER_REFERENCE"] = 71] = "CHARACTER_REFERENCE";
  State4[State4["NAMED_CHARACTER_REFERENCE"] = 72] = "NAMED_CHARACTER_REFERENCE";
  State4[State4["AMBIGUOUS_AMPERSAND"] = 73] = "AMBIGUOUS_AMPERSAND";
  State4[State4["NUMERIC_CHARACTER_REFERENCE"] = 74] = "NUMERIC_CHARACTER_REFERENCE";
  State4[State4["HEXADEMICAL_CHARACTER_REFERENCE_START"] = 75] = "HEXADEMICAL_CHARACTER_REFERENCE_START";
  State4[State4["HEXADEMICAL_CHARACTER_REFERENCE"] = 76] = "HEXADEMICAL_CHARACTER_REFERENCE";
  State4[State4["DECIMAL_CHARACTER_REFERENCE"] = 77] = "DECIMAL_CHARACTER_REFERENCE";
  State4[State4["NUMERIC_CHARACTER_REFERENCE_END"] = 78] = "NUMERIC_CHARACTER_REFERENCE_END";
})(State || (State = {}));
var TokenizerMode = {
  DATA: State.DATA,
  RCDATA: State.RCDATA,
  RAWTEXT: State.RAWTEXT,
  SCRIPT_DATA: State.SCRIPT_DATA,
  PLAINTEXT: State.PLAINTEXT,
  CDATA_SECTION: State.CDATA_SECTION
};
function isAsciiDigit(cp) {
  return cp >= CODE_POINTS.DIGIT_0 && cp <= CODE_POINTS.DIGIT_9;
}
function isAsciiUpper(cp) {
  return cp >= CODE_POINTS.LATIN_CAPITAL_A && cp <= CODE_POINTS.LATIN_CAPITAL_Z;
}
function isAsciiLower(cp) {
  return cp >= CODE_POINTS.LATIN_SMALL_A && cp <= CODE_POINTS.LATIN_SMALL_Z;
}
function isAsciiLetter(cp) {
  return isAsciiLower(cp) || isAsciiUpper(cp);
}
function isAsciiAlphaNumeric2(cp) {
  return isAsciiLetter(cp) || isAsciiDigit(cp);
}
function isAsciiUpperHexDigit(cp) {
  return cp >= CODE_POINTS.LATIN_CAPITAL_A && cp <= CODE_POINTS.LATIN_CAPITAL_F;
}
function isAsciiLowerHexDigit(cp) {
  return cp >= CODE_POINTS.LATIN_SMALL_A && cp <= CODE_POINTS.LATIN_SMALL_F;
}
function isAsciiHexDigit(cp) {
  return isAsciiDigit(cp) || isAsciiUpperHexDigit(cp) || isAsciiLowerHexDigit(cp);
}
function toAsciiLower(cp) {
  return cp + 32;
}
function isWhitespace2(cp) {
  return cp === CODE_POINTS.SPACE || cp === CODE_POINTS.LINE_FEED || cp === CODE_POINTS.TABULATION || cp === CODE_POINTS.FORM_FEED;
}
function isEntityInAttributeInvalidEnd2(nextCp) {
  return nextCp === CODE_POINTS.EQUALS_SIGN || isAsciiAlphaNumeric2(nextCp);
}
function isScriptDataDoubleEscapeSequenceEnd(cp) {
  return isWhitespace2(cp) || cp === CODE_POINTS.SOLIDUS || cp === CODE_POINTS.GREATER_THAN_SIGN;
}
var Tokenizer = class {
  constructor(options, handler) {
    this.options = options;
    this.handler = handler;
    this.paused = false;
    this.inLoop = false;
    this.inForeignNode = false;
    this.lastStartTagName = "";
    this.active = false;
    this.state = State.DATA;
    this.returnState = State.DATA;
    this.charRefCode = -1;
    this.consumedAfterSnapshot = -1;
    this.currentCharacterToken = null;
    this.currentToken = null;
    this.currentAttr = { name: "", value: "" };
    this.preprocessor = new Preprocessor(handler);
    this.currentLocation = this.getCurrentLocation(-1);
  }
  //Errors
  _err(code2) {
    var _a2, _b;
    (_b = (_a2 = this.handler).onParseError) === null || _b === void 0 ? void 0 : _b.call(_a2, this.preprocessor.getError(code2));
  }
  // NOTE: `offset` may never run across line boundaries.
  getCurrentLocation(offset) {
    if (!this.options.sourceCodeLocationInfo) {
      return null;
    }
    return {
      startLine: this.preprocessor.line,
      startCol: this.preprocessor.col - offset,
      startOffset: this.preprocessor.offset - offset,
      endLine: -1,
      endCol: -1,
      endOffset: -1
    };
  }
  _runParsingLoop() {
    if (this.inLoop)
      return;
    this.inLoop = true;
    while (this.active && !this.paused) {
      this.consumedAfterSnapshot = 0;
      const cp = this._consume();
      if (!this._ensureHibernation()) {
        this._callState(cp);
      }
    }
    this.inLoop = false;
  }
  //API
  pause() {
    this.paused = true;
  }
  resume(writeCallback) {
    if (!this.paused) {
      throw new Error("Parser was already resumed");
    }
    this.paused = false;
    if (this.inLoop)
      return;
    this._runParsingLoop();
    if (!this.paused) {
      writeCallback === null || writeCallback === void 0 ? void 0 : writeCallback();
    }
  }
  write(chunk, isLastChunk, writeCallback) {
    this.active = true;
    this.preprocessor.write(chunk, isLastChunk);
    this._runParsingLoop();
    if (!this.paused) {
      writeCallback === null || writeCallback === void 0 ? void 0 : writeCallback();
    }
  }
  insertHtmlAtCurrentPos(chunk) {
    this.active = true;
    this.preprocessor.insertHtmlAtCurrentPos(chunk);
    this._runParsingLoop();
  }
  //Hibernation
  _ensureHibernation() {
    if (this.preprocessor.endOfChunkHit) {
      this._unconsume(this.consumedAfterSnapshot);
      this.active = false;
      return true;
    }
    return false;
  }
  //Consumption
  _consume() {
    this.consumedAfterSnapshot++;
    return this.preprocessor.advance();
  }
  _unconsume(count) {
    this.consumedAfterSnapshot -= count;
    this.preprocessor.retreat(count);
  }
  _reconsumeInState(state, cp) {
    this.state = state;
    this._callState(cp);
  }
  _advanceBy(count) {
    this.consumedAfterSnapshot += count;
    for (let i = 0; i < count; i++) {
      this.preprocessor.advance();
    }
  }
  _consumeSequenceIfMatch(pattern, caseSensitive) {
    if (this.preprocessor.startsWith(pattern, caseSensitive)) {
      this._advanceBy(pattern.length - 1);
      return true;
    }
    return false;
  }
  //Token creation
  _createStartTagToken() {
    this.currentToken = {
      type: TokenType.START_TAG,
      tagName: "",
      tagID: TAG_ID.UNKNOWN,
      selfClosing: false,
      ackSelfClosing: false,
      attrs: [],
      location: this.getCurrentLocation(1)
    };
  }
  _createEndTagToken() {
    this.currentToken = {
      type: TokenType.END_TAG,
      tagName: "",
      tagID: TAG_ID.UNKNOWN,
      selfClosing: false,
      ackSelfClosing: false,
      attrs: [],
      location: this.getCurrentLocation(2)
    };
  }
  _createCommentToken(offset) {
    this.currentToken = {
      type: TokenType.COMMENT,
      data: "",
      location: this.getCurrentLocation(offset)
    };
  }
  _createDoctypeToken(initialName) {
    this.currentToken = {
      type: TokenType.DOCTYPE,
      name: initialName,
      forceQuirks: false,
      publicId: null,
      systemId: null,
      location: this.currentLocation
    };
  }
  _createCharacterToken(type2, chars) {
    this.currentCharacterToken = {
      type: type2,
      chars,
      location: this.currentLocation
    };
  }
  //Tag attributes
  _createAttr(attrNameFirstCh) {
    this.currentAttr = {
      name: attrNameFirstCh,
      value: ""
    };
    this.currentLocation = this.getCurrentLocation(0);
  }
  _leaveAttrName() {
    var _a2;
    var _b;
    const token = this.currentToken;
    if (getTokenAttr(token, this.currentAttr.name) === null) {
      token.attrs.push(this.currentAttr);
      if (token.location && this.currentLocation) {
        const attrLocations = (_a2 = (_b = token.location).attrs) !== null && _a2 !== void 0 ? _a2 : _b.attrs = /* @__PURE__ */ Object.create(null);
        attrLocations[this.currentAttr.name] = this.currentLocation;
        this._leaveAttrValue();
      }
    } else {
      this._err(ERR.duplicateAttribute);
    }
  }
  _leaveAttrValue() {
    if (this.currentLocation) {
      this.currentLocation.endLine = this.preprocessor.line;
      this.currentLocation.endCol = this.preprocessor.col;
      this.currentLocation.endOffset = this.preprocessor.offset;
    }
  }
  //Token emission
  prepareToken(ct) {
    this._emitCurrentCharacterToken(ct.location);
    this.currentToken = null;
    if (ct.location) {
      ct.location.endLine = this.preprocessor.line;
      ct.location.endCol = this.preprocessor.col + 1;
      ct.location.endOffset = this.preprocessor.offset + 1;
    }
    this.currentLocation = this.getCurrentLocation(-1);
  }
  emitCurrentTagToken() {
    const ct = this.currentToken;
    this.prepareToken(ct);
    ct.tagID = getTagID(ct.tagName);
    if (ct.type === TokenType.START_TAG) {
      this.lastStartTagName = ct.tagName;
      this.handler.onStartTag(ct);
    } else {
      if (ct.attrs.length > 0) {
        this._err(ERR.endTagWithAttributes);
      }
      if (ct.selfClosing) {
        this._err(ERR.endTagWithTrailingSolidus);
      }
      this.handler.onEndTag(ct);
    }
    this.preprocessor.dropParsedChunk();
  }
  emitCurrentComment(ct) {
    this.prepareToken(ct);
    this.handler.onComment(ct);
    this.preprocessor.dropParsedChunk();
  }
  emitCurrentDoctype(ct) {
    this.prepareToken(ct);
    this.handler.onDoctype(ct);
    this.preprocessor.dropParsedChunk();
  }
  _emitCurrentCharacterToken(nextLocation) {
    if (this.currentCharacterToken) {
      if (nextLocation && this.currentCharacterToken.location) {
        this.currentCharacterToken.location.endLine = nextLocation.startLine;
        this.currentCharacterToken.location.endCol = nextLocation.startCol;
        this.currentCharacterToken.location.endOffset = nextLocation.startOffset;
      }
      switch (this.currentCharacterToken.type) {
        case TokenType.CHARACTER: {
          this.handler.onCharacter(this.currentCharacterToken);
          break;
        }
        case TokenType.NULL_CHARACTER: {
          this.handler.onNullCharacter(this.currentCharacterToken);
          break;
        }
        case TokenType.WHITESPACE_CHARACTER: {
          this.handler.onWhitespaceCharacter(this.currentCharacterToken);
          break;
        }
      }
      this.currentCharacterToken = null;
    }
  }
  _emitEOFToken() {
    const location = this.getCurrentLocation(0);
    if (location) {
      location.endLine = location.startLine;
      location.endCol = location.startCol;
      location.endOffset = location.startOffset;
    }
    this._emitCurrentCharacterToken(location);
    this.handler.onEof({ type: TokenType.EOF, location });
    this.active = false;
  }
  //Characters emission
  //OPTIMIZATION: specification uses only one type of character tokens (one token per character).
  //This causes a huge memory overhead and a lot of unnecessary parser loops. parse5 uses 3 groups of characters.
  //If we have a sequence of characters that belong to the same group, the parser can process it
  //as a single solid character token.
  //So, there are 3 types of character tokens in parse5:
  //1)TokenType.NULL_CHARACTER - \u0000-character sequences (e.g. '\u0000\u0000\u0000')
  //2)TokenType.WHITESPACE_CHARACTER - any whitespace/new-line character sequences (e.g. '\n  \r\t   \f')
  //3)TokenType.CHARACTER - any character sequence which don't belong to groups 1 and 2 (e.g. 'abcdef1234@@#$%^')
  _appendCharToCurrentCharacterToken(type2, ch) {
    if (this.currentCharacterToken) {
      if (this.currentCharacterToken.type !== type2) {
        this.currentLocation = this.getCurrentLocation(0);
        this._emitCurrentCharacterToken(this.currentLocation);
        this.preprocessor.dropParsedChunk();
      } else {
        this.currentCharacterToken.chars += ch;
        return;
      }
    }
    this._createCharacterToken(type2, ch);
  }
  _emitCodePoint(cp) {
    const type2 = isWhitespace2(cp) ? TokenType.WHITESPACE_CHARACTER : cp === CODE_POINTS.NULL ? TokenType.NULL_CHARACTER : TokenType.CHARACTER;
    this._appendCharToCurrentCharacterToken(type2, String.fromCodePoint(cp));
  }
  //NOTE: used when we emit characters explicitly.
  //This is always for non-whitespace and non-null characters, which allows us to avoid additional checks.
  _emitChars(ch) {
    this._appendCharToCurrentCharacterToken(TokenType.CHARACTER, ch);
  }
  // Character reference helpers
  _matchNamedCharacterReference(cp) {
    let result = null;
    let excess = 0;
    let withoutSemicolon = false;
    for (let i = 0, current = decode_data_html_default[0]; i >= 0; cp = this._consume()) {
      i = determineBranch(decode_data_html_default, current, i + 1, cp);
      if (i < 0)
        break;
      excess += 1;
      current = decode_data_html_default[i];
      const masked = current & BinTrieFlags.VALUE_LENGTH;
      if (masked) {
        const valueLength = (masked >> 14) - 1;
        if (cp !== CODE_POINTS.SEMICOLON && this._isCharacterReferenceInAttribute() && isEntityInAttributeInvalidEnd2(this.preprocessor.peek(1))) {
          result = [CODE_POINTS.AMPERSAND];
          i += valueLength;
        } else {
          result = valueLength === 0 ? [decode_data_html_default[i] & ~BinTrieFlags.VALUE_LENGTH] : valueLength === 1 ? [decode_data_html_default[++i]] : [decode_data_html_default[++i], decode_data_html_default[++i]];
          excess = 0;
          withoutSemicolon = cp !== CODE_POINTS.SEMICOLON;
        }
        if (valueLength === 0) {
          this._consume();
          break;
        }
      }
    }
    this._unconsume(excess);
    if (withoutSemicolon && !this.preprocessor.endOfChunkHit) {
      this._err(ERR.missingSemicolonAfterCharacterReference);
    }
    this._unconsume(1);
    return result;
  }
  _isCharacterReferenceInAttribute() {
    return this.returnState === State.ATTRIBUTE_VALUE_DOUBLE_QUOTED || this.returnState === State.ATTRIBUTE_VALUE_SINGLE_QUOTED || this.returnState === State.ATTRIBUTE_VALUE_UNQUOTED;
  }
  _flushCodePointConsumedAsCharacterReference(cp) {
    if (this._isCharacterReferenceInAttribute()) {
      this.currentAttr.value += String.fromCodePoint(cp);
    } else {
      this._emitCodePoint(cp);
    }
  }
  // Calling states this way turns out to be much faster than any other approach.
  _callState(cp) {
    switch (this.state) {
      case State.DATA: {
        this._stateData(cp);
        break;
      }
      case State.RCDATA: {
        this._stateRcdata(cp);
        break;
      }
      case State.RAWTEXT: {
        this._stateRawtext(cp);
        break;
      }
      case State.SCRIPT_DATA: {
        this._stateScriptData(cp);
        break;
      }
      case State.PLAINTEXT: {
        this._statePlaintext(cp);
        break;
      }
      case State.TAG_OPEN: {
        this._stateTagOpen(cp);
        break;
      }
      case State.END_TAG_OPEN: {
        this._stateEndTagOpen(cp);
        break;
      }
      case State.TAG_NAME: {
        this._stateTagName(cp);
        break;
      }
      case State.RCDATA_LESS_THAN_SIGN: {
        this._stateRcdataLessThanSign(cp);
        break;
      }
      case State.RCDATA_END_TAG_OPEN: {
        this._stateRcdataEndTagOpen(cp);
        break;
      }
      case State.RCDATA_END_TAG_NAME: {
        this._stateRcdataEndTagName(cp);
        break;
      }
      case State.RAWTEXT_LESS_THAN_SIGN: {
        this._stateRawtextLessThanSign(cp);
        break;
      }
      case State.RAWTEXT_END_TAG_OPEN: {
        this._stateRawtextEndTagOpen(cp);
        break;
      }
      case State.RAWTEXT_END_TAG_NAME: {
        this._stateRawtextEndTagName(cp);
        break;
      }
      case State.SCRIPT_DATA_LESS_THAN_SIGN: {
        this._stateScriptDataLessThanSign(cp);
        break;
      }
      case State.SCRIPT_DATA_END_TAG_OPEN: {
        this._stateScriptDataEndTagOpen(cp);
        break;
      }
      case State.SCRIPT_DATA_END_TAG_NAME: {
        this._stateScriptDataEndTagName(cp);
        break;
      }
      case State.SCRIPT_DATA_ESCAPE_START: {
        this._stateScriptDataEscapeStart(cp);
        break;
      }
      case State.SCRIPT_DATA_ESCAPE_START_DASH: {
        this._stateScriptDataEscapeStartDash(cp);
        break;
      }
      case State.SCRIPT_DATA_ESCAPED: {
        this._stateScriptDataEscaped(cp);
        break;
      }
      case State.SCRIPT_DATA_ESCAPED_DASH: {
        this._stateScriptDataEscapedDash(cp);
        break;
      }
      case State.SCRIPT_DATA_ESCAPED_DASH_DASH: {
        this._stateScriptDataEscapedDashDash(cp);
        break;
      }
      case State.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN: {
        this._stateScriptDataEscapedLessThanSign(cp);
        break;
      }
      case State.SCRIPT_DATA_ESCAPED_END_TAG_OPEN: {
        this._stateScriptDataEscapedEndTagOpen(cp);
        break;
      }
      case State.SCRIPT_DATA_ESCAPED_END_TAG_NAME: {
        this._stateScriptDataEscapedEndTagName(cp);
        break;
      }
      case State.SCRIPT_DATA_DOUBLE_ESCAPE_START: {
        this._stateScriptDataDoubleEscapeStart(cp);
        break;
      }
      case State.SCRIPT_DATA_DOUBLE_ESCAPED: {
        this._stateScriptDataDoubleEscaped(cp);
        break;
      }
      case State.SCRIPT_DATA_DOUBLE_ESCAPED_DASH: {
        this._stateScriptDataDoubleEscapedDash(cp);
        break;
      }
      case State.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH: {
        this._stateScriptDataDoubleEscapedDashDash(cp);
        break;
      }
      case State.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN: {
        this._stateScriptDataDoubleEscapedLessThanSign(cp);
        break;
      }
      case State.SCRIPT_DATA_DOUBLE_ESCAPE_END: {
        this._stateScriptDataDoubleEscapeEnd(cp);
        break;
      }
      case State.BEFORE_ATTRIBUTE_NAME: {
        this._stateBeforeAttributeName(cp);
        break;
      }
      case State.ATTRIBUTE_NAME: {
        this._stateAttributeName(cp);
        break;
      }
      case State.AFTER_ATTRIBUTE_NAME: {
        this._stateAfterAttributeName(cp);
        break;
      }
      case State.BEFORE_ATTRIBUTE_VALUE: {
        this._stateBeforeAttributeValue(cp);
        break;
      }
      case State.ATTRIBUTE_VALUE_DOUBLE_QUOTED: {
        this._stateAttributeValueDoubleQuoted(cp);
        break;
      }
      case State.ATTRIBUTE_VALUE_SINGLE_QUOTED: {
        this._stateAttributeValueSingleQuoted(cp);
        break;
      }
      case State.ATTRIBUTE_VALUE_UNQUOTED: {
        this._stateAttributeValueUnquoted(cp);
        break;
      }
      case State.AFTER_ATTRIBUTE_VALUE_QUOTED: {
        this._stateAfterAttributeValueQuoted(cp);
        break;
      }
      case State.SELF_CLOSING_START_TAG: {
        this._stateSelfClosingStartTag(cp);
        break;
      }
      case State.BOGUS_COMMENT: {
        this._stateBogusComment(cp);
        break;
      }
      case State.MARKUP_DECLARATION_OPEN: {
        this._stateMarkupDeclarationOpen(cp);
        break;
      }
      case State.COMMENT_START: {
        this._stateCommentStart(cp);
        break;
      }
      case State.COMMENT_START_DASH: {
        this._stateCommentStartDash(cp);
        break;
      }
      case State.COMMENT: {
        this._stateComment(cp);
        break;
      }
      case State.COMMENT_LESS_THAN_SIGN: {
        this._stateCommentLessThanSign(cp);
        break;
      }
      case State.COMMENT_LESS_THAN_SIGN_BANG: {
        this._stateCommentLessThanSignBang(cp);
        break;
      }
      case State.COMMENT_LESS_THAN_SIGN_BANG_DASH: {
        this._stateCommentLessThanSignBangDash(cp);
        break;
      }
      case State.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH: {
        this._stateCommentLessThanSignBangDashDash(cp);
        break;
      }
      case State.COMMENT_END_DASH: {
        this._stateCommentEndDash(cp);
        break;
      }
      case State.COMMENT_END: {
        this._stateCommentEnd(cp);
        break;
      }
      case State.COMMENT_END_BANG: {
        this._stateCommentEndBang(cp);
        break;
      }
      case State.DOCTYPE: {
        this._stateDoctype(cp);
        break;
      }
      case State.BEFORE_DOCTYPE_NAME: {
        this._stateBeforeDoctypeName(cp);
        break;
      }
      case State.DOCTYPE_NAME: {
        this._stateDoctypeName(cp);
        break;
      }
      case State.AFTER_DOCTYPE_NAME: {
        this._stateAfterDoctypeName(cp);
        break;
      }
      case State.AFTER_DOCTYPE_PUBLIC_KEYWORD: {
        this._stateAfterDoctypePublicKeyword(cp);
        break;
      }
      case State.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER: {
        this._stateBeforeDoctypePublicIdentifier(cp);
        break;
      }
      case State.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED: {
        this._stateDoctypePublicIdentifierDoubleQuoted(cp);
        break;
      }
      case State.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED: {
        this._stateDoctypePublicIdentifierSingleQuoted(cp);
        break;
      }
      case State.AFTER_DOCTYPE_PUBLIC_IDENTIFIER: {
        this._stateAfterDoctypePublicIdentifier(cp);
        break;
      }
      case State.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS: {
        this._stateBetweenDoctypePublicAndSystemIdentifiers(cp);
        break;
      }
      case State.AFTER_DOCTYPE_SYSTEM_KEYWORD: {
        this._stateAfterDoctypeSystemKeyword(cp);
        break;
      }
      case State.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER: {
        this._stateBeforeDoctypeSystemIdentifier(cp);
        break;
      }
      case State.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED: {
        this._stateDoctypeSystemIdentifierDoubleQuoted(cp);
        break;
      }
      case State.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED: {
        this._stateDoctypeSystemIdentifierSingleQuoted(cp);
        break;
      }
      case State.AFTER_DOCTYPE_SYSTEM_IDENTIFIER: {
        this._stateAfterDoctypeSystemIdentifier(cp);
        break;
      }
      case State.BOGUS_DOCTYPE: {
        this._stateBogusDoctype(cp);
        break;
      }
      case State.CDATA_SECTION: {
        this._stateCdataSection(cp);
        break;
      }
      case State.CDATA_SECTION_BRACKET: {
        this._stateCdataSectionBracket(cp);
        break;
      }
      case State.CDATA_SECTION_END: {
        this._stateCdataSectionEnd(cp);
        break;
      }
      case State.CHARACTER_REFERENCE: {
        this._stateCharacterReference(cp);
        break;
      }
      case State.NAMED_CHARACTER_REFERENCE: {
        this._stateNamedCharacterReference(cp);
        break;
      }
      case State.AMBIGUOUS_AMPERSAND: {
        this._stateAmbiguousAmpersand(cp);
        break;
      }
      case State.NUMERIC_CHARACTER_REFERENCE: {
        this._stateNumericCharacterReference(cp);
        break;
      }
      case State.HEXADEMICAL_CHARACTER_REFERENCE_START: {
        this._stateHexademicalCharacterReferenceStart(cp);
        break;
      }
      case State.HEXADEMICAL_CHARACTER_REFERENCE: {
        this._stateHexademicalCharacterReference(cp);
        break;
      }
      case State.DECIMAL_CHARACTER_REFERENCE: {
        this._stateDecimalCharacterReference(cp);
        break;
      }
      case State.NUMERIC_CHARACTER_REFERENCE_END: {
        this._stateNumericCharacterReferenceEnd(cp);
        break;
      }
      default: {
        throw new Error("Unknown state");
      }
    }
  }
  // State machine
  // Data state
  //------------------------------------------------------------------
  _stateData(cp) {
    switch (cp) {
      case CODE_POINTS.LESS_THAN_SIGN: {
        this.state = State.TAG_OPEN;
        break;
      }
      case CODE_POINTS.AMPERSAND: {
        this.returnState = State.DATA;
        this.state = State.CHARACTER_REFERENCE;
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        this._emitCodePoint(cp);
        break;
      }
      case CODE_POINTS.EOF: {
        this._emitEOFToken();
        break;
      }
      default: {
        this._emitCodePoint(cp);
      }
    }
  }
  //  RCDATA state
  //------------------------------------------------------------------
  _stateRcdata(cp) {
    switch (cp) {
      case CODE_POINTS.AMPERSAND: {
        this.returnState = State.RCDATA;
        this.state = State.CHARACTER_REFERENCE;
        break;
      }
      case CODE_POINTS.LESS_THAN_SIGN: {
        this.state = State.RCDATA_LESS_THAN_SIGN;
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        this._emitChars(REPLACEMENT_CHARACTER);
        break;
      }
      case CODE_POINTS.EOF: {
        this._emitEOFToken();
        break;
      }
      default: {
        this._emitCodePoint(cp);
      }
    }
  }
  // RAWTEXT state
  //------------------------------------------------------------------
  _stateRawtext(cp) {
    switch (cp) {
      case CODE_POINTS.LESS_THAN_SIGN: {
        this.state = State.RAWTEXT_LESS_THAN_SIGN;
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        this._emitChars(REPLACEMENT_CHARACTER);
        break;
      }
      case CODE_POINTS.EOF: {
        this._emitEOFToken();
        break;
      }
      default: {
        this._emitCodePoint(cp);
      }
    }
  }
  // Script data state
  //------------------------------------------------------------------
  _stateScriptData(cp) {
    switch (cp) {
      case CODE_POINTS.LESS_THAN_SIGN: {
        this.state = State.SCRIPT_DATA_LESS_THAN_SIGN;
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        this._emitChars(REPLACEMENT_CHARACTER);
        break;
      }
      case CODE_POINTS.EOF: {
        this._emitEOFToken();
        break;
      }
      default: {
        this._emitCodePoint(cp);
      }
    }
  }
  // PLAINTEXT state
  //------------------------------------------------------------------
  _statePlaintext(cp) {
    switch (cp) {
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        this._emitChars(REPLACEMENT_CHARACTER);
        break;
      }
      case CODE_POINTS.EOF: {
        this._emitEOFToken();
        break;
      }
      default: {
        this._emitCodePoint(cp);
      }
    }
  }
  // Tag open state
  //------------------------------------------------------------------
  _stateTagOpen(cp) {
    if (isAsciiLetter(cp)) {
      this._createStartTagToken();
      this.state = State.TAG_NAME;
      this._stateTagName(cp);
    } else
      switch (cp) {
        case CODE_POINTS.EXCLAMATION_MARK: {
          this.state = State.MARKUP_DECLARATION_OPEN;
          break;
        }
        case CODE_POINTS.SOLIDUS: {
          this.state = State.END_TAG_OPEN;
          break;
        }
        case CODE_POINTS.QUESTION_MARK: {
          this._err(ERR.unexpectedQuestionMarkInsteadOfTagName);
          this._createCommentToken(1);
          this.state = State.BOGUS_COMMENT;
          this._stateBogusComment(cp);
          break;
        }
        case CODE_POINTS.EOF: {
          this._err(ERR.eofBeforeTagName);
          this._emitChars("<");
          this._emitEOFToken();
          break;
        }
        default: {
          this._err(ERR.invalidFirstCharacterOfTagName);
          this._emitChars("<");
          this.state = State.DATA;
          this._stateData(cp);
        }
      }
  }
  // End tag open state
  //------------------------------------------------------------------
  _stateEndTagOpen(cp) {
    if (isAsciiLetter(cp)) {
      this._createEndTagToken();
      this.state = State.TAG_NAME;
      this._stateTagName(cp);
    } else
      switch (cp) {
        case CODE_POINTS.GREATER_THAN_SIGN: {
          this._err(ERR.missingEndTagName);
          this.state = State.DATA;
          break;
        }
        case CODE_POINTS.EOF: {
          this._err(ERR.eofBeforeTagName);
          this._emitChars("</");
          this._emitEOFToken();
          break;
        }
        default: {
          this._err(ERR.invalidFirstCharacterOfTagName);
          this._createCommentToken(2);
          this.state = State.BOGUS_COMMENT;
          this._stateBogusComment(cp);
        }
      }
  }
  // Tag name state
  //------------------------------------------------------------------
  _stateTagName(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        this.state = State.BEFORE_ATTRIBUTE_NAME;
        break;
      }
      case CODE_POINTS.SOLIDUS: {
        this.state = State.SELF_CLOSING_START_TAG;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.state = State.DATA;
        this.emitCurrentTagToken();
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        token.tagName += REPLACEMENT_CHARACTER;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInTag);
        this._emitEOFToken();
        break;
      }
      default: {
        token.tagName += String.fromCodePoint(isAsciiUpper(cp) ? toAsciiLower(cp) : cp);
      }
    }
  }
  // RCDATA less-than sign state
  //------------------------------------------------------------------
  _stateRcdataLessThanSign(cp) {
    if (cp === CODE_POINTS.SOLIDUS) {
      this.state = State.RCDATA_END_TAG_OPEN;
    } else {
      this._emitChars("<");
      this.state = State.RCDATA;
      this._stateRcdata(cp);
    }
  }
  // RCDATA end tag open state
  //------------------------------------------------------------------
  _stateRcdataEndTagOpen(cp) {
    if (isAsciiLetter(cp)) {
      this.state = State.RCDATA_END_TAG_NAME;
      this._stateRcdataEndTagName(cp);
    } else {
      this._emitChars("</");
      this.state = State.RCDATA;
      this._stateRcdata(cp);
    }
  }
  handleSpecialEndTag(_cp) {
    if (!this.preprocessor.startsWith(this.lastStartTagName, false)) {
      return !this._ensureHibernation();
    }
    this._createEndTagToken();
    const token = this.currentToken;
    token.tagName = this.lastStartTagName;
    const cp = this.preprocessor.peek(this.lastStartTagName.length);
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        this._advanceBy(this.lastStartTagName.length);
        this.state = State.BEFORE_ATTRIBUTE_NAME;
        return false;
      }
      case CODE_POINTS.SOLIDUS: {
        this._advanceBy(this.lastStartTagName.length);
        this.state = State.SELF_CLOSING_START_TAG;
        return false;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._advanceBy(this.lastStartTagName.length);
        this.emitCurrentTagToken();
        this.state = State.DATA;
        return false;
      }
      default: {
        return !this._ensureHibernation();
      }
    }
  }
  // RCDATA end tag name state
  //------------------------------------------------------------------
  _stateRcdataEndTagName(cp) {
    if (this.handleSpecialEndTag(cp)) {
      this._emitChars("</");
      this.state = State.RCDATA;
      this._stateRcdata(cp);
    }
  }
  // RAWTEXT less-than sign state
  //------------------------------------------------------------------
  _stateRawtextLessThanSign(cp) {
    if (cp === CODE_POINTS.SOLIDUS) {
      this.state = State.RAWTEXT_END_TAG_OPEN;
    } else {
      this._emitChars("<");
      this.state = State.RAWTEXT;
      this._stateRawtext(cp);
    }
  }
  // RAWTEXT end tag open state
  //------------------------------------------------------------------
  _stateRawtextEndTagOpen(cp) {
    if (isAsciiLetter(cp)) {
      this.state = State.RAWTEXT_END_TAG_NAME;
      this._stateRawtextEndTagName(cp);
    } else {
      this._emitChars("</");
      this.state = State.RAWTEXT;
      this._stateRawtext(cp);
    }
  }
  // RAWTEXT end tag name state
  //------------------------------------------------------------------
  _stateRawtextEndTagName(cp) {
    if (this.handleSpecialEndTag(cp)) {
      this._emitChars("</");
      this.state = State.RAWTEXT;
      this._stateRawtext(cp);
    }
  }
  // Script data less-than sign state
  //------------------------------------------------------------------
  _stateScriptDataLessThanSign(cp) {
    switch (cp) {
      case CODE_POINTS.SOLIDUS: {
        this.state = State.SCRIPT_DATA_END_TAG_OPEN;
        break;
      }
      case CODE_POINTS.EXCLAMATION_MARK: {
        this.state = State.SCRIPT_DATA_ESCAPE_START;
        this._emitChars("<!");
        break;
      }
      default: {
        this._emitChars("<");
        this.state = State.SCRIPT_DATA;
        this._stateScriptData(cp);
      }
    }
  }
  // Script data end tag open state
  //------------------------------------------------------------------
  _stateScriptDataEndTagOpen(cp) {
    if (isAsciiLetter(cp)) {
      this.state = State.SCRIPT_DATA_END_TAG_NAME;
      this._stateScriptDataEndTagName(cp);
    } else {
      this._emitChars("</");
      this.state = State.SCRIPT_DATA;
      this._stateScriptData(cp);
    }
  }
  // Script data end tag name state
  //------------------------------------------------------------------
  _stateScriptDataEndTagName(cp) {
    if (this.handleSpecialEndTag(cp)) {
      this._emitChars("</");
      this.state = State.SCRIPT_DATA;
      this._stateScriptData(cp);
    }
  }
  // Script data escape start state
  //------------------------------------------------------------------
  _stateScriptDataEscapeStart(cp) {
    if (cp === CODE_POINTS.HYPHEN_MINUS) {
      this.state = State.SCRIPT_DATA_ESCAPE_START_DASH;
      this._emitChars("-");
    } else {
      this.state = State.SCRIPT_DATA;
      this._stateScriptData(cp);
    }
  }
  // Script data escape start dash state
  //------------------------------------------------------------------
  _stateScriptDataEscapeStartDash(cp) {
    if (cp === CODE_POINTS.HYPHEN_MINUS) {
      this.state = State.SCRIPT_DATA_ESCAPED_DASH_DASH;
      this._emitChars("-");
    } else {
      this.state = State.SCRIPT_DATA;
      this._stateScriptData(cp);
    }
  }
  // Script data escaped state
  //------------------------------------------------------------------
  _stateScriptDataEscaped(cp) {
    switch (cp) {
      case CODE_POINTS.HYPHEN_MINUS: {
        this.state = State.SCRIPT_DATA_ESCAPED_DASH;
        this._emitChars("-");
        break;
      }
      case CODE_POINTS.LESS_THAN_SIGN: {
        this.state = State.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        this._emitChars(REPLACEMENT_CHARACTER);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInScriptHtmlCommentLikeText);
        this._emitEOFToken();
        break;
      }
      default: {
        this._emitCodePoint(cp);
      }
    }
  }
  // Script data escaped dash state
  //------------------------------------------------------------------
  _stateScriptDataEscapedDash(cp) {
    switch (cp) {
      case CODE_POINTS.HYPHEN_MINUS: {
        this.state = State.SCRIPT_DATA_ESCAPED_DASH_DASH;
        this._emitChars("-");
        break;
      }
      case CODE_POINTS.LESS_THAN_SIGN: {
        this.state = State.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        this.state = State.SCRIPT_DATA_ESCAPED;
        this._emitChars(REPLACEMENT_CHARACTER);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInScriptHtmlCommentLikeText);
        this._emitEOFToken();
        break;
      }
      default: {
        this.state = State.SCRIPT_DATA_ESCAPED;
        this._emitCodePoint(cp);
      }
    }
  }
  // Script data escaped dash dash state
  //------------------------------------------------------------------
  _stateScriptDataEscapedDashDash(cp) {
    switch (cp) {
      case CODE_POINTS.HYPHEN_MINUS: {
        this._emitChars("-");
        break;
      }
      case CODE_POINTS.LESS_THAN_SIGN: {
        this.state = State.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.state = State.SCRIPT_DATA;
        this._emitChars(">");
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        this.state = State.SCRIPT_DATA_ESCAPED;
        this._emitChars(REPLACEMENT_CHARACTER);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInScriptHtmlCommentLikeText);
        this._emitEOFToken();
        break;
      }
      default: {
        this.state = State.SCRIPT_DATA_ESCAPED;
        this._emitCodePoint(cp);
      }
    }
  }
  // Script data escaped less-than sign state
  //------------------------------------------------------------------
  _stateScriptDataEscapedLessThanSign(cp) {
    if (cp === CODE_POINTS.SOLIDUS) {
      this.state = State.SCRIPT_DATA_ESCAPED_END_TAG_OPEN;
    } else if (isAsciiLetter(cp)) {
      this._emitChars("<");
      this.state = State.SCRIPT_DATA_DOUBLE_ESCAPE_START;
      this._stateScriptDataDoubleEscapeStart(cp);
    } else {
      this._emitChars("<");
      this.state = State.SCRIPT_DATA_ESCAPED;
      this._stateScriptDataEscaped(cp);
    }
  }
  // Script data escaped end tag open state
  //------------------------------------------------------------------
  _stateScriptDataEscapedEndTagOpen(cp) {
    if (isAsciiLetter(cp)) {
      this.state = State.SCRIPT_DATA_ESCAPED_END_TAG_NAME;
      this._stateScriptDataEscapedEndTagName(cp);
    } else {
      this._emitChars("</");
      this.state = State.SCRIPT_DATA_ESCAPED;
      this._stateScriptDataEscaped(cp);
    }
  }
  // Script data escaped end tag name state
  //------------------------------------------------------------------
  _stateScriptDataEscapedEndTagName(cp) {
    if (this.handleSpecialEndTag(cp)) {
      this._emitChars("</");
      this.state = State.SCRIPT_DATA_ESCAPED;
      this._stateScriptDataEscaped(cp);
    }
  }
  // Script data double escape start state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapeStart(cp) {
    if (this.preprocessor.startsWith(SEQUENCES.SCRIPT, false) && isScriptDataDoubleEscapeSequenceEnd(this.preprocessor.peek(SEQUENCES.SCRIPT.length))) {
      this._emitCodePoint(cp);
      for (let i = 0; i < SEQUENCES.SCRIPT.length; i++) {
        this._emitCodePoint(this._consume());
      }
      this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED;
    } else if (!this._ensureHibernation()) {
      this.state = State.SCRIPT_DATA_ESCAPED;
      this._stateScriptDataEscaped(cp);
    }
  }
  // Script data double escaped state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscaped(cp) {
    switch (cp) {
      case CODE_POINTS.HYPHEN_MINUS: {
        this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED_DASH;
        this._emitChars("-");
        break;
      }
      case CODE_POINTS.LESS_THAN_SIGN: {
        this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN;
        this._emitChars("<");
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        this._emitChars(REPLACEMENT_CHARACTER);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInScriptHtmlCommentLikeText);
        this._emitEOFToken();
        break;
      }
      default: {
        this._emitCodePoint(cp);
      }
    }
  }
  // Script data double escaped dash state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapedDash(cp) {
    switch (cp) {
      case CODE_POINTS.HYPHEN_MINUS: {
        this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH;
        this._emitChars("-");
        break;
      }
      case CODE_POINTS.LESS_THAN_SIGN: {
        this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN;
        this._emitChars("<");
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED;
        this._emitChars(REPLACEMENT_CHARACTER);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInScriptHtmlCommentLikeText);
        this._emitEOFToken();
        break;
      }
      default: {
        this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED;
        this._emitCodePoint(cp);
      }
    }
  }
  // Script data double escaped dash dash state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapedDashDash(cp) {
    switch (cp) {
      case CODE_POINTS.HYPHEN_MINUS: {
        this._emitChars("-");
        break;
      }
      case CODE_POINTS.LESS_THAN_SIGN: {
        this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN;
        this._emitChars("<");
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.state = State.SCRIPT_DATA;
        this._emitChars(">");
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED;
        this._emitChars(REPLACEMENT_CHARACTER);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInScriptHtmlCommentLikeText);
        this._emitEOFToken();
        break;
      }
      default: {
        this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED;
        this._emitCodePoint(cp);
      }
    }
  }
  // Script data double escaped less-than sign state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapedLessThanSign(cp) {
    if (cp === CODE_POINTS.SOLIDUS) {
      this.state = State.SCRIPT_DATA_DOUBLE_ESCAPE_END;
      this._emitChars("/");
    } else {
      this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED;
      this._stateScriptDataDoubleEscaped(cp);
    }
  }
  // Script data double escape end state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapeEnd(cp) {
    if (this.preprocessor.startsWith(SEQUENCES.SCRIPT, false) && isScriptDataDoubleEscapeSequenceEnd(this.preprocessor.peek(SEQUENCES.SCRIPT.length))) {
      this._emitCodePoint(cp);
      for (let i = 0; i < SEQUENCES.SCRIPT.length; i++) {
        this._emitCodePoint(this._consume());
      }
      this.state = State.SCRIPT_DATA_ESCAPED;
    } else if (!this._ensureHibernation()) {
      this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED;
      this._stateScriptDataDoubleEscaped(cp);
    }
  }
  // Before attribute name state
  //------------------------------------------------------------------
  _stateBeforeAttributeName(cp) {
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        break;
      }
      case CODE_POINTS.SOLIDUS:
      case CODE_POINTS.GREATER_THAN_SIGN:
      case CODE_POINTS.EOF: {
        this.state = State.AFTER_ATTRIBUTE_NAME;
        this._stateAfterAttributeName(cp);
        break;
      }
      case CODE_POINTS.EQUALS_SIGN: {
        this._err(ERR.unexpectedEqualsSignBeforeAttributeName);
        this._createAttr("=");
        this.state = State.ATTRIBUTE_NAME;
        break;
      }
      default: {
        this._createAttr("");
        this.state = State.ATTRIBUTE_NAME;
        this._stateAttributeName(cp);
      }
    }
  }
  // Attribute name state
  //------------------------------------------------------------------
  _stateAttributeName(cp) {
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED:
      case CODE_POINTS.SOLIDUS:
      case CODE_POINTS.GREATER_THAN_SIGN:
      case CODE_POINTS.EOF: {
        this._leaveAttrName();
        this.state = State.AFTER_ATTRIBUTE_NAME;
        this._stateAfterAttributeName(cp);
        break;
      }
      case CODE_POINTS.EQUALS_SIGN: {
        this._leaveAttrName();
        this.state = State.BEFORE_ATTRIBUTE_VALUE;
        break;
      }
      case CODE_POINTS.QUOTATION_MARK:
      case CODE_POINTS.APOSTROPHE:
      case CODE_POINTS.LESS_THAN_SIGN: {
        this._err(ERR.unexpectedCharacterInAttributeName);
        this.currentAttr.name += String.fromCodePoint(cp);
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        this.currentAttr.name += REPLACEMENT_CHARACTER;
        break;
      }
      default: {
        this.currentAttr.name += String.fromCodePoint(isAsciiUpper(cp) ? toAsciiLower(cp) : cp);
      }
    }
  }
  // After attribute name state
  //------------------------------------------------------------------
  _stateAfterAttributeName(cp) {
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        break;
      }
      case CODE_POINTS.SOLIDUS: {
        this.state = State.SELF_CLOSING_START_TAG;
        break;
      }
      case CODE_POINTS.EQUALS_SIGN: {
        this.state = State.BEFORE_ATTRIBUTE_VALUE;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.state = State.DATA;
        this.emitCurrentTagToken();
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInTag);
        this._emitEOFToken();
        break;
      }
      default: {
        this._createAttr("");
        this.state = State.ATTRIBUTE_NAME;
        this._stateAttributeName(cp);
      }
    }
  }
  // Before attribute value state
  //------------------------------------------------------------------
  _stateBeforeAttributeValue(cp) {
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        break;
      }
      case CODE_POINTS.QUOTATION_MARK: {
        this.state = State.ATTRIBUTE_VALUE_DOUBLE_QUOTED;
        break;
      }
      case CODE_POINTS.APOSTROPHE: {
        this.state = State.ATTRIBUTE_VALUE_SINGLE_QUOTED;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(ERR.missingAttributeValue);
        this.state = State.DATA;
        this.emitCurrentTagToken();
        break;
      }
      default: {
        this.state = State.ATTRIBUTE_VALUE_UNQUOTED;
        this._stateAttributeValueUnquoted(cp);
      }
    }
  }
  // Attribute value (double-quoted) state
  //------------------------------------------------------------------
  _stateAttributeValueDoubleQuoted(cp) {
    switch (cp) {
      case CODE_POINTS.QUOTATION_MARK: {
        this.state = State.AFTER_ATTRIBUTE_VALUE_QUOTED;
        break;
      }
      case CODE_POINTS.AMPERSAND: {
        this.returnState = State.ATTRIBUTE_VALUE_DOUBLE_QUOTED;
        this.state = State.CHARACTER_REFERENCE;
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        this.currentAttr.value += REPLACEMENT_CHARACTER;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInTag);
        this._emitEOFToken();
        break;
      }
      default: {
        this.currentAttr.value += String.fromCodePoint(cp);
      }
    }
  }
  // Attribute value (single-quoted) state
  //------------------------------------------------------------------
  _stateAttributeValueSingleQuoted(cp) {
    switch (cp) {
      case CODE_POINTS.APOSTROPHE: {
        this.state = State.AFTER_ATTRIBUTE_VALUE_QUOTED;
        break;
      }
      case CODE_POINTS.AMPERSAND: {
        this.returnState = State.ATTRIBUTE_VALUE_SINGLE_QUOTED;
        this.state = State.CHARACTER_REFERENCE;
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        this.currentAttr.value += REPLACEMENT_CHARACTER;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInTag);
        this._emitEOFToken();
        break;
      }
      default: {
        this.currentAttr.value += String.fromCodePoint(cp);
      }
    }
  }
  // Attribute value (unquoted) state
  //------------------------------------------------------------------
  _stateAttributeValueUnquoted(cp) {
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        this._leaveAttrValue();
        this.state = State.BEFORE_ATTRIBUTE_NAME;
        break;
      }
      case CODE_POINTS.AMPERSAND: {
        this.returnState = State.ATTRIBUTE_VALUE_UNQUOTED;
        this.state = State.CHARACTER_REFERENCE;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._leaveAttrValue();
        this.state = State.DATA;
        this.emitCurrentTagToken();
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        this.currentAttr.value += REPLACEMENT_CHARACTER;
        break;
      }
      case CODE_POINTS.QUOTATION_MARK:
      case CODE_POINTS.APOSTROPHE:
      case CODE_POINTS.LESS_THAN_SIGN:
      case CODE_POINTS.EQUALS_SIGN:
      case CODE_POINTS.GRAVE_ACCENT: {
        this._err(ERR.unexpectedCharacterInUnquotedAttributeValue);
        this.currentAttr.value += String.fromCodePoint(cp);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInTag);
        this._emitEOFToken();
        break;
      }
      default: {
        this.currentAttr.value += String.fromCodePoint(cp);
      }
    }
  }
  // After attribute value (quoted) state
  //------------------------------------------------------------------
  _stateAfterAttributeValueQuoted(cp) {
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        this._leaveAttrValue();
        this.state = State.BEFORE_ATTRIBUTE_NAME;
        break;
      }
      case CODE_POINTS.SOLIDUS: {
        this._leaveAttrValue();
        this.state = State.SELF_CLOSING_START_TAG;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._leaveAttrValue();
        this.state = State.DATA;
        this.emitCurrentTagToken();
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInTag);
        this._emitEOFToken();
        break;
      }
      default: {
        this._err(ERR.missingWhitespaceBetweenAttributes);
        this.state = State.BEFORE_ATTRIBUTE_NAME;
        this._stateBeforeAttributeName(cp);
      }
    }
  }
  // Self-closing start tag state
  //------------------------------------------------------------------
  _stateSelfClosingStartTag(cp) {
    switch (cp) {
      case CODE_POINTS.GREATER_THAN_SIGN: {
        const token = this.currentToken;
        token.selfClosing = true;
        this.state = State.DATA;
        this.emitCurrentTagToken();
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInTag);
        this._emitEOFToken();
        break;
      }
      default: {
        this._err(ERR.unexpectedSolidusInTag);
        this.state = State.BEFORE_ATTRIBUTE_NAME;
        this._stateBeforeAttributeName(cp);
      }
    }
  }
  // Bogus comment state
  //------------------------------------------------------------------
  _stateBogusComment(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.state = State.DATA;
        this.emitCurrentComment(token);
        break;
      }
      case CODE_POINTS.EOF: {
        this.emitCurrentComment(token);
        this._emitEOFToken();
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        token.data += REPLACEMENT_CHARACTER;
        break;
      }
      default: {
        token.data += String.fromCodePoint(cp);
      }
    }
  }
  // Markup declaration open state
  //------------------------------------------------------------------
  _stateMarkupDeclarationOpen(cp) {
    if (this._consumeSequenceIfMatch(SEQUENCES.DASH_DASH, true)) {
      this._createCommentToken(SEQUENCES.DASH_DASH.length + 1);
      this.state = State.COMMENT_START;
    } else if (this._consumeSequenceIfMatch(SEQUENCES.DOCTYPE, false)) {
      this.currentLocation = this.getCurrentLocation(SEQUENCES.DOCTYPE.length + 1);
      this.state = State.DOCTYPE;
    } else if (this._consumeSequenceIfMatch(SEQUENCES.CDATA_START, true)) {
      if (this.inForeignNode) {
        this.state = State.CDATA_SECTION;
      } else {
        this._err(ERR.cdataInHtmlContent);
        this._createCommentToken(SEQUENCES.CDATA_START.length + 1);
        this.currentToken.data = "[CDATA[";
        this.state = State.BOGUS_COMMENT;
      }
    } else if (!this._ensureHibernation()) {
      this._err(ERR.incorrectlyOpenedComment);
      this._createCommentToken(2);
      this.state = State.BOGUS_COMMENT;
      this._stateBogusComment(cp);
    }
  }
  // Comment start state
  //------------------------------------------------------------------
  _stateCommentStart(cp) {
    switch (cp) {
      case CODE_POINTS.HYPHEN_MINUS: {
        this.state = State.COMMENT_START_DASH;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(ERR.abruptClosingOfEmptyComment);
        this.state = State.DATA;
        const token = this.currentToken;
        this.emitCurrentComment(token);
        break;
      }
      default: {
        this.state = State.COMMENT;
        this._stateComment(cp);
      }
    }
  }
  // Comment start dash state
  //------------------------------------------------------------------
  _stateCommentStartDash(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.HYPHEN_MINUS: {
        this.state = State.COMMENT_END;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(ERR.abruptClosingOfEmptyComment);
        this.state = State.DATA;
        this.emitCurrentComment(token);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInComment);
        this.emitCurrentComment(token);
        this._emitEOFToken();
        break;
      }
      default: {
        token.data += "-";
        this.state = State.COMMENT;
        this._stateComment(cp);
      }
    }
  }
  // Comment state
  //------------------------------------------------------------------
  _stateComment(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.HYPHEN_MINUS: {
        this.state = State.COMMENT_END_DASH;
        break;
      }
      case CODE_POINTS.LESS_THAN_SIGN: {
        token.data += "<";
        this.state = State.COMMENT_LESS_THAN_SIGN;
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        token.data += REPLACEMENT_CHARACTER;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInComment);
        this.emitCurrentComment(token);
        this._emitEOFToken();
        break;
      }
      default: {
        token.data += String.fromCodePoint(cp);
      }
    }
  }
  // Comment less-than sign state
  //------------------------------------------------------------------
  _stateCommentLessThanSign(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.EXCLAMATION_MARK: {
        token.data += "!";
        this.state = State.COMMENT_LESS_THAN_SIGN_BANG;
        break;
      }
      case CODE_POINTS.LESS_THAN_SIGN: {
        token.data += "<";
        break;
      }
      default: {
        this.state = State.COMMENT;
        this._stateComment(cp);
      }
    }
  }
  // Comment less-than sign bang state
  //------------------------------------------------------------------
  _stateCommentLessThanSignBang(cp) {
    if (cp === CODE_POINTS.HYPHEN_MINUS) {
      this.state = State.COMMENT_LESS_THAN_SIGN_BANG_DASH;
    } else {
      this.state = State.COMMENT;
      this._stateComment(cp);
    }
  }
  // Comment less-than sign bang dash state
  //------------------------------------------------------------------
  _stateCommentLessThanSignBangDash(cp) {
    if (cp === CODE_POINTS.HYPHEN_MINUS) {
      this.state = State.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH;
    } else {
      this.state = State.COMMENT_END_DASH;
      this._stateCommentEndDash(cp);
    }
  }
  // Comment less-than sign bang dash dash state
  //------------------------------------------------------------------
  _stateCommentLessThanSignBangDashDash(cp) {
    if (cp !== CODE_POINTS.GREATER_THAN_SIGN && cp !== CODE_POINTS.EOF) {
      this._err(ERR.nestedComment);
    }
    this.state = State.COMMENT_END;
    this._stateCommentEnd(cp);
  }
  // Comment end dash state
  //------------------------------------------------------------------
  _stateCommentEndDash(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.HYPHEN_MINUS: {
        this.state = State.COMMENT_END;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInComment);
        this.emitCurrentComment(token);
        this._emitEOFToken();
        break;
      }
      default: {
        token.data += "-";
        this.state = State.COMMENT;
        this._stateComment(cp);
      }
    }
  }
  // Comment end state
  //------------------------------------------------------------------
  _stateCommentEnd(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.state = State.DATA;
        this.emitCurrentComment(token);
        break;
      }
      case CODE_POINTS.EXCLAMATION_MARK: {
        this.state = State.COMMENT_END_BANG;
        break;
      }
      case CODE_POINTS.HYPHEN_MINUS: {
        token.data += "-";
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInComment);
        this.emitCurrentComment(token);
        this._emitEOFToken();
        break;
      }
      default: {
        token.data += "--";
        this.state = State.COMMENT;
        this._stateComment(cp);
      }
    }
  }
  // Comment end bang state
  //------------------------------------------------------------------
  _stateCommentEndBang(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.HYPHEN_MINUS: {
        token.data += "--!";
        this.state = State.COMMENT_END_DASH;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(ERR.incorrectlyClosedComment);
        this.state = State.DATA;
        this.emitCurrentComment(token);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInComment);
        this.emitCurrentComment(token);
        this._emitEOFToken();
        break;
      }
      default: {
        token.data += "--!";
        this.state = State.COMMENT;
        this._stateComment(cp);
      }
    }
  }
  // DOCTYPE state
  //------------------------------------------------------------------
  _stateDoctype(cp) {
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        this.state = State.BEFORE_DOCTYPE_NAME;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.state = State.BEFORE_DOCTYPE_NAME;
        this._stateBeforeDoctypeName(cp);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype);
        this._createDoctypeToken(null);
        const token = this.currentToken;
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this._emitEOFToken();
        break;
      }
      default: {
        this._err(ERR.missingWhitespaceBeforeDoctypeName);
        this.state = State.BEFORE_DOCTYPE_NAME;
        this._stateBeforeDoctypeName(cp);
      }
    }
  }
  // Before DOCTYPE name state
  //------------------------------------------------------------------
  _stateBeforeDoctypeName(cp) {
    if (isAsciiUpper(cp)) {
      this._createDoctypeToken(String.fromCharCode(toAsciiLower(cp)));
      this.state = State.DOCTYPE_NAME;
    } else
      switch (cp) {
        case CODE_POINTS.SPACE:
        case CODE_POINTS.LINE_FEED:
        case CODE_POINTS.TABULATION:
        case CODE_POINTS.FORM_FEED: {
          break;
        }
        case CODE_POINTS.NULL: {
          this._err(ERR.unexpectedNullCharacter);
          this._createDoctypeToken(REPLACEMENT_CHARACTER);
          this.state = State.DOCTYPE_NAME;
          break;
        }
        case CODE_POINTS.GREATER_THAN_SIGN: {
          this._err(ERR.missingDoctypeName);
          this._createDoctypeToken(null);
          const token = this.currentToken;
          token.forceQuirks = true;
          this.emitCurrentDoctype(token);
          this.state = State.DATA;
          break;
        }
        case CODE_POINTS.EOF: {
          this._err(ERR.eofInDoctype);
          this._createDoctypeToken(null);
          const token = this.currentToken;
          token.forceQuirks = true;
          this.emitCurrentDoctype(token);
          this._emitEOFToken();
          break;
        }
        default: {
          this._createDoctypeToken(String.fromCodePoint(cp));
          this.state = State.DOCTYPE_NAME;
        }
      }
  }
  // DOCTYPE name state
  //------------------------------------------------------------------
  _stateDoctypeName(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        this.state = State.AFTER_DOCTYPE_NAME;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.state = State.DATA;
        this.emitCurrentDoctype(token);
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        token.name += REPLACEMENT_CHARACTER;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this._emitEOFToken();
        break;
      }
      default: {
        token.name += String.fromCodePoint(isAsciiUpper(cp) ? toAsciiLower(cp) : cp);
      }
    }
  }
  // After DOCTYPE name state
  //------------------------------------------------------------------
  _stateAfterDoctypeName(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.state = State.DATA;
        this.emitCurrentDoctype(token);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this._emitEOFToken();
        break;
      }
      default: {
        if (this._consumeSequenceIfMatch(SEQUENCES.PUBLIC, false)) {
          this.state = State.AFTER_DOCTYPE_PUBLIC_KEYWORD;
        } else if (this._consumeSequenceIfMatch(SEQUENCES.SYSTEM, false)) {
          this.state = State.AFTER_DOCTYPE_SYSTEM_KEYWORD;
        } else if (!this._ensureHibernation()) {
          this._err(ERR.invalidCharacterSequenceAfterDoctypeName);
          token.forceQuirks = true;
          this.state = State.BOGUS_DOCTYPE;
          this._stateBogusDoctype(cp);
        }
      }
    }
  }
  // After DOCTYPE public keyword state
  //------------------------------------------------------------------
  _stateAfterDoctypePublicKeyword(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        this.state = State.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER;
        break;
      }
      case CODE_POINTS.QUOTATION_MARK: {
        this._err(ERR.missingWhitespaceAfterDoctypePublicKeyword);
        token.publicId = "";
        this.state = State.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case CODE_POINTS.APOSTROPHE: {
        this._err(ERR.missingWhitespaceAfterDoctypePublicKeyword);
        token.publicId = "";
        this.state = State.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(ERR.missingDoctypePublicIdentifier);
        token.forceQuirks = true;
        this.state = State.DATA;
        this.emitCurrentDoctype(token);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this._emitEOFToken();
        break;
      }
      default: {
        this._err(ERR.missingQuoteBeforeDoctypePublicIdentifier);
        token.forceQuirks = true;
        this.state = State.BOGUS_DOCTYPE;
        this._stateBogusDoctype(cp);
      }
    }
  }
  // Before DOCTYPE public identifier state
  //------------------------------------------------------------------
  _stateBeforeDoctypePublicIdentifier(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        break;
      }
      case CODE_POINTS.QUOTATION_MARK: {
        token.publicId = "";
        this.state = State.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case CODE_POINTS.APOSTROPHE: {
        token.publicId = "";
        this.state = State.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(ERR.missingDoctypePublicIdentifier);
        token.forceQuirks = true;
        this.state = State.DATA;
        this.emitCurrentDoctype(token);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this._emitEOFToken();
        break;
      }
      default: {
        this._err(ERR.missingQuoteBeforeDoctypePublicIdentifier);
        token.forceQuirks = true;
        this.state = State.BOGUS_DOCTYPE;
        this._stateBogusDoctype(cp);
      }
    }
  }
  // DOCTYPE public identifier (double-quoted) state
  //------------------------------------------------------------------
  _stateDoctypePublicIdentifierDoubleQuoted(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.QUOTATION_MARK: {
        this.state = State.AFTER_DOCTYPE_PUBLIC_IDENTIFIER;
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        token.publicId += REPLACEMENT_CHARACTER;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(ERR.abruptDoctypePublicIdentifier);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this.state = State.DATA;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this._emitEOFToken();
        break;
      }
      default: {
        token.publicId += String.fromCodePoint(cp);
      }
    }
  }
  // DOCTYPE public identifier (single-quoted) state
  //------------------------------------------------------------------
  _stateDoctypePublicIdentifierSingleQuoted(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.APOSTROPHE: {
        this.state = State.AFTER_DOCTYPE_PUBLIC_IDENTIFIER;
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        token.publicId += REPLACEMENT_CHARACTER;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(ERR.abruptDoctypePublicIdentifier);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this.state = State.DATA;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this._emitEOFToken();
        break;
      }
      default: {
        token.publicId += String.fromCodePoint(cp);
      }
    }
  }
  // After DOCTYPE public identifier state
  //------------------------------------------------------------------
  _stateAfterDoctypePublicIdentifier(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        this.state = State.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.state = State.DATA;
        this.emitCurrentDoctype(token);
        break;
      }
      case CODE_POINTS.QUOTATION_MARK: {
        this._err(ERR.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers);
        token.systemId = "";
        this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case CODE_POINTS.APOSTROPHE: {
        this._err(ERR.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers);
        token.systemId = "";
        this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this._emitEOFToken();
        break;
      }
      default: {
        this._err(ERR.missingQuoteBeforeDoctypeSystemIdentifier);
        token.forceQuirks = true;
        this.state = State.BOGUS_DOCTYPE;
        this._stateBogusDoctype(cp);
      }
    }
  }
  // Between DOCTYPE public and system identifiers state
  //------------------------------------------------------------------
  _stateBetweenDoctypePublicAndSystemIdentifiers(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.emitCurrentDoctype(token);
        this.state = State.DATA;
        break;
      }
      case CODE_POINTS.QUOTATION_MARK: {
        token.systemId = "";
        this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case CODE_POINTS.APOSTROPHE: {
        token.systemId = "";
        this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this._emitEOFToken();
        break;
      }
      default: {
        this._err(ERR.missingQuoteBeforeDoctypeSystemIdentifier);
        token.forceQuirks = true;
        this.state = State.BOGUS_DOCTYPE;
        this._stateBogusDoctype(cp);
      }
    }
  }
  // After DOCTYPE system keyword state
  //------------------------------------------------------------------
  _stateAfterDoctypeSystemKeyword(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        this.state = State.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER;
        break;
      }
      case CODE_POINTS.QUOTATION_MARK: {
        this._err(ERR.missingWhitespaceAfterDoctypeSystemKeyword);
        token.systemId = "";
        this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case CODE_POINTS.APOSTROPHE: {
        this._err(ERR.missingWhitespaceAfterDoctypeSystemKeyword);
        token.systemId = "";
        this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(ERR.missingDoctypeSystemIdentifier);
        token.forceQuirks = true;
        this.state = State.DATA;
        this.emitCurrentDoctype(token);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this._emitEOFToken();
        break;
      }
      default: {
        this._err(ERR.missingQuoteBeforeDoctypeSystemIdentifier);
        token.forceQuirks = true;
        this.state = State.BOGUS_DOCTYPE;
        this._stateBogusDoctype(cp);
      }
    }
  }
  // Before DOCTYPE system identifier state
  //------------------------------------------------------------------
  _stateBeforeDoctypeSystemIdentifier(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        break;
      }
      case CODE_POINTS.QUOTATION_MARK: {
        token.systemId = "";
        this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case CODE_POINTS.APOSTROPHE: {
        token.systemId = "";
        this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(ERR.missingDoctypeSystemIdentifier);
        token.forceQuirks = true;
        this.state = State.DATA;
        this.emitCurrentDoctype(token);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this._emitEOFToken();
        break;
      }
      default: {
        this._err(ERR.missingQuoteBeforeDoctypeSystemIdentifier);
        token.forceQuirks = true;
        this.state = State.BOGUS_DOCTYPE;
        this._stateBogusDoctype(cp);
      }
    }
  }
  // DOCTYPE system identifier (double-quoted) state
  //------------------------------------------------------------------
  _stateDoctypeSystemIdentifierDoubleQuoted(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.QUOTATION_MARK: {
        this.state = State.AFTER_DOCTYPE_SYSTEM_IDENTIFIER;
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        token.systemId += REPLACEMENT_CHARACTER;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(ERR.abruptDoctypeSystemIdentifier);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this.state = State.DATA;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this._emitEOFToken();
        break;
      }
      default: {
        token.systemId += String.fromCodePoint(cp);
      }
    }
  }
  // DOCTYPE system identifier (single-quoted) state
  //------------------------------------------------------------------
  _stateDoctypeSystemIdentifierSingleQuoted(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.APOSTROPHE: {
        this.state = State.AFTER_DOCTYPE_SYSTEM_IDENTIFIER;
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        token.systemId += REPLACEMENT_CHARACTER;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(ERR.abruptDoctypeSystemIdentifier);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this.state = State.DATA;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this._emitEOFToken();
        break;
      }
      default: {
        token.systemId += String.fromCodePoint(cp);
      }
    }
  }
  // After DOCTYPE system identifier state
  //------------------------------------------------------------------
  _stateAfterDoctypeSystemIdentifier(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.emitCurrentDoctype(token);
        this.state = State.DATA;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this._emitEOFToken();
        break;
      }
      default: {
        this._err(ERR.unexpectedCharacterAfterDoctypeSystemIdentifier);
        this.state = State.BOGUS_DOCTYPE;
        this._stateBogusDoctype(cp);
      }
    }
  }
  // Bogus DOCTYPE state
  //------------------------------------------------------------------
  _stateBogusDoctype(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.emitCurrentDoctype(token);
        this.state = State.DATA;
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        break;
      }
      case CODE_POINTS.EOF: {
        this.emitCurrentDoctype(token);
        this._emitEOFToken();
        break;
      }
      default:
    }
  }
  // CDATA section state
  //------------------------------------------------------------------
  _stateCdataSection(cp) {
    switch (cp) {
      case CODE_POINTS.RIGHT_SQUARE_BRACKET: {
        this.state = State.CDATA_SECTION_BRACKET;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInCdata);
        this._emitEOFToken();
        break;
      }
      default: {
        this._emitCodePoint(cp);
      }
    }
  }
  // CDATA section bracket state
  //------------------------------------------------------------------
  _stateCdataSectionBracket(cp) {
    if (cp === CODE_POINTS.RIGHT_SQUARE_BRACKET) {
      this.state = State.CDATA_SECTION_END;
    } else {
      this._emitChars("]");
      this.state = State.CDATA_SECTION;
      this._stateCdataSection(cp);
    }
  }
  // CDATA section end state
  //------------------------------------------------------------------
  _stateCdataSectionEnd(cp) {
    switch (cp) {
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.state = State.DATA;
        break;
      }
      case CODE_POINTS.RIGHT_SQUARE_BRACKET: {
        this._emitChars("]");
        break;
      }
      default: {
        this._emitChars("]]");
        this.state = State.CDATA_SECTION;
        this._stateCdataSection(cp);
      }
    }
  }
  // Character reference state
  //------------------------------------------------------------------
  _stateCharacterReference(cp) {
    if (cp === CODE_POINTS.NUMBER_SIGN) {
      this.state = State.NUMERIC_CHARACTER_REFERENCE;
    } else if (isAsciiAlphaNumeric2(cp)) {
      this.state = State.NAMED_CHARACTER_REFERENCE;
      this._stateNamedCharacterReference(cp);
    } else {
      this._flushCodePointConsumedAsCharacterReference(CODE_POINTS.AMPERSAND);
      this._reconsumeInState(this.returnState, cp);
    }
  }
  // Named character reference state
  //------------------------------------------------------------------
  _stateNamedCharacterReference(cp) {
    const matchResult = this._matchNamedCharacterReference(cp);
    if (this._ensureHibernation()) {
    } else if (matchResult) {
      for (let i = 0; i < matchResult.length; i++) {
        this._flushCodePointConsumedAsCharacterReference(matchResult[i]);
      }
      this.state = this.returnState;
    } else {
      this._flushCodePointConsumedAsCharacterReference(CODE_POINTS.AMPERSAND);
      this.state = State.AMBIGUOUS_AMPERSAND;
    }
  }
  // Ambiguos ampersand state
  //------------------------------------------------------------------
  _stateAmbiguousAmpersand(cp) {
    if (isAsciiAlphaNumeric2(cp)) {
      this._flushCodePointConsumedAsCharacterReference(cp);
    } else {
      if (cp === CODE_POINTS.SEMICOLON) {
        this._err(ERR.unknownNamedCharacterReference);
      }
      this._reconsumeInState(this.returnState, cp);
    }
  }
  // Numeric character reference state
  //------------------------------------------------------------------
  _stateNumericCharacterReference(cp) {
    this.charRefCode = 0;
    if (cp === CODE_POINTS.LATIN_SMALL_X || cp === CODE_POINTS.LATIN_CAPITAL_X) {
      this.state = State.HEXADEMICAL_CHARACTER_REFERENCE_START;
    } else if (isAsciiDigit(cp)) {
      this.state = State.DECIMAL_CHARACTER_REFERENCE;
      this._stateDecimalCharacterReference(cp);
    } else {
      this._err(ERR.absenceOfDigitsInNumericCharacterReference);
      this._flushCodePointConsumedAsCharacterReference(CODE_POINTS.AMPERSAND);
      this._flushCodePointConsumedAsCharacterReference(CODE_POINTS.NUMBER_SIGN);
      this._reconsumeInState(this.returnState, cp);
    }
  }
  // Hexademical character reference start state
  //------------------------------------------------------------------
  _stateHexademicalCharacterReferenceStart(cp) {
    if (isAsciiHexDigit(cp)) {
      this.state = State.HEXADEMICAL_CHARACTER_REFERENCE;
      this._stateHexademicalCharacterReference(cp);
    } else {
      this._err(ERR.absenceOfDigitsInNumericCharacterReference);
      this._flushCodePointConsumedAsCharacterReference(CODE_POINTS.AMPERSAND);
      this._flushCodePointConsumedAsCharacterReference(CODE_POINTS.NUMBER_SIGN);
      this._unconsume(2);
      this.state = this.returnState;
    }
  }
  // Hexademical character reference state
  //------------------------------------------------------------------
  _stateHexademicalCharacterReference(cp) {
    if (isAsciiUpperHexDigit(cp)) {
      this.charRefCode = this.charRefCode * 16 + cp - 55;
    } else if (isAsciiLowerHexDigit(cp)) {
      this.charRefCode = this.charRefCode * 16 + cp - 87;
    } else if (isAsciiDigit(cp)) {
      this.charRefCode = this.charRefCode * 16 + cp - 48;
    } else if (cp === CODE_POINTS.SEMICOLON) {
      this.state = State.NUMERIC_CHARACTER_REFERENCE_END;
    } else {
      this._err(ERR.missingSemicolonAfterCharacterReference);
      this.state = State.NUMERIC_CHARACTER_REFERENCE_END;
      this._stateNumericCharacterReferenceEnd(cp);
    }
  }
  // Decimal character reference state
  //------------------------------------------------------------------
  _stateDecimalCharacterReference(cp) {
    if (isAsciiDigit(cp)) {
      this.charRefCode = this.charRefCode * 10 + cp - 48;
    } else if (cp === CODE_POINTS.SEMICOLON) {
      this.state = State.NUMERIC_CHARACTER_REFERENCE_END;
    } else {
      this._err(ERR.missingSemicolonAfterCharacterReference);
      this.state = State.NUMERIC_CHARACTER_REFERENCE_END;
      this._stateNumericCharacterReferenceEnd(cp);
    }
  }
  // Numeric character reference end state
  //------------------------------------------------------------------
  _stateNumericCharacterReferenceEnd(cp) {
    if (this.charRefCode === CODE_POINTS.NULL) {
      this._err(ERR.nullCharacterReference);
      this.charRefCode = CODE_POINTS.REPLACEMENT_CHARACTER;
    } else if (this.charRefCode > 1114111) {
      this._err(ERR.characterReferenceOutsideUnicodeRange);
      this.charRefCode = CODE_POINTS.REPLACEMENT_CHARACTER;
    } else if (isSurrogate(this.charRefCode)) {
      this._err(ERR.surrogateCharacterReference);
      this.charRefCode = CODE_POINTS.REPLACEMENT_CHARACTER;
    } else if (isUndefinedCodePoint(this.charRefCode)) {
      this._err(ERR.noncharacterCharacterReference);
    } else if (isControlCodePoint(this.charRefCode) || this.charRefCode === CODE_POINTS.CARRIAGE_RETURN) {
      this._err(ERR.controlCharacterReference);
      const replacement = C1_CONTROLS_REFERENCE_REPLACEMENTS.get(this.charRefCode);
      if (replacement !== void 0) {
        this.charRefCode = replacement;
      }
    }
    this._flushCodePointConsumedAsCharacterReference(this.charRefCode);
    this._reconsumeInState(this.returnState, cp);
  }
};

// node_modules/.pnpm/parse5@7.1.2/node_modules/parse5/dist/parser/open-element-stack.js
var IMPLICIT_END_TAG_REQUIRED = /* @__PURE__ */ new Set([TAG_ID.DD, TAG_ID.DT, TAG_ID.LI, TAG_ID.OPTGROUP, TAG_ID.OPTION, TAG_ID.P, TAG_ID.RB, TAG_ID.RP, TAG_ID.RT, TAG_ID.RTC]);
var IMPLICIT_END_TAG_REQUIRED_THOROUGHLY = /* @__PURE__ */ new Set([
  ...IMPLICIT_END_TAG_REQUIRED,
  TAG_ID.CAPTION,
  TAG_ID.COLGROUP,
  TAG_ID.TBODY,
  TAG_ID.TD,
  TAG_ID.TFOOT,
  TAG_ID.TH,
  TAG_ID.THEAD,
  TAG_ID.TR
]);
var SCOPING_ELEMENT_NS = /* @__PURE__ */ new Map([
  [TAG_ID.APPLET, NS.HTML],
  [TAG_ID.CAPTION, NS.HTML],
  [TAG_ID.HTML, NS.HTML],
  [TAG_ID.MARQUEE, NS.HTML],
  [TAG_ID.OBJECT, NS.HTML],
  [TAG_ID.TABLE, NS.HTML],
  [TAG_ID.TD, NS.HTML],
  [TAG_ID.TEMPLATE, NS.HTML],
  [TAG_ID.TH, NS.HTML],
  [TAG_ID.ANNOTATION_XML, NS.MATHML],
  [TAG_ID.MI, NS.MATHML],
  [TAG_ID.MN, NS.MATHML],
  [TAG_ID.MO, NS.MATHML],
  [TAG_ID.MS, NS.MATHML],
  [TAG_ID.MTEXT, NS.MATHML],
  [TAG_ID.DESC, NS.SVG],
  [TAG_ID.FOREIGN_OBJECT, NS.SVG],
  [TAG_ID.TITLE, NS.SVG]
]);
var NAMED_HEADERS = [TAG_ID.H1, TAG_ID.H2, TAG_ID.H3, TAG_ID.H4, TAG_ID.H5, TAG_ID.H6];
var TABLE_ROW_CONTEXT = [TAG_ID.TR, TAG_ID.TEMPLATE, TAG_ID.HTML];
var TABLE_BODY_CONTEXT = [TAG_ID.TBODY, TAG_ID.TFOOT, TAG_ID.THEAD, TAG_ID.TEMPLATE, TAG_ID.HTML];
var TABLE_CONTEXT = [TAG_ID.TABLE, TAG_ID.TEMPLATE, TAG_ID.HTML];
var TABLE_CELLS = [TAG_ID.TD, TAG_ID.TH];
var OpenElementStack = class {
  get currentTmplContentOrNode() {
    return this._isInTemplate() ? this.treeAdapter.getTemplateContent(this.current) : this.current;
  }
  constructor(document2, treeAdapter, handler) {
    this.treeAdapter = treeAdapter;
    this.handler = handler;
    this.items = [];
    this.tagIDs = [];
    this.stackTop = -1;
    this.tmplCount = 0;
    this.currentTagId = TAG_ID.UNKNOWN;
    this.current = document2;
  }
  //Index of element
  _indexOf(element) {
    return this.items.lastIndexOf(element, this.stackTop);
  }
  //Update current element
  _isInTemplate() {
    return this.currentTagId === TAG_ID.TEMPLATE && this.treeAdapter.getNamespaceURI(this.current) === NS.HTML;
  }
  _updateCurrentElement() {
    this.current = this.items[this.stackTop];
    this.currentTagId = this.tagIDs[this.stackTop];
  }
  //Mutations
  push(element, tagID) {
    this.stackTop++;
    this.items[this.stackTop] = element;
    this.current = element;
    this.tagIDs[this.stackTop] = tagID;
    this.currentTagId = tagID;
    if (this._isInTemplate()) {
      this.tmplCount++;
    }
    this.handler.onItemPush(element, tagID, true);
  }
  pop() {
    const popped = this.current;
    if (this.tmplCount > 0 && this._isInTemplate()) {
      this.tmplCount--;
    }
    this.stackTop--;
    this._updateCurrentElement();
    this.handler.onItemPop(popped, true);
  }
  replace(oldElement, newElement) {
    const idx = this._indexOf(oldElement);
    this.items[idx] = newElement;
    if (idx === this.stackTop) {
      this.current = newElement;
    }
  }
  insertAfter(referenceElement, newElement, newElementID) {
    const insertionIdx = this._indexOf(referenceElement) + 1;
    this.items.splice(insertionIdx, 0, newElement);
    this.tagIDs.splice(insertionIdx, 0, newElementID);
    this.stackTop++;
    if (insertionIdx === this.stackTop) {
      this._updateCurrentElement();
    }
    this.handler.onItemPush(this.current, this.currentTagId, insertionIdx === this.stackTop);
  }
  popUntilTagNamePopped(tagName) {
    let targetIdx = this.stackTop + 1;
    do {
      targetIdx = this.tagIDs.lastIndexOf(tagName, targetIdx - 1);
    } while (targetIdx > 0 && this.treeAdapter.getNamespaceURI(this.items[targetIdx]) !== NS.HTML);
    this.shortenToLength(targetIdx < 0 ? 0 : targetIdx);
  }
  shortenToLength(idx) {
    while (this.stackTop >= idx) {
      const popped = this.current;
      if (this.tmplCount > 0 && this._isInTemplate()) {
        this.tmplCount -= 1;
      }
      this.stackTop--;
      this._updateCurrentElement();
      this.handler.onItemPop(popped, this.stackTop < idx);
    }
  }
  popUntilElementPopped(element) {
    const idx = this._indexOf(element);
    this.shortenToLength(idx < 0 ? 0 : idx);
  }
  popUntilPopped(tagNames, targetNS) {
    const idx = this._indexOfTagNames(tagNames, targetNS);
    this.shortenToLength(idx < 0 ? 0 : idx);
  }
  popUntilNumberedHeaderPopped() {
    this.popUntilPopped(NAMED_HEADERS, NS.HTML);
  }
  popUntilTableCellPopped() {
    this.popUntilPopped(TABLE_CELLS, NS.HTML);
  }
  popAllUpToHtmlElement() {
    this.tmplCount = 0;
    this.shortenToLength(1);
  }
  _indexOfTagNames(tagNames, namespace) {
    for (let i = this.stackTop; i >= 0; i--) {
      if (tagNames.includes(this.tagIDs[i]) && this.treeAdapter.getNamespaceURI(this.items[i]) === namespace) {
        return i;
      }
    }
    return -1;
  }
  clearBackTo(tagNames, targetNS) {
    const idx = this._indexOfTagNames(tagNames, targetNS);
    this.shortenToLength(idx + 1);
  }
  clearBackToTableContext() {
    this.clearBackTo(TABLE_CONTEXT, NS.HTML);
  }
  clearBackToTableBodyContext() {
    this.clearBackTo(TABLE_BODY_CONTEXT, NS.HTML);
  }
  clearBackToTableRowContext() {
    this.clearBackTo(TABLE_ROW_CONTEXT, NS.HTML);
  }
  remove(element) {
    const idx = this._indexOf(element);
    if (idx >= 0) {
      if (idx === this.stackTop) {
        this.pop();
      } else {
        this.items.splice(idx, 1);
        this.tagIDs.splice(idx, 1);
        this.stackTop--;
        this._updateCurrentElement();
        this.handler.onItemPop(element, false);
      }
    }
  }
  //Search
  tryPeekProperlyNestedBodyElement() {
    return this.stackTop >= 1 && this.tagIDs[1] === TAG_ID.BODY ? this.items[1] : null;
  }
  contains(element) {
    return this._indexOf(element) > -1;
  }
  getCommonAncestor(element) {
    const elementIdx = this._indexOf(element) - 1;
    return elementIdx >= 0 ? this.items[elementIdx] : null;
  }
  isRootHtmlElementCurrent() {
    return this.stackTop === 0 && this.tagIDs[0] === TAG_ID.HTML;
  }
  //Element in scope
  hasInScope(tagName) {
    for (let i = this.stackTop; i >= 0; i--) {
      const tn = this.tagIDs[i];
      const ns = this.treeAdapter.getNamespaceURI(this.items[i]);
      if (tn === tagName && ns === NS.HTML) {
        return true;
      }
      if (SCOPING_ELEMENT_NS.get(tn) === ns) {
        return false;
      }
    }
    return true;
  }
  hasNumberedHeaderInScope() {
    for (let i = this.stackTop; i >= 0; i--) {
      const tn = this.tagIDs[i];
      const ns = this.treeAdapter.getNamespaceURI(this.items[i]);
      if (isNumberedHeader(tn) && ns === NS.HTML) {
        return true;
      }
      if (SCOPING_ELEMENT_NS.get(tn) === ns) {
        return false;
      }
    }
    return true;
  }
  hasInListItemScope(tagName) {
    for (let i = this.stackTop; i >= 0; i--) {
      const tn = this.tagIDs[i];
      const ns = this.treeAdapter.getNamespaceURI(this.items[i]);
      if (tn === tagName && ns === NS.HTML) {
        return true;
      }
      if ((tn === TAG_ID.UL || tn === TAG_ID.OL) && ns === NS.HTML || SCOPING_ELEMENT_NS.get(tn) === ns) {
        return false;
      }
    }
    return true;
  }
  hasInButtonScope(tagName) {
    for (let i = this.stackTop; i >= 0; i--) {
      const tn = this.tagIDs[i];
      const ns = this.treeAdapter.getNamespaceURI(this.items[i]);
      if (tn === tagName && ns === NS.HTML) {
        return true;
      }
      if (tn === TAG_ID.BUTTON && ns === NS.HTML || SCOPING_ELEMENT_NS.get(tn) === ns) {
        return false;
      }
    }
    return true;
  }
  hasInTableScope(tagName) {
    for (let i = this.stackTop; i >= 0; i--) {
      const tn = this.tagIDs[i];
      const ns = this.treeAdapter.getNamespaceURI(this.items[i]);
      if (ns !== NS.HTML) {
        continue;
      }
      if (tn === tagName) {
        return true;
      }
      if (tn === TAG_ID.TABLE || tn === TAG_ID.TEMPLATE || tn === TAG_ID.HTML) {
        return false;
      }
    }
    return true;
  }
  hasTableBodyContextInTableScope() {
    for (let i = this.stackTop; i >= 0; i--) {
      const tn = this.tagIDs[i];
      const ns = this.treeAdapter.getNamespaceURI(this.items[i]);
      if (ns !== NS.HTML) {
        continue;
      }
      if (tn === TAG_ID.TBODY || tn === TAG_ID.THEAD || tn === TAG_ID.TFOOT) {
        return true;
      }
      if (tn === TAG_ID.TABLE || tn === TAG_ID.HTML) {
        return false;
      }
    }
    return true;
  }
  hasInSelectScope(tagName) {
    for (let i = this.stackTop; i >= 0; i--) {
      const tn = this.tagIDs[i];
      const ns = this.treeAdapter.getNamespaceURI(this.items[i]);
      if (ns !== NS.HTML) {
        continue;
      }
      if (tn === tagName) {
        return true;
      }
      if (tn !== TAG_ID.OPTION && tn !== TAG_ID.OPTGROUP) {
        return false;
      }
    }
    return true;
  }
  //Implied end tags
  generateImpliedEndTags() {
    while (IMPLICIT_END_TAG_REQUIRED.has(this.currentTagId)) {
      this.pop();
    }
  }
  generateImpliedEndTagsThoroughly() {
    while (IMPLICIT_END_TAG_REQUIRED_THOROUGHLY.has(this.currentTagId)) {
      this.pop();
    }
  }
  generateImpliedEndTagsWithExclusion(exclusionId) {
    while (this.currentTagId !== exclusionId && IMPLICIT_END_TAG_REQUIRED_THOROUGHLY.has(this.currentTagId)) {
      this.pop();
    }
  }
};

// node_modules/.pnpm/parse5@7.1.2/node_modules/parse5/dist/parser/formatting-element-list.js
var NOAH_ARK_CAPACITY = 3;
var EntryType;
(function(EntryType2) {
  EntryType2[EntryType2["Marker"] = 0] = "Marker";
  EntryType2[EntryType2["Element"] = 1] = "Element";
})(EntryType = EntryType || (EntryType = {}));
var MARKER = { type: EntryType.Marker };
var FormattingElementList = class {
  constructor(treeAdapter) {
    this.treeAdapter = treeAdapter;
    this.entries = [];
    this.bookmark = null;
  }
  //Noah Ark's condition
  //OPTIMIZATION: at first we try to find possible candidates for exclusion using
  //lightweight heuristics without thorough attributes check.
  _getNoahArkConditionCandidates(newElement, neAttrs) {
    const candidates = [];
    const neAttrsLength = neAttrs.length;
    const neTagName = this.treeAdapter.getTagName(newElement);
    const neNamespaceURI = this.treeAdapter.getNamespaceURI(newElement);
    for (let i = 0; i < this.entries.length; i++) {
      const entry = this.entries[i];
      if (entry.type === EntryType.Marker) {
        break;
      }
      const { element } = entry;
      if (this.treeAdapter.getTagName(element) === neTagName && this.treeAdapter.getNamespaceURI(element) === neNamespaceURI) {
        const elementAttrs = this.treeAdapter.getAttrList(element);
        if (elementAttrs.length === neAttrsLength) {
          candidates.push({ idx: i, attrs: elementAttrs });
        }
      }
    }
    return candidates;
  }
  _ensureNoahArkCondition(newElement) {
    if (this.entries.length < NOAH_ARK_CAPACITY)
      return;
    const neAttrs = this.treeAdapter.getAttrList(newElement);
    const candidates = this._getNoahArkConditionCandidates(newElement, neAttrs);
    if (candidates.length < NOAH_ARK_CAPACITY)
      return;
    const neAttrsMap = new Map(neAttrs.map((neAttr) => [neAttr.name, neAttr.value]));
    let validCandidates = 0;
    for (let i = 0; i < candidates.length; i++) {
      const candidate = candidates[i];
      if (candidate.attrs.every((cAttr) => neAttrsMap.get(cAttr.name) === cAttr.value)) {
        validCandidates += 1;
        if (validCandidates >= NOAH_ARK_CAPACITY) {
          this.entries.splice(candidate.idx, 1);
        }
      }
    }
  }
  //Mutations
  insertMarker() {
    this.entries.unshift(MARKER);
  }
  pushElement(element, token) {
    this._ensureNoahArkCondition(element);
    this.entries.unshift({
      type: EntryType.Element,
      element,
      token
    });
  }
  insertElementAfterBookmark(element, token) {
    const bookmarkIdx = this.entries.indexOf(this.bookmark);
    this.entries.splice(bookmarkIdx, 0, {
      type: EntryType.Element,
      element,
      token
    });
  }
  removeEntry(entry) {
    const entryIndex = this.entries.indexOf(entry);
    if (entryIndex >= 0) {
      this.entries.splice(entryIndex, 1);
    }
  }
  /**
   * Clears the list of formatting elements up to the last marker.
   *
   * @see https://html.spec.whatwg.org/multipage/parsing.html#clear-the-list-of-active-formatting-elements-up-to-the-last-marker
   */
  clearToLastMarker() {
    const markerIdx = this.entries.indexOf(MARKER);
    if (markerIdx >= 0) {
      this.entries.splice(0, markerIdx + 1);
    } else {
      this.entries.length = 0;
    }
  }
  //Search
  getElementEntryInScopeWithTagName(tagName) {
    const entry = this.entries.find((entry2) => entry2.type === EntryType.Marker || this.treeAdapter.getTagName(entry2.element) === tagName);
    return entry && entry.type === EntryType.Element ? entry : null;
  }
  getElementEntry(element) {
    return this.entries.find((entry) => entry.type === EntryType.Element && entry.element === element);
  }
};

// node_modules/.pnpm/parse5@7.1.2/node_modules/parse5/dist/tree-adapters/default.js
function createTextNode(value) {
  return {
    nodeName: "#text",
    value,
    parentNode: null
  };
}
var defaultTreeAdapter = {
  //Node construction
  createDocument() {
    return {
      nodeName: "#document",
      mode: DOCUMENT_MODE.NO_QUIRKS,
      childNodes: []
    };
  },
  createDocumentFragment() {
    return {
      nodeName: "#document-fragment",
      childNodes: []
    };
  },
  createElement(tagName, namespaceURI, attrs) {
    return {
      nodeName: tagName,
      tagName,
      attrs,
      namespaceURI,
      childNodes: [],
      parentNode: null
    };
  },
  createCommentNode(data2) {
    return {
      nodeName: "#comment",
      data: data2,
      parentNode: null
    };
  },
  //Tree mutation
  appendChild(parentNode, newNode) {
    parentNode.childNodes.push(newNode);
    newNode.parentNode = parentNode;
  },
  insertBefore(parentNode, newNode, referenceNode) {
    const insertionIdx = parentNode.childNodes.indexOf(referenceNode);
    parentNode.childNodes.splice(insertionIdx, 0, newNode);
    newNode.parentNode = parentNode;
  },
  setTemplateContent(templateElement, contentElement) {
    templateElement.content = contentElement;
  },
  getTemplateContent(templateElement) {
    return templateElement.content;
  },
  setDocumentType(document2, name2, publicId, systemId) {
    const doctypeNode = document2.childNodes.find((node) => node.nodeName === "#documentType");
    if (doctypeNode) {
      doctypeNode.name = name2;
      doctypeNode.publicId = publicId;
      doctypeNode.systemId = systemId;
    } else {
      const node = {
        nodeName: "#documentType",
        name: name2,
        publicId,
        systemId,
        parentNode: null
      };
      defaultTreeAdapter.appendChild(document2, node);
    }
  },
  setDocumentMode(document2, mode) {
    document2.mode = mode;
  },
  getDocumentMode(document2) {
    return document2.mode;
  },
  detachNode(node) {
    if (node.parentNode) {
      const idx = node.parentNode.childNodes.indexOf(node);
      node.parentNode.childNodes.splice(idx, 1);
      node.parentNode = null;
    }
  },
  insertText(parentNode, text4) {
    if (parentNode.childNodes.length > 0) {
      const prevNode = parentNode.childNodes[parentNode.childNodes.length - 1];
      if (defaultTreeAdapter.isTextNode(prevNode)) {
        prevNode.value += text4;
        return;
      }
    }
    defaultTreeAdapter.appendChild(parentNode, createTextNode(text4));
  },
  insertTextBefore(parentNode, text4, referenceNode) {
    const prevNode = parentNode.childNodes[parentNode.childNodes.indexOf(referenceNode) - 1];
    if (prevNode && defaultTreeAdapter.isTextNode(prevNode)) {
      prevNode.value += text4;
    } else {
      defaultTreeAdapter.insertBefore(parentNode, createTextNode(text4), referenceNode);
    }
  },
  adoptAttributes(recipient, attrs) {
    const recipientAttrsMap = new Set(recipient.attrs.map((attr2) => attr2.name));
    for (let j = 0; j < attrs.length; j++) {
      if (!recipientAttrsMap.has(attrs[j].name)) {
        recipient.attrs.push(attrs[j]);
      }
    }
  },
  //Tree traversing
  getFirstChild(node) {
    return node.childNodes[0];
  },
  getChildNodes(node) {
    return node.childNodes;
  },
  getParentNode(node) {
    return node.parentNode;
  },
  getAttrList(element) {
    return element.attrs;
  },
  //Node data
  getTagName(element) {
    return element.tagName;
  },
  getNamespaceURI(element) {
    return element.namespaceURI;
  },
  getTextNodeContent(textNode) {
    return textNode.value;
  },
  getCommentNodeContent(commentNode) {
    return commentNode.data;
  },
  getDocumentTypeNodeName(doctypeNode) {
    return doctypeNode.name;
  },
  getDocumentTypeNodePublicId(doctypeNode) {
    return doctypeNode.publicId;
  },
  getDocumentTypeNodeSystemId(doctypeNode) {
    return doctypeNode.systemId;
  },
  //Node types
  isTextNode(node) {
    return node.nodeName === "#text";
  },
  isCommentNode(node) {
    return node.nodeName === "#comment";
  },
  isDocumentTypeNode(node) {
    return node.nodeName === "#documentType";
  },
  isElementNode(node) {
    return Object.prototype.hasOwnProperty.call(node, "tagName");
  },
  // Source code location
  setNodeSourceCodeLocation(node, location) {
    node.sourceCodeLocation = location;
  },
  getNodeSourceCodeLocation(node) {
    return node.sourceCodeLocation;
  },
  updateNodeSourceCodeLocation(node, endLocation) {
    node.sourceCodeLocation = { ...node.sourceCodeLocation, ...endLocation };
  }
};

// node_modules/.pnpm/parse5@7.1.2/node_modules/parse5/dist/common/doctype.js
var VALID_DOCTYPE_NAME = "html";
var VALID_SYSTEM_ID = "about:legacy-compat";
var QUIRKS_MODE_SYSTEM_ID = "http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd";
var QUIRKS_MODE_PUBLIC_ID_PREFIXES = [
  "+//silmaril//dtd html pro v0r11 19970101//",
  "-//as//dtd html 3.0 aswedit + extensions//",
  "-//advasoft ltd//dtd html 3.0 aswedit + extensions//",
  "-//ietf//dtd html 2.0 level 1//",
  "-//ietf//dtd html 2.0 level 2//",
  "-//ietf//dtd html 2.0 strict level 1//",
  "-//ietf//dtd html 2.0 strict level 2//",
  "-//ietf//dtd html 2.0 strict//",
  "-//ietf//dtd html 2.0//",
  "-//ietf//dtd html 2.1e//",
  "-//ietf//dtd html 3.0//",
  "-//ietf//dtd html 3.2 final//",
  "-//ietf//dtd html 3.2//",
  "-//ietf//dtd html 3//",
  "-//ietf//dtd html level 0//",
  "-//ietf//dtd html level 1//",
  "-//ietf//dtd html level 2//",
  "-//ietf//dtd html level 3//",
  "-//ietf//dtd html strict level 0//",
  "-//ietf//dtd html strict level 1//",
  "-//ietf//dtd html strict level 2//",
  "-//ietf//dtd html strict level 3//",
  "-//ietf//dtd html strict//",
  "-//ietf//dtd html//",
  "-//metrius//dtd metrius presentational//",
  "-//microsoft//dtd internet explorer 2.0 html strict//",
  "-//microsoft//dtd internet explorer 2.0 html//",
  "-//microsoft//dtd internet explorer 2.0 tables//",
  "-//microsoft//dtd internet explorer 3.0 html strict//",
  "-//microsoft//dtd internet explorer 3.0 html//",
  "-//microsoft//dtd internet explorer 3.0 tables//",
  "-//netscape comm. corp.//dtd html//",
  "-//netscape comm. corp.//dtd strict html//",
  "-//o'reilly and associates//dtd html 2.0//",
  "-//o'reilly and associates//dtd html extended 1.0//",
  "-//o'reilly and associates//dtd html extended relaxed 1.0//",
  "-//sq//dtd html 2.0 hotmetal + extensions//",
  "-//softquad software//dtd hotmetal pro 6.0::19990601::extensions to html 4.0//",
  "-//softquad//dtd hotmetal pro 4.0::19971010::extensions to html 4.0//",
  "-//spyglass//dtd html 2.0 extended//",
  "-//sun microsystems corp.//dtd hotjava html//",
  "-//sun microsystems corp.//dtd hotjava strict html//",
  "-//w3c//dtd html 3 1995-03-24//",
  "-//w3c//dtd html 3.2 draft//",
  "-//w3c//dtd html 3.2 final//",
  "-//w3c//dtd html 3.2//",
  "-//w3c//dtd html 3.2s draft//",
  "-//w3c//dtd html 4.0 frameset//",
  "-//w3c//dtd html 4.0 transitional//",
  "-//w3c//dtd html experimental 19960712//",
  "-//w3c//dtd html experimental 970421//",
  "-//w3c//dtd w3 html//",
  "-//w3o//dtd w3 html 3.0//",
  "-//webtechs//dtd mozilla html 2.0//",
  "-//webtechs//dtd mozilla html//"
];
var QUIRKS_MODE_NO_SYSTEM_ID_PUBLIC_ID_PREFIXES = [
  ...QUIRKS_MODE_PUBLIC_ID_PREFIXES,
  "-//w3c//dtd html 4.01 frameset//",
  "-//w3c//dtd html 4.01 transitional//"
];
var QUIRKS_MODE_PUBLIC_IDS = /* @__PURE__ */ new Set([
  "-//w3o//dtd w3 html strict 3.0//en//",
  "-/w3c/dtd html 4.0 transitional/en",
  "html"
]);
var LIMITED_QUIRKS_PUBLIC_ID_PREFIXES = ["-//w3c//dtd xhtml 1.0 frameset//", "-//w3c//dtd xhtml 1.0 transitional//"];
var LIMITED_QUIRKS_WITH_SYSTEM_ID_PUBLIC_ID_PREFIXES = [
  ...LIMITED_QUIRKS_PUBLIC_ID_PREFIXES,
  "-//w3c//dtd html 4.01 frameset//",
  "-//w3c//dtd html 4.01 transitional//"
];
function hasPrefix(publicId, prefixes) {
  return prefixes.some((prefix) => publicId.startsWith(prefix));
}
function isConforming(token) {
  return token.name === VALID_DOCTYPE_NAME && token.publicId === null && (token.systemId === null || token.systemId === VALID_SYSTEM_ID);
}
function getDocumentMode(token) {
  if (token.name !== VALID_DOCTYPE_NAME) {
    return DOCUMENT_MODE.QUIRKS;
  }
  const { systemId } = token;
  if (systemId && systemId.toLowerCase() === QUIRKS_MODE_SYSTEM_ID) {
    return DOCUMENT_MODE.QUIRKS;
  }
  let { publicId } = token;
  if (publicId !== null) {
    publicId = publicId.toLowerCase();
    if (QUIRKS_MODE_PUBLIC_IDS.has(publicId)) {
      return DOCUMENT_MODE.QUIRKS;
    }
    let prefixes = systemId === null ? QUIRKS_MODE_NO_SYSTEM_ID_PUBLIC_ID_PREFIXES : QUIRKS_MODE_PUBLIC_ID_PREFIXES;
    if (hasPrefix(publicId, prefixes)) {
      return DOCUMENT_MODE.QUIRKS;
    }
    prefixes = systemId === null ? LIMITED_QUIRKS_PUBLIC_ID_PREFIXES : LIMITED_QUIRKS_WITH_SYSTEM_ID_PUBLIC_ID_PREFIXES;
    if (hasPrefix(publicId, prefixes)) {
      return DOCUMENT_MODE.LIMITED_QUIRKS;
    }
  }
  return DOCUMENT_MODE.NO_QUIRKS;
}

// node_modules/.pnpm/parse5@7.1.2/node_modules/parse5/dist/common/foreign-content.js
var foreign_content_exports = {};
__export(foreign_content_exports, {
  SVG_TAG_NAMES_ADJUSTMENT_MAP: () => SVG_TAG_NAMES_ADJUSTMENT_MAP,
  adjustTokenMathMLAttrs: () => adjustTokenMathMLAttrs,
  adjustTokenSVGAttrs: () => adjustTokenSVGAttrs,
  adjustTokenSVGTagName: () => adjustTokenSVGTagName,
  adjustTokenXMLAttrs: () => adjustTokenXMLAttrs,
  causesExit: () => causesExit,
  isIntegrationPoint: () => isIntegrationPoint
});
var MIME_TYPES = {
  TEXT_HTML: "text/html",
  APPLICATION_XML: "application/xhtml+xml"
};
var DEFINITION_URL_ATTR = "definitionurl";
var ADJUSTED_DEFINITION_URL_ATTR = "definitionURL";
var SVG_ATTRS_ADJUSTMENT_MAP = new Map([
  "attributeName",
  "attributeType",
  "baseFrequency",
  "baseProfile",
  "calcMode",
  "clipPathUnits",
  "diffuseConstant",
  "edgeMode",
  "filterUnits",
  "glyphRef",
  "gradientTransform",
  "gradientUnits",
  "kernelMatrix",
  "kernelUnitLength",
  "keyPoints",
  "keySplines",
  "keyTimes",
  "lengthAdjust",
  "limitingConeAngle",
  "markerHeight",
  "markerUnits",
  "markerWidth",
  "maskContentUnits",
  "maskUnits",
  "numOctaves",
  "pathLength",
  "patternContentUnits",
  "patternTransform",
  "patternUnits",
  "pointsAtX",
  "pointsAtY",
  "pointsAtZ",
  "preserveAlpha",
  "preserveAspectRatio",
  "primitiveUnits",
  "refX",
  "refY",
  "repeatCount",
  "repeatDur",
  "requiredExtensions",
  "requiredFeatures",
  "specularConstant",
  "specularExponent",
  "spreadMethod",
  "startOffset",
  "stdDeviation",
  "stitchTiles",
  "surfaceScale",
  "systemLanguage",
  "tableValues",
  "targetX",
  "targetY",
  "textLength",
  "viewBox",
  "viewTarget",
  "xChannelSelector",
  "yChannelSelector",
  "zoomAndPan"
].map((attr2) => [attr2.toLowerCase(), attr2]));
var XML_ATTRS_ADJUSTMENT_MAP = /* @__PURE__ */ new Map([
  ["xlink:actuate", { prefix: "xlink", name: "actuate", namespace: NS.XLINK }],
  ["xlink:arcrole", { prefix: "xlink", name: "arcrole", namespace: NS.XLINK }],
  ["xlink:href", { prefix: "xlink", name: "href", namespace: NS.XLINK }],
  ["xlink:role", { prefix: "xlink", name: "role", namespace: NS.XLINK }],
  ["xlink:show", { prefix: "xlink", name: "show", namespace: NS.XLINK }],
  ["xlink:title", { prefix: "xlink", name: "title", namespace: NS.XLINK }],
  ["xlink:type", { prefix: "xlink", name: "type", namespace: NS.XLINK }],
  ["xml:base", { prefix: "xml", name: "base", namespace: NS.XML }],
  ["xml:lang", { prefix: "xml", name: "lang", namespace: NS.XML }],
  ["xml:space", { prefix: "xml", name: "space", namespace: NS.XML }],
  ["xmlns", { prefix: "", name: "xmlns", namespace: NS.XMLNS }],
  ["xmlns:xlink", { prefix: "xmlns", name: "xlink", namespace: NS.XMLNS }]
]);
var SVG_TAG_NAMES_ADJUSTMENT_MAP = new Map([
  "altGlyph",
  "altGlyphDef",
  "altGlyphItem",
  "animateColor",
  "animateMotion",
  "animateTransform",
  "clipPath",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feDistantLight",
  "feFlood",
  "feFuncA",
  "feFuncB",
  "feFuncG",
  "feFuncR",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMergeNode",
  "feMorphology",
  "feOffset",
  "fePointLight",
  "feSpecularLighting",
  "feSpotLight",
  "feTile",
  "feTurbulence",
  "foreignObject",
  "glyphRef",
  "linearGradient",
  "radialGradient",
  "textPath"
].map((tn) => [tn.toLowerCase(), tn]));
var EXITS_FOREIGN_CONTENT = /* @__PURE__ */ new Set([
  TAG_ID.B,
  TAG_ID.BIG,
  TAG_ID.BLOCKQUOTE,
  TAG_ID.BODY,
  TAG_ID.BR,
  TAG_ID.CENTER,
  TAG_ID.CODE,
  TAG_ID.DD,
  TAG_ID.DIV,
  TAG_ID.DL,
  TAG_ID.DT,
  TAG_ID.EM,
  TAG_ID.EMBED,
  TAG_ID.H1,
  TAG_ID.H2,
  TAG_ID.H3,
  TAG_ID.H4,
  TAG_ID.H5,
  TAG_ID.H6,
  TAG_ID.HEAD,
  TAG_ID.HR,
  TAG_ID.I,
  TAG_ID.IMG,
  TAG_ID.LI,
  TAG_ID.LISTING,
  TAG_ID.MENU,
  TAG_ID.META,
  TAG_ID.NOBR,
  TAG_ID.OL,
  TAG_ID.P,
  TAG_ID.PRE,
  TAG_ID.RUBY,
  TAG_ID.S,
  TAG_ID.SMALL,
  TAG_ID.SPAN,
  TAG_ID.STRONG,
  TAG_ID.STRIKE,
  TAG_ID.SUB,
  TAG_ID.SUP,
  TAG_ID.TABLE,
  TAG_ID.TT,
  TAG_ID.U,
  TAG_ID.UL,
  TAG_ID.VAR
]);
function causesExit(startTagToken) {
  const tn = startTagToken.tagID;
  const isFontWithAttrs = tn === TAG_ID.FONT && startTagToken.attrs.some(({ name: name2 }) => name2 === ATTRS.COLOR || name2 === ATTRS.SIZE || name2 === ATTRS.FACE);
  return isFontWithAttrs || EXITS_FOREIGN_CONTENT.has(tn);
}
function adjustTokenMathMLAttrs(token) {
  for (let i = 0; i < token.attrs.length; i++) {
    if (token.attrs[i].name === DEFINITION_URL_ATTR) {
      token.attrs[i].name = ADJUSTED_DEFINITION_URL_ATTR;
      break;
    }
  }
}
function adjustTokenSVGAttrs(token) {
  for (let i = 0; i < token.attrs.length; i++) {
    const adjustedAttrName = SVG_ATTRS_ADJUSTMENT_MAP.get(token.attrs[i].name);
    if (adjustedAttrName != null) {
      token.attrs[i].name = adjustedAttrName;
    }
  }
}
function adjustTokenXMLAttrs(token) {
  for (let i = 0; i < token.attrs.length; i++) {
    const adjustedAttrEntry = XML_ATTRS_ADJUSTMENT_MAP.get(token.attrs[i].name);
    if (adjustedAttrEntry) {
      token.attrs[i].prefix = adjustedAttrEntry.prefix;
      token.attrs[i].name = adjustedAttrEntry.name;
      token.attrs[i].namespace = adjustedAttrEntry.namespace;
    }
  }
}
function adjustTokenSVGTagName(token) {
  const adjustedTagName = SVG_TAG_NAMES_ADJUSTMENT_MAP.get(token.tagName);
  if (adjustedTagName != null) {
    token.tagName = adjustedTagName;
    token.tagID = getTagID(token.tagName);
  }
}
function isMathMLTextIntegrationPoint(tn, ns) {
  return ns === NS.MATHML && (tn === TAG_ID.MI || tn === TAG_ID.MO || tn === TAG_ID.MN || tn === TAG_ID.MS || tn === TAG_ID.MTEXT);
}
function isHtmlIntegrationPoint(tn, ns, attrs) {
  if (ns === NS.MATHML && tn === TAG_ID.ANNOTATION_XML) {
    for (let i = 0; i < attrs.length; i++) {
      if (attrs[i].name === ATTRS.ENCODING) {
        const value = attrs[i].value.toLowerCase();
        return value === MIME_TYPES.TEXT_HTML || value === MIME_TYPES.APPLICATION_XML;
      }
    }
  }
  return ns === NS.SVG && (tn === TAG_ID.FOREIGN_OBJECT || tn === TAG_ID.DESC || tn === TAG_ID.TITLE);
}
function isIntegrationPoint(tn, ns, attrs, foreignNS) {
  return (!foreignNS || foreignNS === NS.HTML) && isHtmlIntegrationPoint(tn, ns, attrs) || (!foreignNS || foreignNS === NS.MATHML) && isMathMLTextIntegrationPoint(tn, ns);
}

// node_modules/.pnpm/parse5@7.1.2/node_modules/parse5/dist/parser/index.js
var HIDDEN_INPUT_TYPE = "hidden";
var AA_OUTER_LOOP_ITER = 8;
var AA_INNER_LOOP_ITER = 3;
var InsertionMode;
(function(InsertionMode2) {
  InsertionMode2[InsertionMode2["INITIAL"] = 0] = "INITIAL";
  InsertionMode2[InsertionMode2["BEFORE_HTML"] = 1] = "BEFORE_HTML";
  InsertionMode2[InsertionMode2["BEFORE_HEAD"] = 2] = "BEFORE_HEAD";
  InsertionMode2[InsertionMode2["IN_HEAD"] = 3] = "IN_HEAD";
  InsertionMode2[InsertionMode2["IN_HEAD_NO_SCRIPT"] = 4] = "IN_HEAD_NO_SCRIPT";
  InsertionMode2[InsertionMode2["AFTER_HEAD"] = 5] = "AFTER_HEAD";
  InsertionMode2[InsertionMode2["IN_BODY"] = 6] = "IN_BODY";
  InsertionMode2[InsertionMode2["TEXT"] = 7] = "TEXT";
  InsertionMode2[InsertionMode2["IN_TABLE"] = 8] = "IN_TABLE";
  InsertionMode2[InsertionMode2["IN_TABLE_TEXT"] = 9] = "IN_TABLE_TEXT";
  InsertionMode2[InsertionMode2["IN_CAPTION"] = 10] = "IN_CAPTION";
  InsertionMode2[InsertionMode2["IN_COLUMN_GROUP"] = 11] = "IN_COLUMN_GROUP";
  InsertionMode2[InsertionMode2["IN_TABLE_BODY"] = 12] = "IN_TABLE_BODY";
  InsertionMode2[InsertionMode2["IN_ROW"] = 13] = "IN_ROW";
  InsertionMode2[InsertionMode2["IN_CELL"] = 14] = "IN_CELL";
  InsertionMode2[InsertionMode2["IN_SELECT"] = 15] = "IN_SELECT";
  InsertionMode2[InsertionMode2["IN_SELECT_IN_TABLE"] = 16] = "IN_SELECT_IN_TABLE";
  InsertionMode2[InsertionMode2["IN_TEMPLATE"] = 17] = "IN_TEMPLATE";
  InsertionMode2[InsertionMode2["AFTER_BODY"] = 18] = "AFTER_BODY";
  InsertionMode2[InsertionMode2["IN_FRAMESET"] = 19] = "IN_FRAMESET";
  InsertionMode2[InsertionMode2["AFTER_FRAMESET"] = 20] = "AFTER_FRAMESET";
  InsertionMode2[InsertionMode2["AFTER_AFTER_BODY"] = 21] = "AFTER_AFTER_BODY";
  InsertionMode2[InsertionMode2["AFTER_AFTER_FRAMESET"] = 22] = "AFTER_AFTER_FRAMESET";
})(InsertionMode || (InsertionMode = {}));
var BASE_LOC = {
  startLine: -1,
  startCol: -1,
  startOffset: -1,
  endLine: -1,
  endCol: -1,
  endOffset: -1
};
var TABLE_STRUCTURE_TAGS = /* @__PURE__ */ new Set([TAG_ID.TABLE, TAG_ID.TBODY, TAG_ID.TFOOT, TAG_ID.THEAD, TAG_ID.TR]);
var defaultParserOptions = {
  scriptingEnabled: true,
  sourceCodeLocationInfo: false,
  treeAdapter: defaultTreeAdapter,
  onParseError: null
};
var Parser = class {
  constructor(options, document2, fragmentContext = null, scriptHandler = null) {
    this.fragmentContext = fragmentContext;
    this.scriptHandler = scriptHandler;
    this.currentToken = null;
    this.stopped = false;
    this.insertionMode = InsertionMode.INITIAL;
    this.originalInsertionMode = InsertionMode.INITIAL;
    this.headElement = null;
    this.formElement = null;
    this.currentNotInHTML = false;
    this.tmplInsertionModeStack = [];
    this.pendingCharacterTokens = [];
    this.hasNonWhitespacePendingCharacterToken = false;
    this.framesetOk = true;
    this.skipNextNewLine = false;
    this.fosterParentingEnabled = false;
    this.options = {
      ...defaultParserOptions,
      ...options
    };
    this.treeAdapter = this.options.treeAdapter;
    this.onParseError = this.options.onParseError;
    if (this.onParseError) {
      this.options.sourceCodeLocationInfo = true;
    }
    this.document = document2 !== null && document2 !== void 0 ? document2 : this.treeAdapter.createDocument();
    this.tokenizer = new Tokenizer(this.options, this);
    this.activeFormattingElements = new FormattingElementList(this.treeAdapter);
    this.fragmentContextID = fragmentContext ? getTagID(this.treeAdapter.getTagName(fragmentContext)) : TAG_ID.UNKNOWN;
    this._setContextModes(fragmentContext !== null && fragmentContext !== void 0 ? fragmentContext : this.document, this.fragmentContextID);
    this.openElements = new OpenElementStack(this.document, this.treeAdapter, this);
  }
  // API
  static parse(html3, options) {
    const parser = new this(options);
    parser.tokenizer.write(html3, true);
    return parser.document;
  }
  static getFragmentParser(fragmentContext, options) {
    const opts = {
      ...defaultParserOptions,
      ...options
    };
    fragmentContext !== null && fragmentContext !== void 0 ? fragmentContext : fragmentContext = opts.treeAdapter.createElement(TAG_NAMES.TEMPLATE, NS.HTML, []);
    const documentMock = opts.treeAdapter.createElement("documentmock", NS.HTML, []);
    const parser = new this(opts, documentMock, fragmentContext);
    if (parser.fragmentContextID === TAG_ID.TEMPLATE) {
      parser.tmplInsertionModeStack.unshift(InsertionMode.IN_TEMPLATE);
    }
    parser._initTokenizerForFragmentParsing();
    parser._insertFakeRootElement();
    parser._resetInsertionMode();
    parser._findFormInFragmentContext();
    return parser;
  }
  getFragment() {
    const rootElement = this.treeAdapter.getFirstChild(this.document);
    const fragment = this.treeAdapter.createDocumentFragment();
    this._adoptNodes(rootElement, fragment);
    return fragment;
  }
  //Errors
  _err(token, code2, beforeToken) {
    var _a2;
    if (!this.onParseError)
      return;
    const loc = (_a2 = token.location) !== null && _a2 !== void 0 ? _a2 : BASE_LOC;
    const err = {
      code: code2,
      startLine: loc.startLine,
      startCol: loc.startCol,
      startOffset: loc.startOffset,
      endLine: beforeToken ? loc.startLine : loc.endLine,
      endCol: beforeToken ? loc.startCol : loc.endCol,
      endOffset: beforeToken ? loc.startOffset : loc.endOffset
    };
    this.onParseError(err);
  }
  //Stack events
  onItemPush(node, tid, isTop) {
    var _a2, _b;
    (_b = (_a2 = this.treeAdapter).onItemPush) === null || _b === void 0 ? void 0 : _b.call(_a2, node);
    if (isTop && this.openElements.stackTop > 0)
      this._setContextModes(node, tid);
  }
  onItemPop(node, isTop) {
    var _a2, _b;
    if (this.options.sourceCodeLocationInfo) {
      this._setEndLocation(node, this.currentToken);
    }
    (_b = (_a2 = this.treeAdapter).onItemPop) === null || _b === void 0 ? void 0 : _b.call(_a2, node, this.openElements.current);
    if (isTop) {
      let current;
      let currentTagId;
      if (this.openElements.stackTop === 0 && this.fragmentContext) {
        current = this.fragmentContext;
        currentTagId = this.fragmentContextID;
      } else {
        ({ current, currentTagId } = this.openElements);
      }
      this._setContextModes(current, currentTagId);
    }
  }
  _setContextModes(current, tid) {
    const isHTML = current === this.document || this.treeAdapter.getNamespaceURI(current) === NS.HTML;
    this.currentNotInHTML = !isHTML;
    this.tokenizer.inForeignNode = !isHTML && !this._isIntegrationPoint(tid, current);
  }
  _switchToTextParsing(currentToken, nextTokenizerState) {
    this._insertElement(currentToken, NS.HTML);
    this.tokenizer.state = nextTokenizerState;
    this.originalInsertionMode = this.insertionMode;
    this.insertionMode = InsertionMode.TEXT;
  }
  switchToPlaintextParsing() {
    this.insertionMode = InsertionMode.TEXT;
    this.originalInsertionMode = InsertionMode.IN_BODY;
    this.tokenizer.state = TokenizerMode.PLAINTEXT;
  }
  //Fragment parsing
  _getAdjustedCurrentElement() {
    return this.openElements.stackTop === 0 && this.fragmentContext ? this.fragmentContext : this.openElements.current;
  }
  _findFormInFragmentContext() {
    let node = this.fragmentContext;
    while (node) {
      if (this.treeAdapter.getTagName(node) === TAG_NAMES.FORM) {
        this.formElement = node;
        break;
      }
      node = this.treeAdapter.getParentNode(node);
    }
  }
  _initTokenizerForFragmentParsing() {
    if (!this.fragmentContext || this.treeAdapter.getNamespaceURI(this.fragmentContext) !== NS.HTML) {
      return;
    }
    switch (this.fragmentContextID) {
      case TAG_ID.TITLE:
      case TAG_ID.TEXTAREA: {
        this.tokenizer.state = TokenizerMode.RCDATA;
        break;
      }
      case TAG_ID.STYLE:
      case TAG_ID.XMP:
      case TAG_ID.IFRAME:
      case TAG_ID.NOEMBED:
      case TAG_ID.NOFRAMES:
      case TAG_ID.NOSCRIPT: {
        this.tokenizer.state = TokenizerMode.RAWTEXT;
        break;
      }
      case TAG_ID.SCRIPT: {
        this.tokenizer.state = TokenizerMode.SCRIPT_DATA;
        break;
      }
      case TAG_ID.PLAINTEXT: {
        this.tokenizer.state = TokenizerMode.PLAINTEXT;
        break;
      }
      default:
    }
  }
  //Tree mutation
  _setDocumentType(token) {
    const name2 = token.name || "";
    const publicId = token.publicId || "";
    const systemId = token.systemId || "";
    this.treeAdapter.setDocumentType(this.document, name2, publicId, systemId);
    if (token.location) {
      const documentChildren = this.treeAdapter.getChildNodes(this.document);
      const docTypeNode = documentChildren.find((node) => this.treeAdapter.isDocumentTypeNode(node));
      if (docTypeNode) {
        this.treeAdapter.setNodeSourceCodeLocation(docTypeNode, token.location);
      }
    }
  }
  _attachElementToTree(element, location) {
    if (this.options.sourceCodeLocationInfo) {
      const loc = location && {
        ...location,
        startTag: location
      };
      this.treeAdapter.setNodeSourceCodeLocation(element, loc);
    }
    if (this._shouldFosterParentOnInsertion()) {
      this._fosterParentElement(element);
    } else {
      const parent2 = this.openElements.currentTmplContentOrNode;
      this.treeAdapter.appendChild(parent2, element);
    }
  }
  _appendElement(token, namespaceURI) {
    const element = this.treeAdapter.createElement(token.tagName, namespaceURI, token.attrs);
    this._attachElementToTree(element, token.location);
  }
  _insertElement(token, namespaceURI) {
    const element = this.treeAdapter.createElement(token.tagName, namespaceURI, token.attrs);
    this._attachElementToTree(element, token.location);
    this.openElements.push(element, token.tagID);
  }
  _insertFakeElement(tagName, tagID) {
    const element = this.treeAdapter.createElement(tagName, NS.HTML, []);
    this._attachElementToTree(element, null);
    this.openElements.push(element, tagID);
  }
  _insertTemplate(token) {
    const tmpl = this.treeAdapter.createElement(token.tagName, NS.HTML, token.attrs);
    const content = this.treeAdapter.createDocumentFragment();
    this.treeAdapter.setTemplateContent(tmpl, content);
    this._attachElementToTree(tmpl, token.location);
    this.openElements.push(tmpl, token.tagID);
    if (this.options.sourceCodeLocationInfo)
      this.treeAdapter.setNodeSourceCodeLocation(content, null);
  }
  _insertFakeRootElement() {
    const element = this.treeAdapter.createElement(TAG_NAMES.HTML, NS.HTML, []);
    if (this.options.sourceCodeLocationInfo)
      this.treeAdapter.setNodeSourceCodeLocation(element, null);
    this.treeAdapter.appendChild(this.openElements.current, element);
    this.openElements.push(element, TAG_ID.HTML);
  }
  _appendCommentNode(token, parent2) {
    const commentNode = this.treeAdapter.createCommentNode(token.data);
    this.treeAdapter.appendChild(parent2, commentNode);
    if (this.options.sourceCodeLocationInfo) {
      this.treeAdapter.setNodeSourceCodeLocation(commentNode, token.location);
    }
  }
  _insertCharacters(token) {
    let parent2;
    let beforeElement;
    if (this._shouldFosterParentOnInsertion()) {
      ({ parent: parent2, beforeElement } = this._findFosterParentingLocation());
      if (beforeElement) {
        this.treeAdapter.insertTextBefore(parent2, token.chars, beforeElement);
      } else {
        this.treeAdapter.insertText(parent2, token.chars);
      }
    } else {
      parent2 = this.openElements.currentTmplContentOrNode;
      this.treeAdapter.insertText(parent2, token.chars);
    }
    if (!token.location)
      return;
    const siblings2 = this.treeAdapter.getChildNodes(parent2);
    const textNodeIdx = beforeElement ? siblings2.lastIndexOf(beforeElement) : siblings2.length;
    const textNode = siblings2[textNodeIdx - 1];
    const tnLoc = this.treeAdapter.getNodeSourceCodeLocation(textNode);
    if (tnLoc) {
      const { endLine, endCol, endOffset } = token.location;
      this.treeAdapter.updateNodeSourceCodeLocation(textNode, { endLine, endCol, endOffset });
    } else if (this.options.sourceCodeLocationInfo) {
      this.treeAdapter.setNodeSourceCodeLocation(textNode, token.location);
    }
  }
  _adoptNodes(donor, recipient) {
    for (let child = this.treeAdapter.getFirstChild(donor); child; child = this.treeAdapter.getFirstChild(donor)) {
      this.treeAdapter.detachNode(child);
      this.treeAdapter.appendChild(recipient, child);
    }
  }
  _setEndLocation(element, closingToken) {
    if (this.treeAdapter.getNodeSourceCodeLocation(element) && closingToken.location) {
      const ctLoc = closingToken.location;
      const tn = this.treeAdapter.getTagName(element);
      const endLoc = (
        // NOTE: For cases like <p> <p> </p> - First 'p' closes without a closing
        // tag and for cases like <td> <p> </td> - 'p' closes without a closing tag.
        closingToken.type === TokenType.END_TAG && tn === closingToken.tagName ? {
          endTag: { ...ctLoc },
          endLine: ctLoc.endLine,
          endCol: ctLoc.endCol,
          endOffset: ctLoc.endOffset
        } : {
          endLine: ctLoc.startLine,
          endCol: ctLoc.startCol,
          endOffset: ctLoc.startOffset
        }
      );
      this.treeAdapter.updateNodeSourceCodeLocation(element, endLoc);
    }
  }
  //Token processing
  shouldProcessStartTagTokenInForeignContent(token) {
    if (!this.currentNotInHTML)
      return false;
    let current;
    let currentTagId;
    if (this.openElements.stackTop === 0 && this.fragmentContext) {
      current = this.fragmentContext;
      currentTagId = this.fragmentContextID;
    } else {
      ({ current, currentTagId } = this.openElements);
    }
    if (token.tagID === TAG_ID.SVG && this.treeAdapter.getTagName(current) === TAG_NAMES.ANNOTATION_XML && this.treeAdapter.getNamespaceURI(current) === NS.MATHML) {
      return false;
    }
    return (
      // Check that `current` is not an integration point for HTML or MathML elements.
      this.tokenizer.inForeignNode || // If it _is_ an integration point, then we might have to check that it is not an HTML
      // integration point.
      (token.tagID === TAG_ID.MGLYPH || token.tagID === TAG_ID.MALIGNMARK) && !this._isIntegrationPoint(currentTagId, current, NS.HTML)
    );
  }
  _processToken(token) {
    switch (token.type) {
      case TokenType.CHARACTER: {
        this.onCharacter(token);
        break;
      }
      case TokenType.NULL_CHARACTER: {
        this.onNullCharacter(token);
        break;
      }
      case TokenType.COMMENT: {
        this.onComment(token);
        break;
      }
      case TokenType.DOCTYPE: {
        this.onDoctype(token);
        break;
      }
      case TokenType.START_TAG: {
        this._processStartTag(token);
        break;
      }
      case TokenType.END_TAG: {
        this.onEndTag(token);
        break;
      }
      case TokenType.EOF: {
        this.onEof(token);
        break;
      }
      case TokenType.WHITESPACE_CHARACTER: {
        this.onWhitespaceCharacter(token);
        break;
      }
    }
  }
  //Integration points
  _isIntegrationPoint(tid, element, foreignNS) {
    const ns = this.treeAdapter.getNamespaceURI(element);
    const attrs = this.treeAdapter.getAttrList(element);
    return isIntegrationPoint(tid, ns, attrs, foreignNS);
  }
  //Active formatting elements reconstruction
  _reconstructActiveFormattingElements() {
    const listLength = this.activeFormattingElements.entries.length;
    if (listLength) {
      const endIndex = this.activeFormattingElements.entries.findIndex((entry) => entry.type === EntryType.Marker || this.openElements.contains(entry.element));
      const unopenIdx = endIndex < 0 ? listLength - 1 : endIndex - 1;
      for (let i = unopenIdx; i >= 0; i--) {
        const entry = this.activeFormattingElements.entries[i];
        this._insertElement(entry.token, this.treeAdapter.getNamespaceURI(entry.element));
        entry.element = this.openElements.current;
      }
    }
  }
  //Close elements
  _closeTableCell() {
    this.openElements.generateImpliedEndTags();
    this.openElements.popUntilTableCellPopped();
    this.activeFormattingElements.clearToLastMarker();
    this.insertionMode = InsertionMode.IN_ROW;
  }
  _closePElement() {
    this.openElements.generateImpliedEndTagsWithExclusion(TAG_ID.P);
    this.openElements.popUntilTagNamePopped(TAG_ID.P);
  }
  //Insertion modes
  _resetInsertionMode() {
    for (let i = this.openElements.stackTop; i >= 0; i--) {
      switch (i === 0 && this.fragmentContext ? this.fragmentContextID : this.openElements.tagIDs[i]) {
        case TAG_ID.TR: {
          this.insertionMode = InsertionMode.IN_ROW;
          return;
        }
        case TAG_ID.TBODY:
        case TAG_ID.THEAD:
        case TAG_ID.TFOOT: {
          this.insertionMode = InsertionMode.IN_TABLE_BODY;
          return;
        }
        case TAG_ID.CAPTION: {
          this.insertionMode = InsertionMode.IN_CAPTION;
          return;
        }
        case TAG_ID.COLGROUP: {
          this.insertionMode = InsertionMode.IN_COLUMN_GROUP;
          return;
        }
        case TAG_ID.TABLE: {
          this.insertionMode = InsertionMode.IN_TABLE;
          return;
        }
        case TAG_ID.BODY: {
          this.insertionMode = InsertionMode.IN_BODY;
          return;
        }
        case TAG_ID.FRAMESET: {
          this.insertionMode = InsertionMode.IN_FRAMESET;
          return;
        }
        case TAG_ID.SELECT: {
          this._resetInsertionModeForSelect(i);
          return;
        }
        case TAG_ID.TEMPLATE: {
          this.insertionMode = this.tmplInsertionModeStack[0];
          return;
        }
        case TAG_ID.HTML: {
          this.insertionMode = this.headElement ? InsertionMode.AFTER_HEAD : InsertionMode.BEFORE_HEAD;
          return;
        }
        case TAG_ID.TD:
        case TAG_ID.TH: {
          if (i > 0) {
            this.insertionMode = InsertionMode.IN_CELL;
            return;
          }
          break;
        }
        case TAG_ID.HEAD: {
          if (i > 0) {
            this.insertionMode = InsertionMode.IN_HEAD;
            return;
          }
          break;
        }
      }
    }
    this.insertionMode = InsertionMode.IN_BODY;
  }
  _resetInsertionModeForSelect(selectIdx) {
    if (selectIdx > 0) {
      for (let i = selectIdx - 1; i > 0; i--) {
        const tn = this.openElements.tagIDs[i];
        if (tn === TAG_ID.TEMPLATE) {
          break;
        } else if (tn === TAG_ID.TABLE) {
          this.insertionMode = InsertionMode.IN_SELECT_IN_TABLE;
          return;
        }
      }
    }
    this.insertionMode = InsertionMode.IN_SELECT;
  }
  //Foster parenting
  _isElementCausesFosterParenting(tn) {
    return TABLE_STRUCTURE_TAGS.has(tn);
  }
  _shouldFosterParentOnInsertion() {
    return this.fosterParentingEnabled && this._isElementCausesFosterParenting(this.openElements.currentTagId);
  }
  _findFosterParentingLocation() {
    for (let i = this.openElements.stackTop; i >= 0; i--) {
      const openElement = this.openElements.items[i];
      switch (this.openElements.tagIDs[i]) {
        case TAG_ID.TEMPLATE: {
          if (this.treeAdapter.getNamespaceURI(openElement) === NS.HTML) {
            return { parent: this.treeAdapter.getTemplateContent(openElement), beforeElement: null };
          }
          break;
        }
        case TAG_ID.TABLE: {
          const parent2 = this.treeAdapter.getParentNode(openElement);
          if (parent2) {
            return { parent: parent2, beforeElement: openElement };
          }
          return { parent: this.openElements.items[i - 1], beforeElement: null };
        }
        default:
      }
    }
    return { parent: this.openElements.items[0], beforeElement: null };
  }
  _fosterParentElement(element) {
    const location = this._findFosterParentingLocation();
    if (location.beforeElement) {
      this.treeAdapter.insertBefore(location.parent, element, location.beforeElement);
    } else {
      this.treeAdapter.appendChild(location.parent, element);
    }
  }
  //Special elements
  _isSpecialElement(element, id) {
    const ns = this.treeAdapter.getNamespaceURI(element);
    return SPECIAL_ELEMENTS[ns].has(id);
  }
  onCharacter(token) {
    this.skipNextNewLine = false;
    if (this.tokenizer.inForeignNode) {
      characterInForeignContent(this, token);
      return;
    }
    switch (this.insertionMode) {
      case InsertionMode.INITIAL: {
        tokenInInitialMode(this, token);
        break;
      }
      case InsertionMode.BEFORE_HTML: {
        tokenBeforeHtml(this, token);
        break;
      }
      case InsertionMode.BEFORE_HEAD: {
        tokenBeforeHead(this, token);
        break;
      }
      case InsertionMode.IN_HEAD: {
        tokenInHead(this, token);
        break;
      }
      case InsertionMode.IN_HEAD_NO_SCRIPT: {
        tokenInHeadNoScript(this, token);
        break;
      }
      case InsertionMode.AFTER_HEAD: {
        tokenAfterHead(this, token);
        break;
      }
      case InsertionMode.IN_BODY:
      case InsertionMode.IN_CAPTION:
      case InsertionMode.IN_CELL:
      case InsertionMode.IN_TEMPLATE: {
        characterInBody(this, token);
        break;
      }
      case InsertionMode.TEXT:
      case InsertionMode.IN_SELECT:
      case InsertionMode.IN_SELECT_IN_TABLE: {
        this._insertCharacters(token);
        break;
      }
      case InsertionMode.IN_TABLE:
      case InsertionMode.IN_TABLE_BODY:
      case InsertionMode.IN_ROW: {
        characterInTable(this, token);
        break;
      }
      case InsertionMode.IN_TABLE_TEXT: {
        characterInTableText(this, token);
        break;
      }
      case InsertionMode.IN_COLUMN_GROUP: {
        tokenInColumnGroup(this, token);
        break;
      }
      case InsertionMode.AFTER_BODY: {
        tokenAfterBody(this, token);
        break;
      }
      case InsertionMode.AFTER_AFTER_BODY: {
        tokenAfterAfterBody(this, token);
        break;
      }
      default:
    }
  }
  onNullCharacter(token) {
    this.skipNextNewLine = false;
    if (this.tokenizer.inForeignNode) {
      nullCharacterInForeignContent(this, token);
      return;
    }
    switch (this.insertionMode) {
      case InsertionMode.INITIAL: {
        tokenInInitialMode(this, token);
        break;
      }
      case InsertionMode.BEFORE_HTML: {
        tokenBeforeHtml(this, token);
        break;
      }
      case InsertionMode.BEFORE_HEAD: {
        tokenBeforeHead(this, token);
        break;
      }
      case InsertionMode.IN_HEAD: {
        tokenInHead(this, token);
        break;
      }
      case InsertionMode.IN_HEAD_NO_SCRIPT: {
        tokenInHeadNoScript(this, token);
        break;
      }
      case InsertionMode.AFTER_HEAD: {
        tokenAfterHead(this, token);
        break;
      }
      case InsertionMode.TEXT: {
        this._insertCharacters(token);
        break;
      }
      case InsertionMode.IN_TABLE:
      case InsertionMode.IN_TABLE_BODY:
      case InsertionMode.IN_ROW: {
        characterInTable(this, token);
        break;
      }
      case InsertionMode.IN_COLUMN_GROUP: {
        tokenInColumnGroup(this, token);
        break;
      }
      case InsertionMode.AFTER_BODY: {
        tokenAfterBody(this, token);
        break;
      }
      case InsertionMode.AFTER_AFTER_BODY: {
        tokenAfterAfterBody(this, token);
        break;
      }
      default:
    }
  }
  onComment(token) {
    this.skipNextNewLine = false;
    if (this.currentNotInHTML) {
      appendComment(this, token);
      return;
    }
    switch (this.insertionMode) {
      case InsertionMode.INITIAL:
      case InsertionMode.BEFORE_HTML:
      case InsertionMode.BEFORE_HEAD:
      case InsertionMode.IN_HEAD:
      case InsertionMode.IN_HEAD_NO_SCRIPT:
      case InsertionMode.AFTER_HEAD:
      case InsertionMode.IN_BODY:
      case InsertionMode.IN_TABLE:
      case InsertionMode.IN_CAPTION:
      case InsertionMode.IN_COLUMN_GROUP:
      case InsertionMode.IN_TABLE_BODY:
      case InsertionMode.IN_ROW:
      case InsertionMode.IN_CELL:
      case InsertionMode.IN_SELECT:
      case InsertionMode.IN_SELECT_IN_TABLE:
      case InsertionMode.IN_TEMPLATE:
      case InsertionMode.IN_FRAMESET:
      case InsertionMode.AFTER_FRAMESET: {
        appendComment(this, token);
        break;
      }
      case InsertionMode.IN_TABLE_TEXT: {
        tokenInTableText(this, token);
        break;
      }
      case InsertionMode.AFTER_BODY: {
        appendCommentToRootHtmlElement(this, token);
        break;
      }
      case InsertionMode.AFTER_AFTER_BODY:
      case InsertionMode.AFTER_AFTER_FRAMESET: {
        appendCommentToDocument(this, token);
        break;
      }
      default:
    }
  }
  onDoctype(token) {
    this.skipNextNewLine = false;
    switch (this.insertionMode) {
      case InsertionMode.INITIAL: {
        doctypeInInitialMode(this, token);
        break;
      }
      case InsertionMode.BEFORE_HEAD:
      case InsertionMode.IN_HEAD:
      case InsertionMode.IN_HEAD_NO_SCRIPT:
      case InsertionMode.AFTER_HEAD: {
        this._err(token, ERR.misplacedDoctype);
        break;
      }
      case InsertionMode.IN_TABLE_TEXT: {
        tokenInTableText(this, token);
        break;
      }
      default:
    }
  }
  onStartTag(token) {
    this.skipNextNewLine = false;
    this.currentToken = token;
    this._processStartTag(token);
    if (token.selfClosing && !token.ackSelfClosing) {
      this._err(token, ERR.nonVoidHtmlElementStartTagWithTrailingSolidus);
    }
  }
  /**
   * Processes a given start tag.
   *
   * `onStartTag` checks if a self-closing tag was recognized. When a token
   * is moved inbetween multiple insertion modes, this check for self-closing
   * could lead to false positives. To avoid this, `_processStartTag` is used
   * for nested calls.
   *
   * @param token The token to process.
   */
  _processStartTag(token) {
    if (this.shouldProcessStartTagTokenInForeignContent(token)) {
      startTagInForeignContent(this, token);
    } else {
      this._startTagOutsideForeignContent(token);
    }
  }
  _startTagOutsideForeignContent(token) {
    switch (this.insertionMode) {
      case InsertionMode.INITIAL: {
        tokenInInitialMode(this, token);
        break;
      }
      case InsertionMode.BEFORE_HTML: {
        startTagBeforeHtml(this, token);
        break;
      }
      case InsertionMode.BEFORE_HEAD: {
        startTagBeforeHead(this, token);
        break;
      }
      case InsertionMode.IN_HEAD: {
        startTagInHead(this, token);
        break;
      }
      case InsertionMode.IN_HEAD_NO_SCRIPT: {
        startTagInHeadNoScript(this, token);
        break;
      }
      case InsertionMode.AFTER_HEAD: {
        startTagAfterHead(this, token);
        break;
      }
      case InsertionMode.IN_BODY: {
        startTagInBody(this, token);
        break;
      }
      case InsertionMode.IN_TABLE: {
        startTagInTable(this, token);
        break;
      }
      case InsertionMode.IN_TABLE_TEXT: {
        tokenInTableText(this, token);
        break;
      }
      case InsertionMode.IN_CAPTION: {
        startTagInCaption(this, token);
        break;
      }
      case InsertionMode.IN_COLUMN_GROUP: {
        startTagInColumnGroup(this, token);
        break;
      }
      case InsertionMode.IN_TABLE_BODY: {
        startTagInTableBody(this, token);
        break;
      }
      case InsertionMode.IN_ROW: {
        startTagInRow(this, token);
        break;
      }
      case InsertionMode.IN_CELL: {
        startTagInCell(this, token);
        break;
      }
      case InsertionMode.IN_SELECT: {
        startTagInSelect(this, token);
        break;
      }
      case InsertionMode.IN_SELECT_IN_TABLE: {
        startTagInSelectInTable(this, token);
        break;
      }
      case InsertionMode.IN_TEMPLATE: {
        startTagInTemplate(this, token);
        break;
      }
      case InsertionMode.AFTER_BODY: {
        startTagAfterBody(this, token);
        break;
      }
      case InsertionMode.IN_FRAMESET: {
        startTagInFrameset(this, token);
        break;
      }
      case InsertionMode.AFTER_FRAMESET: {
        startTagAfterFrameset(this, token);
        break;
      }
      case InsertionMode.AFTER_AFTER_BODY: {
        startTagAfterAfterBody(this, token);
        break;
      }
      case InsertionMode.AFTER_AFTER_FRAMESET: {
        startTagAfterAfterFrameset(this, token);
        break;
      }
      default:
    }
  }
  onEndTag(token) {
    this.skipNextNewLine = false;
    this.currentToken = token;
    if (this.currentNotInHTML) {
      endTagInForeignContent(this, token);
    } else {
      this._endTagOutsideForeignContent(token);
    }
  }
  _endTagOutsideForeignContent(token) {
    switch (this.insertionMode) {
      case InsertionMode.INITIAL: {
        tokenInInitialMode(this, token);
        break;
      }
      case InsertionMode.BEFORE_HTML: {
        endTagBeforeHtml(this, token);
        break;
      }
      case InsertionMode.BEFORE_HEAD: {
        endTagBeforeHead(this, token);
        break;
      }
      case InsertionMode.IN_HEAD: {
        endTagInHead(this, token);
        break;
      }
      case InsertionMode.IN_HEAD_NO_SCRIPT: {
        endTagInHeadNoScript(this, token);
        break;
      }
      case InsertionMode.AFTER_HEAD: {
        endTagAfterHead(this, token);
        break;
      }
      case InsertionMode.IN_BODY: {
        endTagInBody(this, token);
        break;
      }
      case InsertionMode.TEXT: {
        endTagInText(this, token);
        break;
      }
      case InsertionMode.IN_TABLE: {
        endTagInTable(this, token);
        break;
      }
      case InsertionMode.IN_TABLE_TEXT: {
        tokenInTableText(this, token);
        break;
      }
      case InsertionMode.IN_CAPTION: {
        endTagInCaption(this, token);
        break;
      }
      case InsertionMode.IN_COLUMN_GROUP: {
        endTagInColumnGroup(this, token);
        break;
      }
      case InsertionMode.IN_TABLE_BODY: {
        endTagInTableBody(this, token);
        break;
      }
      case InsertionMode.IN_ROW: {
        endTagInRow(this, token);
        break;
      }
      case InsertionMode.IN_CELL: {
        endTagInCell(this, token);
        break;
      }
      case InsertionMode.IN_SELECT: {
        endTagInSelect(this, token);
        break;
      }
      case InsertionMode.IN_SELECT_IN_TABLE: {
        endTagInSelectInTable(this, token);
        break;
      }
      case InsertionMode.IN_TEMPLATE: {
        endTagInTemplate(this, token);
        break;
      }
      case InsertionMode.AFTER_BODY: {
        endTagAfterBody(this, token);
        break;
      }
      case InsertionMode.IN_FRAMESET: {
        endTagInFrameset(this, token);
        break;
      }
      case InsertionMode.AFTER_FRAMESET: {
        endTagAfterFrameset(this, token);
        break;
      }
      case InsertionMode.AFTER_AFTER_BODY: {
        tokenAfterAfterBody(this, token);
        break;
      }
      default:
    }
  }
  onEof(token) {
    switch (this.insertionMode) {
      case InsertionMode.INITIAL: {
        tokenInInitialMode(this, token);
        break;
      }
      case InsertionMode.BEFORE_HTML: {
        tokenBeforeHtml(this, token);
        break;
      }
      case InsertionMode.BEFORE_HEAD: {
        tokenBeforeHead(this, token);
        break;
      }
      case InsertionMode.IN_HEAD: {
        tokenInHead(this, token);
        break;
      }
      case InsertionMode.IN_HEAD_NO_SCRIPT: {
        tokenInHeadNoScript(this, token);
        break;
      }
      case InsertionMode.AFTER_HEAD: {
        tokenAfterHead(this, token);
        break;
      }
      case InsertionMode.IN_BODY:
      case InsertionMode.IN_TABLE:
      case InsertionMode.IN_CAPTION:
      case InsertionMode.IN_COLUMN_GROUP:
      case InsertionMode.IN_TABLE_BODY:
      case InsertionMode.IN_ROW:
      case InsertionMode.IN_CELL:
      case InsertionMode.IN_SELECT:
      case InsertionMode.IN_SELECT_IN_TABLE: {
        eofInBody(this, token);
        break;
      }
      case InsertionMode.TEXT: {
        eofInText(this, token);
        break;
      }
      case InsertionMode.IN_TABLE_TEXT: {
        tokenInTableText(this, token);
        break;
      }
      case InsertionMode.IN_TEMPLATE: {
        eofInTemplate(this, token);
        break;
      }
      case InsertionMode.AFTER_BODY:
      case InsertionMode.IN_FRAMESET:
      case InsertionMode.AFTER_FRAMESET:
      case InsertionMode.AFTER_AFTER_BODY:
      case InsertionMode.AFTER_AFTER_FRAMESET: {
        stopParsing(this, token);
        break;
      }
      default:
    }
  }
  onWhitespaceCharacter(token) {
    if (this.skipNextNewLine) {
      this.skipNextNewLine = false;
      if (token.chars.charCodeAt(0) === CODE_POINTS.LINE_FEED) {
        if (token.chars.length === 1) {
          return;
        }
        token.chars = token.chars.substr(1);
      }
    }
    if (this.tokenizer.inForeignNode) {
      this._insertCharacters(token);
      return;
    }
    switch (this.insertionMode) {
      case InsertionMode.IN_HEAD:
      case InsertionMode.IN_HEAD_NO_SCRIPT:
      case InsertionMode.AFTER_HEAD:
      case InsertionMode.TEXT:
      case InsertionMode.IN_COLUMN_GROUP:
      case InsertionMode.IN_SELECT:
      case InsertionMode.IN_SELECT_IN_TABLE:
      case InsertionMode.IN_FRAMESET:
      case InsertionMode.AFTER_FRAMESET: {
        this._insertCharacters(token);
        break;
      }
      case InsertionMode.IN_BODY:
      case InsertionMode.IN_CAPTION:
      case InsertionMode.IN_CELL:
      case InsertionMode.IN_TEMPLATE:
      case InsertionMode.AFTER_BODY:
      case InsertionMode.AFTER_AFTER_BODY:
      case InsertionMode.AFTER_AFTER_FRAMESET: {
        whitespaceCharacterInBody(this, token);
        break;
      }
      case InsertionMode.IN_TABLE:
      case InsertionMode.IN_TABLE_BODY:
      case InsertionMode.IN_ROW: {
        characterInTable(this, token);
        break;
      }
      case InsertionMode.IN_TABLE_TEXT: {
        whitespaceCharacterInTableText(this, token);
        break;
      }
      default:
    }
  }
};
function aaObtainFormattingElementEntry(p, token) {
  let formattingElementEntry = p.activeFormattingElements.getElementEntryInScopeWithTagName(token.tagName);
  if (formattingElementEntry) {
    if (!p.openElements.contains(formattingElementEntry.element)) {
      p.activeFormattingElements.removeEntry(formattingElementEntry);
      formattingElementEntry = null;
    } else if (!p.openElements.hasInScope(token.tagID)) {
      formattingElementEntry = null;
    }
  } else {
    genericEndTagInBody(p, token);
  }
  return formattingElementEntry;
}
function aaObtainFurthestBlock(p, formattingElementEntry) {
  let furthestBlock = null;
  let idx = p.openElements.stackTop;
  for (; idx >= 0; idx--) {
    const element = p.openElements.items[idx];
    if (element === formattingElementEntry.element) {
      break;
    }
    if (p._isSpecialElement(element, p.openElements.tagIDs[idx])) {
      furthestBlock = element;
    }
  }
  if (!furthestBlock) {
    p.openElements.shortenToLength(idx < 0 ? 0 : idx);
    p.activeFormattingElements.removeEntry(formattingElementEntry);
  }
  return furthestBlock;
}
function aaInnerLoop(p, furthestBlock, formattingElement) {
  let lastElement = furthestBlock;
  let nextElement = p.openElements.getCommonAncestor(furthestBlock);
  for (let i = 0, element = nextElement; element !== formattingElement; i++, element = nextElement) {
    nextElement = p.openElements.getCommonAncestor(element);
    const elementEntry = p.activeFormattingElements.getElementEntry(element);
    const counterOverflow = elementEntry && i >= AA_INNER_LOOP_ITER;
    const shouldRemoveFromOpenElements = !elementEntry || counterOverflow;
    if (shouldRemoveFromOpenElements) {
      if (counterOverflow) {
        p.activeFormattingElements.removeEntry(elementEntry);
      }
      p.openElements.remove(element);
    } else {
      element = aaRecreateElementFromEntry(p, elementEntry);
      if (lastElement === furthestBlock) {
        p.activeFormattingElements.bookmark = elementEntry;
      }
      p.treeAdapter.detachNode(lastElement);
      p.treeAdapter.appendChild(element, lastElement);
      lastElement = element;
    }
  }
  return lastElement;
}
function aaRecreateElementFromEntry(p, elementEntry) {
  const ns = p.treeAdapter.getNamespaceURI(elementEntry.element);
  const newElement = p.treeAdapter.createElement(elementEntry.token.tagName, ns, elementEntry.token.attrs);
  p.openElements.replace(elementEntry.element, newElement);
  elementEntry.element = newElement;
  return newElement;
}
function aaInsertLastNodeInCommonAncestor(p, commonAncestor, lastElement) {
  const tn = p.treeAdapter.getTagName(commonAncestor);
  const tid = getTagID(tn);
  if (p._isElementCausesFosterParenting(tid)) {
    p._fosterParentElement(lastElement);
  } else {
    const ns = p.treeAdapter.getNamespaceURI(commonAncestor);
    if (tid === TAG_ID.TEMPLATE && ns === NS.HTML) {
      commonAncestor = p.treeAdapter.getTemplateContent(commonAncestor);
    }
    p.treeAdapter.appendChild(commonAncestor, lastElement);
  }
}
function aaReplaceFormattingElement(p, furthestBlock, formattingElementEntry) {
  const ns = p.treeAdapter.getNamespaceURI(formattingElementEntry.element);
  const { token } = formattingElementEntry;
  const newElement = p.treeAdapter.createElement(token.tagName, ns, token.attrs);
  p._adoptNodes(furthestBlock, newElement);
  p.treeAdapter.appendChild(furthestBlock, newElement);
  p.activeFormattingElements.insertElementAfterBookmark(newElement, token);
  p.activeFormattingElements.removeEntry(formattingElementEntry);
  p.openElements.remove(formattingElementEntry.element);
  p.openElements.insertAfter(furthestBlock, newElement, token.tagID);
}
function callAdoptionAgency(p, token) {
  for (let i = 0; i < AA_OUTER_LOOP_ITER; i++) {
    const formattingElementEntry = aaObtainFormattingElementEntry(p, token);
    if (!formattingElementEntry) {
      break;
    }
    const furthestBlock = aaObtainFurthestBlock(p, formattingElementEntry);
    if (!furthestBlock) {
      break;
    }
    p.activeFormattingElements.bookmark = formattingElementEntry;
    const lastElement = aaInnerLoop(p, furthestBlock, formattingElementEntry.element);
    const commonAncestor = p.openElements.getCommonAncestor(formattingElementEntry.element);
    p.treeAdapter.detachNode(lastElement);
    if (commonAncestor)
      aaInsertLastNodeInCommonAncestor(p, commonAncestor, lastElement);
    aaReplaceFormattingElement(p, furthestBlock, formattingElementEntry);
  }
}
function appendComment(p, token) {
  p._appendCommentNode(token, p.openElements.currentTmplContentOrNode);
}
function appendCommentToRootHtmlElement(p, token) {
  p._appendCommentNode(token, p.openElements.items[0]);
}
function appendCommentToDocument(p, token) {
  p._appendCommentNode(token, p.document);
}
function stopParsing(p, token) {
  p.stopped = true;
  if (token.location) {
    const target = p.fragmentContext ? 0 : 2;
    for (let i = p.openElements.stackTop; i >= target; i--) {
      p._setEndLocation(p.openElements.items[i], token);
    }
    if (!p.fragmentContext && p.openElements.stackTop >= 0) {
      const htmlElement = p.openElements.items[0];
      const htmlLocation = p.treeAdapter.getNodeSourceCodeLocation(htmlElement);
      if (htmlLocation && !htmlLocation.endTag) {
        p._setEndLocation(htmlElement, token);
        if (p.openElements.stackTop >= 1) {
          const bodyElement = p.openElements.items[1];
          const bodyLocation = p.treeAdapter.getNodeSourceCodeLocation(bodyElement);
          if (bodyLocation && !bodyLocation.endTag) {
            p._setEndLocation(bodyElement, token);
          }
        }
      }
    }
  }
}
function doctypeInInitialMode(p, token) {
  p._setDocumentType(token);
  const mode = token.forceQuirks ? DOCUMENT_MODE.QUIRKS : getDocumentMode(token);
  if (!isConforming(token)) {
    p._err(token, ERR.nonConformingDoctype);
  }
  p.treeAdapter.setDocumentMode(p.document, mode);
  p.insertionMode = InsertionMode.BEFORE_HTML;
}
function tokenInInitialMode(p, token) {
  p._err(token, ERR.missingDoctype, true);
  p.treeAdapter.setDocumentMode(p.document, DOCUMENT_MODE.QUIRKS);
  p.insertionMode = InsertionMode.BEFORE_HTML;
  p._processToken(token);
}
function startTagBeforeHtml(p, token) {
  if (token.tagID === TAG_ID.HTML) {
    p._insertElement(token, NS.HTML);
    p.insertionMode = InsertionMode.BEFORE_HEAD;
  } else {
    tokenBeforeHtml(p, token);
  }
}
function endTagBeforeHtml(p, token) {
  const tn = token.tagID;
  if (tn === TAG_ID.HTML || tn === TAG_ID.HEAD || tn === TAG_ID.BODY || tn === TAG_ID.BR) {
    tokenBeforeHtml(p, token);
  }
}
function tokenBeforeHtml(p, token) {
  p._insertFakeRootElement();
  p.insertionMode = InsertionMode.BEFORE_HEAD;
  p._processToken(token);
}
function startTagBeforeHead(p, token) {
  switch (token.tagID) {
    case TAG_ID.HTML: {
      startTagInBody(p, token);
      break;
    }
    case TAG_ID.HEAD: {
      p._insertElement(token, NS.HTML);
      p.headElement = p.openElements.current;
      p.insertionMode = InsertionMode.IN_HEAD;
      break;
    }
    default: {
      tokenBeforeHead(p, token);
    }
  }
}
function endTagBeforeHead(p, token) {
  const tn = token.tagID;
  if (tn === TAG_ID.HEAD || tn === TAG_ID.BODY || tn === TAG_ID.HTML || tn === TAG_ID.BR) {
    tokenBeforeHead(p, token);
  } else {
    p._err(token, ERR.endTagWithoutMatchingOpenElement);
  }
}
function tokenBeforeHead(p, token) {
  p._insertFakeElement(TAG_NAMES.HEAD, TAG_ID.HEAD);
  p.headElement = p.openElements.current;
  p.insertionMode = InsertionMode.IN_HEAD;
  p._processToken(token);
}
function startTagInHead(p, token) {
  switch (token.tagID) {
    case TAG_ID.HTML: {
      startTagInBody(p, token);
      break;
    }
    case TAG_ID.BASE:
    case TAG_ID.BASEFONT:
    case TAG_ID.BGSOUND:
    case TAG_ID.LINK:
    case TAG_ID.META: {
      p._appendElement(token, NS.HTML);
      token.ackSelfClosing = true;
      break;
    }
    case TAG_ID.TITLE: {
      p._switchToTextParsing(token, TokenizerMode.RCDATA);
      break;
    }
    case TAG_ID.NOSCRIPT: {
      if (p.options.scriptingEnabled) {
        p._switchToTextParsing(token, TokenizerMode.RAWTEXT);
      } else {
        p._insertElement(token, NS.HTML);
        p.insertionMode = InsertionMode.IN_HEAD_NO_SCRIPT;
      }
      break;
    }
    case TAG_ID.NOFRAMES:
    case TAG_ID.STYLE: {
      p._switchToTextParsing(token, TokenizerMode.RAWTEXT);
      break;
    }
    case TAG_ID.SCRIPT: {
      p._switchToTextParsing(token, TokenizerMode.SCRIPT_DATA);
      break;
    }
    case TAG_ID.TEMPLATE: {
      p._insertTemplate(token);
      p.activeFormattingElements.insertMarker();
      p.framesetOk = false;
      p.insertionMode = InsertionMode.IN_TEMPLATE;
      p.tmplInsertionModeStack.unshift(InsertionMode.IN_TEMPLATE);
      break;
    }
    case TAG_ID.HEAD: {
      p._err(token, ERR.misplacedStartTagForHeadElement);
      break;
    }
    default: {
      tokenInHead(p, token);
    }
  }
}
function endTagInHead(p, token) {
  switch (token.tagID) {
    case TAG_ID.HEAD: {
      p.openElements.pop();
      p.insertionMode = InsertionMode.AFTER_HEAD;
      break;
    }
    case TAG_ID.BODY:
    case TAG_ID.BR:
    case TAG_ID.HTML: {
      tokenInHead(p, token);
      break;
    }
    case TAG_ID.TEMPLATE: {
      templateEndTagInHead(p, token);
      break;
    }
    default: {
      p._err(token, ERR.endTagWithoutMatchingOpenElement);
    }
  }
}
function templateEndTagInHead(p, token) {
  if (p.openElements.tmplCount > 0) {
    p.openElements.generateImpliedEndTagsThoroughly();
    if (p.openElements.currentTagId !== TAG_ID.TEMPLATE) {
      p._err(token, ERR.closingOfElementWithOpenChildElements);
    }
    p.openElements.popUntilTagNamePopped(TAG_ID.TEMPLATE);
    p.activeFormattingElements.clearToLastMarker();
    p.tmplInsertionModeStack.shift();
    p._resetInsertionMode();
  } else {
    p._err(token, ERR.endTagWithoutMatchingOpenElement);
  }
}
function tokenInHead(p, token) {
  p.openElements.pop();
  p.insertionMode = InsertionMode.AFTER_HEAD;
  p._processToken(token);
}
function startTagInHeadNoScript(p, token) {
  switch (token.tagID) {
    case TAG_ID.HTML: {
      startTagInBody(p, token);
      break;
    }
    case TAG_ID.BASEFONT:
    case TAG_ID.BGSOUND:
    case TAG_ID.HEAD:
    case TAG_ID.LINK:
    case TAG_ID.META:
    case TAG_ID.NOFRAMES:
    case TAG_ID.STYLE: {
      startTagInHead(p, token);
      break;
    }
    case TAG_ID.NOSCRIPT: {
      p._err(token, ERR.nestedNoscriptInHead);
      break;
    }
    default: {
      tokenInHeadNoScript(p, token);
    }
  }
}
function endTagInHeadNoScript(p, token) {
  switch (token.tagID) {
    case TAG_ID.NOSCRIPT: {
      p.openElements.pop();
      p.insertionMode = InsertionMode.IN_HEAD;
      break;
    }
    case TAG_ID.BR: {
      tokenInHeadNoScript(p, token);
      break;
    }
    default: {
      p._err(token, ERR.endTagWithoutMatchingOpenElement);
    }
  }
}
function tokenInHeadNoScript(p, token) {
  const errCode = token.type === TokenType.EOF ? ERR.openElementsLeftAfterEof : ERR.disallowedContentInNoscriptInHead;
  p._err(token, errCode);
  p.openElements.pop();
  p.insertionMode = InsertionMode.IN_HEAD;
  p._processToken(token);
}
function startTagAfterHead(p, token) {
  switch (token.tagID) {
    case TAG_ID.HTML: {
      startTagInBody(p, token);
      break;
    }
    case TAG_ID.BODY: {
      p._insertElement(token, NS.HTML);
      p.framesetOk = false;
      p.insertionMode = InsertionMode.IN_BODY;
      break;
    }
    case TAG_ID.FRAMESET: {
      p._insertElement(token, NS.HTML);
      p.insertionMode = InsertionMode.IN_FRAMESET;
      break;
    }
    case TAG_ID.BASE:
    case TAG_ID.BASEFONT:
    case TAG_ID.BGSOUND:
    case TAG_ID.LINK:
    case TAG_ID.META:
    case TAG_ID.NOFRAMES:
    case TAG_ID.SCRIPT:
    case TAG_ID.STYLE:
    case TAG_ID.TEMPLATE:
    case TAG_ID.TITLE: {
      p._err(token, ERR.abandonedHeadElementChild);
      p.openElements.push(p.headElement, TAG_ID.HEAD);
      startTagInHead(p, token);
      p.openElements.remove(p.headElement);
      break;
    }
    case TAG_ID.HEAD: {
      p._err(token, ERR.misplacedStartTagForHeadElement);
      break;
    }
    default: {
      tokenAfterHead(p, token);
    }
  }
}
function endTagAfterHead(p, token) {
  switch (token.tagID) {
    case TAG_ID.BODY:
    case TAG_ID.HTML:
    case TAG_ID.BR: {
      tokenAfterHead(p, token);
      break;
    }
    case TAG_ID.TEMPLATE: {
      templateEndTagInHead(p, token);
      break;
    }
    default: {
      p._err(token, ERR.endTagWithoutMatchingOpenElement);
    }
  }
}
function tokenAfterHead(p, token) {
  p._insertFakeElement(TAG_NAMES.BODY, TAG_ID.BODY);
  p.insertionMode = InsertionMode.IN_BODY;
  modeInBody(p, token);
}
function modeInBody(p, token) {
  switch (token.type) {
    case TokenType.CHARACTER: {
      characterInBody(p, token);
      break;
    }
    case TokenType.WHITESPACE_CHARACTER: {
      whitespaceCharacterInBody(p, token);
      break;
    }
    case TokenType.COMMENT: {
      appendComment(p, token);
      break;
    }
    case TokenType.START_TAG: {
      startTagInBody(p, token);
      break;
    }
    case TokenType.END_TAG: {
      endTagInBody(p, token);
      break;
    }
    case TokenType.EOF: {
      eofInBody(p, token);
      break;
    }
    default:
  }
}
function whitespaceCharacterInBody(p, token) {
  p._reconstructActiveFormattingElements();
  p._insertCharacters(token);
}
function characterInBody(p, token) {
  p._reconstructActiveFormattingElements();
  p._insertCharacters(token);
  p.framesetOk = false;
}
function htmlStartTagInBody(p, token) {
  if (p.openElements.tmplCount === 0) {
    p.treeAdapter.adoptAttributes(p.openElements.items[0], token.attrs);
  }
}
function bodyStartTagInBody(p, token) {
  const bodyElement = p.openElements.tryPeekProperlyNestedBodyElement();
  if (bodyElement && p.openElements.tmplCount === 0) {
    p.framesetOk = false;
    p.treeAdapter.adoptAttributes(bodyElement, token.attrs);
  }
}
function framesetStartTagInBody(p, token) {
  const bodyElement = p.openElements.tryPeekProperlyNestedBodyElement();
  if (p.framesetOk && bodyElement) {
    p.treeAdapter.detachNode(bodyElement);
    p.openElements.popAllUpToHtmlElement();
    p._insertElement(token, NS.HTML);
    p.insertionMode = InsertionMode.IN_FRAMESET;
  }
}
function addressStartTagInBody(p, token) {
  if (p.openElements.hasInButtonScope(TAG_ID.P)) {
    p._closePElement();
  }
  p._insertElement(token, NS.HTML);
}
function numberedHeaderStartTagInBody(p, token) {
  if (p.openElements.hasInButtonScope(TAG_ID.P)) {
    p._closePElement();
  }
  if (isNumberedHeader(p.openElements.currentTagId)) {
    p.openElements.pop();
  }
  p._insertElement(token, NS.HTML);
}
function preStartTagInBody(p, token) {
  if (p.openElements.hasInButtonScope(TAG_ID.P)) {
    p._closePElement();
  }
  p._insertElement(token, NS.HTML);
  p.skipNextNewLine = true;
  p.framesetOk = false;
}
function formStartTagInBody(p, token) {
  const inTemplate = p.openElements.tmplCount > 0;
  if (!p.formElement || inTemplate) {
    if (p.openElements.hasInButtonScope(TAG_ID.P)) {
      p._closePElement();
    }
    p._insertElement(token, NS.HTML);
    if (!inTemplate) {
      p.formElement = p.openElements.current;
    }
  }
}
function listItemStartTagInBody(p, token) {
  p.framesetOk = false;
  const tn = token.tagID;
  for (let i = p.openElements.stackTop; i >= 0; i--) {
    const elementId = p.openElements.tagIDs[i];
    if (tn === TAG_ID.LI && elementId === TAG_ID.LI || (tn === TAG_ID.DD || tn === TAG_ID.DT) && (elementId === TAG_ID.DD || elementId === TAG_ID.DT)) {
      p.openElements.generateImpliedEndTagsWithExclusion(elementId);
      p.openElements.popUntilTagNamePopped(elementId);
      break;
    }
    if (elementId !== TAG_ID.ADDRESS && elementId !== TAG_ID.DIV && elementId !== TAG_ID.P && p._isSpecialElement(p.openElements.items[i], elementId)) {
      break;
    }
  }
  if (p.openElements.hasInButtonScope(TAG_ID.P)) {
    p._closePElement();
  }
  p._insertElement(token, NS.HTML);
}
function plaintextStartTagInBody(p, token) {
  if (p.openElements.hasInButtonScope(TAG_ID.P)) {
    p._closePElement();
  }
  p._insertElement(token, NS.HTML);
  p.tokenizer.state = TokenizerMode.PLAINTEXT;
}
function buttonStartTagInBody(p, token) {
  if (p.openElements.hasInScope(TAG_ID.BUTTON)) {
    p.openElements.generateImpliedEndTags();
    p.openElements.popUntilTagNamePopped(TAG_ID.BUTTON);
  }
  p._reconstructActiveFormattingElements();
  p._insertElement(token, NS.HTML);
  p.framesetOk = false;
}
function aStartTagInBody(p, token) {
  const activeElementEntry = p.activeFormattingElements.getElementEntryInScopeWithTagName(TAG_NAMES.A);
  if (activeElementEntry) {
    callAdoptionAgency(p, token);
    p.openElements.remove(activeElementEntry.element);
    p.activeFormattingElements.removeEntry(activeElementEntry);
  }
  p._reconstructActiveFormattingElements();
  p._insertElement(token, NS.HTML);
  p.activeFormattingElements.pushElement(p.openElements.current, token);
}
function bStartTagInBody(p, token) {
  p._reconstructActiveFormattingElements();
  p._insertElement(token, NS.HTML);
  p.activeFormattingElements.pushElement(p.openElements.current, token);
}
function nobrStartTagInBody(p, token) {
  p._reconstructActiveFormattingElements();
  if (p.openElements.hasInScope(TAG_ID.NOBR)) {
    callAdoptionAgency(p, token);
    p._reconstructActiveFormattingElements();
  }
  p._insertElement(token, NS.HTML);
  p.activeFormattingElements.pushElement(p.openElements.current, token);
}
function appletStartTagInBody(p, token) {
  p._reconstructActiveFormattingElements();
  p._insertElement(token, NS.HTML);
  p.activeFormattingElements.insertMarker();
  p.framesetOk = false;
}
function tableStartTagInBody(p, token) {
  if (p.treeAdapter.getDocumentMode(p.document) !== DOCUMENT_MODE.QUIRKS && p.openElements.hasInButtonScope(TAG_ID.P)) {
    p._closePElement();
  }
  p._insertElement(token, NS.HTML);
  p.framesetOk = false;
  p.insertionMode = InsertionMode.IN_TABLE;
}
function areaStartTagInBody(p, token) {
  p._reconstructActiveFormattingElements();
  p._appendElement(token, NS.HTML);
  p.framesetOk = false;
  token.ackSelfClosing = true;
}
function isHiddenInput(token) {
  const inputType = getTokenAttr(token, ATTRS.TYPE);
  return inputType != null && inputType.toLowerCase() === HIDDEN_INPUT_TYPE;
}
function inputStartTagInBody(p, token) {
  p._reconstructActiveFormattingElements();
  p._appendElement(token, NS.HTML);
  if (!isHiddenInput(token)) {
    p.framesetOk = false;
  }
  token.ackSelfClosing = true;
}
function paramStartTagInBody(p, token) {
  p._appendElement(token, NS.HTML);
  token.ackSelfClosing = true;
}
function hrStartTagInBody(p, token) {
  if (p.openElements.hasInButtonScope(TAG_ID.P)) {
    p._closePElement();
  }
  p._appendElement(token, NS.HTML);
  p.framesetOk = false;
  token.ackSelfClosing = true;
}
function imageStartTagInBody(p, token) {
  token.tagName = TAG_NAMES.IMG;
  token.tagID = TAG_ID.IMG;
  areaStartTagInBody(p, token);
}
function textareaStartTagInBody(p, token) {
  p._insertElement(token, NS.HTML);
  p.skipNextNewLine = true;
  p.tokenizer.state = TokenizerMode.RCDATA;
  p.originalInsertionMode = p.insertionMode;
  p.framesetOk = false;
  p.insertionMode = InsertionMode.TEXT;
}
function xmpStartTagInBody(p, token) {
  if (p.openElements.hasInButtonScope(TAG_ID.P)) {
    p._closePElement();
  }
  p._reconstructActiveFormattingElements();
  p.framesetOk = false;
  p._switchToTextParsing(token, TokenizerMode.RAWTEXT);
}
function iframeStartTagInBody(p, token) {
  p.framesetOk = false;
  p._switchToTextParsing(token, TokenizerMode.RAWTEXT);
}
function noembedStartTagInBody(p, token) {
  p._switchToTextParsing(token, TokenizerMode.RAWTEXT);
}
function selectStartTagInBody(p, token) {
  p._reconstructActiveFormattingElements();
  p._insertElement(token, NS.HTML);
  p.framesetOk = false;
  p.insertionMode = p.insertionMode === InsertionMode.IN_TABLE || p.insertionMode === InsertionMode.IN_CAPTION || p.insertionMode === InsertionMode.IN_TABLE_BODY || p.insertionMode === InsertionMode.IN_ROW || p.insertionMode === InsertionMode.IN_CELL ? InsertionMode.IN_SELECT_IN_TABLE : InsertionMode.IN_SELECT;
}
function optgroupStartTagInBody(p, token) {
  if (p.openElements.currentTagId === TAG_ID.OPTION) {
    p.openElements.pop();
  }
  p._reconstructActiveFormattingElements();
  p._insertElement(token, NS.HTML);
}
function rbStartTagInBody(p, token) {
  if (p.openElements.hasInScope(TAG_ID.RUBY)) {
    p.openElements.generateImpliedEndTags();
  }
  p._insertElement(token, NS.HTML);
}
function rtStartTagInBody(p, token) {
  if (p.openElements.hasInScope(TAG_ID.RUBY)) {
    p.openElements.generateImpliedEndTagsWithExclusion(TAG_ID.RTC);
  }
  p._insertElement(token, NS.HTML);
}
function mathStartTagInBody(p, token) {
  p._reconstructActiveFormattingElements();
  adjustTokenMathMLAttrs(token);
  adjustTokenXMLAttrs(token);
  if (token.selfClosing) {
    p._appendElement(token, NS.MATHML);
  } else {
    p._insertElement(token, NS.MATHML);
  }
  token.ackSelfClosing = true;
}
function svgStartTagInBody(p, token) {
  p._reconstructActiveFormattingElements();
  adjustTokenSVGAttrs(token);
  adjustTokenXMLAttrs(token);
  if (token.selfClosing) {
    p._appendElement(token, NS.SVG);
  } else {
    p._insertElement(token, NS.SVG);
  }
  token.ackSelfClosing = true;
}
function genericStartTagInBody(p, token) {
  p._reconstructActiveFormattingElements();
  p._insertElement(token, NS.HTML);
}
function startTagInBody(p, token) {
  switch (token.tagID) {
    case TAG_ID.I:
    case TAG_ID.S:
    case TAG_ID.B:
    case TAG_ID.U:
    case TAG_ID.EM:
    case TAG_ID.TT:
    case TAG_ID.BIG:
    case TAG_ID.CODE:
    case TAG_ID.FONT:
    case TAG_ID.SMALL:
    case TAG_ID.STRIKE:
    case TAG_ID.STRONG: {
      bStartTagInBody(p, token);
      break;
    }
    case TAG_ID.A: {
      aStartTagInBody(p, token);
      break;
    }
    case TAG_ID.H1:
    case TAG_ID.H2:
    case TAG_ID.H3:
    case TAG_ID.H4:
    case TAG_ID.H5:
    case TAG_ID.H6: {
      numberedHeaderStartTagInBody(p, token);
      break;
    }
    case TAG_ID.P:
    case TAG_ID.DL:
    case TAG_ID.OL:
    case TAG_ID.UL:
    case TAG_ID.DIV:
    case TAG_ID.DIR:
    case TAG_ID.NAV:
    case TAG_ID.MAIN:
    case TAG_ID.MENU:
    case TAG_ID.ASIDE:
    case TAG_ID.CENTER:
    case TAG_ID.FIGURE:
    case TAG_ID.FOOTER:
    case TAG_ID.HEADER:
    case TAG_ID.HGROUP:
    case TAG_ID.DIALOG:
    case TAG_ID.DETAILS:
    case TAG_ID.ADDRESS:
    case TAG_ID.ARTICLE:
    case TAG_ID.SECTION:
    case TAG_ID.SUMMARY:
    case TAG_ID.FIELDSET:
    case TAG_ID.BLOCKQUOTE:
    case TAG_ID.FIGCAPTION: {
      addressStartTagInBody(p, token);
      break;
    }
    case TAG_ID.LI:
    case TAG_ID.DD:
    case TAG_ID.DT: {
      listItemStartTagInBody(p, token);
      break;
    }
    case TAG_ID.BR:
    case TAG_ID.IMG:
    case TAG_ID.WBR:
    case TAG_ID.AREA:
    case TAG_ID.EMBED:
    case TAG_ID.KEYGEN: {
      areaStartTagInBody(p, token);
      break;
    }
    case TAG_ID.HR: {
      hrStartTagInBody(p, token);
      break;
    }
    case TAG_ID.RB:
    case TAG_ID.RTC: {
      rbStartTagInBody(p, token);
      break;
    }
    case TAG_ID.RT:
    case TAG_ID.RP: {
      rtStartTagInBody(p, token);
      break;
    }
    case TAG_ID.PRE:
    case TAG_ID.LISTING: {
      preStartTagInBody(p, token);
      break;
    }
    case TAG_ID.XMP: {
      xmpStartTagInBody(p, token);
      break;
    }
    case TAG_ID.SVG: {
      svgStartTagInBody(p, token);
      break;
    }
    case TAG_ID.HTML: {
      htmlStartTagInBody(p, token);
      break;
    }
    case TAG_ID.BASE:
    case TAG_ID.LINK:
    case TAG_ID.META:
    case TAG_ID.STYLE:
    case TAG_ID.TITLE:
    case TAG_ID.SCRIPT:
    case TAG_ID.BGSOUND:
    case TAG_ID.BASEFONT:
    case TAG_ID.TEMPLATE: {
      startTagInHead(p, token);
      break;
    }
    case TAG_ID.BODY: {
      bodyStartTagInBody(p, token);
      break;
    }
    case TAG_ID.FORM: {
      formStartTagInBody(p, token);
      break;
    }
    case TAG_ID.NOBR: {
      nobrStartTagInBody(p, token);
      break;
    }
    case TAG_ID.MATH: {
      mathStartTagInBody(p, token);
      break;
    }
    case TAG_ID.TABLE: {
      tableStartTagInBody(p, token);
      break;
    }
    case TAG_ID.INPUT: {
      inputStartTagInBody(p, token);
      break;
    }
    case TAG_ID.PARAM:
    case TAG_ID.TRACK:
    case TAG_ID.SOURCE: {
      paramStartTagInBody(p, token);
      break;
    }
    case TAG_ID.IMAGE: {
      imageStartTagInBody(p, token);
      break;
    }
    case TAG_ID.BUTTON: {
      buttonStartTagInBody(p, token);
      break;
    }
    case TAG_ID.APPLET:
    case TAG_ID.OBJECT:
    case TAG_ID.MARQUEE: {
      appletStartTagInBody(p, token);
      break;
    }
    case TAG_ID.IFRAME: {
      iframeStartTagInBody(p, token);
      break;
    }
    case TAG_ID.SELECT: {
      selectStartTagInBody(p, token);
      break;
    }
    case TAG_ID.OPTION:
    case TAG_ID.OPTGROUP: {
      optgroupStartTagInBody(p, token);
      break;
    }
    case TAG_ID.NOEMBED: {
      noembedStartTagInBody(p, token);
      break;
    }
    case TAG_ID.FRAMESET: {
      framesetStartTagInBody(p, token);
      break;
    }
    case TAG_ID.TEXTAREA: {
      textareaStartTagInBody(p, token);
      break;
    }
    case TAG_ID.NOSCRIPT: {
      if (p.options.scriptingEnabled) {
        noembedStartTagInBody(p, token);
      } else {
        genericStartTagInBody(p, token);
      }
      break;
    }
    case TAG_ID.PLAINTEXT: {
      plaintextStartTagInBody(p, token);
      break;
    }
    case TAG_ID.COL:
    case TAG_ID.TH:
    case TAG_ID.TD:
    case TAG_ID.TR:
    case TAG_ID.HEAD:
    case TAG_ID.FRAME:
    case TAG_ID.TBODY:
    case TAG_ID.TFOOT:
    case TAG_ID.THEAD:
    case TAG_ID.CAPTION:
    case TAG_ID.COLGROUP: {
      break;
    }
    default: {
      genericStartTagInBody(p, token);
    }
  }
}
function bodyEndTagInBody(p, token) {
  if (p.openElements.hasInScope(TAG_ID.BODY)) {
    p.insertionMode = InsertionMode.AFTER_BODY;
    if (p.options.sourceCodeLocationInfo) {
      const bodyElement = p.openElements.tryPeekProperlyNestedBodyElement();
      if (bodyElement) {
        p._setEndLocation(bodyElement, token);
      }
    }
  }
}
function htmlEndTagInBody(p, token) {
  if (p.openElements.hasInScope(TAG_ID.BODY)) {
    p.insertionMode = InsertionMode.AFTER_BODY;
    endTagAfterBody(p, token);
  }
}
function addressEndTagInBody(p, token) {
  const tn = token.tagID;
  if (p.openElements.hasInScope(tn)) {
    p.openElements.generateImpliedEndTags();
    p.openElements.popUntilTagNamePopped(tn);
  }
}
function formEndTagInBody(p) {
  const inTemplate = p.openElements.tmplCount > 0;
  const { formElement } = p;
  if (!inTemplate) {
    p.formElement = null;
  }
  if ((formElement || inTemplate) && p.openElements.hasInScope(TAG_ID.FORM)) {
    p.openElements.generateImpliedEndTags();
    if (inTemplate) {
      p.openElements.popUntilTagNamePopped(TAG_ID.FORM);
    } else if (formElement) {
      p.openElements.remove(formElement);
    }
  }
}
function pEndTagInBody(p) {
  if (!p.openElements.hasInButtonScope(TAG_ID.P)) {
    p._insertFakeElement(TAG_NAMES.P, TAG_ID.P);
  }
  p._closePElement();
}
function liEndTagInBody(p) {
  if (p.openElements.hasInListItemScope(TAG_ID.LI)) {
    p.openElements.generateImpliedEndTagsWithExclusion(TAG_ID.LI);
    p.openElements.popUntilTagNamePopped(TAG_ID.LI);
  }
}
function ddEndTagInBody(p, token) {
  const tn = token.tagID;
  if (p.openElements.hasInScope(tn)) {
    p.openElements.generateImpliedEndTagsWithExclusion(tn);
    p.openElements.popUntilTagNamePopped(tn);
  }
}
function numberedHeaderEndTagInBody(p) {
  if (p.openElements.hasNumberedHeaderInScope()) {
    p.openElements.generateImpliedEndTags();
    p.openElements.popUntilNumberedHeaderPopped();
  }
}
function appletEndTagInBody(p, token) {
  const tn = token.tagID;
  if (p.openElements.hasInScope(tn)) {
    p.openElements.generateImpliedEndTags();
    p.openElements.popUntilTagNamePopped(tn);
    p.activeFormattingElements.clearToLastMarker();
  }
}
function brEndTagInBody(p) {
  p._reconstructActiveFormattingElements();
  p._insertFakeElement(TAG_NAMES.BR, TAG_ID.BR);
  p.openElements.pop();
  p.framesetOk = false;
}
function genericEndTagInBody(p, token) {
  const tn = token.tagName;
  const tid = token.tagID;
  for (let i = p.openElements.stackTop; i > 0; i--) {
    const element = p.openElements.items[i];
    const elementId = p.openElements.tagIDs[i];
    if (tid === elementId && (tid !== TAG_ID.UNKNOWN || p.treeAdapter.getTagName(element) === tn)) {
      p.openElements.generateImpliedEndTagsWithExclusion(tid);
      if (p.openElements.stackTop >= i)
        p.openElements.shortenToLength(i);
      break;
    }
    if (p._isSpecialElement(element, elementId)) {
      break;
    }
  }
}
function endTagInBody(p, token) {
  switch (token.tagID) {
    case TAG_ID.A:
    case TAG_ID.B:
    case TAG_ID.I:
    case TAG_ID.S:
    case TAG_ID.U:
    case TAG_ID.EM:
    case TAG_ID.TT:
    case TAG_ID.BIG:
    case TAG_ID.CODE:
    case TAG_ID.FONT:
    case TAG_ID.NOBR:
    case TAG_ID.SMALL:
    case TAG_ID.STRIKE:
    case TAG_ID.STRONG: {
      callAdoptionAgency(p, token);
      break;
    }
    case TAG_ID.P: {
      pEndTagInBody(p);
      break;
    }
    case TAG_ID.DL:
    case TAG_ID.UL:
    case TAG_ID.OL:
    case TAG_ID.DIR:
    case TAG_ID.DIV:
    case TAG_ID.NAV:
    case TAG_ID.PRE:
    case TAG_ID.MAIN:
    case TAG_ID.MENU:
    case TAG_ID.ASIDE:
    case TAG_ID.BUTTON:
    case TAG_ID.CENTER:
    case TAG_ID.FIGURE:
    case TAG_ID.FOOTER:
    case TAG_ID.HEADER:
    case TAG_ID.HGROUP:
    case TAG_ID.DIALOG:
    case TAG_ID.ADDRESS:
    case TAG_ID.ARTICLE:
    case TAG_ID.DETAILS:
    case TAG_ID.SECTION:
    case TAG_ID.SUMMARY:
    case TAG_ID.LISTING:
    case TAG_ID.FIELDSET:
    case TAG_ID.BLOCKQUOTE:
    case TAG_ID.FIGCAPTION: {
      addressEndTagInBody(p, token);
      break;
    }
    case TAG_ID.LI: {
      liEndTagInBody(p);
      break;
    }
    case TAG_ID.DD:
    case TAG_ID.DT: {
      ddEndTagInBody(p, token);
      break;
    }
    case TAG_ID.H1:
    case TAG_ID.H2:
    case TAG_ID.H3:
    case TAG_ID.H4:
    case TAG_ID.H5:
    case TAG_ID.H6: {
      numberedHeaderEndTagInBody(p);
      break;
    }
    case TAG_ID.BR: {
      brEndTagInBody(p);
      break;
    }
    case TAG_ID.BODY: {
      bodyEndTagInBody(p, token);
      break;
    }
    case TAG_ID.HTML: {
      htmlEndTagInBody(p, token);
      break;
    }
    case TAG_ID.FORM: {
      formEndTagInBody(p);
      break;
    }
    case TAG_ID.APPLET:
    case TAG_ID.OBJECT:
    case TAG_ID.MARQUEE: {
      appletEndTagInBody(p, token);
      break;
    }
    case TAG_ID.TEMPLATE: {
      templateEndTagInHead(p, token);
      break;
    }
    default: {
      genericEndTagInBody(p, token);
    }
  }
}
function eofInBody(p, token) {
  if (p.tmplInsertionModeStack.length > 0) {
    eofInTemplate(p, token);
  } else {
    stopParsing(p, token);
  }
}
function endTagInText(p, token) {
  var _a2;
  if (token.tagID === TAG_ID.SCRIPT) {
    (_a2 = p.scriptHandler) === null || _a2 === void 0 ? void 0 : _a2.call(p, p.openElements.current);
  }
  p.openElements.pop();
  p.insertionMode = p.originalInsertionMode;
}
function eofInText(p, token) {
  p._err(token, ERR.eofInElementThatCanContainOnlyText);
  p.openElements.pop();
  p.insertionMode = p.originalInsertionMode;
  p.onEof(token);
}
function characterInTable(p, token) {
  if (TABLE_STRUCTURE_TAGS.has(p.openElements.currentTagId)) {
    p.pendingCharacterTokens.length = 0;
    p.hasNonWhitespacePendingCharacterToken = false;
    p.originalInsertionMode = p.insertionMode;
    p.insertionMode = InsertionMode.IN_TABLE_TEXT;
    switch (token.type) {
      case TokenType.CHARACTER: {
        characterInTableText(p, token);
        break;
      }
      case TokenType.WHITESPACE_CHARACTER: {
        whitespaceCharacterInTableText(p, token);
        break;
      }
    }
  } else {
    tokenInTable(p, token);
  }
}
function captionStartTagInTable(p, token) {
  p.openElements.clearBackToTableContext();
  p.activeFormattingElements.insertMarker();
  p._insertElement(token, NS.HTML);
  p.insertionMode = InsertionMode.IN_CAPTION;
}
function colgroupStartTagInTable(p, token) {
  p.openElements.clearBackToTableContext();
  p._insertElement(token, NS.HTML);
  p.insertionMode = InsertionMode.IN_COLUMN_GROUP;
}
function colStartTagInTable(p, token) {
  p.openElements.clearBackToTableContext();
  p._insertFakeElement(TAG_NAMES.COLGROUP, TAG_ID.COLGROUP);
  p.insertionMode = InsertionMode.IN_COLUMN_GROUP;
  startTagInColumnGroup(p, token);
}
function tbodyStartTagInTable(p, token) {
  p.openElements.clearBackToTableContext();
  p._insertElement(token, NS.HTML);
  p.insertionMode = InsertionMode.IN_TABLE_BODY;
}
function tdStartTagInTable(p, token) {
  p.openElements.clearBackToTableContext();
  p._insertFakeElement(TAG_NAMES.TBODY, TAG_ID.TBODY);
  p.insertionMode = InsertionMode.IN_TABLE_BODY;
  startTagInTableBody(p, token);
}
function tableStartTagInTable(p, token) {
  if (p.openElements.hasInTableScope(TAG_ID.TABLE)) {
    p.openElements.popUntilTagNamePopped(TAG_ID.TABLE);
    p._resetInsertionMode();
    p._processStartTag(token);
  }
}
function inputStartTagInTable(p, token) {
  if (isHiddenInput(token)) {
    p._appendElement(token, NS.HTML);
  } else {
    tokenInTable(p, token);
  }
  token.ackSelfClosing = true;
}
function formStartTagInTable(p, token) {
  if (!p.formElement && p.openElements.tmplCount === 0) {
    p._insertElement(token, NS.HTML);
    p.formElement = p.openElements.current;
    p.openElements.pop();
  }
}
function startTagInTable(p, token) {
  switch (token.tagID) {
    case TAG_ID.TD:
    case TAG_ID.TH:
    case TAG_ID.TR: {
      tdStartTagInTable(p, token);
      break;
    }
    case TAG_ID.STYLE:
    case TAG_ID.SCRIPT:
    case TAG_ID.TEMPLATE: {
      startTagInHead(p, token);
      break;
    }
    case TAG_ID.COL: {
      colStartTagInTable(p, token);
      break;
    }
    case TAG_ID.FORM: {
      formStartTagInTable(p, token);
      break;
    }
    case TAG_ID.TABLE: {
      tableStartTagInTable(p, token);
      break;
    }
    case TAG_ID.TBODY:
    case TAG_ID.TFOOT:
    case TAG_ID.THEAD: {
      tbodyStartTagInTable(p, token);
      break;
    }
    case TAG_ID.INPUT: {
      inputStartTagInTable(p, token);
      break;
    }
    case TAG_ID.CAPTION: {
      captionStartTagInTable(p, token);
      break;
    }
    case TAG_ID.COLGROUP: {
      colgroupStartTagInTable(p, token);
      break;
    }
    default: {
      tokenInTable(p, token);
    }
  }
}
function endTagInTable(p, token) {
  switch (token.tagID) {
    case TAG_ID.TABLE: {
      if (p.openElements.hasInTableScope(TAG_ID.TABLE)) {
        p.openElements.popUntilTagNamePopped(TAG_ID.TABLE);
        p._resetInsertionMode();
      }
      break;
    }
    case TAG_ID.TEMPLATE: {
      templateEndTagInHead(p, token);
      break;
    }
    case TAG_ID.BODY:
    case TAG_ID.CAPTION:
    case TAG_ID.COL:
    case TAG_ID.COLGROUP:
    case TAG_ID.HTML:
    case TAG_ID.TBODY:
    case TAG_ID.TD:
    case TAG_ID.TFOOT:
    case TAG_ID.TH:
    case TAG_ID.THEAD:
    case TAG_ID.TR: {
      break;
    }
    default: {
      tokenInTable(p, token);
    }
  }
}
function tokenInTable(p, token) {
  const savedFosterParentingState = p.fosterParentingEnabled;
  p.fosterParentingEnabled = true;
  modeInBody(p, token);
  p.fosterParentingEnabled = savedFosterParentingState;
}
function whitespaceCharacterInTableText(p, token) {
  p.pendingCharacterTokens.push(token);
}
function characterInTableText(p, token) {
  p.pendingCharacterTokens.push(token);
  p.hasNonWhitespacePendingCharacterToken = true;
}
function tokenInTableText(p, token) {
  let i = 0;
  if (p.hasNonWhitespacePendingCharacterToken) {
    for (; i < p.pendingCharacterTokens.length; i++) {
      tokenInTable(p, p.pendingCharacterTokens[i]);
    }
  } else {
    for (; i < p.pendingCharacterTokens.length; i++) {
      p._insertCharacters(p.pendingCharacterTokens[i]);
    }
  }
  p.insertionMode = p.originalInsertionMode;
  p._processToken(token);
}
var TABLE_VOID_ELEMENTS = /* @__PURE__ */ new Set([TAG_ID.CAPTION, TAG_ID.COL, TAG_ID.COLGROUP, TAG_ID.TBODY, TAG_ID.TD, TAG_ID.TFOOT, TAG_ID.TH, TAG_ID.THEAD, TAG_ID.TR]);
function startTagInCaption(p, token) {
  const tn = token.tagID;
  if (TABLE_VOID_ELEMENTS.has(tn)) {
    if (p.openElements.hasInTableScope(TAG_ID.CAPTION)) {
      p.openElements.generateImpliedEndTags();
      p.openElements.popUntilTagNamePopped(TAG_ID.CAPTION);
      p.activeFormattingElements.clearToLastMarker();
      p.insertionMode = InsertionMode.IN_TABLE;
      startTagInTable(p, token);
    }
  } else {
    startTagInBody(p, token);
  }
}
function endTagInCaption(p, token) {
  const tn = token.tagID;
  switch (tn) {
    case TAG_ID.CAPTION:
    case TAG_ID.TABLE: {
      if (p.openElements.hasInTableScope(TAG_ID.CAPTION)) {
        p.openElements.generateImpliedEndTags();
        p.openElements.popUntilTagNamePopped(TAG_ID.CAPTION);
        p.activeFormattingElements.clearToLastMarker();
        p.insertionMode = InsertionMode.IN_TABLE;
        if (tn === TAG_ID.TABLE) {
          endTagInTable(p, token);
        }
      }
      break;
    }
    case TAG_ID.BODY:
    case TAG_ID.COL:
    case TAG_ID.COLGROUP:
    case TAG_ID.HTML:
    case TAG_ID.TBODY:
    case TAG_ID.TD:
    case TAG_ID.TFOOT:
    case TAG_ID.TH:
    case TAG_ID.THEAD:
    case TAG_ID.TR: {
      break;
    }
    default: {
      endTagInBody(p, token);
    }
  }
}
function startTagInColumnGroup(p, token) {
  switch (token.tagID) {
    case TAG_ID.HTML: {
      startTagInBody(p, token);
      break;
    }
    case TAG_ID.COL: {
      p._appendElement(token, NS.HTML);
      token.ackSelfClosing = true;
      break;
    }
    case TAG_ID.TEMPLATE: {
      startTagInHead(p, token);
      break;
    }
    default: {
      tokenInColumnGroup(p, token);
    }
  }
}
function endTagInColumnGroup(p, token) {
  switch (token.tagID) {
    case TAG_ID.COLGROUP: {
      if (p.openElements.currentTagId === TAG_ID.COLGROUP) {
        p.openElements.pop();
        p.insertionMode = InsertionMode.IN_TABLE;
      }
      break;
    }
    case TAG_ID.TEMPLATE: {
      templateEndTagInHead(p, token);
      break;
    }
    case TAG_ID.COL: {
      break;
    }
    default: {
      tokenInColumnGroup(p, token);
    }
  }
}
function tokenInColumnGroup(p, token) {
  if (p.openElements.currentTagId === TAG_ID.COLGROUP) {
    p.openElements.pop();
    p.insertionMode = InsertionMode.IN_TABLE;
    p._processToken(token);
  }
}
function startTagInTableBody(p, token) {
  switch (token.tagID) {
    case TAG_ID.TR: {
      p.openElements.clearBackToTableBodyContext();
      p._insertElement(token, NS.HTML);
      p.insertionMode = InsertionMode.IN_ROW;
      break;
    }
    case TAG_ID.TH:
    case TAG_ID.TD: {
      p.openElements.clearBackToTableBodyContext();
      p._insertFakeElement(TAG_NAMES.TR, TAG_ID.TR);
      p.insertionMode = InsertionMode.IN_ROW;
      startTagInRow(p, token);
      break;
    }
    case TAG_ID.CAPTION:
    case TAG_ID.COL:
    case TAG_ID.COLGROUP:
    case TAG_ID.TBODY:
    case TAG_ID.TFOOT:
    case TAG_ID.THEAD: {
      if (p.openElements.hasTableBodyContextInTableScope()) {
        p.openElements.clearBackToTableBodyContext();
        p.openElements.pop();
        p.insertionMode = InsertionMode.IN_TABLE;
        startTagInTable(p, token);
      }
      break;
    }
    default: {
      startTagInTable(p, token);
    }
  }
}
function endTagInTableBody(p, token) {
  const tn = token.tagID;
  switch (token.tagID) {
    case TAG_ID.TBODY:
    case TAG_ID.TFOOT:
    case TAG_ID.THEAD: {
      if (p.openElements.hasInTableScope(tn)) {
        p.openElements.clearBackToTableBodyContext();
        p.openElements.pop();
        p.insertionMode = InsertionMode.IN_TABLE;
      }
      break;
    }
    case TAG_ID.TABLE: {
      if (p.openElements.hasTableBodyContextInTableScope()) {
        p.openElements.clearBackToTableBodyContext();
        p.openElements.pop();
        p.insertionMode = InsertionMode.IN_TABLE;
        endTagInTable(p, token);
      }
      break;
    }
    case TAG_ID.BODY:
    case TAG_ID.CAPTION:
    case TAG_ID.COL:
    case TAG_ID.COLGROUP:
    case TAG_ID.HTML:
    case TAG_ID.TD:
    case TAG_ID.TH:
    case TAG_ID.TR: {
      break;
    }
    default: {
      endTagInTable(p, token);
    }
  }
}
function startTagInRow(p, token) {
  switch (token.tagID) {
    case TAG_ID.TH:
    case TAG_ID.TD: {
      p.openElements.clearBackToTableRowContext();
      p._insertElement(token, NS.HTML);
      p.insertionMode = InsertionMode.IN_CELL;
      p.activeFormattingElements.insertMarker();
      break;
    }
    case TAG_ID.CAPTION:
    case TAG_ID.COL:
    case TAG_ID.COLGROUP:
    case TAG_ID.TBODY:
    case TAG_ID.TFOOT:
    case TAG_ID.THEAD:
    case TAG_ID.TR: {
      if (p.openElements.hasInTableScope(TAG_ID.TR)) {
        p.openElements.clearBackToTableRowContext();
        p.openElements.pop();
        p.insertionMode = InsertionMode.IN_TABLE_BODY;
        startTagInTableBody(p, token);
      }
      break;
    }
    default: {
      startTagInTable(p, token);
    }
  }
}
function endTagInRow(p, token) {
  switch (token.tagID) {
    case TAG_ID.TR: {
      if (p.openElements.hasInTableScope(TAG_ID.TR)) {
        p.openElements.clearBackToTableRowContext();
        p.openElements.pop();
        p.insertionMode = InsertionMode.IN_TABLE_BODY;
      }
      break;
    }
    case TAG_ID.TABLE: {
      if (p.openElements.hasInTableScope(TAG_ID.TR)) {
        p.openElements.clearBackToTableRowContext();
        p.openElements.pop();
        p.insertionMode = InsertionMode.IN_TABLE_BODY;
        endTagInTableBody(p, token);
      }
      break;
    }
    case TAG_ID.TBODY:
    case TAG_ID.TFOOT:
    case TAG_ID.THEAD: {
      if (p.openElements.hasInTableScope(token.tagID) || p.openElements.hasInTableScope(TAG_ID.TR)) {
        p.openElements.clearBackToTableRowContext();
        p.openElements.pop();
        p.insertionMode = InsertionMode.IN_TABLE_BODY;
        endTagInTableBody(p, token);
      }
      break;
    }
    case TAG_ID.BODY:
    case TAG_ID.CAPTION:
    case TAG_ID.COL:
    case TAG_ID.COLGROUP:
    case TAG_ID.HTML:
    case TAG_ID.TD:
    case TAG_ID.TH: {
      break;
    }
    default: {
      endTagInTable(p, token);
    }
  }
}
function startTagInCell(p, token) {
  const tn = token.tagID;
  if (TABLE_VOID_ELEMENTS.has(tn)) {
    if (p.openElements.hasInTableScope(TAG_ID.TD) || p.openElements.hasInTableScope(TAG_ID.TH)) {
      p._closeTableCell();
      startTagInRow(p, token);
    }
  } else {
    startTagInBody(p, token);
  }
}
function endTagInCell(p, token) {
  const tn = token.tagID;
  switch (tn) {
    case TAG_ID.TD:
    case TAG_ID.TH: {
      if (p.openElements.hasInTableScope(tn)) {
        p.openElements.generateImpliedEndTags();
        p.openElements.popUntilTagNamePopped(tn);
        p.activeFormattingElements.clearToLastMarker();
        p.insertionMode = InsertionMode.IN_ROW;
      }
      break;
    }
    case TAG_ID.TABLE:
    case TAG_ID.TBODY:
    case TAG_ID.TFOOT:
    case TAG_ID.THEAD:
    case TAG_ID.TR: {
      if (p.openElements.hasInTableScope(tn)) {
        p._closeTableCell();
        endTagInRow(p, token);
      }
      break;
    }
    case TAG_ID.BODY:
    case TAG_ID.CAPTION:
    case TAG_ID.COL:
    case TAG_ID.COLGROUP:
    case TAG_ID.HTML: {
      break;
    }
    default: {
      endTagInBody(p, token);
    }
  }
}
function startTagInSelect(p, token) {
  switch (token.tagID) {
    case TAG_ID.HTML: {
      startTagInBody(p, token);
      break;
    }
    case TAG_ID.OPTION: {
      if (p.openElements.currentTagId === TAG_ID.OPTION) {
        p.openElements.pop();
      }
      p._insertElement(token, NS.HTML);
      break;
    }
    case TAG_ID.OPTGROUP: {
      if (p.openElements.currentTagId === TAG_ID.OPTION) {
        p.openElements.pop();
      }
      if (p.openElements.currentTagId === TAG_ID.OPTGROUP) {
        p.openElements.pop();
      }
      p._insertElement(token, NS.HTML);
      break;
    }
    case TAG_ID.INPUT:
    case TAG_ID.KEYGEN:
    case TAG_ID.TEXTAREA:
    case TAG_ID.SELECT: {
      if (p.openElements.hasInSelectScope(TAG_ID.SELECT)) {
        p.openElements.popUntilTagNamePopped(TAG_ID.SELECT);
        p._resetInsertionMode();
        if (token.tagID !== TAG_ID.SELECT) {
          p._processStartTag(token);
        }
      }
      break;
    }
    case TAG_ID.SCRIPT:
    case TAG_ID.TEMPLATE: {
      startTagInHead(p, token);
      break;
    }
    default:
  }
}
function endTagInSelect(p, token) {
  switch (token.tagID) {
    case TAG_ID.OPTGROUP: {
      if (p.openElements.stackTop > 0 && p.openElements.currentTagId === TAG_ID.OPTION && p.openElements.tagIDs[p.openElements.stackTop - 1] === TAG_ID.OPTGROUP) {
        p.openElements.pop();
      }
      if (p.openElements.currentTagId === TAG_ID.OPTGROUP) {
        p.openElements.pop();
      }
      break;
    }
    case TAG_ID.OPTION: {
      if (p.openElements.currentTagId === TAG_ID.OPTION) {
        p.openElements.pop();
      }
      break;
    }
    case TAG_ID.SELECT: {
      if (p.openElements.hasInSelectScope(TAG_ID.SELECT)) {
        p.openElements.popUntilTagNamePopped(TAG_ID.SELECT);
        p._resetInsertionMode();
      }
      break;
    }
    case TAG_ID.TEMPLATE: {
      templateEndTagInHead(p, token);
      break;
    }
    default:
  }
}
function startTagInSelectInTable(p, token) {
  const tn = token.tagID;
  if (tn === TAG_ID.CAPTION || tn === TAG_ID.TABLE || tn === TAG_ID.TBODY || tn === TAG_ID.TFOOT || tn === TAG_ID.THEAD || tn === TAG_ID.TR || tn === TAG_ID.TD || tn === TAG_ID.TH) {
    p.openElements.popUntilTagNamePopped(TAG_ID.SELECT);
    p._resetInsertionMode();
    p._processStartTag(token);
  } else {
    startTagInSelect(p, token);
  }
}
function endTagInSelectInTable(p, token) {
  const tn = token.tagID;
  if (tn === TAG_ID.CAPTION || tn === TAG_ID.TABLE || tn === TAG_ID.TBODY || tn === TAG_ID.TFOOT || tn === TAG_ID.THEAD || tn === TAG_ID.TR || tn === TAG_ID.TD || tn === TAG_ID.TH) {
    if (p.openElements.hasInTableScope(tn)) {
      p.openElements.popUntilTagNamePopped(TAG_ID.SELECT);
      p._resetInsertionMode();
      p.onEndTag(token);
    }
  } else {
    endTagInSelect(p, token);
  }
}
function startTagInTemplate(p, token) {
  switch (token.tagID) {
    case TAG_ID.BASE:
    case TAG_ID.BASEFONT:
    case TAG_ID.BGSOUND:
    case TAG_ID.LINK:
    case TAG_ID.META:
    case TAG_ID.NOFRAMES:
    case TAG_ID.SCRIPT:
    case TAG_ID.STYLE:
    case TAG_ID.TEMPLATE:
    case TAG_ID.TITLE: {
      startTagInHead(p, token);
      break;
    }
    case TAG_ID.CAPTION:
    case TAG_ID.COLGROUP:
    case TAG_ID.TBODY:
    case TAG_ID.TFOOT:
    case TAG_ID.THEAD: {
      p.tmplInsertionModeStack[0] = InsertionMode.IN_TABLE;
      p.insertionMode = InsertionMode.IN_TABLE;
      startTagInTable(p, token);
      break;
    }
    case TAG_ID.COL: {
      p.tmplInsertionModeStack[0] = InsertionMode.IN_COLUMN_GROUP;
      p.insertionMode = InsertionMode.IN_COLUMN_GROUP;
      startTagInColumnGroup(p, token);
      break;
    }
    case TAG_ID.TR: {
      p.tmplInsertionModeStack[0] = InsertionMode.IN_TABLE_BODY;
      p.insertionMode = InsertionMode.IN_TABLE_BODY;
      startTagInTableBody(p, token);
      break;
    }
    case TAG_ID.TD:
    case TAG_ID.TH: {
      p.tmplInsertionModeStack[0] = InsertionMode.IN_ROW;
      p.insertionMode = InsertionMode.IN_ROW;
      startTagInRow(p, token);
      break;
    }
    default: {
      p.tmplInsertionModeStack[0] = InsertionMode.IN_BODY;
      p.insertionMode = InsertionMode.IN_BODY;
      startTagInBody(p, token);
    }
  }
}
function endTagInTemplate(p, token) {
  if (token.tagID === TAG_ID.TEMPLATE) {
    templateEndTagInHead(p, token);
  }
}
function eofInTemplate(p, token) {
  if (p.openElements.tmplCount > 0) {
    p.openElements.popUntilTagNamePopped(TAG_ID.TEMPLATE);
    p.activeFormattingElements.clearToLastMarker();
    p.tmplInsertionModeStack.shift();
    p._resetInsertionMode();
    p.onEof(token);
  } else {
    stopParsing(p, token);
  }
}
function startTagAfterBody(p, token) {
  if (token.tagID === TAG_ID.HTML) {
    startTagInBody(p, token);
  } else {
    tokenAfterBody(p, token);
  }
}
function endTagAfterBody(p, token) {
  var _a2;
  if (token.tagID === TAG_ID.HTML) {
    if (!p.fragmentContext) {
      p.insertionMode = InsertionMode.AFTER_AFTER_BODY;
    }
    if (p.options.sourceCodeLocationInfo && p.openElements.tagIDs[0] === TAG_ID.HTML) {
      p._setEndLocation(p.openElements.items[0], token);
      const bodyElement = p.openElements.items[1];
      if (bodyElement && !((_a2 = p.treeAdapter.getNodeSourceCodeLocation(bodyElement)) === null || _a2 === void 0 ? void 0 : _a2.endTag)) {
        p._setEndLocation(bodyElement, token);
      }
    }
  } else {
    tokenAfterBody(p, token);
  }
}
function tokenAfterBody(p, token) {
  p.insertionMode = InsertionMode.IN_BODY;
  modeInBody(p, token);
}
function startTagInFrameset(p, token) {
  switch (token.tagID) {
    case TAG_ID.HTML: {
      startTagInBody(p, token);
      break;
    }
    case TAG_ID.FRAMESET: {
      p._insertElement(token, NS.HTML);
      break;
    }
    case TAG_ID.FRAME: {
      p._appendElement(token, NS.HTML);
      token.ackSelfClosing = true;
      break;
    }
    case TAG_ID.NOFRAMES: {
      startTagInHead(p, token);
      break;
    }
    default:
  }
}
function endTagInFrameset(p, token) {
  if (token.tagID === TAG_ID.FRAMESET && !p.openElements.isRootHtmlElementCurrent()) {
    p.openElements.pop();
    if (!p.fragmentContext && p.openElements.currentTagId !== TAG_ID.FRAMESET) {
      p.insertionMode = InsertionMode.AFTER_FRAMESET;
    }
  }
}
function startTagAfterFrameset(p, token) {
  switch (token.tagID) {
    case TAG_ID.HTML: {
      startTagInBody(p, token);
      break;
    }
    case TAG_ID.NOFRAMES: {
      startTagInHead(p, token);
      break;
    }
    default:
  }
}
function endTagAfterFrameset(p, token) {
  if (token.tagID === TAG_ID.HTML) {
    p.insertionMode = InsertionMode.AFTER_AFTER_FRAMESET;
  }
}
function startTagAfterAfterBody(p, token) {
  if (token.tagID === TAG_ID.HTML) {
    startTagInBody(p, token);
  } else {
    tokenAfterAfterBody(p, token);
  }
}
function tokenAfterAfterBody(p, token) {
  p.insertionMode = InsertionMode.IN_BODY;
  modeInBody(p, token);
}
function startTagAfterAfterFrameset(p, token) {
  switch (token.tagID) {
    case TAG_ID.HTML: {
      startTagInBody(p, token);
      break;
    }
    case TAG_ID.NOFRAMES: {
      startTagInHead(p, token);
      break;
    }
    default:
  }
}
function nullCharacterInForeignContent(p, token) {
  token.chars = REPLACEMENT_CHARACTER;
  p._insertCharacters(token);
}
function characterInForeignContent(p, token) {
  p._insertCharacters(token);
  p.framesetOk = false;
}
function popUntilHtmlOrIntegrationPoint(p) {
  while (p.treeAdapter.getNamespaceURI(p.openElements.current) !== NS.HTML && !p._isIntegrationPoint(p.openElements.currentTagId, p.openElements.current)) {
    p.openElements.pop();
  }
}
function startTagInForeignContent(p, token) {
  if (causesExit(token)) {
    popUntilHtmlOrIntegrationPoint(p);
    p._startTagOutsideForeignContent(token);
  } else {
    const current = p._getAdjustedCurrentElement();
    const currentNs = p.treeAdapter.getNamespaceURI(current);
    if (currentNs === NS.MATHML) {
      adjustTokenMathMLAttrs(token);
    } else if (currentNs === NS.SVG) {
      adjustTokenSVGTagName(token);
      adjustTokenSVGAttrs(token);
    }
    adjustTokenXMLAttrs(token);
    if (token.selfClosing) {
      p._appendElement(token, currentNs);
    } else {
      p._insertElement(token, currentNs);
    }
    token.ackSelfClosing = true;
  }
}
function endTagInForeignContent(p, token) {
  if (token.tagID === TAG_ID.P || token.tagID === TAG_ID.BR) {
    popUntilHtmlOrIntegrationPoint(p);
    p._endTagOutsideForeignContent(token);
    return;
  }
  for (let i = p.openElements.stackTop; i > 0; i--) {
    const element = p.openElements.items[i];
    if (p.treeAdapter.getNamespaceURI(element) === NS.HTML) {
      p._endTagOutsideForeignContent(token);
      break;
    }
    const tagName = p.treeAdapter.getTagName(element);
    if (tagName.toLowerCase() === token.tagName) {
      token.tagName = tagName;
      p.openElements.shortenToLength(i);
      break;
    }
  }
}

// node_modules/.pnpm/parse5@7.1.2/node_modules/parse5/dist/serializer/index.js
var VOID_ELEMENTS = /* @__PURE__ */ new Set([
  TAG_NAMES.AREA,
  TAG_NAMES.BASE,
  TAG_NAMES.BASEFONT,
  TAG_NAMES.BGSOUND,
  TAG_NAMES.BR,
  TAG_NAMES.COL,
  TAG_NAMES.EMBED,
  TAG_NAMES.FRAME,
  TAG_NAMES.HR,
  TAG_NAMES.IMG,
  TAG_NAMES.INPUT,
  TAG_NAMES.KEYGEN,
  TAG_NAMES.LINK,
  TAG_NAMES.META,
  TAG_NAMES.PARAM,
  TAG_NAMES.SOURCE,
  TAG_NAMES.TRACK,
  TAG_NAMES.WBR
]);
function isVoidElement(node, options) {
  return options.treeAdapter.isElementNode(node) && options.treeAdapter.getNamespaceURI(node) === NS.HTML && VOID_ELEMENTS.has(options.treeAdapter.getTagName(node));
}
var defaultOpts3 = { treeAdapter: defaultTreeAdapter, scriptingEnabled: true };
function serializeOuter(node, options) {
  const opts = { ...defaultOpts3, ...options };
  return serializeNode(node, opts);
}
function serializeChildNodes(parentNode, options) {
  let html3 = "";
  const container = options.treeAdapter.isElementNode(parentNode) && options.treeAdapter.getTagName(parentNode) === TAG_NAMES.TEMPLATE && options.treeAdapter.getNamespaceURI(parentNode) === NS.HTML ? options.treeAdapter.getTemplateContent(parentNode) : parentNode;
  const childNodes = options.treeAdapter.getChildNodes(container);
  if (childNodes) {
    for (const currentNode of childNodes) {
      html3 += serializeNode(currentNode, options);
    }
  }
  return html3;
}
function serializeNode(node, options) {
  if (options.treeAdapter.isElementNode(node)) {
    return serializeElement(node, options);
  }
  if (options.treeAdapter.isTextNode(node)) {
    return serializeTextNode(node, options);
  }
  if (options.treeAdapter.isCommentNode(node)) {
    return serializeCommentNode(node, options);
  }
  if (options.treeAdapter.isDocumentTypeNode(node)) {
    return serializeDocumentTypeNode(node, options);
  }
  return "";
}
function serializeElement(node, options) {
  const tn = options.treeAdapter.getTagName(node);
  return `<${tn}${serializeAttributes(node, options)}>${isVoidElement(node, options) ? "" : `${serializeChildNodes(node, options)}</${tn}>`}`;
}
function serializeAttributes(node, { treeAdapter }) {
  let html3 = "";
  for (const attr2 of treeAdapter.getAttrList(node)) {
    html3 += " ";
    if (!attr2.namespace) {
      html3 += attr2.name;
    } else
      switch (attr2.namespace) {
        case NS.XML: {
          html3 += `xml:${attr2.name}`;
          break;
        }
        case NS.XMLNS: {
          if (attr2.name !== "xmlns") {
            html3 += "xmlns:";
          }
          html3 += attr2.name;
          break;
        }
        case NS.XLINK: {
          html3 += `xlink:${attr2.name}`;
          break;
        }
        default: {
          html3 += `${attr2.prefix}:${attr2.name}`;
        }
      }
    html3 += `="${escapeAttribute(attr2.value)}"`;
  }
  return html3;
}
function serializeTextNode(node, options) {
  const { treeAdapter } = options;
  const content = treeAdapter.getTextNodeContent(node);
  const parent2 = treeAdapter.getParentNode(node);
  const parentTn = parent2 && treeAdapter.isElementNode(parent2) && treeAdapter.getTagName(parent2);
  return parentTn && treeAdapter.getNamespaceURI(parent2) === NS.HTML && hasUnescapedText(parentTn, options.scriptingEnabled) ? content : escapeText(content);
}
function serializeCommentNode(node, { treeAdapter }) {
  return `<!--${treeAdapter.getCommentNodeContent(node)}-->`;
}
function serializeDocumentTypeNode(node, { treeAdapter }) {
  return `<!DOCTYPE ${treeAdapter.getDocumentTypeNodeName(node)}>`;
}

// node_modules/.pnpm/parse5@7.1.2/node_modules/parse5/dist/index.js
function parse4(html3, options) {
  return Parser.parse(html3, options);
}
function parseFragment(fragmentContext, html3, options) {
  if (typeof fragmentContext === "string") {
    options = html3;
    html3 = fragmentContext;
    fragmentContext = null;
  }
  const parser = Parser.getFragmentParser(fragmentContext, options);
  parser.tokenizer.write(html3, true);
  return parser.getFragment();
}

// node_modules/.pnpm/parse5-htmlparser2-tree-adapter@7.0.0/node_modules/parse5-htmlparser2-tree-adapter/dist/index.js
function createTextNode2(value) {
  return new Text2(value);
}
function enquoteDoctypeId(id) {
  const quote = id.includes('"') ? "'" : '"';
  return quote + id + quote;
}
function serializeDoctypeContent(name2, publicId, systemId) {
  let str2 = "!DOCTYPE ";
  if (name2) {
    str2 += name2;
  }
  if (publicId) {
    str2 += ` PUBLIC ${enquoteDoctypeId(publicId)}`;
  } else if (systemId) {
    str2 += " SYSTEM";
  }
  if (systemId) {
    str2 += ` ${enquoteDoctypeId(systemId)}`;
  }
  return str2;
}
var adapter = {
  // Re-exports from domhandler
  isCommentNode: isComment,
  isElementNode: isTag2,
  isTextNode: isText,
  //Node construction
  createDocument() {
    const node = new Document([]);
    node["x-mode"] = html_exports.DOCUMENT_MODE.NO_QUIRKS;
    return node;
  },
  createDocumentFragment() {
    return new Document([]);
  },
  createElement(tagName, namespaceURI, attrs) {
    const attribs = /* @__PURE__ */ Object.create(null);
    const attribsNamespace = /* @__PURE__ */ Object.create(null);
    const attribsPrefix = /* @__PURE__ */ Object.create(null);
    for (let i = 0; i < attrs.length; i++) {
      const attrName = attrs[i].name;
      attribs[attrName] = attrs[i].value;
      attribsNamespace[attrName] = attrs[i].namespace;
      attribsPrefix[attrName] = attrs[i].prefix;
    }
    const node = new Element(tagName, attribs, []);
    node.namespace = namespaceURI;
    node["x-attribsNamespace"] = attribsNamespace;
    node["x-attribsPrefix"] = attribsPrefix;
    return node;
  },
  createCommentNode(data2) {
    return new Comment2(data2);
  },
  //Tree mutation
  appendChild(parentNode, newNode) {
    const prev2 = parentNode.children[parentNode.children.length - 1];
    if (prev2) {
      prev2.next = newNode;
      newNode.prev = prev2;
    }
    parentNode.children.push(newNode);
    newNode.parent = parentNode;
  },
  insertBefore(parentNode, newNode, referenceNode) {
    const insertionIdx = parentNode.children.indexOf(referenceNode);
    const { prev: prev2 } = referenceNode;
    if (prev2) {
      prev2.next = newNode;
      newNode.prev = prev2;
    }
    referenceNode.prev = newNode;
    newNode.next = referenceNode;
    parentNode.children.splice(insertionIdx, 0, newNode);
    newNode.parent = parentNode;
  },
  setTemplateContent(templateElement, contentElement) {
    adapter.appendChild(templateElement, contentElement);
  },
  getTemplateContent(templateElement) {
    return templateElement.children[0];
  },
  setDocumentType(document2, name2, publicId, systemId) {
    const data2 = serializeDoctypeContent(name2, publicId, systemId);
    let doctypeNode = document2.children.find((node) => isDirective(node) && node.name === "!doctype");
    if (doctypeNode) {
      doctypeNode.data = data2 !== null && data2 !== void 0 ? data2 : null;
    } else {
      doctypeNode = new ProcessingInstruction("!doctype", data2);
      adapter.appendChild(document2, doctypeNode);
    }
    doctypeNode["x-name"] = name2 !== null && name2 !== void 0 ? name2 : void 0;
    doctypeNode["x-publicId"] = publicId !== null && publicId !== void 0 ? publicId : void 0;
    doctypeNode["x-systemId"] = systemId !== null && systemId !== void 0 ? systemId : void 0;
  },
  setDocumentMode(document2, mode) {
    document2["x-mode"] = mode;
  },
  getDocumentMode(document2) {
    return document2["x-mode"];
  },
  detachNode(node) {
    if (node.parent) {
      const idx = node.parent.children.indexOf(node);
      const { prev: prev2, next: next2 } = node;
      node.prev = null;
      node.next = null;
      if (prev2) {
        prev2.next = next2;
      }
      if (next2) {
        next2.prev = prev2;
      }
      node.parent.children.splice(idx, 1);
      node.parent = null;
    }
  },
  insertText(parentNode, text4) {
    const lastChild = parentNode.children[parentNode.children.length - 1];
    if (lastChild && isText(lastChild)) {
      lastChild.data += text4;
    } else {
      adapter.appendChild(parentNode, createTextNode2(text4));
    }
  },
  insertTextBefore(parentNode, text4, referenceNode) {
    const prevNode = parentNode.children[parentNode.children.indexOf(referenceNode) - 1];
    if (prevNode && isText(prevNode)) {
      prevNode.data += text4;
    } else {
      adapter.insertBefore(parentNode, createTextNode2(text4), referenceNode);
    }
  },
  adoptAttributes(recipient, attrs) {
    for (let i = 0; i < attrs.length; i++) {
      const attrName = attrs[i].name;
      if (typeof recipient.attribs[attrName] === "undefined") {
        recipient.attribs[attrName] = attrs[i].value;
        recipient["x-attribsNamespace"][attrName] = attrs[i].namespace;
        recipient["x-attribsPrefix"][attrName] = attrs[i].prefix;
      }
    }
  },
  //Tree traversing
  getFirstChild(node) {
    return node.children[0];
  },
  getChildNodes(node) {
    return node.children;
  },
  getParentNode(node) {
    return node.parent;
  },
  getAttrList(element) {
    return element.attributes;
  },
  //Node data
  getTagName(element) {
    return element.name;
  },
  getNamespaceURI(element) {
    return element.namespace;
  },
  getTextNodeContent(textNode) {
    return textNode.data;
  },
  getCommentNodeContent(commentNode) {
    return commentNode.data;
  },
  getDocumentTypeNodeName(doctypeNode) {
    var _a2;
    return (_a2 = doctypeNode["x-name"]) !== null && _a2 !== void 0 ? _a2 : "";
  },
  getDocumentTypeNodePublicId(doctypeNode) {
    var _a2;
    return (_a2 = doctypeNode["x-publicId"]) !== null && _a2 !== void 0 ? _a2 : "";
  },
  getDocumentTypeNodeSystemId(doctypeNode) {
    var _a2;
    return (_a2 = doctypeNode["x-systemId"]) !== null && _a2 !== void 0 ? _a2 : "";
  },
  //Node types
  isDocumentTypeNode(node) {
    return isDirective(node) && node.name === "!doctype";
  },
  // Source code location
  setNodeSourceCodeLocation(node, location) {
    if (location) {
      node.startIndex = location.startOffset;
      node.endIndex = location.endOffset;
    }
    node.sourceCodeLocation = location;
  },
  getNodeSourceCodeLocation(node) {
    return node.sourceCodeLocation;
  },
  updateNodeSourceCodeLocation(node, endLocation) {
    if (endLocation.endOffset != null)
      node.endIndex = endLocation.endOffset;
    node.sourceCodeLocation = {
      ...node.sourceCodeLocation,
      ...endLocation
    };
  }
};

// node_modules/.pnpm/cheerio@1.0.0-rc.12/node_modules/cheerio/lib/esm/parsers/parse5-adapter.js
function parseWithParse5(content, options, isDocument2, context) {
  const opts = {
    scriptingEnabled: typeof options.scriptingEnabled === "boolean" ? options.scriptingEnabled : true,
    treeAdapter: adapter,
    sourceCodeLocationInfo: options.sourceCodeLocationInfo
  };
  return isDocument2 ? parse4(content, opts) : parseFragment(context, content, opts);
}
var renderOpts = { treeAdapter: adapter };
function renderWithParse5(dom) {
  const nodes = "length" in dom ? dom : [dom];
  for (let index2 = 0; index2 < nodes.length; index2 += 1) {
    const node = nodes[index2];
    if (isDocument(node)) {
      Array.prototype.splice.call(nodes, index2, 1, ...node.children);
    }
  }
  let result = "";
  for (let index2 = 0; index2 < nodes.length; index2 += 1) {
    const node = nodes[index2];
    result += serializeOuter(node, renderOpts);
  }
  return result;
}

// node_modules/.pnpm/htmlparser2@8.0.2/node_modules/htmlparser2/lib/esm/Tokenizer.js
var CharCodes2;
(function(CharCodes3) {
  CharCodes3[CharCodes3["Tab"] = 9] = "Tab";
  CharCodes3[CharCodes3["NewLine"] = 10] = "NewLine";
  CharCodes3[CharCodes3["FormFeed"] = 12] = "FormFeed";
  CharCodes3[CharCodes3["CarriageReturn"] = 13] = "CarriageReturn";
  CharCodes3[CharCodes3["Space"] = 32] = "Space";
  CharCodes3[CharCodes3["ExclamationMark"] = 33] = "ExclamationMark";
  CharCodes3[CharCodes3["Number"] = 35] = "Number";
  CharCodes3[CharCodes3["Amp"] = 38] = "Amp";
  CharCodes3[CharCodes3["SingleQuote"] = 39] = "SingleQuote";
  CharCodes3[CharCodes3["DoubleQuote"] = 34] = "DoubleQuote";
  CharCodes3[CharCodes3["Dash"] = 45] = "Dash";
  CharCodes3[CharCodes3["Slash"] = 47] = "Slash";
  CharCodes3[CharCodes3["Zero"] = 48] = "Zero";
  CharCodes3[CharCodes3["Nine"] = 57] = "Nine";
  CharCodes3[CharCodes3["Semi"] = 59] = "Semi";
  CharCodes3[CharCodes3["Lt"] = 60] = "Lt";
  CharCodes3[CharCodes3["Eq"] = 61] = "Eq";
  CharCodes3[CharCodes3["Gt"] = 62] = "Gt";
  CharCodes3[CharCodes3["Questionmark"] = 63] = "Questionmark";
  CharCodes3[CharCodes3["UpperA"] = 65] = "UpperA";
  CharCodes3[CharCodes3["LowerA"] = 97] = "LowerA";
  CharCodes3[CharCodes3["UpperF"] = 70] = "UpperF";
  CharCodes3[CharCodes3["LowerF"] = 102] = "LowerF";
  CharCodes3[CharCodes3["UpperZ"] = 90] = "UpperZ";
  CharCodes3[CharCodes3["LowerZ"] = 122] = "LowerZ";
  CharCodes3[CharCodes3["LowerX"] = 120] = "LowerX";
  CharCodes3[CharCodes3["OpeningSquareBracket"] = 91] = "OpeningSquareBracket";
})(CharCodes2 || (CharCodes2 = {}));
var State2;
(function(State4) {
  State4[State4["Text"] = 1] = "Text";
  State4[State4["BeforeTagName"] = 2] = "BeforeTagName";
  State4[State4["InTagName"] = 3] = "InTagName";
  State4[State4["InSelfClosingTag"] = 4] = "InSelfClosingTag";
  State4[State4["BeforeClosingTagName"] = 5] = "BeforeClosingTagName";
  State4[State4["InClosingTagName"] = 6] = "InClosingTagName";
  State4[State4["AfterClosingTagName"] = 7] = "AfterClosingTagName";
  State4[State4["BeforeAttributeName"] = 8] = "BeforeAttributeName";
  State4[State4["InAttributeName"] = 9] = "InAttributeName";
  State4[State4["AfterAttributeName"] = 10] = "AfterAttributeName";
  State4[State4["BeforeAttributeValue"] = 11] = "BeforeAttributeValue";
  State4[State4["InAttributeValueDq"] = 12] = "InAttributeValueDq";
  State4[State4["InAttributeValueSq"] = 13] = "InAttributeValueSq";
  State4[State4["InAttributeValueNq"] = 14] = "InAttributeValueNq";
  State4[State4["BeforeDeclaration"] = 15] = "BeforeDeclaration";
  State4[State4["InDeclaration"] = 16] = "InDeclaration";
  State4[State4["InProcessingInstruction"] = 17] = "InProcessingInstruction";
  State4[State4["BeforeComment"] = 18] = "BeforeComment";
  State4[State4["CDATASequence"] = 19] = "CDATASequence";
  State4[State4["InSpecialComment"] = 20] = "InSpecialComment";
  State4[State4["InCommentLike"] = 21] = "InCommentLike";
  State4[State4["BeforeSpecialS"] = 22] = "BeforeSpecialS";
  State4[State4["SpecialStartSequence"] = 23] = "SpecialStartSequence";
  State4[State4["InSpecialTag"] = 24] = "InSpecialTag";
  State4[State4["BeforeEntity"] = 25] = "BeforeEntity";
  State4[State4["BeforeNumericEntity"] = 26] = "BeforeNumericEntity";
  State4[State4["InNamedEntity"] = 27] = "InNamedEntity";
  State4[State4["InNumericEntity"] = 28] = "InNumericEntity";
  State4[State4["InHexEntity"] = 29] = "InHexEntity";
})(State2 || (State2 = {}));
function isWhitespace3(c) {
  return c === CharCodes2.Space || c === CharCodes2.NewLine || c === CharCodes2.Tab || c === CharCodes2.FormFeed || c === CharCodes2.CarriageReturn;
}
function isEndOfTagSection(c) {
  return c === CharCodes2.Slash || c === CharCodes2.Gt || isWhitespace3(c);
}
function isNumber2(c) {
  return c >= CharCodes2.Zero && c <= CharCodes2.Nine;
}
function isASCIIAlpha(c) {
  return c >= CharCodes2.LowerA && c <= CharCodes2.LowerZ || c >= CharCodes2.UpperA && c <= CharCodes2.UpperZ;
}
function isHexDigit(c) {
  return c >= CharCodes2.UpperA && c <= CharCodes2.UpperF || c >= CharCodes2.LowerA && c <= CharCodes2.LowerF;
}
var QuoteType;
(function(QuoteType2) {
  QuoteType2[QuoteType2["NoValue"] = 0] = "NoValue";
  QuoteType2[QuoteType2["Unquoted"] = 1] = "Unquoted";
  QuoteType2[QuoteType2["Single"] = 2] = "Single";
  QuoteType2[QuoteType2["Double"] = 3] = "Double";
})(QuoteType || (QuoteType = {}));
var Sequences = {
  Cdata: new Uint8Array([67, 68, 65, 84, 65, 91]),
  CdataEnd: new Uint8Array([93, 93, 62]),
  CommentEnd: new Uint8Array([45, 45, 62]),
  ScriptEnd: new Uint8Array([60, 47, 115, 99, 114, 105, 112, 116]),
  StyleEnd: new Uint8Array([60, 47, 115, 116, 121, 108, 101]),
  TitleEnd: new Uint8Array([60, 47, 116, 105, 116, 108, 101])
  // `</title`
};
var Tokenizer2 = class {
  constructor({ xmlMode = false, decodeEntities = true }, cbs) {
    this.cbs = cbs;
    this.state = State2.Text;
    this.buffer = "";
    this.sectionStart = 0;
    this.index = 0;
    this.baseState = State2.Text;
    this.isSpecial = false;
    this.running = true;
    this.offset = 0;
    this.currentSequence = void 0;
    this.sequenceIndex = 0;
    this.trieIndex = 0;
    this.trieCurrent = 0;
    this.entityResult = 0;
    this.entityExcess = 0;
    this.xmlMode = xmlMode;
    this.decodeEntities = decodeEntities;
    this.entityTrie = xmlMode ? decode_data_xml_default : decode_data_html_default;
  }
  reset() {
    this.state = State2.Text;
    this.buffer = "";
    this.sectionStart = 0;
    this.index = 0;
    this.baseState = State2.Text;
    this.currentSequence = void 0;
    this.running = true;
    this.offset = 0;
  }
  write(chunk) {
    this.offset += this.buffer.length;
    this.buffer = chunk;
    this.parse();
  }
  end() {
    if (this.running)
      this.finish();
  }
  pause() {
    this.running = false;
  }
  resume() {
    this.running = true;
    if (this.index < this.buffer.length + this.offset) {
      this.parse();
    }
  }
  /**
   * The current index within all of the written data.
   */
  getIndex() {
    return this.index;
  }
  /**
   * The start of the current section.
   */
  getSectionStart() {
    return this.sectionStart;
  }
  stateText(c) {
    if (c === CharCodes2.Lt || !this.decodeEntities && this.fastForwardTo(CharCodes2.Lt)) {
      if (this.index > this.sectionStart) {
        this.cbs.ontext(this.sectionStart, this.index);
      }
      this.state = State2.BeforeTagName;
      this.sectionStart = this.index;
    } else if (this.decodeEntities && c === CharCodes2.Amp) {
      this.state = State2.BeforeEntity;
    }
  }
  stateSpecialStartSequence(c) {
    const isEnd = this.sequenceIndex === this.currentSequence.length;
    const isMatch = isEnd ? (
      // If we are at the end of the sequence, make sure the tag name has ended
      isEndOfTagSection(c)
    ) : (
      // Otherwise, do a case-insensitive comparison
      (c | 32) === this.currentSequence[this.sequenceIndex]
    );
    if (!isMatch) {
      this.isSpecial = false;
    } else if (!isEnd) {
      this.sequenceIndex++;
      return;
    }
    this.sequenceIndex = 0;
    this.state = State2.InTagName;
    this.stateInTagName(c);
  }
  /** Look for an end tag. For <title> tags, also decode entities. */
  stateInSpecialTag(c) {
    if (this.sequenceIndex === this.currentSequence.length) {
      if (c === CharCodes2.Gt || isWhitespace3(c)) {
        const endOfText = this.index - this.currentSequence.length;
        if (this.sectionStart < endOfText) {
          const actualIndex = this.index;
          this.index = endOfText;
          this.cbs.ontext(this.sectionStart, endOfText);
          this.index = actualIndex;
        }
        this.isSpecial = false;
        this.sectionStart = endOfText + 2;
        this.stateInClosingTagName(c);
        return;
      }
      this.sequenceIndex = 0;
    }
    if ((c | 32) === this.currentSequence[this.sequenceIndex]) {
      this.sequenceIndex += 1;
    } else if (this.sequenceIndex === 0) {
      if (this.currentSequence === Sequences.TitleEnd) {
        if (this.decodeEntities && c === CharCodes2.Amp) {
          this.state = State2.BeforeEntity;
        }
      } else if (this.fastForwardTo(CharCodes2.Lt)) {
        this.sequenceIndex = 1;
      }
    } else {
      this.sequenceIndex = Number(c === CharCodes2.Lt);
    }
  }
  stateCDATASequence(c) {
    if (c === Sequences.Cdata[this.sequenceIndex]) {
      if (++this.sequenceIndex === Sequences.Cdata.length) {
        this.state = State2.InCommentLike;
        this.currentSequence = Sequences.CdataEnd;
        this.sequenceIndex = 0;
        this.sectionStart = this.index + 1;
      }
    } else {
      this.sequenceIndex = 0;
      this.state = State2.InDeclaration;
      this.stateInDeclaration(c);
    }
  }
  /**
   * When we wait for one specific character, we can speed things up
   * by skipping through the buffer until we find it.
   *
   * @returns Whether the character was found.
   */
  fastForwardTo(c) {
    while (++this.index < this.buffer.length + this.offset) {
      if (this.buffer.charCodeAt(this.index - this.offset) === c) {
        return true;
      }
    }
    this.index = this.buffer.length + this.offset - 1;
    return false;
  }
  /**
   * Comments and CDATA end with `-->` and `]]>`.
   *
   * Their common qualities are:
   * - Their end sequences have a distinct character they start with.
   * - That character is then repeated, so we have to check multiple repeats.
   * - All characters but the start character of the sequence can be skipped.
   */
  stateInCommentLike(c) {
    if (c === this.currentSequence[this.sequenceIndex]) {
      if (++this.sequenceIndex === this.currentSequence.length) {
        if (this.currentSequence === Sequences.CdataEnd) {
          this.cbs.oncdata(this.sectionStart, this.index, 2);
        } else {
          this.cbs.oncomment(this.sectionStart, this.index, 2);
        }
        this.sequenceIndex = 0;
        this.sectionStart = this.index + 1;
        this.state = State2.Text;
      }
    } else if (this.sequenceIndex === 0) {
      if (this.fastForwardTo(this.currentSequence[0])) {
        this.sequenceIndex = 1;
      }
    } else if (c !== this.currentSequence[this.sequenceIndex - 1]) {
      this.sequenceIndex = 0;
    }
  }
  /**
   * HTML only allows ASCII alpha characters (a-z and A-Z) at the beginning of a tag name.
   *
   * XML allows a lot more characters here (@see https://www.w3.org/TR/REC-xml/#NT-NameStartChar).
   * We allow anything that wouldn't end the tag.
   */
  isTagStartChar(c) {
    return this.xmlMode ? !isEndOfTagSection(c) : isASCIIAlpha(c);
  }
  startSpecial(sequence, offset) {
    this.isSpecial = true;
    this.currentSequence = sequence;
    this.sequenceIndex = offset;
    this.state = State2.SpecialStartSequence;
  }
  stateBeforeTagName(c) {
    if (c === CharCodes2.ExclamationMark) {
      this.state = State2.BeforeDeclaration;
      this.sectionStart = this.index + 1;
    } else if (c === CharCodes2.Questionmark) {
      this.state = State2.InProcessingInstruction;
      this.sectionStart = this.index + 1;
    } else if (this.isTagStartChar(c)) {
      const lower = c | 32;
      this.sectionStart = this.index;
      if (!this.xmlMode && lower === Sequences.TitleEnd[2]) {
        this.startSpecial(Sequences.TitleEnd, 3);
      } else {
        this.state = !this.xmlMode && lower === Sequences.ScriptEnd[2] ? State2.BeforeSpecialS : State2.InTagName;
      }
    } else if (c === CharCodes2.Slash) {
      this.state = State2.BeforeClosingTagName;
    } else {
      this.state = State2.Text;
      this.stateText(c);
    }
  }
  stateInTagName(c) {
    if (isEndOfTagSection(c)) {
      this.cbs.onopentagname(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.state = State2.BeforeAttributeName;
      this.stateBeforeAttributeName(c);
    }
  }
  stateBeforeClosingTagName(c) {
    if (isWhitespace3(c)) {
    } else if (c === CharCodes2.Gt) {
      this.state = State2.Text;
    } else {
      this.state = this.isTagStartChar(c) ? State2.InClosingTagName : State2.InSpecialComment;
      this.sectionStart = this.index;
    }
  }
  stateInClosingTagName(c) {
    if (c === CharCodes2.Gt || isWhitespace3(c)) {
      this.cbs.onclosetag(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.state = State2.AfterClosingTagName;
      this.stateAfterClosingTagName(c);
    }
  }
  stateAfterClosingTagName(c) {
    if (c === CharCodes2.Gt || this.fastForwardTo(CharCodes2.Gt)) {
      this.state = State2.Text;
      this.baseState = State2.Text;
      this.sectionStart = this.index + 1;
    }
  }
  stateBeforeAttributeName(c) {
    if (c === CharCodes2.Gt) {
      this.cbs.onopentagend(this.index);
      if (this.isSpecial) {
        this.state = State2.InSpecialTag;
        this.sequenceIndex = 0;
      } else {
        this.state = State2.Text;
      }
      this.baseState = this.state;
      this.sectionStart = this.index + 1;
    } else if (c === CharCodes2.Slash) {
      this.state = State2.InSelfClosingTag;
    } else if (!isWhitespace3(c)) {
      this.state = State2.InAttributeName;
      this.sectionStart = this.index;
    }
  }
  stateInSelfClosingTag(c) {
    if (c === CharCodes2.Gt) {
      this.cbs.onselfclosingtag(this.index);
      this.state = State2.Text;
      this.baseState = State2.Text;
      this.sectionStart = this.index + 1;
      this.isSpecial = false;
    } else if (!isWhitespace3(c)) {
      this.state = State2.BeforeAttributeName;
      this.stateBeforeAttributeName(c);
    }
  }
  stateInAttributeName(c) {
    if (c === CharCodes2.Eq || isEndOfTagSection(c)) {
      this.cbs.onattribname(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.state = State2.AfterAttributeName;
      this.stateAfterAttributeName(c);
    }
  }
  stateAfterAttributeName(c) {
    if (c === CharCodes2.Eq) {
      this.state = State2.BeforeAttributeValue;
    } else if (c === CharCodes2.Slash || c === CharCodes2.Gt) {
      this.cbs.onattribend(QuoteType.NoValue, this.index);
      this.state = State2.BeforeAttributeName;
      this.stateBeforeAttributeName(c);
    } else if (!isWhitespace3(c)) {
      this.cbs.onattribend(QuoteType.NoValue, this.index);
      this.state = State2.InAttributeName;
      this.sectionStart = this.index;
    }
  }
  stateBeforeAttributeValue(c) {
    if (c === CharCodes2.DoubleQuote) {
      this.state = State2.InAttributeValueDq;
      this.sectionStart = this.index + 1;
    } else if (c === CharCodes2.SingleQuote) {
      this.state = State2.InAttributeValueSq;
      this.sectionStart = this.index + 1;
    } else if (!isWhitespace3(c)) {
      this.sectionStart = this.index;
      this.state = State2.InAttributeValueNq;
      this.stateInAttributeValueNoQuotes(c);
    }
  }
  handleInAttributeValue(c, quote) {
    if (c === quote || !this.decodeEntities && this.fastForwardTo(quote)) {
      this.cbs.onattribdata(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.cbs.onattribend(quote === CharCodes2.DoubleQuote ? QuoteType.Double : QuoteType.Single, this.index);
      this.state = State2.BeforeAttributeName;
    } else if (this.decodeEntities && c === CharCodes2.Amp) {
      this.baseState = this.state;
      this.state = State2.BeforeEntity;
    }
  }
  stateInAttributeValueDoubleQuotes(c) {
    this.handleInAttributeValue(c, CharCodes2.DoubleQuote);
  }
  stateInAttributeValueSingleQuotes(c) {
    this.handleInAttributeValue(c, CharCodes2.SingleQuote);
  }
  stateInAttributeValueNoQuotes(c) {
    if (isWhitespace3(c) || c === CharCodes2.Gt) {
      this.cbs.onattribdata(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.cbs.onattribend(QuoteType.Unquoted, this.index);
      this.state = State2.BeforeAttributeName;
      this.stateBeforeAttributeName(c);
    } else if (this.decodeEntities && c === CharCodes2.Amp) {
      this.baseState = this.state;
      this.state = State2.BeforeEntity;
    }
  }
  stateBeforeDeclaration(c) {
    if (c === CharCodes2.OpeningSquareBracket) {
      this.state = State2.CDATASequence;
      this.sequenceIndex = 0;
    } else {
      this.state = c === CharCodes2.Dash ? State2.BeforeComment : State2.InDeclaration;
    }
  }
  stateInDeclaration(c) {
    if (c === CharCodes2.Gt || this.fastForwardTo(CharCodes2.Gt)) {
      this.cbs.ondeclaration(this.sectionStart, this.index);
      this.state = State2.Text;
      this.sectionStart = this.index + 1;
    }
  }
  stateInProcessingInstruction(c) {
    if (c === CharCodes2.Gt || this.fastForwardTo(CharCodes2.Gt)) {
      this.cbs.onprocessinginstruction(this.sectionStart, this.index);
      this.state = State2.Text;
      this.sectionStart = this.index + 1;
    }
  }
  stateBeforeComment(c) {
    if (c === CharCodes2.Dash) {
      this.state = State2.InCommentLike;
      this.currentSequence = Sequences.CommentEnd;
      this.sequenceIndex = 2;
      this.sectionStart = this.index + 1;
    } else {
      this.state = State2.InDeclaration;
    }
  }
  stateInSpecialComment(c) {
    if (c === CharCodes2.Gt || this.fastForwardTo(CharCodes2.Gt)) {
      this.cbs.oncomment(this.sectionStart, this.index, 0);
      this.state = State2.Text;
      this.sectionStart = this.index + 1;
    }
  }
  stateBeforeSpecialS(c) {
    const lower = c | 32;
    if (lower === Sequences.ScriptEnd[3]) {
      this.startSpecial(Sequences.ScriptEnd, 4);
    } else if (lower === Sequences.StyleEnd[3]) {
      this.startSpecial(Sequences.StyleEnd, 4);
    } else {
      this.state = State2.InTagName;
      this.stateInTagName(c);
    }
  }
  stateBeforeEntity(c) {
    this.entityExcess = 1;
    this.entityResult = 0;
    if (c === CharCodes2.Number) {
      this.state = State2.BeforeNumericEntity;
    } else if (c === CharCodes2.Amp) {
    } else {
      this.trieIndex = 0;
      this.trieCurrent = this.entityTrie[0];
      this.state = State2.InNamedEntity;
      this.stateInNamedEntity(c);
    }
  }
  stateInNamedEntity(c) {
    this.entityExcess += 1;
    this.trieIndex = determineBranch(this.entityTrie, this.trieCurrent, this.trieIndex + 1, c);
    if (this.trieIndex < 0) {
      this.emitNamedEntity();
      this.index--;
      return;
    }
    this.trieCurrent = this.entityTrie[this.trieIndex];
    const masked = this.trieCurrent & BinTrieFlags.VALUE_LENGTH;
    if (masked) {
      const valueLength = (masked >> 14) - 1;
      if (!this.allowLegacyEntity() && c !== CharCodes2.Semi) {
        this.trieIndex += valueLength;
      } else {
        const entityStart = this.index - this.entityExcess + 1;
        if (entityStart > this.sectionStart) {
          this.emitPartial(this.sectionStart, entityStart);
        }
        this.entityResult = this.trieIndex;
        this.trieIndex += valueLength;
        this.entityExcess = 0;
        this.sectionStart = this.index + 1;
        if (valueLength === 0) {
          this.emitNamedEntity();
        }
      }
    }
  }
  emitNamedEntity() {
    this.state = this.baseState;
    if (this.entityResult === 0) {
      return;
    }
    const valueLength = (this.entityTrie[this.entityResult] & BinTrieFlags.VALUE_LENGTH) >> 14;
    switch (valueLength) {
      case 1: {
        this.emitCodePoint(this.entityTrie[this.entityResult] & ~BinTrieFlags.VALUE_LENGTH);
        break;
      }
      case 2: {
        this.emitCodePoint(this.entityTrie[this.entityResult + 1]);
        break;
      }
      case 3: {
        this.emitCodePoint(this.entityTrie[this.entityResult + 1]);
        this.emitCodePoint(this.entityTrie[this.entityResult + 2]);
      }
    }
  }
  stateBeforeNumericEntity(c) {
    if ((c | 32) === CharCodes2.LowerX) {
      this.entityExcess++;
      this.state = State2.InHexEntity;
    } else {
      this.state = State2.InNumericEntity;
      this.stateInNumericEntity(c);
    }
  }
  emitNumericEntity(strict) {
    const entityStart = this.index - this.entityExcess - 1;
    const numberStart = entityStart + 2 + Number(this.state === State2.InHexEntity);
    if (numberStart !== this.index) {
      if (entityStart > this.sectionStart) {
        this.emitPartial(this.sectionStart, entityStart);
      }
      this.sectionStart = this.index + Number(strict);
      this.emitCodePoint(replaceCodePoint(this.entityResult));
    }
    this.state = this.baseState;
  }
  stateInNumericEntity(c) {
    if (c === CharCodes2.Semi) {
      this.emitNumericEntity(true);
    } else if (isNumber2(c)) {
      this.entityResult = this.entityResult * 10 + (c - CharCodes2.Zero);
      this.entityExcess++;
    } else {
      if (this.allowLegacyEntity()) {
        this.emitNumericEntity(false);
      } else {
        this.state = this.baseState;
      }
      this.index--;
    }
  }
  stateInHexEntity(c) {
    if (c === CharCodes2.Semi) {
      this.emitNumericEntity(true);
    } else if (isNumber2(c)) {
      this.entityResult = this.entityResult * 16 + (c - CharCodes2.Zero);
      this.entityExcess++;
    } else if (isHexDigit(c)) {
      this.entityResult = this.entityResult * 16 + ((c | 32) - CharCodes2.LowerA + 10);
      this.entityExcess++;
    } else {
      if (this.allowLegacyEntity()) {
        this.emitNumericEntity(false);
      } else {
        this.state = this.baseState;
      }
      this.index--;
    }
  }
  allowLegacyEntity() {
    return !this.xmlMode && (this.baseState === State2.Text || this.baseState === State2.InSpecialTag);
  }
  /**
   * Remove data that has already been consumed from the buffer.
   */
  cleanup() {
    if (this.running && this.sectionStart !== this.index) {
      if (this.state === State2.Text || this.state === State2.InSpecialTag && this.sequenceIndex === 0) {
        this.cbs.ontext(this.sectionStart, this.index);
        this.sectionStart = this.index;
      } else if (this.state === State2.InAttributeValueDq || this.state === State2.InAttributeValueSq || this.state === State2.InAttributeValueNq) {
        this.cbs.onattribdata(this.sectionStart, this.index);
        this.sectionStart = this.index;
      }
    }
  }
  shouldContinue() {
    return this.index < this.buffer.length + this.offset && this.running;
  }
  /**
   * Iterates through the buffer, calling the function corresponding to the current state.
   *
   * States that are more likely to be hit are higher up, as a performance improvement.
   */
  parse() {
    while (this.shouldContinue()) {
      const c = this.buffer.charCodeAt(this.index - this.offset);
      switch (this.state) {
        case State2.Text: {
          this.stateText(c);
          break;
        }
        case State2.SpecialStartSequence: {
          this.stateSpecialStartSequence(c);
          break;
        }
        case State2.InSpecialTag: {
          this.stateInSpecialTag(c);
          break;
        }
        case State2.CDATASequence: {
          this.stateCDATASequence(c);
          break;
        }
        case State2.InAttributeValueDq: {
          this.stateInAttributeValueDoubleQuotes(c);
          break;
        }
        case State2.InAttributeName: {
          this.stateInAttributeName(c);
          break;
        }
        case State2.InCommentLike: {
          this.stateInCommentLike(c);
          break;
        }
        case State2.InSpecialComment: {
          this.stateInSpecialComment(c);
          break;
        }
        case State2.BeforeAttributeName: {
          this.stateBeforeAttributeName(c);
          break;
        }
        case State2.InTagName: {
          this.stateInTagName(c);
          break;
        }
        case State2.InClosingTagName: {
          this.stateInClosingTagName(c);
          break;
        }
        case State2.BeforeTagName: {
          this.stateBeforeTagName(c);
          break;
        }
        case State2.AfterAttributeName: {
          this.stateAfterAttributeName(c);
          break;
        }
        case State2.InAttributeValueSq: {
          this.stateInAttributeValueSingleQuotes(c);
          break;
        }
        case State2.BeforeAttributeValue: {
          this.stateBeforeAttributeValue(c);
          break;
        }
        case State2.BeforeClosingTagName: {
          this.stateBeforeClosingTagName(c);
          break;
        }
        case State2.AfterClosingTagName: {
          this.stateAfterClosingTagName(c);
          break;
        }
        case State2.BeforeSpecialS: {
          this.stateBeforeSpecialS(c);
          break;
        }
        case State2.InAttributeValueNq: {
          this.stateInAttributeValueNoQuotes(c);
          break;
        }
        case State2.InSelfClosingTag: {
          this.stateInSelfClosingTag(c);
          break;
        }
        case State2.InDeclaration: {
          this.stateInDeclaration(c);
          break;
        }
        case State2.BeforeDeclaration: {
          this.stateBeforeDeclaration(c);
          break;
        }
        case State2.BeforeComment: {
          this.stateBeforeComment(c);
          break;
        }
        case State2.InProcessingInstruction: {
          this.stateInProcessingInstruction(c);
          break;
        }
        case State2.InNamedEntity: {
          this.stateInNamedEntity(c);
          break;
        }
        case State2.BeforeEntity: {
          this.stateBeforeEntity(c);
          break;
        }
        case State2.InHexEntity: {
          this.stateInHexEntity(c);
          break;
        }
        case State2.InNumericEntity: {
          this.stateInNumericEntity(c);
          break;
        }
        default: {
          this.stateBeforeNumericEntity(c);
        }
      }
      this.index++;
    }
    this.cleanup();
  }
  finish() {
    if (this.state === State2.InNamedEntity) {
      this.emitNamedEntity();
    }
    if (this.sectionStart < this.index) {
      this.handleTrailingData();
    }
    this.cbs.onend();
  }
  /** Handle any trailing data. */
  handleTrailingData() {
    const endIndex = this.buffer.length + this.offset;
    if (this.state === State2.InCommentLike) {
      if (this.currentSequence === Sequences.CdataEnd) {
        this.cbs.oncdata(this.sectionStart, endIndex, 0);
      } else {
        this.cbs.oncomment(this.sectionStart, endIndex, 0);
      }
    } else if (this.state === State2.InNumericEntity && this.allowLegacyEntity()) {
      this.emitNumericEntity(false);
    } else if (this.state === State2.InHexEntity && this.allowLegacyEntity()) {
      this.emitNumericEntity(false);
    } else if (this.state === State2.InTagName || this.state === State2.BeforeAttributeName || this.state === State2.BeforeAttributeValue || this.state === State2.AfterAttributeName || this.state === State2.InAttributeName || this.state === State2.InAttributeValueSq || this.state === State2.InAttributeValueDq || this.state === State2.InAttributeValueNq || this.state === State2.InClosingTagName) {
    } else {
      this.cbs.ontext(this.sectionStart, endIndex);
    }
  }
  emitPartial(start, endIndex) {
    if (this.baseState !== State2.Text && this.baseState !== State2.InSpecialTag) {
      this.cbs.onattribdata(start, endIndex);
    } else {
      this.cbs.ontext(start, endIndex);
    }
  }
  emitCodePoint(cp) {
    if (this.baseState !== State2.Text && this.baseState !== State2.InSpecialTag) {
      this.cbs.onattribentity(cp);
    } else {
      this.cbs.ontextentity(cp);
    }
  }
};

// node_modules/.pnpm/htmlparser2@8.0.2/node_modules/htmlparser2/lib/esm/Parser.js
var formTags = /* @__PURE__ */ new Set([
  "input",
  "option",
  "optgroup",
  "select",
  "button",
  "datalist",
  "textarea"
]);
var pTag = /* @__PURE__ */ new Set(["p"]);
var tableSectionTags = /* @__PURE__ */ new Set(["thead", "tbody"]);
var ddtTags = /* @__PURE__ */ new Set(["dd", "dt"]);
var rtpTags = /* @__PURE__ */ new Set(["rt", "rp"]);
var openImpliesClose = /* @__PURE__ */ new Map([
  ["tr", /* @__PURE__ */ new Set(["tr", "th", "td"])],
  ["th", /* @__PURE__ */ new Set(["th"])],
  ["td", /* @__PURE__ */ new Set(["thead", "th", "td"])],
  ["body", /* @__PURE__ */ new Set(["head", "link", "script"])],
  ["li", /* @__PURE__ */ new Set(["li"])],
  ["p", pTag],
  ["h1", pTag],
  ["h2", pTag],
  ["h3", pTag],
  ["h4", pTag],
  ["h5", pTag],
  ["h6", pTag],
  ["select", formTags],
  ["input", formTags],
  ["output", formTags],
  ["button", formTags],
  ["datalist", formTags],
  ["textarea", formTags],
  ["option", /* @__PURE__ */ new Set(["option"])],
  ["optgroup", /* @__PURE__ */ new Set(["optgroup", "option"])],
  ["dd", ddtTags],
  ["dt", ddtTags],
  ["address", pTag],
  ["article", pTag],
  ["aside", pTag],
  ["blockquote", pTag],
  ["details", pTag],
  ["div", pTag],
  ["dl", pTag],
  ["fieldset", pTag],
  ["figcaption", pTag],
  ["figure", pTag],
  ["footer", pTag],
  ["form", pTag],
  ["header", pTag],
  ["hr", pTag],
  ["main", pTag],
  ["nav", pTag],
  ["ol", pTag],
  ["pre", pTag],
  ["section", pTag],
  ["table", pTag],
  ["ul", pTag],
  ["rt", rtpTags],
  ["rp", rtpTags],
  ["tbody", tableSectionTags],
  ["tfoot", tableSectionTags]
]);
var voidElements = /* @__PURE__ */ new Set([
  "area",
  "base",
  "basefont",
  "br",
  "col",
  "command",
  "embed",
  "frame",
  "hr",
  "img",
  "input",
  "isindex",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
]);
var foreignContextElements = /* @__PURE__ */ new Set(["math", "svg"]);
var htmlIntegrationElements = /* @__PURE__ */ new Set([
  "mi",
  "mo",
  "mn",
  "ms",
  "mtext",
  "annotation-xml",
  "foreignobject",
  "desc",
  "title"
]);
var reNameEnd = /\s|\//;
var Parser2 = class {
  constructor(cbs, options = {}) {
    var _a2, _b, _c, _d, _e;
    this.options = options;
    this.startIndex = 0;
    this.endIndex = 0;
    this.openTagStart = 0;
    this.tagname = "";
    this.attribname = "";
    this.attribvalue = "";
    this.attribs = null;
    this.stack = [];
    this.foreignContext = [];
    this.buffers = [];
    this.bufferOffset = 0;
    this.writeIndex = 0;
    this.ended = false;
    this.cbs = cbs !== null && cbs !== void 0 ? cbs : {};
    this.lowerCaseTagNames = (_a2 = options.lowerCaseTags) !== null && _a2 !== void 0 ? _a2 : !options.xmlMode;
    this.lowerCaseAttributeNames = (_b = options.lowerCaseAttributeNames) !== null && _b !== void 0 ? _b : !options.xmlMode;
    this.tokenizer = new ((_c = options.Tokenizer) !== null && _c !== void 0 ? _c : Tokenizer2)(this.options, this);
    (_e = (_d = this.cbs).onparserinit) === null || _e === void 0 ? void 0 : _e.call(_d, this);
  }
  // Tokenizer event handlers
  /** @internal */
  ontext(start, endIndex) {
    var _a2, _b;
    const data2 = this.getSlice(start, endIndex);
    this.endIndex = endIndex - 1;
    (_b = (_a2 = this.cbs).ontext) === null || _b === void 0 ? void 0 : _b.call(_a2, data2);
    this.startIndex = endIndex;
  }
  /** @internal */
  ontextentity(cp) {
    var _a2, _b;
    const index2 = this.tokenizer.getSectionStart();
    this.endIndex = index2 - 1;
    (_b = (_a2 = this.cbs).ontext) === null || _b === void 0 ? void 0 : _b.call(_a2, fromCodePoint(cp));
    this.startIndex = index2;
  }
  isVoidElement(name2) {
    return !this.options.xmlMode && voidElements.has(name2);
  }
  /** @internal */
  onopentagname(start, endIndex) {
    this.endIndex = endIndex;
    let name2 = this.getSlice(start, endIndex);
    if (this.lowerCaseTagNames) {
      name2 = name2.toLowerCase();
    }
    this.emitOpenTag(name2);
  }
  emitOpenTag(name2) {
    var _a2, _b, _c, _d;
    this.openTagStart = this.startIndex;
    this.tagname = name2;
    const impliesClose = !this.options.xmlMode && openImpliesClose.get(name2);
    if (impliesClose) {
      while (this.stack.length > 0 && impliesClose.has(this.stack[this.stack.length - 1])) {
        const element = this.stack.pop();
        (_b = (_a2 = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a2, element, true);
      }
    }
    if (!this.isVoidElement(name2)) {
      this.stack.push(name2);
      if (foreignContextElements.has(name2)) {
        this.foreignContext.push(true);
      } else if (htmlIntegrationElements.has(name2)) {
        this.foreignContext.push(false);
      }
    }
    (_d = (_c = this.cbs).onopentagname) === null || _d === void 0 ? void 0 : _d.call(_c, name2);
    if (this.cbs.onopentag)
      this.attribs = {};
  }
  endOpenTag(isImplied) {
    var _a2, _b;
    this.startIndex = this.openTagStart;
    if (this.attribs) {
      (_b = (_a2 = this.cbs).onopentag) === null || _b === void 0 ? void 0 : _b.call(_a2, this.tagname, this.attribs, isImplied);
      this.attribs = null;
    }
    if (this.cbs.onclosetag && this.isVoidElement(this.tagname)) {
      this.cbs.onclosetag(this.tagname, true);
    }
    this.tagname = "";
  }
  /** @internal */
  onopentagend(endIndex) {
    this.endIndex = endIndex;
    this.endOpenTag(false);
    this.startIndex = endIndex + 1;
  }
  /** @internal */
  onclosetag(start, endIndex) {
    var _a2, _b, _c, _d, _e, _f;
    this.endIndex = endIndex;
    let name2 = this.getSlice(start, endIndex);
    if (this.lowerCaseTagNames) {
      name2 = name2.toLowerCase();
    }
    if (foreignContextElements.has(name2) || htmlIntegrationElements.has(name2)) {
      this.foreignContext.pop();
    }
    if (!this.isVoidElement(name2)) {
      const pos = this.stack.lastIndexOf(name2);
      if (pos !== -1) {
        if (this.cbs.onclosetag) {
          let count = this.stack.length - pos;
          while (count--) {
            this.cbs.onclosetag(this.stack.pop(), count !== 0);
          }
        } else
          this.stack.length = pos;
      } else if (!this.options.xmlMode && name2 === "p") {
        this.emitOpenTag("p");
        this.closeCurrentTag(true);
      }
    } else if (!this.options.xmlMode && name2 === "br") {
      (_b = (_a2 = this.cbs).onopentagname) === null || _b === void 0 ? void 0 : _b.call(_a2, "br");
      (_d = (_c = this.cbs).onopentag) === null || _d === void 0 ? void 0 : _d.call(_c, "br", {}, true);
      (_f = (_e = this.cbs).onclosetag) === null || _f === void 0 ? void 0 : _f.call(_e, "br", false);
    }
    this.startIndex = endIndex + 1;
  }
  /** @internal */
  onselfclosingtag(endIndex) {
    this.endIndex = endIndex;
    if (this.options.xmlMode || this.options.recognizeSelfClosing || this.foreignContext[this.foreignContext.length - 1]) {
      this.closeCurrentTag(false);
      this.startIndex = endIndex + 1;
    } else {
      this.onopentagend(endIndex);
    }
  }
  closeCurrentTag(isOpenImplied) {
    var _a2, _b;
    const name2 = this.tagname;
    this.endOpenTag(isOpenImplied);
    if (this.stack[this.stack.length - 1] === name2) {
      (_b = (_a2 = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a2, name2, !isOpenImplied);
      this.stack.pop();
    }
  }
  /** @internal */
  onattribname(start, endIndex) {
    this.startIndex = start;
    const name2 = this.getSlice(start, endIndex);
    this.attribname = this.lowerCaseAttributeNames ? name2.toLowerCase() : name2;
  }
  /** @internal */
  onattribdata(start, endIndex) {
    this.attribvalue += this.getSlice(start, endIndex);
  }
  /** @internal */
  onattribentity(cp) {
    this.attribvalue += fromCodePoint(cp);
  }
  /** @internal */
  onattribend(quote, endIndex) {
    var _a2, _b;
    this.endIndex = endIndex;
    (_b = (_a2 = this.cbs).onattribute) === null || _b === void 0 ? void 0 : _b.call(_a2, this.attribname, this.attribvalue, quote === QuoteType.Double ? '"' : quote === QuoteType.Single ? "'" : quote === QuoteType.NoValue ? void 0 : null);
    if (this.attribs && !Object.prototype.hasOwnProperty.call(this.attribs, this.attribname)) {
      this.attribs[this.attribname] = this.attribvalue;
    }
    this.attribvalue = "";
  }
  getInstructionName(value) {
    const index2 = value.search(reNameEnd);
    let name2 = index2 < 0 ? value : value.substr(0, index2);
    if (this.lowerCaseTagNames) {
      name2 = name2.toLowerCase();
    }
    return name2;
  }
  /** @internal */
  ondeclaration(start, endIndex) {
    this.endIndex = endIndex;
    const value = this.getSlice(start, endIndex);
    if (this.cbs.onprocessinginstruction) {
      const name2 = this.getInstructionName(value);
      this.cbs.onprocessinginstruction(`!${name2}`, `!${value}`);
    }
    this.startIndex = endIndex + 1;
  }
  /** @internal */
  onprocessinginstruction(start, endIndex) {
    this.endIndex = endIndex;
    const value = this.getSlice(start, endIndex);
    if (this.cbs.onprocessinginstruction) {
      const name2 = this.getInstructionName(value);
      this.cbs.onprocessinginstruction(`?${name2}`, `?${value}`);
    }
    this.startIndex = endIndex + 1;
  }
  /** @internal */
  oncomment(start, endIndex, offset) {
    var _a2, _b, _c, _d;
    this.endIndex = endIndex;
    (_b = (_a2 = this.cbs).oncomment) === null || _b === void 0 ? void 0 : _b.call(_a2, this.getSlice(start, endIndex - offset));
    (_d = (_c = this.cbs).oncommentend) === null || _d === void 0 ? void 0 : _d.call(_c);
    this.startIndex = endIndex + 1;
  }
  /** @internal */
  oncdata(start, endIndex, offset) {
    var _a2, _b, _c, _d, _e, _f, _g, _h, _j, _k;
    this.endIndex = endIndex;
    const value = this.getSlice(start, endIndex - offset);
    if (this.options.xmlMode || this.options.recognizeCDATA) {
      (_b = (_a2 = this.cbs).oncdatastart) === null || _b === void 0 ? void 0 : _b.call(_a2);
      (_d = (_c = this.cbs).ontext) === null || _d === void 0 ? void 0 : _d.call(_c, value);
      (_f = (_e = this.cbs).oncdataend) === null || _f === void 0 ? void 0 : _f.call(_e);
    } else {
      (_h = (_g = this.cbs).oncomment) === null || _h === void 0 ? void 0 : _h.call(_g, `[CDATA[${value}]]`);
      (_k = (_j = this.cbs).oncommentend) === null || _k === void 0 ? void 0 : _k.call(_j);
    }
    this.startIndex = endIndex + 1;
  }
  /** @internal */
  onend() {
    var _a2, _b;
    if (this.cbs.onclosetag) {
      this.endIndex = this.startIndex;
      for (let index2 = this.stack.length; index2 > 0; this.cbs.onclosetag(this.stack[--index2], true))
        ;
    }
    (_b = (_a2 = this.cbs).onend) === null || _b === void 0 ? void 0 : _b.call(_a2);
  }
  /**
   * Resets the parser to a blank state, ready to parse a new HTML document
   */
  reset() {
    var _a2, _b, _c, _d;
    (_b = (_a2 = this.cbs).onreset) === null || _b === void 0 ? void 0 : _b.call(_a2);
    this.tokenizer.reset();
    this.tagname = "";
    this.attribname = "";
    this.attribs = null;
    this.stack.length = 0;
    this.startIndex = 0;
    this.endIndex = 0;
    (_d = (_c = this.cbs).onparserinit) === null || _d === void 0 ? void 0 : _d.call(_c, this);
    this.buffers.length = 0;
    this.bufferOffset = 0;
    this.writeIndex = 0;
    this.ended = false;
  }
  /**
   * Resets the parser, then parses a complete document and
   * pushes it to the handler.
   *
   * @param data Document to parse.
   */
  parseComplete(data2) {
    this.reset();
    this.end(data2);
  }
  getSlice(start, end2) {
    while (start - this.bufferOffset >= this.buffers[0].length) {
      this.shiftBuffer();
    }
    let slice2 = this.buffers[0].slice(start - this.bufferOffset, end2 - this.bufferOffset);
    while (end2 - this.bufferOffset > this.buffers[0].length) {
      this.shiftBuffer();
      slice2 += this.buffers[0].slice(0, end2 - this.bufferOffset);
    }
    return slice2;
  }
  shiftBuffer() {
    this.bufferOffset += this.buffers[0].length;
    this.writeIndex--;
    this.buffers.shift();
  }
  /**
   * Parses a chunk of data and calls the corresponding callbacks.
   *
   * @param chunk Chunk to parse.
   */
  write(chunk) {
    var _a2, _b;
    if (this.ended) {
      (_b = (_a2 = this.cbs).onerror) === null || _b === void 0 ? void 0 : _b.call(_a2, new Error(".write() after done!"));
      return;
    }
    this.buffers.push(chunk);
    if (this.tokenizer.running) {
      this.tokenizer.write(chunk);
      this.writeIndex++;
    }
  }
  /**
   * Parses the end of the buffer and clears the stack, calls onend.
   *
   * @param chunk Optional final chunk to parse.
   */
  end(chunk) {
    var _a2, _b;
    if (this.ended) {
      (_b = (_a2 = this.cbs).onerror) === null || _b === void 0 ? void 0 : _b.call(_a2, new Error(".end() after done!"));
      return;
    }
    if (chunk)
      this.write(chunk);
    this.ended = true;
    this.tokenizer.end();
  }
  /**
   * Pauses parsing. The parser won't emit events until `resume` is called.
   */
  pause() {
    this.tokenizer.pause();
  }
  /**
   * Resumes parsing after `pause` was called.
   */
  resume() {
    this.tokenizer.resume();
    while (this.tokenizer.running && this.writeIndex < this.buffers.length) {
      this.tokenizer.write(this.buffers[this.writeIndex++]);
    }
    if (this.ended)
      this.tokenizer.end();
  }
  /**
   * Alias of `write`, for backwards compatibility.
   *
   * @param chunk Chunk to parse.
   * @deprecated
   */
  parseChunk(chunk) {
    this.write(chunk);
  }
  /**
   * Alias of `end`, for backwards compatibility.
   *
   * @param chunk Optional final chunk to parse.
   * @deprecated
   */
  done(chunk) {
    this.end(chunk);
  }
};

// node_modules/.pnpm/htmlparser2@8.0.2/node_modules/htmlparser2/lib/esm/index.js
function parseDocument(data2, options) {
  const handler = new DomHandler(void 0, options);
  new Parser2(handler, options).end(data2);
  return handler.root;
}

// node_modules/.pnpm/cheerio@1.0.0-rc.12/node_modules/cheerio/lib/esm/index.js
var parse5 = getParse((content, options, isDocument2, context) => options.xmlMode || options._useHtmlParser2 ? parseDocument(content, options) : parseWithParse5(content, options, isDocument2, context));
var load = getLoad(parse5, (dom, options) => options.xmlMode || options._useHtmlParser2 ? esm_default(dom, options) : renderWithParse5(dom));
var esm_default2 = load([]);
var { contains: contains2 } = static_exports;
var { merge: merge2 } = static_exports;
var { parseHTML: parseHTML2 } = static_exports;
var { root: root2 } = static_exports;

// node_modules/.pnpm/markmap-html-parser@0.17.0_markmap-common@0.17.0/node_modules/markmap-html-parser/dist/index.mjs
var Levels = ((Levels2) => {
  Levels2[Levels2["None"] = 0] = "None";
  Levels2[Levels2["H1"] = 1] = "H1";
  Levels2[Levels2["H2"] = 2] = "H2";
  Levels2[Levels2["H3"] = 3] = "H3";
  Levels2[Levels2["H4"] = 4] = "H4";
  Levels2[Levels2["H5"] = 5] = "H5";
  Levels2[Levels2["H6"] = 6] = "H6";
  Levels2[Levels2["Block"] = 7] = "Block";
  Levels2[Levels2["List"] = 8] = "List";
  Levels2[Levels2["ListItem"] = 9] = "ListItem";
  return Levels2;
})(Levels || {});
var defaultSelectorRules = {
  "div,p": ({ $node }) => ({
    queue: $node.children()
  }),
  "h1,h2,h3,h4,h5,h6": ({ $node, getContent }) => ({
    ...getContent($node.contents())
  }),
  "ul,ol": ({ $node }) => ({
    queue: $node.children(),
    nesting: true
  }),
  li: ({ $node, getContent }) => {
    const queue = $node.children().filter("ul,ol");
    let content;
    if ($node.contents().first().is("div,p")) {
      content = getContent($node.children().first());
    } else {
      let $contents = $node.contents();
      const i = $contents.index(queue);
      if (i >= 0)
        $contents = $contents.slice(0, i);
      content = getContent($contents);
    }
    return {
      queue,
      nesting: true,
      ...content
    };
  },
  "table,pre,p>img:only-child": ({ $node, getContent }) => ({
    ...getContent($node)
  })
};
var defaultOptions2 = {
  selector: "h1,h2,h3,h4,h5,h6,ul,ol,li,table,pre,p>img:only-child",
  selectorRules: defaultSelectorRules
};
var MARKMAP_COMMENT_PREFIX = "markmap: ";
var SELECTOR_HEADING = /^h[1-6]$/;
var SELECTOR_LIST = /^[uo]l$/;
var SELECTOR_LIST_ITEM = /^li$/;
function getLevel(tagName) {
  if (SELECTOR_HEADING.test(tagName))
    return +tagName[1];
  if (SELECTOR_LIST.test(tagName))
    return 8;
  if (SELECTOR_LIST_ITEM.test(tagName))
    return 9;
  return 7;
}
function parseHtml(html3, opts) {
  const options = {
    ...defaultOptions2,
    ...opts
  };
  const $2 = load(html3);
  const $root = $2("body");
  let id = 0;
  const rootNode = {
    id,
    tag: "",
    html: "",
    level: 0,
    parent: 0,
    childrenLevel: 0,
    children: []
  };
  const headingStack = [];
  let skippingHeading = 0;
  checkNodes($root.children());
  return rootNode;
  function addChild(props) {
    var _a2;
    const { parent: parent2 } = props;
    const node = {
      id: ++id,
      tag: props.tagName,
      level: props.level,
      html: props.html,
      childrenLevel: 0,
      children: props.nesting ? [] : void 0,
      parent: parent2.id
    };
    if ((_a2 = props.comments) == null ? void 0 : _a2.length) {
      node.comments = props.comments;
    }
    if (Object.keys(props.data || {}).length) {
      node.data = props.data;
    }
    if (parent2.children) {
      if (parent2.childrenLevel === 0 || parent2.childrenLevel > node.level) {
        parent2.children = [];
        parent2.childrenLevel = node.level;
      }
      if (parent2.childrenLevel === node.level) {
        parent2.children.push(node);
      }
    }
    return node;
  }
  function getCurrentHeading(level) {
    let heading2;
    while ((heading2 = headingStack.at(-1)) && heading2.level >= level) {
      headingStack.pop();
    }
    return heading2 || rootNode;
  }
  function getContent($node) {
    var _a2;
    const result = extractMagicComments($node);
    const html22 = (_a2 = $2.html(result.$node)) == null ? void 0 : _a2.trimEnd();
    return { comments: result.comments, html: html22 };
  }
  function extractMagicComments($node) {
    const comments = [];
    $node = $node.filter((_, child) => {
      if (child.type === "comment") {
        const data2 = child.data.trim();
        if (data2.startsWith(MARKMAP_COMMENT_PREFIX)) {
          comments.push(data2.slice(MARKMAP_COMMENT_PREFIX.length).trim());
          return false;
        }
      }
      return true;
    });
    return { $node, comments };
  }
  function checkNodes($els, node) {
    $els.each((_, child) => {
      var _a2;
      const $child = $2(child);
      const rule = (_a2 = Object.entries(options.selectorRules).find(
        ([selector]) => $child.is(selector)
      )) == null ? void 0 : _a2[1];
      const result = rule == null ? void 0 : rule({ $node: $child, $: $2, getContent });
      if ((result == null ? void 0 : result.queue) && !result.nesting) {
        checkNodes(result.queue, node);
        return;
      }
      const level = getLevel(child.tagName);
      if (!result) {
        if (level <= 6) {
          skippingHeading = level;
        }
        return;
      }
      if (skippingHeading > 0 && level > skippingHeading)
        return;
      if (!$child.is(options.selector))
        return;
      skippingHeading = 0;
      const isHeading = level <= 6;
      let data2 = $child.data();
      if ($child.children("code:only-child").length) {
        data2 = {
          ...data2,
          ...$child.children().data()
        };
      }
      const childNode = addChild({
        parent: node || getCurrentHeading(level),
        nesting: !!result.queue || isHeading,
        tagName: child.tagName,
        level,
        html: result.html || "",
        comments: result.comments,
        data: data2
      });
      if (isHeading)
        headingStack.push(childNode);
      if (result.queue)
        checkNodes(result.queue, childNode);
    });
  }
}
function convertNode(htmlRoot) {
  return walkTree(htmlRoot, (htmlNode, next2) => {
    const node = {
      content: htmlNode.html,
      children: next2() || []
    };
    if (htmlNode.data) {
      node.payload = {
        ...htmlNode.data
      };
    }
    if (htmlNode.comments) {
      if (htmlNode.comments.includes("foldAll")) {
        node.payload = { ...node.payload, fold: 2 };
      } else if (htmlNode.comments.includes("fold")) {
        node.payload = { ...node.payload, fold: 1 };
      }
    }
    return node;
  });
}
function buildTree(html3, opts) {
  const htmlRoot = parseHtml(html3, opts);
  return convertNode(htmlRoot);
}

// node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/common/utils.mjs
var utils_exports = {};
__export(utils_exports, {
  arrayReplaceAt: () => arrayReplaceAt,
  assign: () => assign,
  escapeHtml: () => escapeHtml,
  escapeRE: () => escapeRE,
  fromCodePoint: () => fromCodePoint2,
  has: () => has2,
  isMdAsciiPunct: () => isMdAsciiPunct,
  isPunctChar: () => isPunctChar,
  isSpace: () => isSpace,
  isString: () => isString,
  isValidEntityCode: () => isValidEntityCode,
  isWhiteSpace: () => isWhiteSpace,
  lib: () => lib,
  normalizeReference: () => normalizeReference,
  unescapeAll: () => unescapeAll,
  unescapeMd: () => unescapeMd
});

// node_modules/.pnpm/mdurl@2.0.0/node_modules/mdurl/index.mjs
var mdurl_exports = {};
__export(mdurl_exports, {
  decode: () => decode_default,
  encode: () => encode_default,
  format: () => format,
  parse: () => parse_default
});

// node_modules/.pnpm/mdurl@2.0.0/node_modules/mdurl/lib/decode.mjs
var decodeCache = {};
function getDecodeCache(exclude) {
  let cache = decodeCache[exclude];
  if (cache) {
    return cache;
  }
  cache = decodeCache[exclude] = [];
  for (let i = 0; i < 128; i++) {
    const ch = String.fromCharCode(i);
    cache.push(ch);
  }
  for (let i = 0; i < exclude.length; i++) {
    const ch = exclude.charCodeAt(i);
    cache[ch] = "%" + ("0" + ch.toString(16).toUpperCase()).slice(-2);
  }
  return cache;
}
function decode(string, exclude) {
  if (typeof exclude !== "string") {
    exclude = decode.defaultChars;
  }
  const cache = getDecodeCache(exclude);
  return string.replace(/(%[a-f0-9]{2})+/gi, function(seq2) {
    let result = "";
    for (let i = 0, l = seq2.length; i < l; i += 3) {
      const b1 = parseInt(seq2.slice(i + 1, i + 3), 16);
      if (b1 < 128) {
        result += cache[b1];
        continue;
      }
      if ((b1 & 224) === 192 && i + 3 < l) {
        const b2 = parseInt(seq2.slice(i + 4, i + 6), 16);
        if ((b2 & 192) === 128) {
          const chr = b1 << 6 & 1984 | b2 & 63;
          if (chr < 128) {
            result += "��";
          } else {
            result += String.fromCharCode(chr);
          }
          i += 3;
          continue;
        }
      }
      if ((b1 & 240) === 224 && i + 6 < l) {
        const b2 = parseInt(seq2.slice(i + 4, i + 6), 16);
        const b3 = parseInt(seq2.slice(i + 7, i + 9), 16);
        if ((b2 & 192) === 128 && (b3 & 192) === 128) {
          const chr = b1 << 12 & 61440 | b2 << 6 & 4032 | b3 & 63;
          if (chr < 2048 || chr >= 55296 && chr <= 57343) {
            result += "���";
          } else {
            result += String.fromCharCode(chr);
          }
          i += 6;
          continue;
        }
      }
      if ((b1 & 248) === 240 && i + 9 < l) {
        const b2 = parseInt(seq2.slice(i + 4, i + 6), 16);
        const b3 = parseInt(seq2.slice(i + 7, i + 9), 16);
        const b4 = parseInt(seq2.slice(i + 10, i + 12), 16);
        if ((b2 & 192) === 128 && (b3 & 192) === 128 && (b4 & 192) === 128) {
          let chr = b1 << 18 & 1835008 | b2 << 12 & 258048 | b3 << 6 & 4032 | b4 & 63;
          if (chr < 65536 || chr > 1114111) {
            result += "����";
          } else {
            chr -= 65536;
            result += String.fromCharCode(55296 + (chr >> 10), 56320 + (chr & 1023));
          }
          i += 9;
          continue;
        }
      }
      result += "�";
    }
    return result;
  });
}
decode.defaultChars = ";/?:@&=+$,#";
decode.componentChars = "";
var decode_default = decode;

// node_modules/.pnpm/mdurl@2.0.0/node_modules/mdurl/lib/encode.mjs
var encodeCache = {};
function getEncodeCache(exclude) {
  let cache = encodeCache[exclude];
  if (cache) {
    return cache;
  }
  cache = encodeCache[exclude] = [];
  for (let i = 0; i < 128; i++) {
    const ch = String.fromCharCode(i);
    if (/^[0-9a-z]$/i.test(ch)) {
      cache.push(ch);
    } else {
      cache.push("%" + ("0" + i.toString(16).toUpperCase()).slice(-2));
    }
  }
  for (let i = 0; i < exclude.length; i++) {
    cache[exclude.charCodeAt(i)] = exclude[i];
  }
  return cache;
}
function encode(string, exclude, keepEscaped) {
  if (typeof exclude !== "string") {
    keepEscaped = exclude;
    exclude = encode.defaultChars;
  }
  if (typeof keepEscaped === "undefined") {
    keepEscaped = true;
  }
  const cache = getEncodeCache(exclude);
  let result = "";
  for (let i = 0, l = string.length; i < l; i++) {
    const code2 = string.charCodeAt(i);
    if (keepEscaped && code2 === 37 && i + 2 < l) {
      if (/^[0-9a-f]{2}$/i.test(string.slice(i + 1, i + 3))) {
        result += string.slice(i, i + 3);
        i += 2;
        continue;
      }
    }
    if (code2 < 128) {
      result += cache[code2];
      continue;
    }
    if (code2 >= 55296 && code2 <= 57343) {
      if (code2 >= 55296 && code2 <= 56319 && i + 1 < l) {
        const nextCode = string.charCodeAt(i + 1);
        if (nextCode >= 56320 && nextCode <= 57343) {
          result += encodeURIComponent(string[i] + string[i + 1]);
          i++;
          continue;
        }
      }
      result += "%EF%BF%BD";
      continue;
    }
    result += encodeURIComponent(string[i]);
  }
  return result;
}
encode.defaultChars = ";/?:@&=+$,-_.!~*'()#";
encode.componentChars = "-_.!~*'()";
var encode_default = encode;

// node_modules/.pnpm/mdurl@2.0.0/node_modules/mdurl/lib/format.mjs
function format(url) {
  let result = "";
  result += url.protocol || "";
  result += url.slashes ? "//" : "";
  result += url.auth ? url.auth + "@" : "";
  if (url.hostname && url.hostname.indexOf(":") !== -1) {
    result += "[" + url.hostname + "]";
  } else {
    result += url.hostname || "";
  }
  result += url.port ? ":" + url.port : "";
  result += url.pathname || "";
  result += url.search || "";
  result += url.hash || "";
  return result;
}

// node_modules/.pnpm/mdurl@2.0.0/node_modules/mdurl/lib/parse.mjs
function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.pathname = null;
}
var protocolPattern = /^([a-z0-9.+-]+:)/i;
var portPattern = /:[0-9]*$/;
var simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/;
var delims = ["<", ">", '"', "`", " ", "\r", "\n", "	"];
var unwise = ["{", "}", "|", "\\", "^", "`"].concat(delims);
var autoEscape = ["'"].concat(unwise);
var nonHostChars = ["%", "/", "?", ";", "#"].concat(autoEscape);
var hostEndingChars = ["/", "?", "#"];
var hostnameMaxLen = 255;
var hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/;
var hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/;
var hostlessProtocol = {
  javascript: true,
  "javascript:": true
};
var slashedProtocol = {
  http: true,
  https: true,
  ftp: true,
  gopher: true,
  file: true,
  "http:": true,
  "https:": true,
  "ftp:": true,
  "gopher:": true,
  "file:": true
};
function urlParse(url, slashesDenoteHost) {
  if (url && url instanceof Url)
    return url;
  const u = new Url();
  u.parse(url, slashesDenoteHost);
  return u;
}
Url.prototype.parse = function(url, slashesDenoteHost) {
  let lowerProto, hec, slashes;
  let rest = url;
  rest = rest.trim();
  if (!slashesDenoteHost && url.split("#").length === 1) {
    const simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
      }
      return this;
    }
  }
  let proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    lowerProto = proto.toLowerCase();
    this.protocol = proto;
    rest = rest.substr(proto.length);
  }
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    slashes = rest.substr(0, 2) === "//";
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }
  if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
    let hostEnd = -1;
    for (let i = 0; i < hostEndingChars.length; i++) {
      hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
        hostEnd = hec;
      }
    }
    let auth, atSign;
    if (hostEnd === -1) {
      atSign = rest.lastIndexOf("@");
    } else {
      atSign = rest.lastIndexOf("@", hostEnd);
    }
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = auth;
    }
    hostEnd = -1;
    for (let i = 0; i < nonHostChars.length; i++) {
      hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
        hostEnd = hec;
      }
    }
    if (hostEnd === -1) {
      hostEnd = rest.length;
    }
    if (rest[hostEnd - 1] === ":") {
      hostEnd--;
    }
    const host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);
    this.parseHost(host);
    this.hostname = this.hostname || "";
    const ipv6Hostname = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
    if (!ipv6Hostname) {
      const hostparts = this.hostname.split(/\./);
      for (let i = 0, l = hostparts.length; i < l; i++) {
        const part = hostparts[i];
        if (!part) {
          continue;
        }
        if (!part.match(hostnamePartPattern)) {
          let newpart = "";
          for (let j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              newpart += "x";
            } else {
              newpart += part[j];
            }
          }
          if (!newpart.match(hostnamePartPattern)) {
            const validParts = hostparts.slice(0, i);
            const notHost = hostparts.slice(i + 1);
            const bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = notHost.join(".") + rest;
            }
            this.hostname = validParts.join(".");
            break;
          }
        }
      }
    }
    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = "";
    }
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
    }
  }
  const hash = rest.indexOf("#");
  if (hash !== -1) {
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  const qm = rest.indexOf("?");
  if (qm !== -1) {
    this.search = rest.substr(qm);
    rest = rest.slice(0, qm);
  }
  if (rest) {
    this.pathname = rest;
  }
  if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
    this.pathname = "";
  }
  return this;
};
Url.prototype.parseHost = function(host) {
  let port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ":") {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) {
    this.hostname = host;
  }
};
var parse_default = urlParse;

// node_modules/.pnpm/uc.micro@2.1.0/node_modules/uc.micro/index.mjs
var uc_exports = {};
__export(uc_exports, {
  Any: () => regex_default,
  Cc: () => regex_default2,
  Cf: () => regex_default3,
  P: () => regex_default4,
  S: () => regex_default5,
  Z: () => regex_default6
});

// node_modules/.pnpm/uc.micro@2.1.0/node_modules/uc.micro/properties/Any/regex.mjs
var regex_default = /[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;

// node_modules/.pnpm/uc.micro@2.1.0/node_modules/uc.micro/categories/Cc/regex.mjs
var regex_default2 = /[\0-\x1F\x7F-\x9F]/;

// node_modules/.pnpm/uc.micro@2.1.0/node_modules/uc.micro/categories/Cf/regex.mjs
var regex_default3 = /[\xAD\u0600-\u0605\u061C\u06DD\u070F\u0890\u0891\u08E2\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB]|\uD804[\uDCBD\uDCCD]|\uD80D[\uDC30-\uDC3F]|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]/;

// node_modules/.pnpm/uc.micro@2.1.0/node_modules/uc.micro/categories/P/regex.mjs
var regex_default4 = /[!-#%-\*,-\/:;\?@\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061D-\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1B7D\u1B7E\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u2E52-\u2E5D\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD803[\uDEAD\uDF55-\uDF59\uDF86-\uDF89]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5A\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDEB9\uDF3C-\uDF3E]|\uD806[\uDC3B\uDD44-\uDD46\uDDE2\uDE3F-\uDE46\uDE9A-\uDE9C\uDE9E-\uDEA2\uDF00-\uDF09]|\uD807[\uDC41-\uDC45\uDC70\uDC71\uDEF7\uDEF8\uDF43-\uDF4F\uDFFF]|\uD809[\uDC70-\uDC74]|\uD80B[\uDFF1\uDFF2]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD81B[\uDE97-\uDE9A\uDFE2]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/;

// node_modules/.pnpm/uc.micro@2.1.0/node_modules/uc.micro/categories/S/regex.mjs
var regex_default5 = /[\$\+<->\^`\|~\xA2-\xA6\xA8\xA9\xAC\xAE-\xB1\xB4\xB8\xD7\xF7\u02C2-\u02C5\u02D2-\u02DF\u02E5-\u02EB\u02ED\u02EF-\u02FF\u0375\u0384\u0385\u03F6\u0482\u058D-\u058F\u0606-\u0608\u060B\u060E\u060F\u06DE\u06E9\u06FD\u06FE\u07F6\u07FE\u07FF\u0888\u09F2\u09F3\u09FA\u09FB\u0AF1\u0B70\u0BF3-\u0BFA\u0C7F\u0D4F\u0D79\u0E3F\u0F01-\u0F03\u0F13\u0F15-\u0F17\u0F1A-\u0F1F\u0F34\u0F36\u0F38\u0FBE-\u0FC5\u0FC7-\u0FCC\u0FCE\u0FCF\u0FD5-\u0FD8\u109E\u109F\u1390-\u1399\u166D\u17DB\u1940\u19DE-\u19FF\u1B61-\u1B6A\u1B74-\u1B7C\u1FBD\u1FBF-\u1FC1\u1FCD-\u1FCF\u1FDD-\u1FDF\u1FED-\u1FEF\u1FFD\u1FFE\u2044\u2052\u207A-\u207C\u208A-\u208C\u20A0-\u20C0\u2100\u2101\u2103-\u2106\u2108\u2109\u2114\u2116-\u2118\u211E-\u2123\u2125\u2127\u2129\u212E\u213A\u213B\u2140-\u2144\u214A-\u214D\u214F\u218A\u218B\u2190-\u2307\u230C-\u2328\u232B-\u2426\u2440-\u244A\u249C-\u24E9\u2500-\u2767\u2794-\u27C4\u27C7-\u27E5\u27F0-\u2982\u2999-\u29D7\u29DC-\u29FB\u29FE-\u2B73\u2B76-\u2B95\u2B97-\u2BFF\u2CE5-\u2CEA\u2E50\u2E51\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFF\u3004\u3012\u3013\u3020\u3036\u3037\u303E\u303F\u309B\u309C\u3190\u3191\u3196-\u319F\u31C0-\u31E3\u31EF\u3200-\u321E\u322A-\u3247\u3250\u3260-\u327F\u328A-\u32B0\u32C0-\u33FF\u4DC0-\u4DFF\uA490-\uA4C6\uA700-\uA716\uA720\uA721\uA789\uA78A\uA828-\uA82B\uA836-\uA839\uAA77-\uAA79\uAB5B\uAB6A\uAB6B\uFB29\uFBB2-\uFBC2\uFD40-\uFD4F\uFDCF\uFDFC-\uFDFF\uFE62\uFE64-\uFE66\uFE69\uFF04\uFF0B\uFF1C-\uFF1E\uFF3E\uFF40\uFF5C\uFF5E\uFFE0-\uFFE6\uFFE8-\uFFEE\uFFFC\uFFFD]|\uD800[\uDD37-\uDD3F\uDD79-\uDD89\uDD8C-\uDD8E\uDD90-\uDD9C\uDDA0\uDDD0-\uDDFC]|\uD802[\uDC77\uDC78\uDEC8]|\uD805\uDF3F|\uD807[\uDFD5-\uDFF1]|\uD81A[\uDF3C-\uDF3F\uDF45]|\uD82F\uDC9C|\uD833[\uDF50-\uDFC3]|\uD834[\uDC00-\uDCF5\uDD00-\uDD26\uDD29-\uDD64\uDD6A-\uDD6C\uDD83\uDD84\uDD8C-\uDDA9\uDDAE-\uDDEA\uDE00-\uDE41\uDE45\uDF00-\uDF56]|\uD835[\uDEC1\uDEDB\uDEFB\uDF15\uDF35\uDF4F\uDF6F\uDF89\uDFA9\uDFC3]|\uD836[\uDC00-\uDDFF\uDE37-\uDE3A\uDE6D-\uDE74\uDE76-\uDE83\uDE85\uDE86]|\uD838[\uDD4F\uDEFF]|\uD83B[\uDCAC\uDCB0\uDD2E\uDEF0\uDEF1]|\uD83C[\uDC00-\uDC2B\uDC30-\uDC93\uDCA0-\uDCAE\uDCB1-\uDCBF\uDCC1-\uDCCF\uDCD1-\uDCF5\uDD0D-\uDDAD\uDDE6-\uDE02\uDE10-\uDE3B\uDE40-\uDE48\uDE50\uDE51\uDE60-\uDE65\uDF00-\uDFFF]|\uD83D[\uDC00-\uDED7\uDEDC-\uDEEC\uDEF0-\uDEFC\uDF00-\uDF76\uDF7B-\uDFD9\uDFE0-\uDFEB\uDFF0]|\uD83E[\uDC00-\uDC0B\uDC10-\uDC47\uDC50-\uDC59\uDC60-\uDC87\uDC90-\uDCAD\uDCB0\uDCB1\uDD00-\uDE53\uDE60-\uDE6D\uDE70-\uDE7C\uDE80-\uDE88\uDE90-\uDEBD\uDEBF-\uDEC5\uDECE-\uDEDB\uDEE0-\uDEE8\uDEF0-\uDEF8\uDF00-\uDF92\uDF94-\uDFCA]/;

// node_modules/.pnpm/uc.micro@2.1.0/node_modules/uc.micro/categories/Z/regex.mjs
var regex_default6 = /[ \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/;

// node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/common/utils.mjs
function _class(obj) {
  return Object.prototype.toString.call(obj);
}
function isString(obj) {
  return _class(obj) === "[object String]";
}
var _hasOwnProperty = Object.prototype.hasOwnProperty;
function has2(object, key) {
  return _hasOwnProperty.call(object, key);
}
function assign(obj) {
  const sources = Array.prototype.slice.call(arguments, 1);
  sources.forEach(function(source) {
    if (!source) {
      return;
    }
    if (typeof source !== "object") {
      throw new TypeError(source + "must be object");
    }
    Object.keys(source).forEach(function(key) {
      obj[key] = source[key];
    });
  });
  return obj;
}
function arrayReplaceAt(src, pos, newElements) {
  return [].concat(src.slice(0, pos), newElements, src.slice(pos + 1));
}
function isValidEntityCode(c) {
  if (c >= 55296 && c <= 57343) {
    return false;
  }
  if (c >= 64976 && c <= 65007) {
    return false;
  }
  if ((c & 65535) === 65535 || (c & 65535) === 65534) {
    return false;
  }
  if (c >= 0 && c <= 8) {
    return false;
  }
  if (c === 11) {
    return false;
  }
  if (c >= 14 && c <= 31) {
    return false;
  }
  if (c >= 127 && c <= 159) {
    return false;
  }
  if (c > 1114111) {
    return false;
  }
  return true;
}
function fromCodePoint2(c) {
  if (c > 65535) {
    c -= 65536;
    const surrogate1 = 55296 + (c >> 10);
    const surrogate2 = 56320 + (c & 1023);
    return String.fromCharCode(surrogate1, surrogate2);
  }
  return String.fromCharCode(c);
}
var UNESCAPE_MD_RE = /\\([!"#$%&'()*+,\-./:;<=>?@[\\\]^_`{|}~])/g;
var ENTITY_RE = /&([a-z#][a-z0-9]{1,31});/gi;
var UNESCAPE_ALL_RE = new RegExp(UNESCAPE_MD_RE.source + "|" + ENTITY_RE.source, "gi");
var DIGITAL_ENTITY_TEST_RE = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))$/i;
function replaceEntityPattern(match2, name2) {
  if (name2.charCodeAt(0) === 35 && DIGITAL_ENTITY_TEST_RE.test(name2)) {
    const code2 = name2[1].toLowerCase() === "x" ? parseInt(name2.slice(2), 16) : parseInt(name2.slice(1), 10);
    if (isValidEntityCode(code2)) {
      return fromCodePoint2(code2);
    }
    return match2;
  }
  const decoded = decodeHTML(match2);
  if (decoded !== match2) {
    return decoded;
  }
  return match2;
}
function unescapeMd(str2) {
  if (str2.indexOf("\\") < 0) {
    return str2;
  }
  return str2.replace(UNESCAPE_MD_RE, "$1");
}
function unescapeAll(str2) {
  if (str2.indexOf("\\") < 0 && str2.indexOf("&") < 0) {
    return str2;
  }
  return str2.replace(UNESCAPE_ALL_RE, function(match2, escaped, entity2) {
    if (escaped) {
      return escaped;
    }
    return replaceEntityPattern(match2, entity2);
  });
}
var HTML_ESCAPE_TEST_RE = /[&<>"]/;
var HTML_ESCAPE_REPLACE_RE = /[&<>"]/g;
var HTML_REPLACEMENTS = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;"
};
function replaceUnsafeChar(ch) {
  return HTML_REPLACEMENTS[ch];
}
function escapeHtml(str2) {
  if (HTML_ESCAPE_TEST_RE.test(str2)) {
    return str2.replace(HTML_ESCAPE_REPLACE_RE, replaceUnsafeChar);
  }
  return str2;
}
var REGEXP_ESCAPE_RE = /[.?*+^$[\]\\(){}|-]/g;
function escapeRE(str2) {
  return str2.replace(REGEXP_ESCAPE_RE, "\\$&");
}
function isSpace(code2) {
  switch (code2) {
    case 9:
    case 32:
      return true;
  }
  return false;
}
function isWhiteSpace(code2) {
  if (code2 >= 8192 && code2 <= 8202) {
    return true;
  }
  switch (code2) {
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 32:
    case 160:
    case 5760:
    case 8239:
    case 8287:
    case 12288:
      return true;
  }
  return false;
}
function isPunctChar(ch) {
  return regex_default4.test(ch) || regex_default5.test(ch);
}
function isMdAsciiPunct(ch) {
  switch (ch) {
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 40:
    case 41:
    case 42:
    case 43:
    case 44:
    case 45:
    case 46:
    case 47:
    case 58:
    case 59:
    case 60:
    case 61:
    case 62:
    case 63:
    case 64:
    case 91:
    case 92:
    case 93:
    case 94:
    case 95:
    case 96:
    case 123:
    case 124:
    case 125:
    case 126:
      return true;
    default:
      return false;
  }
}
function normalizeReference(str2) {
  str2 = str2.trim().replace(/\s+/g, " ");
  if ("ẞ".toLowerCase() === "Ṿ") {
    str2 = str2.replace(/ẞ/g, "ß");
  }
  return str2.toLowerCase().toUpperCase();
}
var lib = { mdurl: mdurl_exports, ucmicro: uc_exports };

// node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/helpers/index.mjs
var helpers_exports = {};
__export(helpers_exports, {
  parseLinkDestination: () => parseLinkDestination,
  parseLinkLabel: () => parseLinkLabel,
  parseLinkTitle: () => parseLinkTitle
});

// node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/helpers/parse_link_label.mjs
function parseLinkLabel(state, start, disableNested) {
  let level, found, marker, prevPos;
  const max = state.posMax;
  const oldPos = state.pos;
  state.pos = start + 1;
  level = 1;
  while (state.pos < max) {
    marker = state.src.charCodeAt(state.pos);
    if (marker === 93) {
      level--;
      if (level === 0) {
        found = true;
        break;
      }
    }
    prevPos = state.pos;
    state.md.inline.skipToken(state);
    if (marker === 91) {
      if (prevPos === state.pos - 1) {
        level++;
      } else if (disableNested) {
        state.pos = oldPos;
        return -1;
      }
    }
  }
  let labelEnd = -1;
  if (found) {
    labelEnd = state.pos;
  }
  state.pos = oldPos;
  return labelEnd;
}

// node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/helpers/parse_link_destination.mjs
function parseLinkDestination(str2, start, max) {
  let code2;
  let pos = start;
  const result = {
    ok: false,
    pos: 0,
    str: ""
  };
  if (str2.charCodeAt(pos) === 60) {
    pos++;
    while (pos < max) {
      code2 = str2.charCodeAt(pos);
      if (code2 === 10) {
        return result;
      }
      if (code2 === 60) {
        return result;
      }
      if (code2 === 62) {
        result.pos = pos + 1;
        result.str = unescapeAll(str2.slice(start + 1, pos));
        result.ok = true;
        return result;
      }
      if (code2 === 92 && pos + 1 < max) {
        pos += 2;
        continue;
      }
      pos++;
    }
    return result;
  }
  let level = 0;
  while (pos < max) {
    code2 = str2.charCodeAt(pos);
    if (code2 === 32) {
      break;
    }
    if (code2 < 32 || code2 === 127) {
      break;
    }
    if (code2 === 92 && pos + 1 < max) {
      if (str2.charCodeAt(pos + 1) === 32) {
        break;
      }
      pos += 2;
      continue;
    }
    if (code2 === 40) {
      level++;
      if (level > 32) {
        return result;
      }
    }
    if (code2 === 41) {
      if (level === 0) {
        break;
      }
      level--;
    }
    pos++;
  }
  if (start === pos) {
    return result;
  }
  if (level !== 0) {
    return result;
  }
  result.str = unescapeAll(str2.slice(start, pos));
  result.pos = pos;
  result.ok = true;
  return result;
}

// node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/helpers/parse_link_title.mjs
function parseLinkTitle(str2, start, max, prev_state) {
  let code2;
  let pos = start;
  const state = {
    // if `true`, this is a valid link title
    ok: false,
    // if `true`, this link can be continued on the next line
    can_continue: false,
    // if `ok`, it's the position of the first character after the closing marker
    pos: 0,
    // if `ok`, it's the unescaped title
    str: "",
    // expected closing marker character code
    marker: 0
  };
  if (prev_state) {
    state.str = prev_state.str;
    state.marker = prev_state.marker;
  } else {
    if (pos >= max) {
      return state;
    }
    let marker = str2.charCodeAt(pos);
    if (marker !== 34 && marker !== 39 && marker !== 40) {
      return state;
    }
    start++;
    pos++;
    if (marker === 40) {
      marker = 41;
    }
    state.marker = marker;
  }
  while (pos < max) {
    code2 = str2.charCodeAt(pos);
    if (code2 === state.marker) {
      state.pos = pos + 1;
      state.str += unescapeAll(str2.slice(start, pos));
      state.ok = true;
      return state;
    } else if (code2 === 40 && state.marker === 41) {
      return state;
    } else if (code2 === 92 && pos + 1 < max) {
      pos++;
    }
    pos++;
  }
  state.can_continue = true;
  state.str += unescapeAll(str2.slice(start, pos));
  return state;
}

// node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/renderer.mjs
var default_rules = {};
default_rules.code_inline = function(tokens, idx, options, env, slf) {
  const token = tokens[idx];
  return "<code" + slf.renderAttrs(token) + ">" + escapeHtml(token.content) + "</code>";
};
default_rules.code_block = function(tokens, idx, options, env, slf) {
  const token = tokens[idx];
  return "<pre" + slf.renderAttrs(token) + "><code>" + escapeHtml(tokens[idx].content) + "</code></pre>\n";
};
default_rules.fence = function(tokens, idx, options, env, slf) {
  const token = tokens[idx];
  const info = token.info ? unescapeAll(token.info).trim() : "";
  let langName = "";
  let langAttrs = "";
  if (info) {
    const arr = info.split(/(\s+)/g);
    langName = arr[0];
    langAttrs = arr.slice(2).join("");
  }
  let highlighted;
  if (options.highlight) {
    highlighted = options.highlight(token.content, langName, langAttrs) || escapeHtml(token.content);
  } else {
    highlighted = escapeHtml(token.content);
  }
  if (highlighted.indexOf("<pre") === 0) {
    return highlighted + "\n";
  }
  if (info) {
    const i = token.attrIndex("class");
    const tmpAttrs = token.attrs ? token.attrs.slice() : [];
    if (i < 0) {
      tmpAttrs.push(["class", options.langPrefix + langName]);
    } else {
      tmpAttrs[i] = tmpAttrs[i].slice();
      tmpAttrs[i][1] += " " + options.langPrefix + langName;
    }
    const tmpToken = {
      attrs: tmpAttrs
    };
    return `<pre><code${slf.renderAttrs(tmpToken)}>${highlighted}</code></pre>
`;
  }
  return `<pre><code${slf.renderAttrs(token)}>${highlighted}</code></pre>
`;
};
default_rules.image = function(tokens, idx, options, env, slf) {
  const token = tokens[idx];
  token.attrs[token.attrIndex("alt")][1] = slf.renderInlineAsText(token.children, options, env);
  return slf.renderToken(tokens, idx, options);
};
default_rules.hardbreak = function(tokens, idx, options) {
  return options.xhtmlOut ? "<br />\n" : "<br>\n";
};
default_rules.softbreak = function(tokens, idx, options) {
  return options.breaks ? options.xhtmlOut ? "<br />\n" : "<br>\n" : "\n";
};
default_rules.text = function(tokens, idx) {
  return escapeHtml(tokens[idx].content);
};
default_rules.html_block = function(tokens, idx) {
  return tokens[idx].content;
};
default_rules.html_inline = function(tokens, idx) {
  return tokens[idx].content;
};
function Renderer() {
  this.rules = assign({}, default_rules);
}
Renderer.prototype.renderAttrs = function renderAttrs(token) {
  let i, l, result;
  if (!token.attrs) {
    return "";
  }
  result = "";
  for (i = 0, l = token.attrs.length; i < l; i++) {
    result += " " + escapeHtml(token.attrs[i][0]) + '="' + escapeHtml(token.attrs[i][1]) + '"';
  }
  return result;
};
Renderer.prototype.renderToken = function renderToken(tokens, idx, options) {
  const token = tokens[idx];
  let result = "";
  if (token.hidden) {
    return "";
  }
  if (token.block && token.nesting !== -1 && idx && tokens[idx - 1].hidden) {
    result += "\n";
  }
  result += (token.nesting === -1 ? "</" : "<") + token.tag;
  result += this.renderAttrs(token);
  if (token.nesting === 0 && options.xhtmlOut) {
    result += " /";
  }
  let needLf = false;
  if (token.block) {
    needLf = true;
    if (token.nesting === 1) {
      if (idx + 1 < tokens.length) {
        const nextToken = tokens[idx + 1];
        if (nextToken.type === "inline" || nextToken.hidden) {
          needLf = false;
        } else if (nextToken.nesting === -1 && nextToken.tag === token.tag) {
          needLf = false;
        }
      }
    }
  }
  result += needLf ? ">\n" : ">";
  return result;
};
Renderer.prototype.renderInline = function(tokens, options, env) {
  let result = "";
  const rules = this.rules;
  for (let i = 0, len = tokens.length; i < len; i++) {
    const type2 = tokens[i].type;
    if (typeof rules[type2] !== "undefined") {
      result += rules[type2](tokens, i, options, env, this);
    } else {
      result += this.renderToken(tokens, i, options);
    }
  }
  return result;
};
Renderer.prototype.renderInlineAsText = function(tokens, options, env) {
  let result = "";
  for (let i = 0, len = tokens.length; i < len; i++) {
    switch (tokens[i].type) {
      case "text":
        result += tokens[i].content;
        break;
      case "image":
        result += this.renderInlineAsText(tokens[i].children, options, env);
        break;
      case "html_inline":
      case "html_block":
        result += tokens[i].content;
        break;
      case "softbreak":
      case "hardbreak":
        result += "\n";
        break;
      default:
    }
  }
  return result;
};
Renderer.prototype.render = function(tokens, options, env) {
  let result = "";
  const rules = this.rules;
  for (let i = 0, len = tokens.length; i < len; i++) {
    const type2 = tokens[i].type;
    if (type2 === "inline") {
      result += this.renderInline(tokens[i].children, options, env);
    } else if (typeof rules[type2] !== "undefined") {
      result += rules[type2](tokens, i, options, env, this);
    } else {
      result += this.renderToken(tokens, i, options, env);
    }
  }
  return result;
};
var renderer_default = Renderer;

// node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/ruler.mjs
function Ruler() {
  this.__rules__ = [];
  this.__cache__ = null;
}
Ruler.prototype.__find__ = function(name2) {
  for (let i = 0; i < this.__rules__.length; i++) {
    if (this.__rules__[i].name === name2) {
      return i;
    }
  }
  return -1;
};
Ruler.prototype.__compile__ = function() {
  const self2 = this;
  const chains = [""];
  self2.__rules__.forEach(function(rule) {
    if (!rule.enabled) {
      return;
    }
    rule.alt.forEach(function(altName) {
      if (chains.indexOf(altName) < 0) {
        chains.push(altName);
      }
    });
  });
  self2.__cache__ = {};
  chains.forEach(function(chain) {
    self2.__cache__[chain] = [];
    self2.__rules__.forEach(function(rule) {
      if (!rule.enabled) {
        return;
      }
      if (chain && rule.alt.indexOf(chain) < 0) {
        return;
      }
      self2.__cache__[chain].push(rule.fn);
    });
  });
};
Ruler.prototype.at = function(name2, fn, options) {
  const index2 = this.__find__(name2);
  const opt = options || {};
  if (index2 === -1) {
    throw new Error("Parser rule not found: " + name2);
  }
  this.__rules__[index2].fn = fn;
  this.__rules__[index2].alt = opt.alt || [];
  this.__cache__ = null;
};
Ruler.prototype.before = function(beforeName, ruleName, fn, options) {
  const index2 = this.__find__(beforeName);
  const opt = options || {};
  if (index2 === -1) {
    throw new Error("Parser rule not found: " + beforeName);
  }
  this.__rules__.splice(index2, 0, {
    name: ruleName,
    enabled: true,
    fn,
    alt: opt.alt || []
  });
  this.__cache__ = null;
};
Ruler.prototype.after = function(afterName, ruleName, fn, options) {
  const index2 = this.__find__(afterName);
  const opt = options || {};
  if (index2 === -1) {
    throw new Error("Parser rule not found: " + afterName);
  }
  this.__rules__.splice(index2 + 1, 0, {
    name: ruleName,
    enabled: true,
    fn,
    alt: opt.alt || []
  });
  this.__cache__ = null;
};
Ruler.prototype.push = function(ruleName, fn, options) {
  const opt = options || {};
  this.__rules__.push({
    name: ruleName,
    enabled: true,
    fn,
    alt: opt.alt || []
  });
  this.__cache__ = null;
};
Ruler.prototype.enable = function(list2, ignoreInvalid) {
  if (!Array.isArray(list2)) {
    list2 = [list2];
  }
  const result = [];
  list2.forEach(function(name2) {
    const idx = this.__find__(name2);
    if (idx < 0) {
      if (ignoreInvalid) {
        return;
      }
      throw new Error("Rules manager: invalid rule name " + name2);
    }
    this.__rules__[idx].enabled = true;
    result.push(name2);
  }, this);
  this.__cache__ = null;
  return result;
};
Ruler.prototype.enableOnly = function(list2, ignoreInvalid) {
  if (!Array.isArray(list2)) {
    list2 = [list2];
  }
  this.__rules__.forEach(function(rule) {
    rule.enabled = false;
  });
  this.enable(list2, ignoreInvalid);
};
Ruler.prototype.disable = function(list2, ignoreInvalid) {
  if (!Array.isArray(list2)) {
    list2 = [list2];
  }
  const result = [];
  list2.forEach(function(name2) {
    const idx = this.__find__(name2);
    if (idx < 0) {
      if (ignoreInvalid) {
        return;
      }
      throw new Error("Rules manager: invalid rule name " + name2);
    }
    this.__rules__[idx].enabled = false;
    result.push(name2);
  }, this);
  this.__cache__ = null;
  return result;
};
Ruler.prototype.getRules = function(chainName) {
  if (this.__cache__ === null) {
    this.__compile__();
  }
  return this.__cache__[chainName] || [];
};
var ruler_default = Ruler;

// node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/token.mjs
function Token(type2, tag, nesting) {
  this.type = type2;
  this.tag = tag;
  this.attrs = null;
  this.map = null;
  this.nesting = nesting;
  this.level = 0;
  this.children = null;
  this.content = "";
  this.markup = "";
  this.info = "";
  this.meta = null;
  this.block = false;
  this.hidden = false;
}
Token.prototype.attrIndex = function attrIndex(name2) {
  if (!this.attrs) {
    return -1;
  }
  const attrs = this.attrs;
  for (let i = 0, len = attrs.length; i < len; i++) {
    if (attrs[i][0] === name2) {
      return i;
    }
  }
  return -1;
};
Token.prototype.attrPush = function attrPush(attrData) {
  if (this.attrs) {
    this.attrs.push(attrData);
  } else {
    this.attrs = [attrData];
  }
};
Token.prototype.attrSet = function attrSet(name2, value) {
  const idx = this.attrIndex(name2);
  const attrData = [name2, value];
  if (idx < 0) {
    this.attrPush(attrData);
  } else {
    this.attrs[idx] = attrData;
  }
};
Token.prototype.attrGet = function attrGet(name2) {
  const idx = this.attrIndex(name2);
  let value = null;
  if (idx >= 0) {
    value = this.attrs[idx][1];
  }
  return value;
};
Token.prototype.attrJoin = function attrJoin(name2, value) {
  const idx = this.attrIndex(name2);
  if (idx < 0) {
    this.attrPush([name2, value]);
  } else {
    this.attrs[idx][1] = this.attrs[idx][1] + " " + value;
  }
};
var token_default = Token;

// node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/rules_core/state_core.mjs
function StateCore(src, md, env) {
  this.src = src;
  this.env = env;
  this.tokens = [];
  this.inlineMode = false;
  this.md = md;
}
StateCore.prototype.Token = token_default;
var state_core_default = StateCore;

// node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/rules_core/normalize.mjs
var NEWLINES_RE = /\r\n?|\n/g;
var NULL_RE = /\0/g;
function normalize(state) {
  let str2;
  str2 = state.src.replace(NEWLINES_RE, "\n");
  str2 = str2.replace(NULL_RE, "�");
  state.src = str2;
}

// node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/rules_core/block.mjs
function block(state) {
  let token;
  if (state.inlineMode) {
    token = new state.Token("inline", "", 0);
    token.content = state.src;
    token.map = [0, 1];
    token.children = [];
    state.tokens.push(token);
  } else {
    state.md.block.parse(state.src, state.md, state.env, state.tokens);
  }
}

// node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/rules_core/inline.mjs
function inline(state) {
  const tokens = state.tokens;
  for (let i = 0, l = tokens.length; i < l; i++) {
    const tok = tokens[i];
    if (tok.type === "inline") {
      state.md.inline.parse(tok.content, state.md, state.env, tok.children);
    }
  }
}

// node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/rules_core/linkify.mjs
function isLinkOpen(str2) {
  return /^<a[>\s]/i.test(str2);
}
function isLinkClose(str2) {
  return /^<\/a\s*>/i.test(str2);
}
function linkify(state) {
  const blockTokens = state.tokens;
  if (!state.md.options.linkify) {
    return;
  }
  for (let j = 0, l = blockTokens.length; j < l; j++) {
    if (blockTokens[j].type !== "inline" || !state.md.linkify.pretest(blockTokens[j].content)) {
      continue;
    }
    let tokens = blockTokens[j].children;
    let htmlLinkLevel = 0;
    for (let i = tokens.length - 1; i >= 0; i--) {
      const currentToken = tokens[i];
      if (currentToken.type === "link_close") {
        i--;
        while (tokens[i].level !== currentToken.level && tokens[i].type !== "link_open") {
          i--;
        }
        continue;
      }
      if (currentToken.type === "html_inline") {
        if (isLinkOpen(currentToken.content) && htmlLinkLevel > 0) {
          htmlLinkLevel--;
        }
        if (isLinkClose(currentToken.content)) {
          htmlLinkLevel++;
        }
      }
      if (htmlLinkLevel > 0) {
        continue;
      }
      if (currentToken.type === "text" && state.md.linkify.test(currentToken.content)) {
        const text4 = currentToken.content;
        let links = state.md.linkify.match(text4);
        const nodes = [];
        let level = currentToken.level;
        let lastPos = 0;
        if (links.length > 0 && links[0].index === 0 && i > 0 && tokens[i - 1].type === "text_special") {
          links = links.slice(1);
        }
        for (let ln = 0; ln < links.length; ln++) {
          const url = links[ln].url;
          const fullUrl = state.md.normalizeLink(url);
          if (!state.md.validateLink(fullUrl)) {
            continue;
          }
          let urlText = links[ln].text;
          if (!links[ln].schema) {
            urlText = state.md.normalizeLinkText("http://" + urlText).replace(/^http:\/\//, "");
          } else if (links[ln].schema === "mailto:" && !/^mailto:/i.test(urlText)) {
            urlText = state.md.normalizeLinkText("mailto:" + urlText).replace(/^mailto:/, "");
          } else {
            urlText = state.md.normalizeLinkText(urlText);
          }
          const pos = links[ln].index;
          if (pos > lastPos) {
            const token = new state.Token("text", "", 0);
            token.content = text4.slice(lastPos, pos);
            token.level = level;
            nodes.push(token);
          }
          const token_o = new state.Token("link_open", "a", 1);
          token_o.attrs = [["href", fullUrl]];
          token_o.level = level++;
          token_o.markup = "linkify";
          token_o.info = "auto";
          nodes.push(token_o);
          const token_t = new state.Token("text", "", 0);
          token_t.content = urlText;
          token_t.level = level;
          nodes.push(token_t);
          const token_c = new state.Token("link_close", "a", -1);
          token_c.level = --level;
          token_c.markup = "linkify";
          token_c.info = "auto";
          nodes.push(token_c);
          lastPos = links[ln].lastIndex;
        }
        if (lastPos < text4.length) {
          const token = new state.Token("text", "", 0);
          token.content = text4.slice(lastPos);
          token.level = level;
          nodes.push(token);
        }
        blockTokens[j].children = tokens = arrayReplaceAt(tokens, i, nodes);
      }
    }
  }
}

// node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/rules_core/replacements.mjs
var RARE_RE = /\+-|\.\.|\?\?\?\?|!!!!|,,|--/;
var SCOPED_ABBR_TEST_RE = /\((c|tm|r)\)/i;
var SCOPED_ABBR_RE = /\((c|tm|r)\)/ig;
var SCOPED_ABBR = {
  c: "©",
  r: "®",
  tm: "™"
};
function replaceFn(match2, name2) {
  return SCOPED_ABBR[name2.toLowerCase()];
}
function replace_scoped(inlineTokens) {
  let inside_autolink = 0;
  for (let i = inlineTokens.length - 1; i >= 0; i--) {
    const token = inlineTokens[i];
    if (token.type === "text" && !inside_autolink) {
      token.content = token.content.replace(SCOPED_ABBR_RE, replaceFn);
    }
    if (token.type === "link_open" && token.info === "auto") {
      inside_autolink--;
    }
    if (token.type === "link_close" && token.info === "auto") {
      inside_autolink++;
    }
  }
}
function replace_rare(inlineTokens) {
  let inside_autolink = 0;
  for (let i = inlineTokens.length - 1; i >= 0; i--) {
    const token = inlineTokens[i];
    if (token.type === "text" && !inside_autolink) {
      if (RARE_RE.test(token.content)) {
        token.content = token.content.replace(/\+-/g, "±").replace(/\.{2,}/g, "…").replace(/([?!])…/g, "$1..").replace(/([?!]){4,}/g, "$1$1$1").replace(/,{2,}/g, ",").replace(/(^|[^-])---(?=[^-]|$)/mg, "$1—").replace(/(^|\s)--(?=\s|$)/mg, "$1–").replace(/(^|[^-\s])--(?=[^-\s]|$)/mg, "$1–");
      }
    }
    if (token.type === "link_open" && token.info === "auto") {
      inside_autolink--;
    }
    if (token.type === "link_close" && token.info === "auto") {
      inside_autolink++;
    }
  }
}
function replace(state) {
  let blkIdx;
  if (!state.md.options.typographer) {
    return;
  }
  for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {
    if (state.tokens[blkIdx].type !== "inline") {
      continue;
    }
    if (SCOPED_ABBR_TEST_RE.test(state.tokens[blkIdx].content)) {
      replace_scoped(state.tokens[blkIdx].children);
    }
    if (RARE_RE.test(state.tokens[blkIdx].content)) {
      replace_rare(state.tokens[blkIdx].children);
    }
  }
}

// node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/rules_core/smartquotes.mjs
var QUOTE_TEST_RE = /['"]/;
var QUOTE_RE = /['"]/g;
var APOSTROPHE = "’";
function replaceAt(str2, index2, ch) {
  return str2.slice(0, index2) + ch + str2.slice(index2 + 1);
}
function process_inlines(tokens, state) {
  let j;
  const stack = [];
  for (let i = 0; i < tokens.length; i++) {
    const token = tokens[i];
    const thisLevel = tokens[i].level;
    for (j = stack.length - 1; j >= 0; j--) {
      if (stack[j].level <= thisLevel) {
        break;
      }
    }
    stack.length = j + 1;
    if (token.type !== "text") {
      continue;
    }
    let text4 = token.content;
    let pos = 0;
    let max = text4.length;
    OUTER:
      while (pos < max) {
        QUOTE_RE.lastIndex = pos;
        const t = QUOTE_RE.exec(text4);
        if (!t) {
          break;
        }
        let canOpen = true;
        let canClose = true;
        pos = t.index + 1;
        const isSingle = t[0] === "'";
        let lastChar = 32;
        if (t.index - 1 >= 0) {
          lastChar = text4.charCodeAt(t.index - 1);
        } else {
          for (j = i - 1; j >= 0; j--) {
            if (tokens[j].type === "softbreak" || tokens[j].type === "hardbreak")
              break;
            if (!tokens[j].content)
              continue;
            lastChar = tokens[j].content.charCodeAt(tokens[j].content.length - 1);
            break;
          }
        }
        let nextChar = 32;
        if (pos < max) {
          nextChar = text4.charCodeAt(pos);
        } else {
          for (j = i + 1; j < tokens.length; j++) {
            if (tokens[j].type === "softbreak" || tokens[j].type === "hardbreak")
              break;
            if (!tokens[j].content)
              continue;
            nextChar = tokens[j].content.charCodeAt(0);
            break;
          }
        }
        const isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));
        const isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));
        const isLastWhiteSpace = isWhiteSpace(lastChar);
        const isNextWhiteSpace = isWhiteSpace(nextChar);
        if (isNextWhiteSpace) {
          canOpen = false;
        } else if (isNextPunctChar) {
          if (!(isLastWhiteSpace || isLastPunctChar)) {
            canOpen = false;
          }
        }
        if (isLastWhiteSpace) {
          canClose = false;
        } else if (isLastPunctChar) {
          if (!(isNextWhiteSpace || isNextPunctChar)) {
            canClose = false;
          }
        }
        if (nextChar === 34 && t[0] === '"') {
          if (lastChar >= 48 && lastChar <= 57) {
            canClose = canOpen = false;
          }
        }
        if (canOpen && canClose) {
          canOpen = isLastPunctChar;
          canClose = isNextPunctChar;
        }
        if (!canOpen && !canClose) {
          if (isSingle) {
            token.content = replaceAt(token.content, t.index, APOSTROPHE);
          }
          continue;
        }
        if (canClose) {
          for (j = stack.length - 1; j >= 0; j--) {
            let item = stack[j];
            if (stack[j].level < thisLevel) {
              break;
            }
            if (item.single === isSingle && stack[j].level === thisLevel) {
              item = stack[j];
              let openQuote;
              let closeQuote;
              if (isSingle) {
                openQuote = state.md.options.quotes[2];
                closeQuote = state.md.options.quotes[3];
              } else {
                openQuote = state.md.options.quotes[0];
                closeQuote = state.md.options.quotes[1];
              }
              token.content = replaceAt(token.content, t.index, closeQuote);
              tokens[item.token].content = replaceAt(
                tokens[item.token].content,
                item.pos,
                openQuote
              );
              pos += closeQuote.length - 1;
              if (item.token === i) {
                pos += openQuote.length - 1;
              }
              text4 = token.content;
              max = text4.length;
              stack.length = j;
              continue OUTER;
            }
          }
        }
        if (canOpen) {
          stack.push({
            token: i,
            pos: t.index,
            single: isSingle,
            level: thisLevel
          });
        } else if (canClose && isSingle) {
          token.content = replaceAt(token.content, t.index, APOSTROPHE);
        }
      }
  }
}
function smartquotes(state) {
  if (!state.md.options.typographer) {
    return;
  }
  for (let blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {
    if (state.tokens[blkIdx].type !== "inline" || !QUOTE_TEST_RE.test(state.tokens[blkIdx].content)) {
      continue;
    }
    process_inlines(state.tokens[blkIdx].children, state);
  }
}

// node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/rules_core/text_join.mjs
function text_join(state) {
  let curr, last2;
  const blockTokens = state.tokens;
  const l = blockTokens.length;
  for (let j = 0; j < l; j++) {
    if (blockTokens[j].type !== "inline")
      continue;
    const tokens = blockTokens[j].children;
    const max = tokens.length;
    for (curr = 0; curr < max; curr++) {
      if (tokens[curr].type === "text_special") {
        tokens[curr].type = "text";
      }
    }
    for (curr = last2 = 0; curr < max; curr++) {
      if (tokens[curr].type === "text" && curr + 1 < max && tokens[curr + 1].type === "text") {
        tokens[curr + 1].content = tokens[curr].content + tokens[curr + 1].content;
      } else {
        if (curr !== last2) {
          tokens[last2] = tokens[curr];
        }
        last2++;
      }
    }
    if (curr !== last2) {
      tokens.length = last2;
    }
  }
}

// node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/parser_core.mjs
var _rules = [
  ["normalize", normalize],
  ["block", block],
  ["inline", inline],
  ["linkify", linkify],
  ["replacements", replace],
  ["smartquotes", smartquotes],
  // `text_join` finds `text_special` tokens (for escape sequences)
  // and joins them with the rest of the text
  ["text_join", text_join]
];
function Core() {
  this.ruler = new ruler_default();
  for (let i = 0; i < _rules.length; i++) {
    this.ruler.push(_rules[i][0], _rules[i][1]);
  }
}
Core.prototype.process = function(state) {
  const rules = this.ruler.getRules("");
  for (let i = 0, l = rules.length; i < l; i++) {
    rules[i](state);
  }
};
Core.prototype.State = state_core_default;
var parser_core_default = Core;

// node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/rules_block/state_block.mjs
function StateBlock(src, md, env, tokens) {
  this.src = src;
  this.md = md;
  this.env = env;
  this.tokens = tokens;
  this.bMarks = [];
  this.eMarks = [];
  this.tShift = [];
  this.sCount = [];
  this.bsCount = [];
  this.blkIndent = 0;
  this.line = 0;
  this.lineMax = 0;
  this.tight = false;
  this.ddIndent = -1;
  this.listIndent = -1;
  this.parentType = "root";
  this.level = 0;
  const s = this.src;
  for (let start = 0, pos = 0, indent = 0, offset = 0, len = s.length, indent_found = false; pos < len; pos++) {
    const ch = s.charCodeAt(pos);
    if (!indent_found) {
      if (isSpace(ch)) {
        indent++;
        if (ch === 9) {
          offset += 4 - offset % 4;
        } else {
          offset++;
        }
        continue;
      } else {
        indent_found = true;
      }
    }
    if (ch === 10 || pos === len - 1) {
      if (ch !== 10) {
        pos++;
      }
      this.bMarks.push(start);
      this.eMarks.push(pos);
      this.tShift.push(indent);
      this.sCount.push(offset);
      this.bsCount.push(0);
      indent_found = false;
      indent = 0;
      offset = 0;
      start = pos + 1;
    }
  }
  this.bMarks.push(s.length);
  this.eMarks.push(s.length);
  this.tShift.push(0);
  this.sCount.push(0);
  this.bsCount.push(0);
  this.lineMax = this.bMarks.length - 1;
}
StateBlock.prototype.push = function(type2, tag, nesting) {
  const token = new token_default(type2, tag, nesting);
  token.block = true;
  if (nesting < 0)
    this.level--;
  token.level = this.level;
  if (nesting > 0)
    this.level++;
  this.tokens.push(token);
  return token;
};
StateBlock.prototype.isEmpty = function isEmpty(line) {
  return this.bMarks[line] + this.tShift[line] >= this.eMarks[line];
};
StateBlock.prototype.skipEmptyLines = function skipEmptyLines(from) {
  for (let max = this.lineMax; from < max; from++) {
    if (this.bMarks[from] + this.tShift[from] < this.eMarks[from]) {
      break;
    }
  }
  return from;
};
StateBlock.prototype.skipSpaces = function skipSpaces(pos) {
  for (let max = this.src.length; pos < max; pos++) {
    const ch = this.src.charCodeAt(pos);
    if (!isSpace(ch)) {
      break;
    }
  }
  return pos;
};
StateBlock.prototype.skipSpacesBack = function skipSpacesBack(pos, min) {
  if (pos <= min) {
    return pos;
  }
  while (pos > min) {
    if (!isSpace(this.src.charCodeAt(--pos))) {
      return pos + 1;
    }
  }
  return pos;
};
StateBlock.prototype.skipChars = function skipChars(pos, code2) {
  for (let max = this.src.length; pos < max; pos++) {
    if (this.src.charCodeAt(pos) !== code2) {
      break;
    }
  }
  return pos;
};
StateBlock.prototype.skipCharsBack = function skipCharsBack(pos, code2, min) {
  if (pos <= min) {
    return pos;
  }
  while (pos > min) {
    if (code2 !== this.src.charCodeAt(--pos)) {
      return pos + 1;
    }
  }
  return pos;
};
StateBlock.prototype.getLines = function getLines(begin, end2, indent, keepLastLF) {
  if (begin >= end2) {
    return "";
  }
  const queue = new Array(end2 - begin);
  for (let i = 0, line = begin; line < end2; line++, i++) {
    let lineIndent = 0;
    const lineStart = this.bMarks[line];
    let first2 = lineStart;
    let last2;
    if (line + 1 < end2 || keepLastLF) {
      last2 = this.eMarks[line] + 1;
    } else {
      last2 = this.eMarks[line];
    }
    while (first2 < last2 && lineIndent < indent) {
      const ch = this.src.charCodeAt(first2);
      if (isSpace(ch)) {
        if (ch === 9) {
          lineIndent += 4 - (lineIndent + this.bsCount[line]) % 4;
        } else {
          lineIndent++;
        }
      } else if (first2 - lineStart < this.tShift[line]) {
        lineIndent++;
      } else {
        break;
      }
      first2++;
    }
    if (lineIndent > indent) {
      queue[i] = new Array(lineIndent - indent + 1).join(" ") + this.src.slice(first2, last2);
    } else {
      queue[i] = this.src.slice(first2, last2);
    }
  }
  return queue.join("");
};
StateBlock.prototype.Token = token_default;
var state_block_default = StateBlock;

// node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/rules_block/table.mjs
var MAX_AUTOCOMPLETED_CELLS = 65536;
function getLine(state, line) {
  const pos = state.bMarks[line] + state.tShift[line];
  const max = state.eMarks[line];
  return state.src.slice(pos, max);
}
function escapedSplit(str2) {
  const result = [];
  const max = str2.length;
  let pos = 0;
  let ch = str2.charCodeAt(pos);
  let isEscaped = false;
  let lastPos = 0;
  let current = "";
  while (pos < max) {
    if (ch === 124) {
      if (!isEscaped) {
        result.push(current + str2.substring(lastPos, pos));
        current = "";
        lastPos = pos + 1;
      } else {
        current += str2.substring(lastPos, pos - 1);
        lastPos = pos;
      }
    }
    isEscaped = ch === 92;
    pos++;
    ch = str2.charCodeAt(pos);
  }
  result.push(current + str2.substring(lastPos));
  return result;
}
function table(state, startLine, endLine, silent) {
  if (startLine + 2 > endLine) {
    return false;
  }
  let nextLine = startLine + 1;
  if (state.sCount[nextLine] < state.blkIndent) {
    return false;
  }
  if (state.sCount[nextLine] - state.blkIndent >= 4) {
    return false;
  }
  let pos = state.bMarks[nextLine] + state.tShift[nextLine];
  if (pos >= state.eMarks[nextLine]) {
    return false;
  }
  const firstCh = state.src.charCodeAt(pos++);
  if (firstCh !== 124 && firstCh !== 45 && firstCh !== 58) {
    return false;
  }
  if (pos >= state.eMarks[nextLine]) {
    return false;
  }
  const secondCh = state.src.charCodeAt(pos++);
  if (secondCh !== 124 && secondCh !== 45 && secondCh !== 58 && !isSpace(secondCh)) {
    return false;
  }
  if (firstCh === 45 && isSpace(secondCh)) {
    return false;
  }
  while (pos < state.eMarks[nextLine]) {
    const ch = state.src.charCodeAt(pos);
    if (ch !== 124 && ch !== 45 && ch !== 58 && !isSpace(ch)) {
      return false;
    }
    pos++;
  }
  let lineText = getLine(state, startLine + 1);
  let columns = lineText.split("|");
  const aligns = [];
  for (let i = 0; i < columns.length; i++) {
    const t = columns[i].trim();
    if (!t) {
      if (i === 0 || i === columns.length - 1) {
        continue;
      } else {
        return false;
      }
    }
    if (!/^:?-+:?$/.test(t)) {
      return false;
    }
    if (t.charCodeAt(t.length - 1) === 58) {
      aligns.push(t.charCodeAt(0) === 58 ? "center" : "right");
    } else if (t.charCodeAt(0) === 58) {
      aligns.push("left");
    } else {
      aligns.push("");
    }
  }
  lineText = getLine(state, startLine).trim();
  if (lineText.indexOf("|") === -1) {
    return false;
  }
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }
  columns = escapedSplit(lineText);
  if (columns.length && columns[0] === "")
    columns.shift();
  if (columns.length && columns[columns.length - 1] === "")
    columns.pop();
  const columnCount = columns.length;
  if (columnCount === 0 || columnCount !== aligns.length) {
    return false;
  }
  if (silent) {
    return true;
  }
  const oldParentType = state.parentType;
  state.parentType = "table";
  const terminatorRules = state.md.block.ruler.getRules("blockquote");
  const token_to = state.push("table_open", "table", 1);
  const tableLines = [startLine, 0];
  token_to.map = tableLines;
  const token_tho = state.push("thead_open", "thead", 1);
  token_tho.map = [startLine, startLine + 1];
  const token_htro = state.push("tr_open", "tr", 1);
  token_htro.map = [startLine, startLine + 1];
  for (let i = 0; i < columns.length; i++) {
    const token_ho = state.push("th_open", "th", 1);
    if (aligns[i]) {
      token_ho.attrs = [["style", "text-align:" + aligns[i]]];
    }
    const token_il = state.push("inline", "", 0);
    token_il.content = columns[i].trim();
    token_il.children = [];
    state.push("th_close", "th", -1);
  }
  state.push("tr_close", "tr", -1);
  state.push("thead_close", "thead", -1);
  let tbodyLines;
  let autocompletedCells = 0;
  for (nextLine = startLine + 2; nextLine < endLine; nextLine++) {
    if (state.sCount[nextLine] < state.blkIndent) {
      break;
    }
    let terminate = false;
    for (let i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      break;
    }
    lineText = getLine(state, nextLine).trim();
    if (!lineText) {
      break;
    }
    if (state.sCount[nextLine] - state.blkIndent >= 4) {
      break;
    }
    columns = escapedSplit(lineText);
    if (columns.length && columns[0] === "")
      columns.shift();
    if (columns.length && columns[columns.length - 1] === "")
      columns.pop();
    autocompletedCells += columnCount - columns.length;
    if (autocompletedCells > MAX_AUTOCOMPLETED_CELLS) {
      break;
    }
    if (nextLine === startLine + 2) {
      const token_tbo = state.push("tbody_open", "tbody", 1);
      token_tbo.map = tbodyLines = [startLine + 2, 0];
    }
    const token_tro = state.push("tr_open", "tr", 1);
    token_tro.map = [nextLine, nextLine + 1];
    for (let i = 0; i < columnCount; i++) {
      const token_tdo = state.push("td_open", "td", 1);
      if (aligns[i]) {
        token_tdo.attrs = [["style", "text-align:" + aligns[i]]];
      }
      const token_il = state.push("inline", "", 0);
      token_il.content = columns[i] ? columns[i].trim() : "";
      token_il.children = [];
      state.push("td_close", "td", -1);
    }
    state.push("tr_close", "tr", -1);
  }
  if (tbodyLines) {
    state.push("tbody_close", "tbody", -1);
    tbodyLines[1] = nextLine;
  }
  state.push("table_close", "table", -1);
  tableLines[1] = nextLine;
  state.parentType = oldParentType;
  state.line = nextLine;
  return true;
}

// node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/rules_block/code.mjs
function code(state, startLine, endLine) {
  if (state.sCount[startLine] - state.blkIndent < 4) {
    return false;
  }
  let nextLine = startLine + 1;
  let last2 = nextLine;
  while (nextLine < endLine) {
    if (state.isEmpty(nextLine)) {
      nextLine++;
      continue;
    }
    if (state.sCount[nextLine] - state.blkIndent >= 4) {
      nextLine++;
      last2 = nextLine;
      continue;
    }
    break;
  }
  state.line = last2;
  const token = state.push("code_block", "code", 0);
  token.content = state.getLines(startLine, last2, 4 + state.blkIndent, false) + "\n";
  token.map = [startLine, state.line];
  return true;
}

// node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/rules_block/fence.mjs
function fence(state, startLine, endLine, silent) {
  let pos = state.bMarks[startLine] + state.tShift[startLine];
  let max = state.eMarks[startLine];
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }
  if (pos + 3 > max) {
    return false;
  }
  const marker = state.src.charCodeAt(pos);
  if (marker !== 126 && marker !== 96) {
    return false;
  }
  let mem = pos;
  pos = state.skipChars(pos, marker);
  let len = pos - mem;
  if (len < 3) {
    return false;
  }
  const markup = state.src.slice(mem, pos);
  const params = state.src.slice(pos, max);
  if (marker === 96) {
    if (params.indexOf(String.fromCharCode(marker)) >= 0) {
      return false;
    }
  }
  if (silent) {
    return true;
  }
  let nextLine = startLine;
  let haveEndMarker = false;
  for (; ; ) {
    nextLine++;
    if (nextLine >= endLine) {
      break;
    }
    pos = mem = state.bMarks[nextLine] + state.tShift[nextLine];
    max = state.eMarks[nextLine];
    if (pos < max && state.sCount[nextLine] < state.blkIndent) {
      break;
    }
    if (state.src.charCodeAt(pos) !== marker) {
      continue;
    }
    if (state.sCount[nextLine] - state.blkIndent >= 4) {
      continue;
    }
    pos = state.skipChars(pos, marker);
    if (pos - mem < len) {
      continue;
    }
    pos = state.skipSpaces(pos);
    if (pos < max) {
      continue;
    }
    haveEndMarker = true;
    break;
  }
  len = state.sCount[startLine];
  state.line = nextLine + (haveEndMarker ? 1 : 0);
  const token = state.push("fence", "code", 0);
  token.info = params;
  token.content = state.getLines(startLine + 1, nextLine, len, true);
  token.markup = markup;
  token.map = [startLine, state.line];
  return true;
}

// node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/rules_block/blockquote.mjs
function blockquote(state, startLine, endLine, silent) {
  let pos = state.bMarks[startLine] + state.tShift[startLine];
  let max = state.eMarks[startLine];
  const oldLineMax = state.lineMax;
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }
  if (state.src.charCodeAt(pos) !== 62) {
    return false;
  }
  if (silent) {
    return true;
  }
  const oldBMarks = [];
  const oldBSCount = [];
  const oldSCount = [];
  const oldTShift = [];
  const terminatorRules = state.md.block.ruler.getRules("blockquote");
  const oldParentType = state.parentType;
  state.parentType = "blockquote";
  let lastLineEmpty = false;
  let nextLine;
  for (nextLine = startLine; nextLine < endLine; nextLine++) {
    const isOutdented = state.sCount[nextLine] < state.blkIndent;
    pos = state.bMarks[nextLine] + state.tShift[nextLine];
    max = state.eMarks[nextLine];
    if (pos >= max) {
      break;
    }
    if (state.src.charCodeAt(pos++) === 62 && !isOutdented) {
      let initial = state.sCount[nextLine] + 1;
      let spaceAfterMarker;
      let adjustTab;
      if (state.src.charCodeAt(pos) === 32) {
        pos++;
        initial++;
        adjustTab = false;
        spaceAfterMarker = true;
      } else if (state.src.charCodeAt(pos) === 9) {
        spaceAfterMarker = true;
        if ((state.bsCount[nextLine] + initial) % 4 === 3) {
          pos++;
          initial++;
          adjustTab = false;
        } else {
          adjustTab = true;
        }
      } else {
        spaceAfterMarker = false;
      }
      let offset = initial;
      oldBMarks.push(state.bMarks[nextLine]);
      state.bMarks[nextLine] = pos;
      while (pos < max) {
        const ch = state.src.charCodeAt(pos);
        if (isSpace(ch)) {
          if (ch === 9) {
            offset += 4 - (offset + state.bsCount[nextLine] + (adjustTab ? 1 : 0)) % 4;
          } else {
            offset++;
          }
        } else {
          break;
        }
        pos++;
      }
      lastLineEmpty = pos >= max;
      oldBSCount.push(state.bsCount[nextLine]);
      state.bsCount[nextLine] = state.sCount[nextLine] + 1 + (spaceAfterMarker ? 1 : 0);
      oldSCount.push(state.sCount[nextLine]);
      state.sCount[nextLine] = offset - initial;
      oldTShift.push(state.tShift[nextLine]);
      state.tShift[nextLine] = pos - state.bMarks[nextLine];
      continue;
    }
    if (lastLineEmpty) {
      break;
    }
    let terminate = false;
    for (let i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      state.lineMax = nextLine;
      if (state.blkIndent !== 0) {
        oldBMarks.push(state.bMarks[nextLine]);
        oldBSCount.push(state.bsCount[nextLine]);
        oldTShift.push(state.tShift[nextLine]);
        oldSCount.push(state.sCount[nextLine]);
        state.sCount[nextLine] -= state.blkIndent;
      }
      break;
    }
    oldBMarks.push(state.bMarks[nextLine]);
    oldBSCount.push(state.bsCount[nextLine]);
    oldTShift.push(state.tShift[nextLine]);
    oldSCount.push(state.sCount[nextLine]);
    state.sCount[nextLine] = -1;
  }
  const oldIndent = state.blkIndent;
  state.blkIndent = 0;
  const token_o = state.push("blockquote_open", "blockquote", 1);
  token_o.markup = ">";
  const lines = [startLine, 0];
  token_o.map = lines;
  state.md.block.tokenize(state, startLine, nextLine);
  const token_c = state.push("blockquote_close", "blockquote", -1);
  token_c.markup = ">";
  state.lineMax = oldLineMax;
  state.parentType = oldParentType;
  lines[1] = state.line;
  for (let i = 0; i < oldTShift.length; i++) {
    state.bMarks[i + startLine] = oldBMarks[i];
    state.tShift[i + startLine] = oldTShift[i];
    state.sCount[i + startLine] = oldSCount[i];
    state.bsCount[i + startLine] = oldBSCount[i];
  }
  state.blkIndent = oldIndent;
  return true;
}

// node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/rules_block/hr.mjs
function hr(state, startLine, endLine, silent) {
  const max = state.eMarks[startLine];
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }
  let pos = state.bMarks[startLine] + state.tShift[startLine];
  const marker = state.src.charCodeAt(pos++);
  if (marker !== 42 && marker !== 45 && marker !== 95) {
    return false;
  }
  let cnt = 1;
  while (pos < max) {
    const ch = state.src.charCodeAt(pos++);
    if (ch !== marker && !isSpace(ch)) {
      return false;
    }
    if (ch === marker) {
      cnt++;
    }
  }
  if (cnt < 3) {
    return false;
  }
  if (silent) {
    return true;
  }
  state.line = startLine + 1;
  const token = state.push("hr", "hr", 0);
  token.map = [startLine, state.line];
  token.markup = Array(cnt + 1).join(String.fromCharCode(marker));
  return true;
}

// node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/rules_block/list.mjs
function skipBulletListMarker(state, startLine) {
  const max = state.eMarks[startLine];
  let pos = state.bMarks[startLine] + state.tShift[startLine];
  const marker = state.src.charCodeAt(pos++);
  if (marker !== 42 && marker !== 45 && marker !== 43) {
    return -1;
  }
  if (pos < max) {
    const ch = state.src.charCodeAt(pos);
    if (!isSpace(ch)) {
      return -1;
    }
  }
  return pos;
}
function skipOrderedListMarker(state, startLine) {
  const start = state.bMarks[startLine] + state.tShift[startLine];
  const max = state.eMarks[startLine];
  let pos = start;
  if (pos + 1 >= max) {
    return -1;
  }
  let ch = state.src.charCodeAt(pos++);
  if (ch < 48 || ch > 57) {
    return -1;
  }
  for (; ; ) {
    if (pos >= max) {
      return -1;
    }
    ch = state.src.charCodeAt(pos++);
    if (ch >= 48 && ch <= 57) {
      if (pos - start >= 10) {
        return -1;
      }
      continue;
    }
    if (ch === 41 || ch === 46) {
      break;
    }
    return -1;
  }
  if (pos < max) {
    ch = state.src.charCodeAt(pos);
    if (!isSpace(ch)) {
      return -1;
    }
  }
  return pos;
}
function markTightParagraphs(state, idx) {
  const level = state.level + 2;
  for (let i = idx + 2, l = state.tokens.length - 2; i < l; i++) {
    if (state.tokens[i].level === level && state.tokens[i].type === "paragraph_open") {
      state.tokens[i + 2].hidden = true;
      state.tokens[i].hidden = true;
      i += 2;
    }
  }
}
function list(state, startLine, endLine, silent) {
  let max, pos, start, token;
  let nextLine = startLine;
  let tight = true;
  if (state.sCount[nextLine] - state.blkIndent >= 4) {
    return false;
  }
  if (state.listIndent >= 0 && state.sCount[nextLine] - state.listIndent >= 4 && state.sCount[nextLine] < state.blkIndent) {
    return false;
  }
  let isTerminatingParagraph = false;
  if (silent && state.parentType === "paragraph") {
    if (state.sCount[nextLine] >= state.blkIndent) {
      isTerminatingParagraph = true;
    }
  }
  let isOrdered;
  let markerValue;
  let posAfterMarker;
  if ((posAfterMarker = skipOrderedListMarker(state, nextLine)) >= 0) {
    isOrdered = true;
    start = state.bMarks[nextLine] + state.tShift[nextLine];
    markerValue = Number(state.src.slice(start, posAfterMarker - 1));
    if (isTerminatingParagraph && markerValue !== 1)
      return false;
  } else if ((posAfterMarker = skipBulletListMarker(state, nextLine)) >= 0) {
    isOrdered = false;
  } else {
    return false;
  }
  if (isTerminatingParagraph) {
    if (state.skipSpaces(posAfterMarker) >= state.eMarks[nextLine])
      return false;
  }
  if (silent) {
    return true;
  }
  const markerCharCode = state.src.charCodeAt(posAfterMarker - 1);
  const listTokIdx = state.tokens.length;
  if (isOrdered) {
    token = state.push("ordered_list_open", "ol", 1);
    if (markerValue !== 1) {
      token.attrs = [["start", markerValue]];
    }
  } else {
    token = state.push("bullet_list_open", "ul", 1);
  }
  const listLines = [nextLine, 0];
  token.map = listLines;
  token.markup = String.fromCharCode(markerCharCode);
  let prevEmptyEnd = false;
  const terminatorRules = state.md.block.ruler.getRules("list");
  const oldParentType = state.parentType;
  state.parentType = "list";
  while (nextLine < endLine) {
    pos = posAfterMarker;
    max = state.eMarks[nextLine];
    const initial = state.sCount[nextLine] + posAfterMarker - (state.bMarks[nextLine] + state.tShift[nextLine]);
    let offset = initial;
    while (pos < max) {
      const ch = state.src.charCodeAt(pos);
      if (ch === 9) {
        offset += 4 - (offset + state.bsCount[nextLine]) % 4;
      } else if (ch === 32) {
        offset++;
      } else {
        break;
      }
      pos++;
    }
    const contentStart = pos;
    let indentAfterMarker;
    if (contentStart >= max) {
      indentAfterMarker = 1;
    } else {
      indentAfterMarker = offset - initial;
    }
    if (indentAfterMarker > 4) {
      indentAfterMarker = 1;
    }
    const indent = initial + indentAfterMarker;
    token = state.push("list_item_open", "li", 1);
    token.markup = String.fromCharCode(markerCharCode);
    const itemLines = [nextLine, 0];
    token.map = itemLines;
    if (isOrdered) {
      token.info = state.src.slice(start, posAfterMarker - 1);
    }
    const oldTight = state.tight;
    const oldTShift = state.tShift[nextLine];
    const oldSCount = state.sCount[nextLine];
    const oldListIndent = state.listIndent;
    state.listIndent = state.blkIndent;
    state.blkIndent = indent;
    state.tight = true;
    state.tShift[nextLine] = contentStart - state.bMarks[nextLine];
    state.sCount[nextLine] = offset;
    if (contentStart >= max && state.isEmpty(nextLine + 1)) {
      state.line = Math.min(state.line + 2, endLine);
    } else {
      state.md.block.tokenize(state, nextLine, endLine, true);
    }
    if (!state.tight || prevEmptyEnd) {
      tight = false;
    }
    prevEmptyEnd = state.line - nextLine > 1 && state.isEmpty(state.line - 1);
    state.blkIndent = state.listIndent;
    state.listIndent = oldListIndent;
    state.tShift[nextLine] = oldTShift;
    state.sCount[nextLine] = oldSCount;
    state.tight = oldTight;
    token = state.push("list_item_close", "li", -1);
    token.markup = String.fromCharCode(markerCharCode);
    nextLine = state.line;
    itemLines[1] = nextLine;
    if (nextLine >= endLine) {
      break;
    }
    if (state.sCount[nextLine] < state.blkIndent) {
      break;
    }
    if (state.sCount[nextLine] - state.blkIndent >= 4) {
      break;
    }
    let terminate = false;
    for (let i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      break;
    }
    if (isOrdered) {
      posAfterMarker = skipOrderedListMarker(state, nextLine);
      if (posAfterMarker < 0) {
        break;
      }
      start = state.bMarks[nextLine] + state.tShift[nextLine];
    } else {
      posAfterMarker = skipBulletListMarker(state, nextLine);
      if (posAfterMarker < 0) {
        break;
      }
    }
    if (markerCharCode !== state.src.charCodeAt(posAfterMarker - 1)) {
      break;
    }
  }
  if (isOrdered) {
    token = state.push("ordered_list_close", "ol", -1);
  } else {
    token = state.push("bullet_list_close", "ul", -1);
  }
  token.markup = String.fromCharCode(markerCharCode);
  listLines[1] = nextLine;
  state.line = nextLine;
  state.parentType = oldParentType;
  if (tight) {
    markTightParagraphs(state, listTokIdx);
  }
  return true;
}

// node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/rules_block/reference.mjs
function reference(state, startLine, _endLine, silent) {
  let pos = state.bMarks[startLine] + state.tShift[startLine];
  let max = state.eMarks[startLine];
  let nextLine = startLine + 1;
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }
  if (state.src.charCodeAt(pos) !== 91) {
    return false;
  }
  function getNextLine(nextLine2) {
    const endLine = state.lineMax;
    if (nextLine2 >= endLine || state.isEmpty(nextLine2)) {
      return null;
    }
    let isContinuation = false;
    if (state.sCount[nextLine2] - state.blkIndent > 3) {
      isContinuation = true;
    }
    if (state.sCount[nextLine2] < 0) {
      isContinuation = true;
    }
    if (!isContinuation) {
      const terminatorRules = state.md.block.ruler.getRules("reference");
      const oldParentType = state.parentType;
      state.parentType = "reference";
      let terminate = false;
      for (let i = 0, l = terminatorRules.length; i < l; i++) {
        if (terminatorRules[i](state, nextLine2, endLine, true)) {
          terminate = true;
          break;
        }
      }
      state.parentType = oldParentType;
      if (terminate) {
        return null;
      }
    }
    const pos2 = state.bMarks[nextLine2] + state.tShift[nextLine2];
    const max2 = state.eMarks[nextLine2];
    return state.src.slice(pos2, max2 + 1);
  }
  let str2 = state.src.slice(pos, max + 1);
  max = str2.length;
  let labelEnd = -1;
  for (pos = 1; pos < max; pos++) {
    const ch = str2.charCodeAt(pos);
    if (ch === 91) {
      return false;
    } else if (ch === 93) {
      labelEnd = pos;
      break;
    } else if (ch === 10) {
      const lineContent = getNextLine(nextLine);
      if (lineContent !== null) {
        str2 += lineContent;
        max = str2.length;
        nextLine++;
      }
    } else if (ch === 92) {
      pos++;
      if (pos < max && str2.charCodeAt(pos) === 10) {
        const lineContent = getNextLine(nextLine);
        if (lineContent !== null) {
          str2 += lineContent;
          max = str2.length;
          nextLine++;
        }
      }
    }
  }
  if (labelEnd < 0 || str2.charCodeAt(labelEnd + 1) !== 58) {
    return false;
  }
  for (pos = labelEnd + 2; pos < max; pos++) {
    const ch = str2.charCodeAt(pos);
    if (ch === 10) {
      const lineContent = getNextLine(nextLine);
      if (lineContent !== null) {
        str2 += lineContent;
        max = str2.length;
        nextLine++;
      }
    } else if (isSpace(ch)) {
    } else {
      break;
    }
  }
  const destRes = state.md.helpers.parseLinkDestination(str2, pos, max);
  if (!destRes.ok) {
    return false;
  }
  const href = state.md.normalizeLink(destRes.str);
  if (!state.md.validateLink(href)) {
    return false;
  }
  pos = destRes.pos;
  const destEndPos = pos;
  const destEndLineNo = nextLine;
  const start = pos;
  for (; pos < max; pos++) {
    const ch = str2.charCodeAt(pos);
    if (ch === 10) {
      const lineContent = getNextLine(nextLine);
      if (lineContent !== null) {
        str2 += lineContent;
        max = str2.length;
        nextLine++;
      }
    } else if (isSpace(ch)) {
    } else {
      break;
    }
  }
  let titleRes = state.md.helpers.parseLinkTitle(str2, pos, max);
  while (titleRes.can_continue) {
    const lineContent = getNextLine(nextLine);
    if (lineContent === null)
      break;
    str2 += lineContent;
    pos = max;
    max = str2.length;
    nextLine++;
    titleRes = state.md.helpers.parseLinkTitle(str2, pos, max, titleRes);
  }
  let title;
  if (pos < max && start !== pos && titleRes.ok) {
    title = titleRes.str;
    pos = titleRes.pos;
  } else {
    title = "";
    pos = destEndPos;
    nextLine = destEndLineNo;
  }
  while (pos < max) {
    const ch = str2.charCodeAt(pos);
    if (!isSpace(ch)) {
      break;
    }
    pos++;
  }
  if (pos < max && str2.charCodeAt(pos) !== 10) {
    if (title) {
      title = "";
      pos = destEndPos;
      nextLine = destEndLineNo;
      while (pos < max) {
        const ch = str2.charCodeAt(pos);
        if (!isSpace(ch)) {
          break;
        }
        pos++;
      }
    }
  }
  if (pos < max && str2.charCodeAt(pos) !== 10) {
    return false;
  }
  const label = normalizeReference(str2.slice(1, labelEnd));
  if (!label) {
    return false;
  }
  if (silent) {
    return true;
  }
  if (typeof state.env.references === "undefined") {
    state.env.references = {};
  }
  if (typeof state.env.references[label] === "undefined") {
    state.env.references[label] = { title, href };
  }
  state.line = nextLine;
  return true;
}

// node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/common/html_blocks.mjs
var html_blocks_default = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "search",
  "section",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
];

// node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/common/html_re.mjs
var attr_name = "[a-zA-Z_:][a-zA-Z0-9:._-]*";
var unquoted = "[^\"'=<>`\\x00-\\x20]+";
var single_quoted = "'[^']*'";
var double_quoted = '"[^"]*"';
var attr_value = "(?:" + unquoted + "|" + single_quoted + "|" + double_quoted + ")";
var attribute = "(?:\\s+" + attr_name + "(?:\\s*=\\s*" + attr_value + ")?)";
var open_tag = "<[A-Za-z][A-Za-z0-9\\-]*" + attribute + "*\\s*\\/?>";
var close_tag = "<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>";
var comment = "<!---?>|<!--(?:[^-]|-[^-]|--[^>])*-->";
var processing = "<[?][\\s\\S]*?[?]>";
var declaration = "<![A-Za-z][^>]*>";
var cdata = "<!\\[CDATA\\[[\\s\\S]*?\\]\\]>";
var HTML_TAG_RE = new RegExp("^(?:" + open_tag + "|" + close_tag + "|" + comment + "|" + processing + "|" + declaration + "|" + cdata + ")");
var HTML_OPEN_CLOSE_TAG_RE = new RegExp("^(?:" + open_tag + "|" + close_tag + ")");

// node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/rules_block/html_block.mjs
var HTML_SEQUENCES = [
  [/^<(script|pre|style|textarea)(?=(\s|>|$))/i, /<\/(script|pre|style|textarea)>/i, true],
  [/^<!--/, /-->/, true],
  [/^<\?/, /\?>/, true],
  [/^<![A-Z]/, />/, true],
  [/^<!\[CDATA\[/, /\]\]>/, true],
  [new RegExp("^</?(" + html_blocks_default.join("|") + ")(?=(\\s|/?>|$))", "i"), /^$/, true],
  [new RegExp(HTML_OPEN_CLOSE_TAG_RE.source + "\\s*$"), /^$/, false]
];
function html_block(state, startLine, endLine, silent) {
  let pos = state.bMarks[startLine] + state.tShift[startLine];
  let max = state.eMarks[startLine];
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }
  if (!state.md.options.html) {
    return false;
  }
  if (state.src.charCodeAt(pos) !== 60) {
    return false;
  }
  let lineText = state.src.slice(pos, max);
  let i = 0;
  for (; i < HTML_SEQUENCES.length; i++) {
    if (HTML_SEQUENCES[i][0].test(lineText)) {
      break;
    }
  }
  if (i === HTML_SEQUENCES.length) {
    return false;
  }
  if (silent) {
    return HTML_SEQUENCES[i][2];
  }
  let nextLine = startLine + 1;
  if (!HTML_SEQUENCES[i][1].test(lineText)) {
    for (; nextLine < endLine; nextLine++) {
      if (state.sCount[nextLine] < state.blkIndent) {
        break;
      }
      pos = state.bMarks[nextLine] + state.tShift[nextLine];
      max = state.eMarks[nextLine];
      lineText = state.src.slice(pos, max);
      if (HTML_SEQUENCES[i][1].test(lineText)) {
        if (lineText.length !== 0) {
          nextLine++;
        }
        break;
      }
    }
  }
  state.line = nextLine;
  const token = state.push("html_block", "", 0);
  token.map = [startLine, nextLine];
  token.content = state.getLines(startLine, nextLine, state.blkIndent, true);
  return true;
}

// node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/rules_block/heading.mjs
function heading(state, startLine, endLine, silent) {
  let pos = state.bMarks[startLine] + state.tShift[startLine];
  let max = state.eMarks[startLine];
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }
  let ch = state.src.charCodeAt(pos);
  if (ch !== 35 || pos >= max) {
    return false;
  }
  let level = 1;
  ch = state.src.charCodeAt(++pos);
  while (ch === 35 && pos < max && level <= 6) {
    level++;
    ch = state.src.charCodeAt(++pos);
  }
  if (level > 6 || pos < max && !isSpace(ch)) {
    return false;
  }
  if (silent) {
    return true;
  }
  max = state.skipSpacesBack(max, pos);
  const tmp = state.skipCharsBack(max, 35, pos);
  if (tmp > pos && isSpace(state.src.charCodeAt(tmp - 1))) {
    max = tmp;
  }
  state.line = startLine + 1;
  const token_o = state.push("heading_open", "h" + String(level), 1);
  token_o.markup = "########".slice(0, level);
  token_o.map = [startLine, state.line];
  const token_i = state.push("inline", "", 0);
  token_i.content = state.src.slice(pos, max).trim();
  token_i.map = [startLine, state.line];
  token_i.children = [];
  const token_c = state.push("heading_close", "h" + String(level), -1);
  token_c.markup = "########".slice(0, level);
  return true;
}

// node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/rules_block/lheading.mjs
function lheading(state, startLine, endLine) {
  const terminatorRules = state.md.block.ruler.getRules("paragraph");
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }
  const oldParentType = state.parentType;
  state.parentType = "paragraph";
  let level = 0;
  let marker;
  let nextLine = startLine + 1;
  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
    if (state.sCount[nextLine] - state.blkIndent > 3) {
      continue;
    }
    if (state.sCount[nextLine] >= state.blkIndent) {
      let pos = state.bMarks[nextLine] + state.tShift[nextLine];
      const max = state.eMarks[nextLine];
      if (pos < max) {
        marker = state.src.charCodeAt(pos);
        if (marker === 45 || marker === 61) {
          pos = state.skipChars(pos, marker);
          pos = state.skipSpaces(pos);
          if (pos >= max) {
            level = marker === 61 ? 1 : 2;
            break;
          }
        }
      }
    }
    if (state.sCount[nextLine] < 0) {
      continue;
    }
    let terminate = false;
    for (let i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      break;
    }
  }
  if (!level) {
    return false;
  }
  const content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
  state.line = nextLine + 1;
  const token_o = state.push("heading_open", "h" + String(level), 1);
  token_o.markup = String.fromCharCode(marker);
  token_o.map = [startLine, state.line];
  const token_i = state.push("inline", "", 0);
  token_i.content = content;
  token_i.map = [startLine, state.line - 1];
  token_i.children = [];
  const token_c = state.push("heading_close", "h" + String(level), -1);
  token_c.markup = String.fromCharCode(marker);
  state.parentType = oldParentType;
  return true;
}

// node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/rules_block/paragraph.mjs
function paragraph(state, startLine, endLine) {
  const terminatorRules = state.md.block.ruler.getRules("paragraph");
  const oldParentType = state.parentType;
  let nextLine = startLine + 1;
  state.parentType = "paragraph";
  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
    if (state.sCount[nextLine] - state.blkIndent > 3) {
      continue;
    }
    if (state.sCount[nextLine] < 0) {
      continue;
    }
    let terminate = false;
    for (let i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      break;
    }
  }
  const content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
  state.line = nextLine;
  const token_o = state.push("paragraph_open", "p", 1);
  token_o.map = [startLine, state.line];
  const token_i = state.push("inline", "", 0);
  token_i.content = content;
  token_i.map = [startLine, state.line];
  token_i.children = [];
  state.push("paragraph_close", "p", -1);
  state.parentType = oldParentType;
  return true;
}

// node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/parser_block.mjs
var _rules2 = [
  // First 2 params - rule name & source. Secondary array - list of rules,
  // which can be terminated by this one.
  ["table", table, ["paragraph", "reference"]],
  ["code", code],
  ["fence", fence, ["paragraph", "reference", "blockquote", "list"]],
  ["blockquote", blockquote, ["paragraph", "reference", "blockquote", "list"]],
  ["hr", hr, ["paragraph", "reference", "blockquote", "list"]],
  ["list", list, ["paragraph", "reference", "blockquote"]],
  ["reference", reference],
  ["html_block", html_block, ["paragraph", "reference", "blockquote"]],
  ["heading", heading, ["paragraph", "reference", "blockquote"]],
  ["lheading", lheading],
  ["paragraph", paragraph]
];
function ParserBlock() {
  this.ruler = new ruler_default();
  for (let i = 0; i < _rules2.length; i++) {
    this.ruler.push(_rules2[i][0], _rules2[i][1], { alt: (_rules2[i][2] || []).slice() });
  }
}
ParserBlock.prototype.tokenize = function(state, startLine, endLine) {
  const rules = this.ruler.getRules("");
  const len = rules.length;
  const maxNesting = state.md.options.maxNesting;
  let line = startLine;
  let hasEmptyLines = false;
  while (line < endLine) {
    state.line = line = state.skipEmptyLines(line);
    if (line >= endLine) {
      break;
    }
    if (state.sCount[line] < state.blkIndent) {
      break;
    }
    if (state.level >= maxNesting) {
      state.line = endLine;
      break;
    }
    const prevLine = state.line;
    let ok = false;
    for (let i = 0; i < len; i++) {
      ok = rules[i](state, line, endLine, false);
      if (ok) {
        if (prevLine >= state.line) {
          throw new Error("block rule didn't increment state.line");
        }
        break;
      }
    }
    if (!ok)
      throw new Error("none of the block rules matched");
    state.tight = !hasEmptyLines;
    if (state.isEmpty(state.line - 1)) {
      hasEmptyLines = true;
    }
    line = state.line;
    if (line < endLine && state.isEmpty(line)) {
      hasEmptyLines = true;
      line++;
      state.line = line;
    }
  }
};
ParserBlock.prototype.parse = function(src, md, env, outTokens) {
  if (!src) {
    return;
  }
  const state = new this.State(src, md, env, outTokens);
  this.tokenize(state, state.line, state.lineMax);
};
ParserBlock.prototype.State = state_block_default;
var parser_block_default = ParserBlock;

// node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/rules_inline/state_inline.mjs
function StateInline(src, md, env, outTokens) {
  this.src = src;
  this.env = env;
  this.md = md;
  this.tokens = outTokens;
  this.tokens_meta = Array(outTokens.length);
  this.pos = 0;
  this.posMax = this.src.length;
  this.level = 0;
  this.pending = "";
  this.pendingLevel = 0;
  this.cache = {};
  this.delimiters = [];
  this._prev_delimiters = [];
  this.backticks = {};
  this.backticksScanned = false;
  this.linkLevel = 0;
}
StateInline.prototype.pushPending = function() {
  const token = new token_default("text", "", 0);
  token.content = this.pending;
  token.level = this.pendingLevel;
  this.tokens.push(token);
  this.pending = "";
  return token;
};
StateInline.prototype.push = function(type2, tag, nesting) {
  if (this.pending) {
    this.pushPending();
  }
  const token = new token_default(type2, tag, nesting);
  let token_meta = null;
  if (nesting < 0) {
    this.level--;
    this.delimiters = this._prev_delimiters.pop();
  }
  token.level = this.level;
  if (nesting > 0) {
    this.level++;
    this._prev_delimiters.push(this.delimiters);
    this.delimiters = [];
    token_meta = { delimiters: this.delimiters };
  }
  this.pendingLevel = this.level;
  this.tokens.push(token);
  this.tokens_meta.push(token_meta);
  return token;
};
StateInline.prototype.scanDelims = function(start, canSplitWord) {
  const max = this.posMax;
  const marker = this.src.charCodeAt(start);
  const lastChar = start > 0 ? this.src.charCodeAt(start - 1) : 32;
  let pos = start;
  while (pos < max && this.src.charCodeAt(pos) === marker) {
    pos++;
  }
  const count = pos - start;
  const nextChar = pos < max ? this.src.charCodeAt(pos) : 32;
  const isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));
  const isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));
  const isLastWhiteSpace = isWhiteSpace(lastChar);
  const isNextWhiteSpace = isWhiteSpace(nextChar);
  const left_flanking = !isNextWhiteSpace && (!isNextPunctChar || isLastWhiteSpace || isLastPunctChar);
  const right_flanking = !isLastWhiteSpace && (!isLastPunctChar || isNextWhiteSpace || isNextPunctChar);
  const can_open = left_flanking && (canSplitWord || !right_flanking || isLastPunctChar);
  const can_close = right_flanking && (canSplitWord || !left_flanking || isNextPunctChar);
  return { can_open, can_close, length: count };
};
StateInline.prototype.Token = token_default;
var state_inline_default = StateInline;

// node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/rules_inline/text.mjs
function isTerminatorChar(ch) {
  switch (ch) {
    case 10:
    case 33:
    case 35:
    case 36:
    case 37:
    case 38:
    case 42:
    case 43:
    case 45:
    case 58:
    case 60:
    case 61:
    case 62:
    case 64:
    case 91:
    case 92:
    case 93:
    case 94:
    case 95:
    case 96:
    case 123:
    case 125:
    case 126:
      return true;
    default:
      return false;
  }
}
function text3(state, silent) {
  let pos = state.pos;
  while (pos < state.posMax && !isTerminatorChar(state.src.charCodeAt(pos))) {
    pos++;
  }
  if (pos === state.pos) {
    return false;
  }
  if (!silent) {
    state.pending += state.src.slice(state.pos, pos);
  }
  state.pos = pos;
  return true;
}

// node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/rules_inline/linkify.mjs
var SCHEME_RE = /(?:^|[^a-z0-9.+-])([a-z][a-z0-9.+-]*)$/i;
function linkify2(state, silent) {
  if (!state.md.options.linkify)
    return false;
  if (state.linkLevel > 0)
    return false;
  const pos = state.pos;
  const max = state.posMax;
  if (pos + 3 > max)
    return false;
  if (state.src.charCodeAt(pos) !== 58)
    return false;
  if (state.src.charCodeAt(pos + 1) !== 47)
    return false;
  if (state.src.charCodeAt(pos + 2) !== 47)
    return false;
  const match2 = state.pending.match(SCHEME_RE);
  if (!match2)
    return false;
  const proto = match2[1];
  const link2 = state.md.linkify.matchAtStart(state.src.slice(pos - proto.length));
  if (!link2)
    return false;
  let url = link2.url;
  if (url.length <= proto.length)
    return false;
  url = url.replace(/\*+$/, "");
  const fullUrl = state.md.normalizeLink(url);
  if (!state.md.validateLink(fullUrl))
    return false;
  if (!silent) {
    state.pending = state.pending.slice(0, -proto.length);
    const token_o = state.push("link_open", "a", 1);
    token_o.attrs = [["href", fullUrl]];
    token_o.markup = "linkify";
    token_o.info = "auto";
    const token_t = state.push("text", "", 0);
    token_t.content = state.md.normalizeLinkText(url);
    const token_c = state.push("link_close", "a", -1);
    token_c.markup = "linkify";
    token_c.info = "auto";
  }
  state.pos += url.length - proto.length;
  return true;
}

// node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/rules_inline/newline.mjs
function newline(state, silent) {
  let pos = state.pos;
  if (state.src.charCodeAt(pos) !== 10) {
    return false;
  }
  const pmax = state.pending.length - 1;
  const max = state.posMax;
  if (!silent) {
    if (pmax >= 0 && state.pending.charCodeAt(pmax) === 32) {
      if (pmax >= 1 && state.pending.charCodeAt(pmax - 1) === 32) {
        let ws = pmax - 1;
        while (ws >= 1 && state.pending.charCodeAt(ws - 1) === 32)
          ws--;
        state.pending = state.pending.slice(0, ws);
        state.push("hardbreak", "br", 0);
      } else {
        state.pending = state.pending.slice(0, -1);
        state.push("softbreak", "br", 0);
      }
    } else {
      state.push("softbreak", "br", 0);
    }
  }
  pos++;
  while (pos < max && isSpace(state.src.charCodeAt(pos))) {
    pos++;
  }
  state.pos = pos;
  return true;
}

// node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/rules_inline/escape.mjs
var ESCAPED = [];
for (let i = 0; i < 256; i++) {
  ESCAPED.push(0);
}
"\\!\"#$%&'()*+,./:;<=>?@[]^_`{|}~-".split("").forEach(function(ch) {
  ESCAPED[ch.charCodeAt(0)] = 1;
});
function escape2(state, silent) {
  let pos = state.pos;
  const max = state.posMax;
  if (state.src.charCodeAt(pos) !== 92)
    return false;
  pos++;
  if (pos >= max)
    return false;
  let ch1 = state.src.charCodeAt(pos);
  if (ch1 === 10) {
    if (!silent) {
      state.push("hardbreak", "br", 0);
    }
    pos++;
    while (pos < max) {
      ch1 = state.src.charCodeAt(pos);
      if (!isSpace(ch1))
        break;
      pos++;
    }
    state.pos = pos;
    return true;
  }
  let escapedStr = state.src[pos];
  if (ch1 >= 55296 && ch1 <= 56319 && pos + 1 < max) {
    const ch2 = state.src.charCodeAt(pos + 1);
    if (ch2 >= 56320 && ch2 <= 57343) {
      escapedStr += state.src[pos + 1];
      pos++;
    }
  }
  const origStr = "\\" + escapedStr;
  if (!silent) {
    const token = state.push("text_special", "", 0);
    if (ch1 < 256 && ESCAPED[ch1] !== 0) {
      token.content = escapedStr;
    } else {
      token.content = origStr;
    }
    token.markup = origStr;
    token.info = "escape";
  }
  state.pos = pos + 1;
  return true;
}

// node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/rules_inline/backticks.mjs
function backtick(state, silent) {
  let pos = state.pos;
  const ch = state.src.charCodeAt(pos);
  if (ch !== 96) {
    return false;
  }
  const start = pos;
  pos++;
  const max = state.posMax;
  while (pos < max && state.src.charCodeAt(pos) === 96) {
    pos++;
  }
  const marker = state.src.slice(start, pos);
  const openerLength = marker.length;
  if (state.backticksScanned && (state.backticks[openerLength] || 0) <= start) {
    if (!silent)
      state.pending += marker;
    state.pos += openerLength;
    return true;
  }
  let matchEnd = pos;
  let matchStart;
  while ((matchStart = state.src.indexOf("`", matchEnd)) !== -1) {
    matchEnd = matchStart + 1;
    while (matchEnd < max && state.src.charCodeAt(matchEnd) === 96) {
      matchEnd++;
    }
    const closerLength = matchEnd - matchStart;
    if (closerLength === openerLength) {
      if (!silent) {
        const token = state.push("code_inline", "code", 0);
        token.markup = marker;
        token.content = state.src.slice(pos, matchStart).replace(/\n/g, " ").replace(/^ (.+) $/, "$1");
      }
      state.pos = matchEnd;
      return true;
    }
    state.backticks[closerLength] = matchStart;
  }
  state.backticksScanned = true;
  if (!silent)
    state.pending += marker;
  state.pos += openerLength;
  return true;
}

// node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/rules_inline/strikethrough.mjs
function strikethrough_tokenize(state, silent) {
  const start = state.pos;
  const marker = state.src.charCodeAt(start);
  if (silent) {
    return false;
  }
  if (marker !== 126) {
    return false;
  }
  const scanned = state.scanDelims(state.pos, true);
  let len = scanned.length;
  const ch = String.fromCharCode(marker);
  if (len < 2) {
    return false;
  }
  let token;
  if (len % 2) {
    token = state.push("text", "", 0);
    token.content = ch;
    len--;
  }
  for (let i = 0; i < len; i += 2) {
    token = state.push("text", "", 0);
    token.content = ch + ch;
    state.delimiters.push({
      marker,
      length: 0,
      // disable "rule of 3" length checks meant for emphasis
      token: state.tokens.length - 1,
      end: -1,
      open: scanned.can_open,
      close: scanned.can_close
    });
  }
  state.pos += scanned.length;
  return true;
}
function postProcess(state, delimiters) {
  let token;
  const loneMarkers = [];
  const max = delimiters.length;
  for (let i = 0; i < max; i++) {
    const startDelim = delimiters[i];
    if (startDelim.marker !== 126) {
      continue;
    }
    if (startDelim.end === -1) {
      continue;
    }
    const endDelim = delimiters[startDelim.end];
    token = state.tokens[startDelim.token];
    token.type = "s_open";
    token.tag = "s";
    token.nesting = 1;
    token.markup = "~~";
    token.content = "";
    token = state.tokens[endDelim.token];
    token.type = "s_close";
    token.tag = "s";
    token.nesting = -1;
    token.markup = "~~";
    token.content = "";
    if (state.tokens[endDelim.token - 1].type === "text" && state.tokens[endDelim.token - 1].content === "~") {
      loneMarkers.push(endDelim.token - 1);
    }
  }
  while (loneMarkers.length) {
    const i = loneMarkers.pop();
    let j = i + 1;
    while (j < state.tokens.length && state.tokens[j].type === "s_close") {
      j++;
    }
    j--;
    if (i !== j) {
      token = state.tokens[j];
      state.tokens[j] = state.tokens[i];
      state.tokens[i] = token;
    }
  }
}
function strikethrough_postProcess(state) {
  const tokens_meta = state.tokens_meta;
  const max = state.tokens_meta.length;
  postProcess(state, state.delimiters);
  for (let curr = 0; curr < max; curr++) {
    if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
      postProcess(state, tokens_meta[curr].delimiters);
    }
  }
}
var strikethrough_default = {
  tokenize: strikethrough_tokenize,
  postProcess: strikethrough_postProcess
};

// node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/rules_inline/emphasis.mjs
function emphasis_tokenize(state, silent) {
  const start = state.pos;
  const marker = state.src.charCodeAt(start);
  if (silent) {
    return false;
  }
  if (marker !== 95 && marker !== 42) {
    return false;
  }
  const scanned = state.scanDelims(state.pos, marker === 42);
  for (let i = 0; i < scanned.length; i++) {
    const token = state.push("text", "", 0);
    token.content = String.fromCharCode(marker);
    state.delimiters.push({
      // Char code of the starting marker (number).
      //
      marker,
      // Total length of these series of delimiters.
      //
      length: scanned.length,
      // A position of the token this delimiter corresponds to.
      //
      token: state.tokens.length - 1,
      // If this delimiter is matched as a valid opener, `end` will be
      // equal to its position, otherwise it's `-1`.
      //
      end: -1,
      // Boolean flags that determine if this delimiter could open or close
      // an emphasis.
      //
      open: scanned.can_open,
      close: scanned.can_close
    });
  }
  state.pos += scanned.length;
  return true;
}
function postProcess2(state, delimiters) {
  const max = delimiters.length;
  for (let i = max - 1; i >= 0; i--) {
    const startDelim = delimiters[i];
    if (startDelim.marker !== 95 && startDelim.marker !== 42) {
      continue;
    }
    if (startDelim.end === -1) {
      continue;
    }
    const endDelim = delimiters[startDelim.end];
    const isStrong = i > 0 && delimiters[i - 1].end === startDelim.end + 1 && // check that first two markers match and adjacent
    delimiters[i - 1].marker === startDelim.marker && delimiters[i - 1].token === startDelim.token - 1 && // check that last two markers are adjacent (we can safely assume they match)
    delimiters[startDelim.end + 1].token === endDelim.token + 1;
    const ch = String.fromCharCode(startDelim.marker);
    const token_o = state.tokens[startDelim.token];
    token_o.type = isStrong ? "strong_open" : "em_open";
    token_o.tag = isStrong ? "strong" : "em";
    token_o.nesting = 1;
    token_o.markup = isStrong ? ch + ch : ch;
    token_o.content = "";
    const token_c = state.tokens[endDelim.token];
    token_c.type = isStrong ? "strong_close" : "em_close";
    token_c.tag = isStrong ? "strong" : "em";
    token_c.nesting = -1;
    token_c.markup = isStrong ? ch + ch : ch;
    token_c.content = "";
    if (isStrong) {
      state.tokens[delimiters[i - 1].token].content = "";
      state.tokens[delimiters[startDelim.end + 1].token].content = "";
      i--;
    }
  }
}
function emphasis_post_process(state) {
  const tokens_meta = state.tokens_meta;
  const max = state.tokens_meta.length;
  postProcess2(state, state.delimiters);
  for (let curr = 0; curr < max; curr++) {
    if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
      postProcess2(state, tokens_meta[curr].delimiters);
    }
  }
}
var emphasis_default = {
  tokenize: emphasis_tokenize,
  postProcess: emphasis_post_process
};

// node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/rules_inline/link.mjs
function link(state, silent) {
  let code2, label, res, ref;
  let href = "";
  let title = "";
  let start = state.pos;
  let parseReference = true;
  if (state.src.charCodeAt(state.pos) !== 91) {
    return false;
  }
  const oldPos = state.pos;
  const max = state.posMax;
  const labelStart = state.pos + 1;
  const labelEnd = state.md.helpers.parseLinkLabel(state, state.pos, true);
  if (labelEnd < 0) {
    return false;
  }
  let pos = labelEnd + 1;
  if (pos < max && state.src.charCodeAt(pos) === 40) {
    parseReference = false;
    pos++;
    for (; pos < max; pos++) {
      code2 = state.src.charCodeAt(pos);
      if (!isSpace(code2) && code2 !== 10) {
        break;
      }
    }
    if (pos >= max) {
      return false;
    }
    start = pos;
    res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);
    if (res.ok) {
      href = state.md.normalizeLink(res.str);
      if (state.md.validateLink(href)) {
        pos = res.pos;
      } else {
        href = "";
      }
      start = pos;
      for (; pos < max; pos++) {
        code2 = state.src.charCodeAt(pos);
        if (!isSpace(code2) && code2 !== 10) {
          break;
        }
      }
      res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);
      if (pos < max && start !== pos && res.ok) {
        title = res.str;
        pos = res.pos;
        for (; pos < max; pos++) {
          code2 = state.src.charCodeAt(pos);
          if (!isSpace(code2) && code2 !== 10) {
            break;
          }
        }
      }
    }
    if (pos >= max || state.src.charCodeAt(pos) !== 41) {
      parseReference = true;
    }
    pos++;
  }
  if (parseReference) {
    if (typeof state.env.references === "undefined") {
      return false;
    }
    if (pos < max && state.src.charCodeAt(pos) === 91) {
      start = pos + 1;
      pos = state.md.helpers.parseLinkLabel(state, pos);
      if (pos >= 0) {
        label = state.src.slice(start, pos++);
      } else {
        pos = labelEnd + 1;
      }
    } else {
      pos = labelEnd + 1;
    }
    if (!label) {
      label = state.src.slice(labelStart, labelEnd);
    }
    ref = state.env.references[normalizeReference(label)];
    if (!ref) {
      state.pos = oldPos;
      return false;
    }
    href = ref.href;
    title = ref.title;
  }
  if (!silent) {
    state.pos = labelStart;
    state.posMax = labelEnd;
    const token_o = state.push("link_open", "a", 1);
    const attrs = [["href", href]];
    token_o.attrs = attrs;
    if (title) {
      attrs.push(["title", title]);
    }
    state.linkLevel++;
    state.md.inline.tokenize(state);
    state.linkLevel--;
    state.push("link_close", "a", -1);
  }
  state.pos = pos;
  state.posMax = max;
  return true;
}

// node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/rules_inline/image.mjs
function image(state, silent) {
  let code2, content, label, pos, ref, res, title, start;
  let href = "";
  const oldPos = state.pos;
  const max = state.posMax;
  if (state.src.charCodeAt(state.pos) !== 33) {
    return false;
  }
  if (state.src.charCodeAt(state.pos + 1) !== 91) {
    return false;
  }
  const labelStart = state.pos + 2;
  const labelEnd = state.md.helpers.parseLinkLabel(state, state.pos + 1, false);
  if (labelEnd < 0) {
    return false;
  }
  pos = labelEnd + 1;
  if (pos < max && state.src.charCodeAt(pos) === 40) {
    pos++;
    for (; pos < max; pos++) {
      code2 = state.src.charCodeAt(pos);
      if (!isSpace(code2) && code2 !== 10) {
        break;
      }
    }
    if (pos >= max) {
      return false;
    }
    start = pos;
    res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);
    if (res.ok) {
      href = state.md.normalizeLink(res.str);
      if (state.md.validateLink(href)) {
        pos = res.pos;
      } else {
        href = "";
      }
    }
    start = pos;
    for (; pos < max; pos++) {
      code2 = state.src.charCodeAt(pos);
      if (!isSpace(code2) && code2 !== 10) {
        break;
      }
    }
    res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);
    if (pos < max && start !== pos && res.ok) {
      title = res.str;
      pos = res.pos;
      for (; pos < max; pos++) {
        code2 = state.src.charCodeAt(pos);
        if (!isSpace(code2) && code2 !== 10) {
          break;
        }
      }
    } else {
      title = "";
    }
    if (pos >= max || state.src.charCodeAt(pos) !== 41) {
      state.pos = oldPos;
      return false;
    }
    pos++;
  } else {
    if (typeof state.env.references === "undefined") {
      return false;
    }
    if (pos < max && state.src.charCodeAt(pos) === 91) {
      start = pos + 1;
      pos = state.md.helpers.parseLinkLabel(state, pos);
      if (pos >= 0) {
        label = state.src.slice(start, pos++);
      } else {
        pos = labelEnd + 1;
      }
    } else {
      pos = labelEnd + 1;
    }
    if (!label) {
      label = state.src.slice(labelStart, labelEnd);
    }
    ref = state.env.references[normalizeReference(label)];
    if (!ref) {
      state.pos = oldPos;
      return false;
    }
    href = ref.href;
    title = ref.title;
  }
  if (!silent) {
    content = state.src.slice(labelStart, labelEnd);
    const tokens = [];
    state.md.inline.parse(
      content,
      state.md,
      state.env,
      tokens
    );
    const token = state.push("image", "img", 0);
    const attrs = [["src", href], ["alt", ""]];
    token.attrs = attrs;
    token.children = tokens;
    token.content = content;
    if (title) {
      attrs.push(["title", title]);
    }
  }
  state.pos = pos;
  state.posMax = max;
  return true;
}

// node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/rules_inline/autolink.mjs
var EMAIL_RE = /^([a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)$/;
var AUTOLINK_RE = /^([a-zA-Z][a-zA-Z0-9+.-]{1,31}):([^<>\x00-\x20]*)$/;
function autolink(state, silent) {
  let pos = state.pos;
  if (state.src.charCodeAt(pos) !== 60) {
    return false;
  }
  const start = state.pos;
  const max = state.posMax;
  for (; ; ) {
    if (++pos >= max)
      return false;
    const ch = state.src.charCodeAt(pos);
    if (ch === 60)
      return false;
    if (ch === 62)
      break;
  }
  const url = state.src.slice(start + 1, pos);
  if (AUTOLINK_RE.test(url)) {
    const fullUrl = state.md.normalizeLink(url);
    if (!state.md.validateLink(fullUrl)) {
      return false;
    }
    if (!silent) {
      const token_o = state.push("link_open", "a", 1);
      token_o.attrs = [["href", fullUrl]];
      token_o.markup = "autolink";
      token_o.info = "auto";
      const token_t = state.push("text", "", 0);
      token_t.content = state.md.normalizeLinkText(url);
      const token_c = state.push("link_close", "a", -1);
      token_c.markup = "autolink";
      token_c.info = "auto";
    }
    state.pos += url.length + 2;
    return true;
  }
  if (EMAIL_RE.test(url)) {
    const fullUrl = state.md.normalizeLink("mailto:" + url);
    if (!state.md.validateLink(fullUrl)) {
      return false;
    }
    if (!silent) {
      const token_o = state.push("link_open", "a", 1);
      token_o.attrs = [["href", fullUrl]];
      token_o.markup = "autolink";
      token_o.info = "auto";
      const token_t = state.push("text", "", 0);
      token_t.content = state.md.normalizeLinkText(url);
      const token_c = state.push("link_close", "a", -1);
      token_c.markup = "autolink";
      token_c.info = "auto";
    }
    state.pos += url.length + 2;
    return true;
  }
  return false;
}

// node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/rules_inline/html_inline.mjs
function isLinkOpen2(str2) {
  return /^<a[>\s]/i.test(str2);
}
function isLinkClose2(str2) {
  return /^<\/a\s*>/i.test(str2);
}
function isLetter(ch) {
  const lc = ch | 32;
  return lc >= 97 && lc <= 122;
}
function html_inline(state, silent) {
  if (!state.md.options.html) {
    return false;
  }
  const max = state.posMax;
  const pos = state.pos;
  if (state.src.charCodeAt(pos) !== 60 || pos + 2 >= max) {
    return false;
  }
  const ch = state.src.charCodeAt(pos + 1);
  if (ch !== 33 && ch !== 63 && ch !== 47 && !isLetter(ch)) {
    return false;
  }
  const match2 = state.src.slice(pos).match(HTML_TAG_RE);
  if (!match2) {
    return false;
  }
  if (!silent) {
    const token = state.push("html_inline", "", 0);
    token.content = match2[0];
    if (isLinkOpen2(token.content))
      state.linkLevel++;
    if (isLinkClose2(token.content))
      state.linkLevel--;
  }
  state.pos += match2[0].length;
  return true;
}

// node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/rules_inline/entity.mjs
var DIGITAL_RE = /^&#((?:x[a-f0-9]{1,6}|[0-9]{1,7}));/i;
var NAMED_RE = /^&([a-z][a-z0-9]{1,31});/i;
function entity(state, silent) {
  const pos = state.pos;
  const max = state.posMax;
  if (state.src.charCodeAt(pos) !== 38)
    return false;
  if (pos + 1 >= max)
    return false;
  const ch = state.src.charCodeAt(pos + 1);
  if (ch === 35) {
    const match2 = state.src.slice(pos).match(DIGITAL_RE);
    if (match2) {
      if (!silent) {
        const code2 = match2[1][0].toLowerCase() === "x" ? parseInt(match2[1].slice(1), 16) : parseInt(match2[1], 10);
        const token = state.push("text_special", "", 0);
        token.content = isValidEntityCode(code2) ? fromCodePoint2(code2) : fromCodePoint2(65533);
        token.markup = match2[0];
        token.info = "entity";
      }
      state.pos += match2[0].length;
      return true;
    }
  } else {
    const match2 = state.src.slice(pos).match(NAMED_RE);
    if (match2) {
      const decoded = decodeHTML(match2[0]);
      if (decoded !== match2[0]) {
        if (!silent) {
          const token = state.push("text_special", "", 0);
          token.content = decoded;
          token.markup = match2[0];
          token.info = "entity";
        }
        state.pos += match2[0].length;
        return true;
      }
    }
  }
  return false;
}

// node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/rules_inline/balance_pairs.mjs
function processDelimiters(delimiters) {
  const openersBottom = {};
  const max = delimiters.length;
  if (!max)
    return;
  let headerIdx = 0;
  let lastTokenIdx = -2;
  const jumps = [];
  for (let closerIdx = 0; closerIdx < max; closerIdx++) {
    const closer = delimiters[closerIdx];
    jumps.push(0);
    if (delimiters[headerIdx].marker !== closer.marker || lastTokenIdx !== closer.token - 1) {
      headerIdx = closerIdx;
    }
    lastTokenIdx = closer.token;
    closer.length = closer.length || 0;
    if (!closer.close)
      continue;
    if (!openersBottom.hasOwnProperty(closer.marker)) {
      openersBottom[closer.marker] = [-1, -1, -1, -1, -1, -1];
    }
    const minOpenerIdx = openersBottom[closer.marker][(closer.open ? 3 : 0) + closer.length % 3];
    let openerIdx = headerIdx - jumps[headerIdx] - 1;
    let newMinOpenerIdx = openerIdx;
    for (; openerIdx > minOpenerIdx; openerIdx -= jumps[openerIdx] + 1) {
      const opener = delimiters[openerIdx];
      if (opener.marker !== closer.marker)
        continue;
      if (opener.open && opener.end < 0) {
        let isOddMatch = false;
        if (opener.close || closer.open) {
          if ((opener.length + closer.length) % 3 === 0) {
            if (opener.length % 3 !== 0 || closer.length % 3 !== 0) {
              isOddMatch = true;
            }
          }
        }
        if (!isOddMatch) {
          const lastJump = openerIdx > 0 && !delimiters[openerIdx - 1].open ? jumps[openerIdx - 1] + 1 : 0;
          jumps[closerIdx] = closerIdx - openerIdx + lastJump;
          jumps[openerIdx] = lastJump;
          closer.open = false;
          opener.end = closerIdx;
          opener.close = false;
          newMinOpenerIdx = -1;
          lastTokenIdx = -2;
          break;
        }
      }
    }
    if (newMinOpenerIdx !== -1) {
      openersBottom[closer.marker][(closer.open ? 3 : 0) + (closer.length || 0) % 3] = newMinOpenerIdx;
    }
  }
}
function link_pairs(state) {
  const tokens_meta = state.tokens_meta;
  const max = state.tokens_meta.length;
  processDelimiters(state.delimiters);
  for (let curr = 0; curr < max; curr++) {
    if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
      processDelimiters(tokens_meta[curr].delimiters);
    }
  }
}

// node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/rules_inline/fragments_join.mjs
function fragments_join(state) {
  let curr, last2;
  let level = 0;
  const tokens = state.tokens;
  const max = state.tokens.length;
  for (curr = last2 = 0; curr < max; curr++) {
    if (tokens[curr].nesting < 0)
      level--;
    tokens[curr].level = level;
    if (tokens[curr].nesting > 0)
      level++;
    if (tokens[curr].type === "text" && curr + 1 < max && tokens[curr + 1].type === "text") {
      tokens[curr + 1].content = tokens[curr].content + tokens[curr + 1].content;
    } else {
      if (curr !== last2) {
        tokens[last2] = tokens[curr];
      }
      last2++;
    }
  }
  if (curr !== last2) {
    tokens.length = last2;
  }
}

// node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/parser_inline.mjs
var _rules3 = [
  ["text", text3],
  ["linkify", linkify2],
  ["newline", newline],
  ["escape", escape2],
  ["backticks", backtick],
  ["strikethrough", strikethrough_default.tokenize],
  ["emphasis", emphasis_default.tokenize],
  ["link", link],
  ["image", image],
  ["autolink", autolink],
  ["html_inline", html_inline],
  ["entity", entity]
];
var _rules22 = [
  ["balance_pairs", link_pairs],
  ["strikethrough", strikethrough_default.postProcess],
  ["emphasis", emphasis_default.postProcess],
  // rules for pairs separate '**' into its own text tokens, which may be left unused,
  // rule below merges unused segments back with the rest of the text
  ["fragments_join", fragments_join]
];
function ParserInline() {
  this.ruler = new ruler_default();
  for (let i = 0; i < _rules3.length; i++) {
    this.ruler.push(_rules3[i][0], _rules3[i][1]);
  }
  this.ruler2 = new ruler_default();
  for (let i = 0; i < _rules22.length; i++) {
    this.ruler2.push(_rules22[i][0], _rules22[i][1]);
  }
}
ParserInline.prototype.skipToken = function(state) {
  const pos = state.pos;
  const rules = this.ruler.getRules("");
  const len = rules.length;
  const maxNesting = state.md.options.maxNesting;
  const cache = state.cache;
  if (typeof cache[pos] !== "undefined") {
    state.pos = cache[pos];
    return;
  }
  let ok = false;
  if (state.level < maxNesting) {
    for (let i = 0; i < len; i++) {
      state.level++;
      ok = rules[i](state, true);
      state.level--;
      if (ok) {
        if (pos >= state.pos) {
          throw new Error("inline rule didn't increment state.pos");
        }
        break;
      }
    }
  } else {
    state.pos = state.posMax;
  }
  if (!ok) {
    state.pos++;
  }
  cache[pos] = state.pos;
};
ParserInline.prototype.tokenize = function(state) {
  const rules = this.ruler.getRules("");
  const len = rules.length;
  const end2 = state.posMax;
  const maxNesting = state.md.options.maxNesting;
  while (state.pos < end2) {
    const prevPos = state.pos;
    let ok = false;
    if (state.level < maxNesting) {
      for (let i = 0; i < len; i++) {
        ok = rules[i](state, false);
        if (ok) {
          if (prevPos >= state.pos) {
            throw new Error("inline rule didn't increment state.pos");
          }
          break;
        }
      }
    }
    if (ok) {
      if (state.pos >= end2) {
        break;
      }
      continue;
    }
    state.pending += state.src[state.pos++];
  }
  if (state.pending) {
    state.pushPending();
  }
};
ParserInline.prototype.parse = function(str2, md, env, outTokens) {
  const state = new this.State(str2, md, env, outTokens);
  this.tokenize(state);
  const rules = this.ruler2.getRules("");
  const len = rules.length;
  for (let i = 0; i < len; i++) {
    rules[i](state);
  }
};
ParserInline.prototype.State = state_inline_default;
var parser_inline_default = ParserInline;

// node_modules/.pnpm/linkify-it@5.0.0/node_modules/linkify-it/lib/re.mjs
function re_default(opts) {
  const re = {};
  opts = opts || {};
  re.src_Any = regex_default.source;
  re.src_Cc = regex_default2.source;
  re.src_Z = regex_default6.source;
  re.src_P = regex_default4.source;
  re.src_ZPCc = [re.src_Z, re.src_P, re.src_Cc].join("|");
  re.src_ZCc = [re.src_Z, re.src_Cc].join("|");
  const text_separators = "[><｜]";
  re.src_pseudo_letter = "(?:(?!" + text_separators + "|" + re.src_ZPCc + ")" + re.src_Any + ")";
  re.src_ip4 = "(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)";
  re.src_auth = "(?:(?:(?!" + re.src_ZCc + "|[@/\\[\\]()]).)+@)?";
  re.src_port = "(?::(?:6(?:[0-4]\\d{3}|5(?:[0-4]\\d{2}|5(?:[0-2]\\d|3[0-5])))|[1-5]?\\d{1,4}))?";
  re.src_host_terminator = "(?=$|" + text_separators + "|" + re.src_ZPCc + ")(?!" + (opts["---"] ? "-(?!--)|" : "-|") + "_|:\\d|\\.-|\\.(?!$|" + re.src_ZPCc + "))";
  re.src_path = "(?:[/?#](?:(?!" + re.src_ZCc + "|" + text_separators + `|[()[\\]{}.,"'?!\\-;]).|\\[(?:(?!` + re.src_ZCc + "|\\]).)*\\]|\\((?:(?!" + re.src_ZCc + "|[)]).)*\\)|\\{(?:(?!" + re.src_ZCc + '|[}]).)*\\}|\\"(?:(?!' + re.src_ZCc + `|["]).)+\\"|\\'(?:(?!` + re.src_ZCc + "|[']).)+\\'|\\'(?=" + re.src_pseudo_letter + "|[-])|\\.{2,}[a-zA-Z0-9%/&]|\\.(?!" + re.src_ZCc + "|[.]|$)|" + (opts["---"] ? "\\-(?!--(?:[^-]|$))(?:-*)|" : "\\-+|") + // allow `,,,` in paths
  ",(?!" + re.src_ZCc + "|$)|;(?!" + re.src_ZCc + "|$)|\\!+(?!" + re.src_ZCc + "|[!]|$)|\\?(?!" + re.src_ZCc + "|[?]|$))+|\\/)?";
  re.src_email_name = '[\\-;:&=\\+\\$,\\.a-zA-Z0-9_][\\-;:&=\\+\\$,\\"\\.a-zA-Z0-9_]*';
  re.src_xn = "xn--[a-z0-9\\-]{1,59}";
  re.src_domain_root = // Allow letters & digits (http://test1)
  "(?:" + re.src_xn + "|" + re.src_pseudo_letter + "{1,63})";
  re.src_domain = "(?:" + re.src_xn + "|(?:" + re.src_pseudo_letter + ")|(?:" + re.src_pseudo_letter + "(?:-|" + re.src_pseudo_letter + "){0,61}" + re.src_pseudo_letter + "))";
  re.src_host = "(?:(?:(?:(?:" + re.src_domain + ")\\.)*" + re.src_domain + "))";
  re.tpl_host_fuzzy = "(?:" + re.src_ip4 + "|(?:(?:(?:" + re.src_domain + ")\\.)+(?:%TLDS%)))";
  re.tpl_host_no_ip_fuzzy = "(?:(?:(?:" + re.src_domain + ")\\.)+(?:%TLDS%))";
  re.src_host_strict = re.src_host + re.src_host_terminator;
  re.tpl_host_fuzzy_strict = re.tpl_host_fuzzy + re.src_host_terminator;
  re.src_host_port_strict = re.src_host + re.src_port + re.src_host_terminator;
  re.tpl_host_port_fuzzy_strict = re.tpl_host_fuzzy + re.src_port + re.src_host_terminator;
  re.tpl_host_port_no_ip_fuzzy_strict = re.tpl_host_no_ip_fuzzy + re.src_port + re.src_host_terminator;
  re.tpl_host_fuzzy_test = "localhost|www\\.|\\.\\d{1,3}\\.|(?:\\.(?:%TLDS%)(?:" + re.src_ZPCc + "|>|$))";
  re.tpl_email_fuzzy = "(^|" + text_separators + '|"|\\(|' + re.src_ZCc + ")(" + re.src_email_name + "@" + re.tpl_host_fuzzy_strict + ")";
  re.tpl_link_fuzzy = // Fuzzy link can't be prepended with .:/\- and non punctuation.
  // but can start with > (markdown blockquote)
  "(^|(?![.:/\\-_@])(?:[$+<=>^`|｜]|" + re.src_ZPCc + "))((?![$+<=>^`|｜])" + re.tpl_host_port_fuzzy_strict + re.src_path + ")";
  re.tpl_link_no_ip_fuzzy = // Fuzzy link can't be prepended with .:/\- and non punctuation.
  // but can start with > (markdown blockquote)
  "(^|(?![.:/\\-_@])(?:[$+<=>^`|｜]|" + re.src_ZPCc + "))((?![$+<=>^`|｜])" + re.tpl_host_port_no_ip_fuzzy_strict + re.src_path + ")";
  return re;
}

// node_modules/.pnpm/linkify-it@5.0.0/node_modules/linkify-it/index.mjs
function assign2(obj) {
  const sources = Array.prototype.slice.call(arguments, 1);
  sources.forEach(function(source) {
    if (!source) {
      return;
    }
    Object.keys(source).forEach(function(key) {
      obj[key] = source[key];
    });
  });
  return obj;
}
function _class2(obj) {
  return Object.prototype.toString.call(obj);
}
function isString2(obj) {
  return _class2(obj) === "[object String]";
}
function isObject(obj) {
  return _class2(obj) === "[object Object]";
}
function isRegExp(obj) {
  return _class2(obj) === "[object RegExp]";
}
function isFunction(obj) {
  return _class2(obj) === "[object Function]";
}
function escapeRE2(str2) {
  return str2.replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&");
}
var defaultOptions3 = {
  fuzzyLink: true,
  fuzzyEmail: true,
  fuzzyIP: false
};
function isOptionsObj(obj) {
  return Object.keys(obj || {}).reduce(function(acc, k) {
    return acc || defaultOptions3.hasOwnProperty(k);
  }, false);
}
var defaultSchemas = {
  "http:": {
    validate: function(text4, pos, self2) {
      const tail = text4.slice(pos);
      if (!self2.re.http) {
        self2.re.http = new RegExp(
          "^\\/\\/" + self2.re.src_auth + self2.re.src_host_port_strict + self2.re.src_path,
          "i"
        );
      }
      if (self2.re.http.test(tail)) {
        return tail.match(self2.re.http)[0].length;
      }
      return 0;
    }
  },
  "https:": "http:",
  "ftp:": "http:",
  "//": {
    validate: function(text4, pos, self2) {
      const tail = text4.slice(pos);
      if (!self2.re.no_http) {
        self2.re.no_http = new RegExp(
          "^" + self2.re.src_auth + // Don't allow single-level domains, because of false positives like '//test'
          // with code comments
          "(?:localhost|(?:(?:" + self2.re.src_domain + ")\\.)+" + self2.re.src_domain_root + ")" + self2.re.src_port + self2.re.src_host_terminator + self2.re.src_path,
          "i"
        );
      }
      if (self2.re.no_http.test(tail)) {
        if (pos >= 3 && text4[pos - 3] === ":") {
          return 0;
        }
        if (pos >= 3 && text4[pos - 3] === "/") {
          return 0;
        }
        return tail.match(self2.re.no_http)[0].length;
      }
      return 0;
    }
  },
  "mailto:": {
    validate: function(text4, pos, self2) {
      const tail = text4.slice(pos);
      if (!self2.re.mailto) {
        self2.re.mailto = new RegExp(
          "^" + self2.re.src_email_name + "@" + self2.re.src_host_strict,
          "i"
        );
      }
      if (self2.re.mailto.test(tail)) {
        return tail.match(self2.re.mailto)[0].length;
      }
      return 0;
    }
  }
};
var tlds_2ch_src_re = "a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]";
var tlds_default = "biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|рф".split("|");
function resetScanCache(self2) {
  self2.__index__ = -1;
  self2.__text_cache__ = "";
}
function createValidator(re) {
  return function(text4, pos) {
    const tail = text4.slice(pos);
    if (re.test(tail)) {
      return tail.match(re)[0].length;
    }
    return 0;
  };
}
function createNormalizer() {
  return function(match2, self2) {
    self2.normalize(match2);
  };
}
function compile4(self2) {
  const re = self2.re = re_default(self2.__opts__);
  const tlds2 = self2.__tlds__.slice();
  self2.onCompile();
  if (!self2.__tlds_replaced__) {
    tlds2.push(tlds_2ch_src_re);
  }
  tlds2.push(re.src_xn);
  re.src_tlds = tlds2.join("|");
  function untpl(tpl) {
    return tpl.replace("%TLDS%", re.src_tlds);
  }
  re.email_fuzzy = RegExp(untpl(re.tpl_email_fuzzy), "i");
  re.link_fuzzy = RegExp(untpl(re.tpl_link_fuzzy), "i");
  re.link_no_ip_fuzzy = RegExp(untpl(re.tpl_link_no_ip_fuzzy), "i");
  re.host_fuzzy_test = RegExp(untpl(re.tpl_host_fuzzy_test), "i");
  const aliases2 = [];
  self2.__compiled__ = {};
  function schemaError(name2, val2) {
    throw new Error('(LinkifyIt) Invalid schema "' + name2 + '": ' + val2);
  }
  Object.keys(self2.__schemas__).forEach(function(name2) {
    const val2 = self2.__schemas__[name2];
    if (val2 === null) {
      return;
    }
    const compiled = { validate: null, link: null };
    self2.__compiled__[name2] = compiled;
    if (isObject(val2)) {
      if (isRegExp(val2.validate)) {
        compiled.validate = createValidator(val2.validate);
      } else if (isFunction(val2.validate)) {
        compiled.validate = val2.validate;
      } else {
        schemaError(name2, val2);
      }
      if (isFunction(val2.normalize)) {
        compiled.normalize = val2.normalize;
      } else if (!val2.normalize) {
        compiled.normalize = createNormalizer();
      } else {
        schemaError(name2, val2);
      }
      return;
    }
    if (isString2(val2)) {
      aliases2.push(name2);
      return;
    }
    schemaError(name2, val2);
  });
  aliases2.forEach(function(alias) {
    if (!self2.__compiled__[self2.__schemas__[alias]]) {
      return;
    }
    self2.__compiled__[alias].validate = self2.__compiled__[self2.__schemas__[alias]].validate;
    self2.__compiled__[alias].normalize = self2.__compiled__[self2.__schemas__[alias]].normalize;
  });
  self2.__compiled__[""] = { validate: null, normalize: createNormalizer() };
  const slist = Object.keys(self2.__compiled__).filter(function(name2) {
    return name2.length > 0 && self2.__compiled__[name2];
  }).map(escapeRE2).join("|");
  self2.re.schema_test = RegExp("(^|(?!_)(?:[><｜]|" + re.src_ZPCc + "))(" + slist + ")", "i");
  self2.re.schema_search = RegExp("(^|(?!_)(?:[><｜]|" + re.src_ZPCc + "))(" + slist + ")", "ig");
  self2.re.schema_at_start = RegExp("^" + self2.re.schema_search.source, "i");
  self2.re.pretest = RegExp(
    "(" + self2.re.schema_test.source + ")|(" + self2.re.host_fuzzy_test.source + ")|@",
    "i"
  );
  resetScanCache(self2);
}
function Match(self2, shift) {
  const start = self2.__index__;
  const end2 = self2.__last_index__;
  const text4 = self2.__text_cache__.slice(start, end2);
  this.schema = self2.__schema__.toLowerCase();
  this.index = start + shift;
  this.lastIndex = end2 + shift;
  this.raw = text4;
  this.text = text4;
  this.url = text4;
}
function createMatch(self2, shift) {
  const match2 = new Match(self2, shift);
  self2.__compiled__[match2.schema].normalize(match2, self2);
  return match2;
}
function LinkifyIt(schemas, options) {
  if (!(this instanceof LinkifyIt)) {
    return new LinkifyIt(schemas, options);
  }
  if (!options) {
    if (isOptionsObj(schemas)) {
      options = schemas;
      schemas = {};
    }
  }
  this.__opts__ = assign2({}, defaultOptions3, options);
  this.__index__ = -1;
  this.__last_index__ = -1;
  this.__schema__ = "";
  this.__text_cache__ = "";
  this.__schemas__ = assign2({}, defaultSchemas, schemas);
  this.__compiled__ = {};
  this.__tlds__ = tlds_default;
  this.__tlds_replaced__ = false;
  this.re = {};
  compile4(this);
}
LinkifyIt.prototype.add = function add2(schema2, definition) {
  this.__schemas__[schema2] = definition;
  compile4(this);
  return this;
};
LinkifyIt.prototype.set = function set(options) {
  this.__opts__ = assign2(this.__opts__, options);
  return this;
};
LinkifyIt.prototype.test = function test(text4) {
  this.__text_cache__ = text4;
  this.__index__ = -1;
  if (!text4.length) {
    return false;
  }
  let m, ml, me, len, shift, next2, re, tld_pos, at_pos;
  if (this.re.schema_test.test(text4)) {
    re = this.re.schema_search;
    re.lastIndex = 0;
    while ((m = re.exec(text4)) !== null) {
      len = this.testSchemaAt(text4, m[2], re.lastIndex);
      if (len) {
        this.__schema__ = m[2];
        this.__index__ = m.index + m[1].length;
        this.__last_index__ = m.index + m[0].length + len;
        break;
      }
    }
  }
  if (this.__opts__.fuzzyLink && this.__compiled__["http:"]) {
    tld_pos = text4.search(this.re.host_fuzzy_test);
    if (tld_pos >= 0) {
      if (this.__index__ < 0 || tld_pos < this.__index__) {
        if ((ml = text4.match(this.__opts__.fuzzyIP ? this.re.link_fuzzy : this.re.link_no_ip_fuzzy)) !== null) {
          shift = ml.index + ml[1].length;
          if (this.__index__ < 0 || shift < this.__index__) {
            this.__schema__ = "";
            this.__index__ = shift;
            this.__last_index__ = ml.index + ml[0].length;
          }
        }
      }
    }
  }
  if (this.__opts__.fuzzyEmail && this.__compiled__["mailto:"]) {
    at_pos = text4.indexOf("@");
    if (at_pos >= 0) {
      if ((me = text4.match(this.re.email_fuzzy)) !== null) {
        shift = me.index + me[1].length;
        next2 = me.index + me[0].length;
        if (this.__index__ < 0 || shift < this.__index__ || shift === this.__index__ && next2 > this.__last_index__) {
          this.__schema__ = "mailto:";
          this.__index__ = shift;
          this.__last_index__ = next2;
        }
      }
    }
  }
  return this.__index__ >= 0;
};
LinkifyIt.prototype.pretest = function pretest(text4) {
  return this.re.pretest.test(text4);
};
LinkifyIt.prototype.testSchemaAt = function testSchemaAt(text4, schema2, pos) {
  if (!this.__compiled__[schema2.toLowerCase()]) {
    return 0;
  }
  return this.__compiled__[schema2.toLowerCase()].validate(text4, pos, this);
};
LinkifyIt.prototype.match = function match(text4) {
  const result = [];
  let shift = 0;
  if (this.__index__ >= 0 && this.__text_cache__ === text4) {
    result.push(createMatch(this, shift));
    shift = this.__last_index__;
  }
  let tail = shift ? text4.slice(shift) : text4;
  while (this.test(tail)) {
    result.push(createMatch(this, shift));
    tail = tail.slice(this.__last_index__);
    shift += this.__last_index__;
  }
  if (result.length) {
    return result;
  }
  return null;
};
LinkifyIt.prototype.matchAtStart = function matchAtStart(text4) {
  this.__text_cache__ = text4;
  this.__index__ = -1;
  if (!text4.length)
    return null;
  const m = this.re.schema_at_start.exec(text4);
  if (!m)
    return null;
  const len = this.testSchemaAt(text4, m[2], m[0].length);
  if (!len)
    return null;
  this.__schema__ = m[2];
  this.__index__ = m.index + m[1].length;
  this.__last_index__ = m.index + m[0].length + len;
  return createMatch(this, 0);
};
LinkifyIt.prototype.tlds = function tlds(list2, keepOld) {
  list2 = Array.isArray(list2) ? list2 : [list2];
  if (!keepOld) {
    this.__tlds__ = list2.slice();
    this.__tlds_replaced__ = true;
    compile4(this);
    return this;
  }
  this.__tlds__ = this.__tlds__.concat(list2).sort().filter(function(el, idx, arr) {
    return el !== arr[idx - 1];
  }).reverse();
  compile4(this);
  return this;
};
LinkifyIt.prototype.normalize = function normalize2(match2) {
  if (!match2.schema) {
    match2.url = "http://" + match2.url;
  }
  if (match2.schema === "mailto:" && !/^mailto:/i.test(match2.url)) {
    match2.url = "mailto:" + match2.url;
  }
};
LinkifyIt.prototype.onCompile = function onCompile() {
};
var linkify_it_default = LinkifyIt;

// node_modules/.pnpm/punycode.js@2.3.1/node_modules/punycode.js/punycode.es6.js
var maxInt = 2147483647;
var base = 36;
var tMin = 1;
var tMax = 26;
var skew = 38;
var damp = 700;
var initialBias = 72;
var initialN = 128;
var delimiter = "-";
var regexPunycode = /^xn--/;
var regexNonASCII = /[^\0-\x7F]/;
var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
var errors = {
  "overflow": "Overflow: input needs wider integers to process",
  "not-basic": "Illegal input >= 0x80 (not a basic code point)",
  "invalid-input": "Invalid input"
};
var baseMinusTMin = base - tMin;
var floor = Math.floor;
var stringFromCharCode = String.fromCharCode;
function error(type2) {
  throw new RangeError(errors[type2]);
}
function map2(array, callback) {
  const result = [];
  let length = array.length;
  while (length--) {
    result[length] = callback(array[length]);
  }
  return result;
}
function mapDomain(domain, callback) {
  const parts = domain.split("@");
  let result = "";
  if (parts.length > 1) {
    result = parts[0] + "@";
    domain = parts[1];
  }
  domain = domain.replace(regexSeparators, ".");
  const labels = domain.split(".");
  const encoded = map2(labels, callback).join(".");
  return result + encoded;
}
function ucs2decode(string) {
  const output = [];
  let counter = 0;
  const length = string.length;
  while (counter < length) {
    const value = string.charCodeAt(counter++);
    if (value >= 55296 && value <= 56319 && counter < length) {
      const extra = string.charCodeAt(counter++);
      if ((extra & 64512) == 56320) {
        output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
      } else {
        output.push(value);
        counter--;
      }
    } else {
      output.push(value);
    }
  }
  return output;
}
var ucs2encode = (codePoints) => String.fromCodePoint(...codePoints);
var basicToDigit = function(codePoint) {
  if (codePoint >= 48 && codePoint < 58) {
    return 26 + (codePoint - 48);
  }
  if (codePoint >= 65 && codePoint < 91) {
    return codePoint - 65;
  }
  if (codePoint >= 97 && codePoint < 123) {
    return codePoint - 97;
  }
  return base;
};
var digitToBasic = function(digit, flag) {
  return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
};
var adapt = function(delta, numPoints, firstTime) {
  let k = 0;
  delta = firstTime ? floor(delta / damp) : delta >> 1;
  delta += floor(delta / numPoints);
  for (; delta > baseMinusTMin * tMax >> 1; k += base) {
    delta = floor(delta / baseMinusTMin);
  }
  return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
};
var decode2 = function(input) {
  const output = [];
  const inputLength = input.length;
  let i = 0;
  let n = initialN;
  let bias = initialBias;
  let basic = input.lastIndexOf(delimiter);
  if (basic < 0) {
    basic = 0;
  }
  for (let j = 0; j < basic; ++j) {
    if (input.charCodeAt(j) >= 128) {
      error("not-basic");
    }
    output.push(input.charCodeAt(j));
  }
  for (let index2 = basic > 0 ? basic + 1 : 0; index2 < inputLength; ) {
    const oldi = i;
    for (let w = 1, k = base; ; k += base) {
      if (index2 >= inputLength) {
        error("invalid-input");
      }
      const digit = basicToDigit(input.charCodeAt(index2++));
      if (digit >= base) {
        error("invalid-input");
      }
      if (digit > floor((maxInt - i) / w)) {
        error("overflow");
      }
      i += digit * w;
      const t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
      if (digit < t) {
        break;
      }
      const baseMinusT = base - t;
      if (w > floor(maxInt / baseMinusT)) {
        error("overflow");
      }
      w *= baseMinusT;
    }
    const out = output.length + 1;
    bias = adapt(i - oldi, out, oldi == 0);
    if (floor(i / out) > maxInt - n) {
      error("overflow");
    }
    n += floor(i / out);
    i %= out;
    output.splice(i++, 0, n);
  }
  return String.fromCodePoint(...output);
};
var encode2 = function(input) {
  const output = [];
  input = ucs2decode(input);
  const inputLength = input.length;
  let n = initialN;
  let delta = 0;
  let bias = initialBias;
  for (const currentValue of input) {
    if (currentValue < 128) {
      output.push(stringFromCharCode(currentValue));
    }
  }
  const basicLength = output.length;
  let handledCPCount = basicLength;
  if (basicLength) {
    output.push(delimiter);
  }
  while (handledCPCount < inputLength) {
    let m = maxInt;
    for (const currentValue of input) {
      if (currentValue >= n && currentValue < m) {
        m = currentValue;
      }
    }
    const handledCPCountPlusOne = handledCPCount + 1;
    if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
      error("overflow");
    }
    delta += (m - n) * handledCPCountPlusOne;
    n = m;
    for (const currentValue of input) {
      if (currentValue < n && ++delta > maxInt) {
        error("overflow");
      }
      if (currentValue === n) {
        let q = delta;
        for (let k = base; ; k += base) {
          const t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
          if (q < t) {
            break;
          }
          const qMinusT = q - t;
          const baseMinusT = base - t;
          output.push(
            stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
          );
          q = floor(qMinusT / baseMinusT);
        }
        output.push(stringFromCharCode(digitToBasic(q, 0)));
        bias = adapt(delta, handledCPCountPlusOne, handledCPCount === basicLength);
        delta = 0;
        ++handledCPCount;
      }
    }
    ++delta;
    ++n;
  }
  return output.join("");
};
var toUnicode = function(input) {
  return mapDomain(input, function(string) {
    return regexPunycode.test(string) ? decode2(string.slice(4).toLowerCase()) : string;
  });
};
var toASCII = function(input) {
  return mapDomain(input, function(string) {
    return regexNonASCII.test(string) ? "xn--" + encode2(string) : string;
  });
};
var punycode = {
  /**
   * A string representing the current Punycode.js version number.
   * @memberOf punycode
   * @type String
   */
  "version": "2.3.1",
  /**
   * An object of methods to convert from JavaScript's internal character
   * representation (UCS-2) to Unicode code points, and back.
   * @see <https://mathiasbynens.be/notes/javascript-encoding>
   * @memberOf punycode
   * @type Object
   */
  "ucs2": {
    "decode": ucs2decode,
    "encode": ucs2encode
  },
  "decode": decode2,
  "encode": encode2,
  "toASCII": toASCII,
  "toUnicode": toUnicode
};
var punycode_es6_default = punycode;

// node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/presets/default.mjs
var default_default = {
  options: {
    // Enable HTML tags in source
    html: false,
    // Use '/' to close single tags (<br />)
    xhtmlOut: false,
    // Convert '\n' in paragraphs into <br>
    breaks: false,
    // CSS language prefix for fenced blocks
    langPrefix: "language-",
    // autoconvert URL-like texts to links
    linkify: false,
    // Enable some language-neutral replacements + quotes beautification
    typographer: false,
    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
    // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
    quotes: "“”‘’",
    /* “”‘’ */
    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,
    // Internal protection, recursion limit
    maxNesting: 100
  },
  components: {
    core: {},
    block: {},
    inline: {}
  }
};

// node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/presets/zero.mjs
var zero_default = {
  options: {
    // Enable HTML tags in source
    html: false,
    // Use '/' to close single tags (<br />)
    xhtmlOut: false,
    // Convert '\n' in paragraphs into <br>
    breaks: false,
    // CSS language prefix for fenced blocks
    langPrefix: "language-",
    // autoconvert URL-like texts to links
    linkify: false,
    // Enable some language-neutral replacements + quotes beautification
    typographer: false,
    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
    // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
    quotes: "“”‘’",
    /* “”‘’ */
    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,
    // Internal protection, recursion limit
    maxNesting: 20
  },
  components: {
    core: {
      rules: [
        "normalize",
        "block",
        "inline",
        "text_join"
      ]
    },
    block: {
      rules: [
        "paragraph"
      ]
    },
    inline: {
      rules: [
        "text"
      ],
      rules2: [
        "balance_pairs",
        "fragments_join"
      ]
    }
  }
};

// node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/presets/commonmark.mjs
var commonmark_default = {
  options: {
    // Enable HTML tags in source
    html: true,
    // Use '/' to close single tags (<br />)
    xhtmlOut: true,
    // Convert '\n' in paragraphs into <br>
    breaks: false,
    // CSS language prefix for fenced blocks
    langPrefix: "language-",
    // autoconvert URL-like texts to links
    linkify: false,
    // Enable some language-neutral replacements + quotes beautification
    typographer: false,
    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
    // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
    quotes: "“”‘’",
    /* “”‘’ */
    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,
    // Internal protection, recursion limit
    maxNesting: 20
  },
  components: {
    core: {
      rules: [
        "normalize",
        "block",
        "inline",
        "text_join"
      ]
    },
    block: {
      rules: [
        "blockquote",
        "code",
        "fence",
        "heading",
        "hr",
        "html_block",
        "lheading",
        "list",
        "reference",
        "paragraph"
      ]
    },
    inline: {
      rules: [
        "autolink",
        "backticks",
        "emphasis",
        "entity",
        "escape",
        "html_inline",
        "image",
        "link",
        "newline",
        "text"
      ],
      rules2: [
        "balance_pairs",
        "emphasis",
        "fragments_join"
      ]
    }
  }
};

// node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/index.mjs
var config = {
  default: default_default,
  zero: zero_default,
  commonmark: commonmark_default
};
var BAD_PROTO_RE = /^(vbscript|javascript|file|data):/;
var GOOD_DATA_RE = /^data:image\/(gif|png|jpeg|webp);/;
function validateLink(url) {
  const str2 = url.trim().toLowerCase();
  return BAD_PROTO_RE.test(str2) ? GOOD_DATA_RE.test(str2) : true;
}
var RECODE_HOSTNAME_FOR = ["http:", "https:", "mailto:"];
function normalizeLink(url) {
  const parsed = parse_default(url, true);
  if (parsed.hostname) {
    if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
      try {
        parsed.hostname = punycode_es6_default.toASCII(parsed.hostname);
      } catch (er) {
      }
    }
  }
  return encode_default(format(parsed));
}
function normalizeLinkText(url) {
  const parsed = parse_default(url, true);
  if (parsed.hostname) {
    if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
      try {
        parsed.hostname = punycode_es6_default.toUnicode(parsed.hostname);
      } catch (er) {
      }
    }
  }
  return decode_default(format(parsed), decode_default.defaultChars + "%");
}
function MarkdownIt(presetName, options) {
  if (!(this instanceof MarkdownIt)) {
    return new MarkdownIt(presetName, options);
  }
  if (!options) {
    if (!isString(presetName)) {
      options = presetName || {};
      presetName = "default";
    }
  }
  this.inline = new parser_inline_default();
  this.block = new parser_block_default();
  this.core = new parser_core_default();
  this.renderer = new renderer_default();
  this.linkify = new linkify_it_default();
  this.validateLink = validateLink;
  this.normalizeLink = normalizeLink;
  this.normalizeLinkText = normalizeLinkText;
  this.utils = utils_exports;
  this.helpers = assign({}, helpers_exports);
  this.options = {};
  this.configure(presetName);
  if (options) {
    this.set(options);
  }
}
MarkdownIt.prototype.set = function(options) {
  assign(this.options, options);
  return this;
};
MarkdownIt.prototype.configure = function(presets) {
  const self2 = this;
  if (isString(presets)) {
    const presetName = presets;
    presets = config[presetName];
    if (!presets) {
      throw new Error('Wrong `markdown-it` preset "' + presetName + '", check name');
    }
  }
  if (!presets) {
    throw new Error("Wrong `markdown-it` preset, can't be empty");
  }
  if (presets.options) {
    self2.set(presets.options);
  }
  if (presets.components) {
    Object.keys(presets.components).forEach(function(name2) {
      if (presets.components[name2].rules) {
        self2[name2].ruler.enableOnly(presets.components[name2].rules);
      }
      if (presets.components[name2].rules2) {
        self2[name2].ruler2.enableOnly(presets.components[name2].rules2);
      }
    });
  }
  return this;
};
MarkdownIt.prototype.enable = function(list2, ignoreInvalid) {
  let result = [];
  if (!Array.isArray(list2)) {
    list2 = [list2];
  }
  ["core", "block", "inline"].forEach(function(chain) {
    result = result.concat(this[chain].ruler.enable(list2, true));
  }, this);
  result = result.concat(this.inline.ruler2.enable(list2, true));
  const missed = list2.filter(function(name2) {
    return result.indexOf(name2) < 0;
  });
  if (missed.length && !ignoreInvalid) {
    throw new Error("MarkdownIt. Failed to enable unknown rule(s): " + missed);
  }
  return this;
};
MarkdownIt.prototype.disable = function(list2, ignoreInvalid) {
  let result = [];
  if (!Array.isArray(list2)) {
    list2 = [list2];
  }
  ["core", "block", "inline"].forEach(function(chain) {
    result = result.concat(this[chain].ruler.disable(list2, true));
  }, this);
  result = result.concat(this.inline.ruler2.disable(list2, true));
  const missed = list2.filter(function(name2) {
    return result.indexOf(name2) < 0;
  });
  if (missed.length && !ignoreInvalid) {
    throw new Error("MarkdownIt. Failed to disable unknown rule(s): " + missed);
  }
  return this;
};
MarkdownIt.prototype.use = function(plugin2) {
  const args = [this].concat(Array.prototype.slice.call(arguments, 1));
  plugin2.apply(plugin2, args);
  return this;
};
MarkdownIt.prototype.parse = function(src, env) {
  if (typeof src !== "string") {
    throw new Error("Input data should be a String");
  }
  const state = new this.core.State(src, this, env);
  this.core.process(state);
  return state.tokens;
};
MarkdownIt.prototype.render = function(src, env) {
  env = env || {};
  return this.renderer.render(this.parse(src, env), this.options, env);
};
MarkdownIt.prototype.parseInline = function(src, env) {
  const state = new this.core.State(src, this, env);
  state.inlineMode = true;
  this.core.process(state);
  return state.tokens;
};
MarkdownIt.prototype.renderInline = function(src, env) {
  env = env || {};
  return this.renderer.render(this.parseInline(src, env), this.options, env);
};
var lib_default = MarkdownIt;

// node_modules/.pnpm/markdown-it-ins@4.0.0/node_modules/markdown-it-ins/index.mjs
function ins_plugin(md) {
  function tokenize(state, silent) {
    const start = state.pos;
    const marker = state.src.charCodeAt(start);
    if (silent) {
      return false;
    }
    if (marker !== 43) {
      return false;
    }
    const scanned = state.scanDelims(state.pos, true);
    let len = scanned.length;
    const ch = String.fromCharCode(marker);
    if (len < 2) {
      return false;
    }
    if (len % 2) {
      const token = state.push("text", "", 0);
      token.content = ch;
      len--;
    }
    for (let i = 0; i < len; i += 2) {
      const token = state.push("text", "", 0);
      token.content = ch + ch;
      if (!scanned.can_open && !scanned.can_close) {
        continue;
      }
      state.delimiters.push({
        marker,
        length: 0,
        // disable "rule of 3" length checks meant for emphasis
        jump: i / 2,
        // 1 delimiter = 2 characters
        token: state.tokens.length - 1,
        end: -1,
        open: scanned.can_open,
        close: scanned.can_close
      });
    }
    state.pos += scanned.length;
    return true;
  }
  function postProcess3(state, delimiters) {
    let token;
    const loneMarkers = [];
    const max = delimiters.length;
    for (let i = 0; i < max; i++) {
      const startDelim = delimiters[i];
      if (startDelim.marker !== 43) {
        continue;
      }
      if (startDelim.end === -1) {
        continue;
      }
      const endDelim = delimiters[startDelim.end];
      token = state.tokens[startDelim.token];
      token.type = "ins_open";
      token.tag = "ins";
      token.nesting = 1;
      token.markup = "++";
      token.content = "";
      token = state.tokens[endDelim.token];
      token.type = "ins_close";
      token.tag = "ins";
      token.nesting = -1;
      token.markup = "++";
      token.content = "";
      if (state.tokens[endDelim.token - 1].type === "text" && state.tokens[endDelim.token - 1].content === "+") {
        loneMarkers.push(endDelim.token - 1);
      }
    }
    while (loneMarkers.length) {
      const i = loneMarkers.pop();
      let j = i + 1;
      while (j < state.tokens.length && state.tokens[j].type === "ins_close") {
        j++;
      }
      j--;
      if (i !== j) {
        token = state.tokens[j];
        state.tokens[j] = state.tokens[i];
        state.tokens[i] = token;
      }
    }
  }
  md.inline.ruler.before("emphasis", "ins", tokenize);
  md.inline.ruler2.before("emphasis", "ins", function(state) {
    const tokens_meta = state.tokens_meta;
    const max = (state.tokens_meta || []).length;
    postProcess3(state, state.delimiters);
    for (let curr = 0; curr < max; curr++) {
      if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
        postProcess3(state, tokens_meta[curr].delimiters);
      }
    }
  });
}

// node_modules/.pnpm/markdown-it-mark@4.0.0/node_modules/markdown-it-mark/index.mjs
function ins_plugin2(md) {
  function tokenize(state, silent) {
    const start = state.pos;
    const marker = state.src.charCodeAt(start);
    if (silent) {
      return false;
    }
    if (marker !== 61) {
      return false;
    }
    const scanned = state.scanDelims(state.pos, true);
    let len = scanned.length;
    const ch = String.fromCharCode(marker);
    if (len < 2) {
      return false;
    }
    if (len % 2) {
      const token = state.push("text", "", 0);
      token.content = ch;
      len--;
    }
    for (let i = 0; i < len; i += 2) {
      const token = state.push("text", "", 0);
      token.content = ch + ch;
      if (!scanned.can_open && !scanned.can_close) {
        continue;
      }
      state.delimiters.push({
        marker,
        length: 0,
        // disable "rule of 3" length checks meant for emphasis
        jump: i / 2,
        // 1 delimiter = 2 characters
        token: state.tokens.length - 1,
        end: -1,
        open: scanned.can_open,
        close: scanned.can_close
      });
    }
    state.pos += scanned.length;
    return true;
  }
  function postProcess3(state, delimiters) {
    const loneMarkers = [];
    const max = delimiters.length;
    for (let i = 0; i < max; i++) {
      const startDelim = delimiters[i];
      if (startDelim.marker !== 61) {
        continue;
      }
      if (startDelim.end === -1) {
        continue;
      }
      const endDelim = delimiters[startDelim.end];
      const token_o = state.tokens[startDelim.token];
      token_o.type = "mark_open";
      token_o.tag = "mark";
      token_o.nesting = 1;
      token_o.markup = "==";
      token_o.content = "";
      const token_c = state.tokens[endDelim.token];
      token_c.type = "mark_close";
      token_c.tag = "mark";
      token_c.nesting = -1;
      token_c.markup = "==";
      token_c.content = "";
      if (state.tokens[endDelim.token - 1].type === "text" && state.tokens[endDelim.token - 1].content === "=") {
        loneMarkers.push(endDelim.token - 1);
      }
    }
    while (loneMarkers.length) {
      const i = loneMarkers.pop();
      let j = i + 1;
      while (j < state.tokens.length && state.tokens[j].type === "mark_close") {
        j++;
      }
      j--;
      if (i !== j) {
        const token = state.tokens[j];
        state.tokens[j] = state.tokens[i];
        state.tokens[i] = token;
      }
    }
  }
  md.inline.ruler.before("emphasis", "mark", tokenize);
  md.inline.ruler2.before("emphasis", "mark", function(state) {
    let curr;
    const tokens_meta = state.tokens_meta;
    const max = (state.tokens_meta || []).length;
    postProcess3(state, state.delimiters);
    for (curr = 0; curr < max; curr++) {
      if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
        postProcess3(state, tokens_meta[curr].delimiters);
      }
    }
  });
}

// node_modules/.pnpm/markdown-it-sub@2.0.0/node_modules/markdown-it-sub/index.mjs
var UNESCAPE_RE = /\\([ \\!"#$%&'()*+,./:;<=>?@[\]^_`{|}~-])/g;
function subscript(state, silent) {
  const max = state.posMax;
  const start = state.pos;
  if (state.src.charCodeAt(start) !== 126) {
    return false;
  }
  if (silent) {
    return false;
  }
  if (start + 2 >= max) {
    return false;
  }
  state.pos = start + 1;
  let found = false;
  while (state.pos < max) {
    if (state.src.charCodeAt(state.pos) === 126) {
      found = true;
      break;
    }
    state.md.inline.skipToken(state);
  }
  if (!found || start + 1 === state.pos) {
    state.pos = start;
    return false;
  }
  const content = state.src.slice(start + 1, state.pos);
  if (content.match(/(^|[^\\])(\\\\)*\s/)) {
    state.pos = start;
    return false;
  }
  state.posMax = state.pos;
  state.pos = start + 1;
  const token_so = state.push("sub_open", "sub", 1);
  token_so.markup = "~";
  const token_t = state.push("text", "", 0);
  token_t.content = content.replace(UNESCAPE_RE, "$1");
  const token_sc = state.push("sub_close", "sub", -1);
  token_sc.markup = "~";
  state.pos = state.posMax + 1;
  state.posMax = max;
  return true;
}
function sub_plugin(md) {
  md.inline.ruler.after("emphasis", "sub", subscript);
}

// node_modules/.pnpm/markdown-it-sup@2.0.0/node_modules/markdown-it-sup/index.mjs
var UNESCAPE_RE2 = /\\([ \\!"#$%&'()*+,./:;<=>?@[\]^_`{|}~-])/g;
function superscript(state, silent) {
  const max = state.posMax;
  const start = state.pos;
  if (state.src.charCodeAt(start) !== 94) {
    return false;
  }
  if (silent) {
    return false;
  }
  if (start + 2 >= max) {
    return false;
  }
  state.pos = start + 1;
  let found = false;
  while (state.pos < max) {
    if (state.src.charCodeAt(state.pos) === 94) {
      found = true;
      break;
    }
    state.md.inline.skipToken(state);
  }
  if (!found || start + 1 === state.pos) {
    state.pos = start;
    return false;
  }
  const content = state.src.slice(start + 1, state.pos);
  if (content.match(/(^|[^\\])(\\\\)*\s/)) {
    state.pos = start;
    return false;
  }
  state.posMax = state.pos;
  state.pos = start + 1;
  const token_so = state.push("sup_open", "sup", 1);
  token_so.markup = "^";
  const token_t = state.push("text", "", 0);
  token_t.content = content.replace(UNESCAPE_RE2, "$1");
  const token_sc = state.push("sup_close", "sup", -1);
  token_sc.markup = "^";
  state.pos = state.posMax + 1;
  state.posMax = max;
  return true;
}
function sup_plugin(md) {
  md.inline.ruler.after("emphasis", "sup", superscript);
}

// node_modules/.pnpm/js-yaml@4.1.0/node_modules/js-yaml/dist/js-yaml.mjs
function isNothing(subject) {
  return typeof subject === "undefined" || subject === null;
}
function isObject2(subject) {
  return typeof subject === "object" && subject !== null;
}
function toArray2(sequence) {
  if (Array.isArray(sequence))
    return sequence;
  else if (isNothing(sequence))
    return [];
  return [sequence];
}
function extend(target, source) {
  var index2, length, key, sourceKeys;
  if (source) {
    sourceKeys = Object.keys(source);
    for (index2 = 0, length = sourceKeys.length; index2 < length; index2 += 1) {
      key = sourceKeys[index2];
      target[key] = source[key];
    }
  }
  return target;
}
function repeat(string, count) {
  var result = "", cycle;
  for (cycle = 0; cycle < count; cycle += 1) {
    result += string;
  }
  return result;
}
function isNegativeZero(number) {
  return number === 0 && Number.NEGATIVE_INFINITY === 1 / number;
}
var isNothing_1 = isNothing;
var isObject_1 = isObject2;
var toArray_1 = toArray2;
var repeat_1 = repeat;
var isNegativeZero_1 = isNegativeZero;
var extend_1 = extend;
var common = {
  isNothing: isNothing_1,
  isObject: isObject_1,
  toArray: toArray_1,
  repeat: repeat_1,
  isNegativeZero: isNegativeZero_1,
  extend: extend_1
};
function formatError(exception2, compact) {
  var where = "", message = exception2.reason || "(unknown reason)";
  if (!exception2.mark)
    return message;
  if (exception2.mark.name) {
    where += 'in "' + exception2.mark.name + '" ';
  }
  where += "(" + (exception2.mark.line + 1) + ":" + (exception2.mark.column + 1) + ")";
  if (!compact && exception2.mark.snippet) {
    where += "\n\n" + exception2.mark.snippet;
  }
  return message + " " + where;
}
function YAMLException$1(reason, mark) {
  Error.call(this);
  this.name = "YAMLException";
  this.reason = reason;
  this.mark = mark;
  this.message = formatError(this, false);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack || "";
  }
}
YAMLException$1.prototype = Object.create(Error.prototype);
YAMLException$1.prototype.constructor = YAMLException$1;
YAMLException$1.prototype.toString = function toString2(compact) {
  return this.name + ": " + formatError(this, compact);
};
var exception = YAMLException$1;
function getLine2(buffer, lineStart, lineEnd, position, maxLineLength) {
  var head = "";
  var tail = "";
  var maxHalfLength = Math.floor(maxLineLength / 2) - 1;
  if (position - lineStart > maxHalfLength) {
    head = " ... ";
    lineStart = position - maxHalfLength + head.length;
  }
  if (lineEnd - position > maxHalfLength) {
    tail = " ...";
    lineEnd = position + maxHalfLength - tail.length;
  }
  return {
    str: head + buffer.slice(lineStart, lineEnd).replace(/\t/g, "→") + tail,
    pos: position - lineStart + head.length
    // relative position
  };
}
function padStart(string, max) {
  return common.repeat(" ", max - string.length) + string;
}
function makeSnippet(mark, options) {
  options = Object.create(options || null);
  if (!mark.buffer)
    return null;
  if (!options.maxLength)
    options.maxLength = 79;
  if (typeof options.indent !== "number")
    options.indent = 1;
  if (typeof options.linesBefore !== "number")
    options.linesBefore = 3;
  if (typeof options.linesAfter !== "number")
    options.linesAfter = 2;
  var re = /\r?\n|\r|\0/g;
  var lineStarts = [0];
  var lineEnds = [];
  var match2;
  var foundLineNo = -1;
  while (match2 = re.exec(mark.buffer)) {
    lineEnds.push(match2.index);
    lineStarts.push(match2.index + match2[0].length);
    if (mark.position <= match2.index && foundLineNo < 0) {
      foundLineNo = lineStarts.length - 2;
    }
  }
  if (foundLineNo < 0)
    foundLineNo = lineStarts.length - 1;
  var result = "", i, line;
  var lineNoLength = Math.min(mark.line + options.linesAfter, lineEnds.length).toString().length;
  var maxLineLength = options.maxLength - (options.indent + lineNoLength + 3);
  for (i = 1; i <= options.linesBefore; i++) {
    if (foundLineNo - i < 0)
      break;
    line = getLine2(
      mark.buffer,
      lineStarts[foundLineNo - i],
      lineEnds[foundLineNo - i],
      mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo - i]),
      maxLineLength
    );
    result = common.repeat(" ", options.indent) + padStart((mark.line - i + 1).toString(), lineNoLength) + " | " + line.str + "\n" + result;
  }
  line = getLine2(mark.buffer, lineStarts[foundLineNo], lineEnds[foundLineNo], mark.position, maxLineLength);
  result += common.repeat(" ", options.indent) + padStart((mark.line + 1).toString(), lineNoLength) + " | " + line.str + "\n";
  result += common.repeat("-", options.indent + lineNoLength + 3 + line.pos) + "^\n";
  for (i = 1; i <= options.linesAfter; i++) {
    if (foundLineNo + i >= lineEnds.length)
      break;
    line = getLine2(
      mark.buffer,
      lineStarts[foundLineNo + i],
      lineEnds[foundLineNo + i],
      mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo + i]),
      maxLineLength
    );
    result += common.repeat(" ", options.indent) + padStart((mark.line + i + 1).toString(), lineNoLength) + " | " + line.str + "\n";
  }
  return result.replace(/\n$/, "");
}
var snippet = makeSnippet;
var TYPE_CONSTRUCTOR_OPTIONS = [
  "kind",
  "multi",
  "resolve",
  "construct",
  "instanceOf",
  "predicate",
  "represent",
  "representName",
  "defaultStyle",
  "styleAliases"
];
var YAML_NODE_KINDS = [
  "scalar",
  "sequence",
  "mapping"
];
function compileStyleAliases(map4) {
  var result = {};
  if (map4 !== null) {
    Object.keys(map4).forEach(function(style) {
      map4[style].forEach(function(alias) {
        result[String(alias)] = style;
      });
    });
  }
  return result;
}
function Type$1(tag, options) {
  options = options || {};
  Object.keys(options).forEach(function(name2) {
    if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name2) === -1) {
      throw new exception('Unknown option "' + name2 + '" is met in definition of "' + tag + '" YAML type.');
    }
  });
  this.options = options;
  this.tag = tag;
  this.kind = options["kind"] || null;
  this.resolve = options["resolve"] || function() {
    return true;
  };
  this.construct = options["construct"] || function(data2) {
    return data2;
  };
  this.instanceOf = options["instanceOf"] || null;
  this.predicate = options["predicate"] || null;
  this.represent = options["represent"] || null;
  this.representName = options["representName"] || null;
  this.defaultStyle = options["defaultStyle"] || null;
  this.multi = options["multi"] || false;
  this.styleAliases = compileStyleAliases(options["styleAliases"] || null);
  if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
    throw new exception('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
  }
}
var type = Type$1;
function compileList(schema2, name2) {
  var result = [];
  schema2[name2].forEach(function(currentType) {
    var newIndex = result.length;
    result.forEach(function(previousType, previousIndex) {
      if (previousType.tag === currentType.tag && previousType.kind === currentType.kind && previousType.multi === currentType.multi) {
        newIndex = previousIndex;
      }
    });
    result[newIndex] = currentType;
  });
  return result;
}
function compileMap() {
  var result = {
    scalar: {},
    sequence: {},
    mapping: {},
    fallback: {},
    multi: {
      scalar: [],
      sequence: [],
      mapping: [],
      fallback: []
    }
  }, index2, length;
  function collectType(type2) {
    if (type2.multi) {
      result.multi[type2.kind].push(type2);
      result.multi["fallback"].push(type2);
    } else {
      result[type2.kind][type2.tag] = result["fallback"][type2.tag] = type2;
    }
  }
  for (index2 = 0, length = arguments.length; index2 < length; index2 += 1) {
    arguments[index2].forEach(collectType);
  }
  return result;
}
function Schema$1(definition) {
  return this.extend(definition);
}
Schema$1.prototype.extend = function extend2(definition) {
  var implicit = [];
  var explicit = [];
  if (definition instanceof type) {
    explicit.push(definition);
  } else if (Array.isArray(definition)) {
    explicit = explicit.concat(definition);
  } else if (definition && (Array.isArray(definition.implicit) || Array.isArray(definition.explicit))) {
    if (definition.implicit)
      implicit = implicit.concat(definition.implicit);
    if (definition.explicit)
      explicit = explicit.concat(definition.explicit);
  } else {
    throw new exception("Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })");
  }
  implicit.forEach(function(type$1) {
    if (!(type$1 instanceof type)) {
      throw new exception("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    }
    if (type$1.loadKind && type$1.loadKind !== "scalar") {
      throw new exception("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
    }
    if (type$1.multi) {
      throw new exception("There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.");
    }
  });
  explicit.forEach(function(type$1) {
    if (!(type$1 instanceof type)) {
      throw new exception("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    }
  });
  var result = Object.create(Schema$1.prototype);
  result.implicit = (this.implicit || []).concat(implicit);
  result.explicit = (this.explicit || []).concat(explicit);
  result.compiledImplicit = compileList(result, "implicit");
  result.compiledExplicit = compileList(result, "explicit");
  result.compiledTypeMap = compileMap(result.compiledImplicit, result.compiledExplicit);
  return result;
};
var schema = Schema$1;
var str = new type("tag:yaml.org,2002:str", {
  kind: "scalar",
  construct: function(data2) {
    return data2 !== null ? data2 : "";
  }
});
var seq = new type("tag:yaml.org,2002:seq", {
  kind: "sequence",
  construct: function(data2) {
    return data2 !== null ? data2 : [];
  }
});
var map3 = new type("tag:yaml.org,2002:map", {
  kind: "mapping",
  construct: function(data2) {
    return data2 !== null ? data2 : {};
  }
});
var failsafe = new schema({
  explicit: [
    str,
    seq,
    map3
  ]
});
function resolveYamlNull(data2) {
  if (data2 === null)
    return true;
  var max = data2.length;
  return max === 1 && data2 === "~" || max === 4 && (data2 === "null" || data2 === "Null" || data2 === "NULL");
}
function constructYamlNull() {
  return null;
}
function isNull(object) {
  return object === null;
}
var _null = new type("tag:yaml.org,2002:null", {
  kind: "scalar",
  resolve: resolveYamlNull,
  construct: constructYamlNull,
  predicate: isNull,
  represent: {
    canonical: function() {
      return "~";
    },
    lowercase: function() {
      return "null";
    },
    uppercase: function() {
      return "NULL";
    },
    camelcase: function() {
      return "Null";
    },
    empty: function() {
      return "";
    }
  },
  defaultStyle: "lowercase"
});
function resolveYamlBoolean(data2) {
  if (data2 === null)
    return false;
  var max = data2.length;
  return max === 4 && (data2 === "true" || data2 === "True" || data2 === "TRUE") || max === 5 && (data2 === "false" || data2 === "False" || data2 === "FALSE");
}
function constructYamlBoolean(data2) {
  return data2 === "true" || data2 === "True" || data2 === "TRUE";
}
function isBoolean(object) {
  return Object.prototype.toString.call(object) === "[object Boolean]";
}
var bool = new type("tag:yaml.org,2002:bool", {
  kind: "scalar",
  resolve: resolveYamlBoolean,
  construct: constructYamlBoolean,
  predicate: isBoolean,
  represent: {
    lowercase: function(object) {
      return object ? "true" : "false";
    },
    uppercase: function(object) {
      return object ? "TRUE" : "FALSE";
    },
    camelcase: function(object) {
      return object ? "True" : "False";
    }
  },
  defaultStyle: "lowercase"
});
function isHexCode(c) {
  return 48 <= c && c <= 57 || 65 <= c && c <= 70 || 97 <= c && c <= 102;
}
function isOctCode(c) {
  return 48 <= c && c <= 55;
}
function isDecCode(c) {
  return 48 <= c && c <= 57;
}
function resolveYamlInteger(data2) {
  if (data2 === null)
    return false;
  var max = data2.length, index2 = 0, hasDigits = false, ch;
  if (!max)
    return false;
  ch = data2[index2];
  if (ch === "-" || ch === "+") {
    ch = data2[++index2];
  }
  if (ch === "0") {
    if (index2 + 1 === max)
      return true;
    ch = data2[++index2];
    if (ch === "b") {
      index2++;
      for (; index2 < max; index2++) {
        ch = data2[index2];
        if (ch === "_")
          continue;
        if (ch !== "0" && ch !== "1")
          return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
    if (ch === "x") {
      index2++;
      for (; index2 < max; index2++) {
        ch = data2[index2];
        if (ch === "_")
          continue;
        if (!isHexCode(data2.charCodeAt(index2)))
          return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
    if (ch === "o") {
      index2++;
      for (; index2 < max; index2++) {
        ch = data2[index2];
        if (ch === "_")
          continue;
        if (!isOctCode(data2.charCodeAt(index2)))
          return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
  }
  if (ch === "_")
    return false;
  for (; index2 < max; index2++) {
    ch = data2[index2];
    if (ch === "_")
      continue;
    if (!isDecCode(data2.charCodeAt(index2))) {
      return false;
    }
    hasDigits = true;
  }
  if (!hasDigits || ch === "_")
    return false;
  return true;
}
function constructYamlInteger(data2) {
  var value = data2, sign = 1, ch;
  if (value.indexOf("_") !== -1) {
    value = value.replace(/_/g, "");
  }
  ch = value[0];
  if (ch === "-" || ch === "+") {
    if (ch === "-")
      sign = -1;
    value = value.slice(1);
    ch = value[0];
  }
  if (value === "0")
    return 0;
  if (ch === "0") {
    if (value[1] === "b")
      return sign * parseInt(value.slice(2), 2);
    if (value[1] === "x")
      return sign * parseInt(value.slice(2), 16);
    if (value[1] === "o")
      return sign * parseInt(value.slice(2), 8);
  }
  return sign * parseInt(value, 10);
}
function isInteger(object) {
  return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 === 0 && !common.isNegativeZero(object));
}
var int = new type("tag:yaml.org,2002:int", {
  kind: "scalar",
  resolve: resolveYamlInteger,
  construct: constructYamlInteger,
  predicate: isInteger,
  represent: {
    binary: function(obj) {
      return obj >= 0 ? "0b" + obj.toString(2) : "-0b" + obj.toString(2).slice(1);
    },
    octal: function(obj) {
      return obj >= 0 ? "0o" + obj.toString(8) : "-0o" + obj.toString(8).slice(1);
    },
    decimal: function(obj) {
      return obj.toString(10);
    },
    /* eslint-disable max-len */
    hexadecimal: function(obj) {
      return obj >= 0 ? "0x" + obj.toString(16).toUpperCase() : "-0x" + obj.toString(16).toUpperCase().slice(1);
    }
  },
  defaultStyle: "decimal",
  styleAliases: {
    binary: [2, "bin"],
    octal: [8, "oct"],
    decimal: [10, "dec"],
    hexadecimal: [16, "hex"]
  }
});
var YAML_FLOAT_PATTERN = new RegExp(
  // 2.5e4, 2.5 and integers
  "^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"
);
function resolveYamlFloat(data2) {
  if (data2 === null)
    return false;
  if (!YAML_FLOAT_PATTERN.test(data2) || // Quick hack to not allow integers end with `_`
  // Probably should update regexp & check speed
  data2[data2.length - 1] === "_") {
    return false;
  }
  return true;
}
function constructYamlFloat(data2) {
  var value, sign;
  value = data2.replace(/_/g, "").toLowerCase();
  sign = value[0] === "-" ? -1 : 1;
  if ("+-".indexOf(value[0]) >= 0) {
    value = value.slice(1);
  }
  if (value === ".inf") {
    return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
  } else if (value === ".nan") {
    return NaN;
  }
  return sign * parseFloat(value, 10);
}
var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
function representYamlFloat(object, style) {
  var res;
  if (isNaN(object)) {
    switch (style) {
      case "lowercase":
        return ".nan";
      case "uppercase":
        return ".NAN";
      case "camelcase":
        return ".NaN";
    }
  } else if (Number.POSITIVE_INFINITY === object) {
    switch (style) {
      case "lowercase":
        return ".inf";
      case "uppercase":
        return ".INF";
      case "camelcase":
        return ".Inf";
    }
  } else if (Number.NEGATIVE_INFINITY === object) {
    switch (style) {
      case "lowercase":
        return "-.inf";
      case "uppercase":
        return "-.INF";
      case "camelcase":
        return "-.Inf";
    }
  } else if (common.isNegativeZero(object)) {
    return "-0.0";
  }
  res = object.toString(10);
  return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace("e", ".e") : res;
}
function isFloat(object) {
  return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 !== 0 || common.isNegativeZero(object));
}
var float = new type("tag:yaml.org,2002:float", {
  kind: "scalar",
  resolve: resolveYamlFloat,
  construct: constructYamlFloat,
  predicate: isFloat,
  represent: representYamlFloat,
  defaultStyle: "lowercase"
});
var json = failsafe.extend({
  implicit: [
    _null,
    bool,
    int,
    float
  ]
});
var core = json;
var YAML_DATE_REGEXP = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"
);
var YAML_TIMESTAMP_REGEXP = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$"
);
function resolveYamlTimestamp(data2) {
  if (data2 === null)
    return false;
  if (YAML_DATE_REGEXP.exec(data2) !== null)
    return true;
  if (YAML_TIMESTAMP_REGEXP.exec(data2) !== null)
    return true;
  return false;
}
function constructYamlTimestamp(data2) {
  var match2, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date;
  match2 = YAML_DATE_REGEXP.exec(data2);
  if (match2 === null)
    match2 = YAML_TIMESTAMP_REGEXP.exec(data2);
  if (match2 === null)
    throw new Error("Date resolve error");
  year = +match2[1];
  month = +match2[2] - 1;
  day = +match2[3];
  if (!match2[4]) {
    return new Date(Date.UTC(year, month, day));
  }
  hour = +match2[4];
  minute = +match2[5];
  second = +match2[6];
  if (match2[7]) {
    fraction = match2[7].slice(0, 3);
    while (fraction.length < 3) {
      fraction += "0";
    }
    fraction = +fraction;
  }
  if (match2[9]) {
    tz_hour = +match2[10];
    tz_minute = +(match2[11] || 0);
    delta = (tz_hour * 60 + tz_minute) * 6e4;
    if (match2[9] === "-")
      delta = -delta;
  }
  date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
  if (delta)
    date.setTime(date.getTime() - delta);
  return date;
}
function representYamlTimestamp(object) {
  return object.toISOString();
}
var timestamp = new type("tag:yaml.org,2002:timestamp", {
  kind: "scalar",
  resolve: resolveYamlTimestamp,
  construct: constructYamlTimestamp,
  instanceOf: Date,
  represent: representYamlTimestamp
});
function resolveYamlMerge(data2) {
  return data2 === "<<" || data2 === null;
}
var merge3 = new type("tag:yaml.org,2002:merge", {
  kind: "scalar",
  resolve: resolveYamlMerge
});
var BASE64_MAP = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r";
function resolveYamlBinary(data2) {
  if (data2 === null)
    return false;
  var code2, idx, bitlen = 0, max = data2.length, map4 = BASE64_MAP;
  for (idx = 0; idx < max; idx++) {
    code2 = map4.indexOf(data2.charAt(idx));
    if (code2 > 64)
      continue;
    if (code2 < 0)
      return false;
    bitlen += 6;
  }
  return bitlen % 8 === 0;
}
function constructYamlBinary(data2) {
  var idx, tailbits, input = data2.replace(/[\r\n=]/g, ""), max = input.length, map4 = BASE64_MAP, bits = 0, result = [];
  for (idx = 0; idx < max; idx++) {
    if (idx % 4 === 0 && idx) {
      result.push(bits >> 16 & 255);
      result.push(bits >> 8 & 255);
      result.push(bits & 255);
    }
    bits = bits << 6 | map4.indexOf(input.charAt(idx));
  }
  tailbits = max % 4 * 6;
  if (tailbits === 0) {
    result.push(bits >> 16 & 255);
    result.push(bits >> 8 & 255);
    result.push(bits & 255);
  } else if (tailbits === 18) {
    result.push(bits >> 10 & 255);
    result.push(bits >> 2 & 255);
  } else if (tailbits === 12) {
    result.push(bits >> 4 & 255);
  }
  return new Uint8Array(result);
}
function representYamlBinary(object) {
  var result = "", bits = 0, idx, tail, max = object.length, map4 = BASE64_MAP;
  for (idx = 0; idx < max; idx++) {
    if (idx % 3 === 0 && idx) {
      result += map4[bits >> 18 & 63];
      result += map4[bits >> 12 & 63];
      result += map4[bits >> 6 & 63];
      result += map4[bits & 63];
    }
    bits = (bits << 8) + object[idx];
  }
  tail = max % 3;
  if (tail === 0) {
    result += map4[bits >> 18 & 63];
    result += map4[bits >> 12 & 63];
    result += map4[bits >> 6 & 63];
    result += map4[bits & 63];
  } else if (tail === 2) {
    result += map4[bits >> 10 & 63];
    result += map4[bits >> 4 & 63];
    result += map4[bits << 2 & 63];
    result += map4[64];
  } else if (tail === 1) {
    result += map4[bits >> 2 & 63];
    result += map4[bits << 4 & 63];
    result += map4[64];
    result += map4[64];
  }
  return result;
}
function isBinary(obj) {
  return Object.prototype.toString.call(obj) === "[object Uint8Array]";
}
var binary = new type("tag:yaml.org,2002:binary", {
  kind: "scalar",
  resolve: resolveYamlBinary,
  construct: constructYamlBinary,
  predicate: isBinary,
  represent: representYamlBinary
});
var _hasOwnProperty$3 = Object.prototype.hasOwnProperty;
var _toString$2 = Object.prototype.toString;
function resolveYamlOmap(data2) {
  if (data2 === null)
    return true;
  var objectKeys = [], index2, length, pair, pairKey, pairHasKey, object = data2;
  for (index2 = 0, length = object.length; index2 < length; index2 += 1) {
    pair = object[index2];
    pairHasKey = false;
    if (_toString$2.call(pair) !== "[object Object]")
      return false;
    for (pairKey in pair) {
      if (_hasOwnProperty$3.call(pair, pairKey)) {
        if (!pairHasKey)
          pairHasKey = true;
        else
          return false;
      }
    }
    if (!pairHasKey)
      return false;
    if (objectKeys.indexOf(pairKey) === -1)
      objectKeys.push(pairKey);
    else
      return false;
  }
  return true;
}
function constructYamlOmap(data2) {
  return data2 !== null ? data2 : [];
}
var omap = new type("tag:yaml.org,2002:omap", {
  kind: "sequence",
  resolve: resolveYamlOmap,
  construct: constructYamlOmap
});
var _toString$1 = Object.prototype.toString;
function resolveYamlPairs(data2) {
  if (data2 === null)
    return true;
  var index2, length, pair, keys, result, object = data2;
  result = new Array(object.length);
  for (index2 = 0, length = object.length; index2 < length; index2 += 1) {
    pair = object[index2];
    if (_toString$1.call(pair) !== "[object Object]")
      return false;
    keys = Object.keys(pair);
    if (keys.length !== 1)
      return false;
    result[index2] = [keys[0], pair[keys[0]]];
  }
  return true;
}
function constructYamlPairs(data2) {
  if (data2 === null)
    return [];
  var index2, length, pair, keys, result, object = data2;
  result = new Array(object.length);
  for (index2 = 0, length = object.length; index2 < length; index2 += 1) {
    pair = object[index2];
    keys = Object.keys(pair);
    result[index2] = [keys[0], pair[keys[0]]];
  }
  return result;
}
var pairs = new type("tag:yaml.org,2002:pairs", {
  kind: "sequence",
  resolve: resolveYamlPairs,
  construct: constructYamlPairs
});
var _hasOwnProperty$2 = Object.prototype.hasOwnProperty;
function resolveYamlSet(data2) {
  if (data2 === null)
    return true;
  var key, object = data2;
  for (key in object) {
    if (_hasOwnProperty$2.call(object, key)) {
      if (object[key] !== null)
        return false;
    }
  }
  return true;
}
function constructYamlSet(data2) {
  return data2 !== null ? data2 : {};
}
var set2 = new type("tag:yaml.org,2002:set", {
  kind: "mapping",
  resolve: resolveYamlSet,
  construct: constructYamlSet
});
var _default = core.extend({
  implicit: [
    timestamp,
    merge3
  ],
  explicit: [
    binary,
    omap,
    pairs,
    set2
  ]
});
var _hasOwnProperty$1 = Object.prototype.hasOwnProperty;
var CONTEXT_FLOW_IN = 1;
var CONTEXT_FLOW_OUT = 2;
var CONTEXT_BLOCK_IN = 3;
var CONTEXT_BLOCK_OUT = 4;
var CHOMPING_CLIP = 1;
var CHOMPING_STRIP = 2;
var CHOMPING_KEEP = 3;
var PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
var PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
function _class3(obj) {
  return Object.prototype.toString.call(obj);
}
function is_EOL(c) {
  return c === 10 || c === 13;
}
function is_WHITE_SPACE(c) {
  return c === 9 || c === 32;
}
function is_WS_OR_EOL(c) {
  return c === 9 || c === 32 || c === 10 || c === 13;
}
function is_FLOW_INDICATOR(c) {
  return c === 44 || c === 91 || c === 93 || c === 123 || c === 125;
}
function fromHexCode(c) {
  var lc;
  if (48 <= c && c <= 57) {
    return c - 48;
  }
  lc = c | 32;
  if (97 <= lc && lc <= 102) {
    return lc - 97 + 10;
  }
  return -1;
}
function escapedHexLen(c) {
  if (c === 120) {
    return 2;
  }
  if (c === 117) {
    return 4;
  }
  if (c === 85) {
    return 8;
  }
  return 0;
}
function fromDecimalCode(c) {
  if (48 <= c && c <= 57) {
    return c - 48;
  }
  return -1;
}
function simpleEscapeSequence(c) {
  return c === 48 ? "\0" : c === 97 ? "\x07" : c === 98 ? "\b" : c === 116 ? "	" : c === 9 ? "	" : c === 110 ? "\n" : c === 118 ? "\v" : c === 102 ? "\f" : c === 114 ? "\r" : c === 101 ? "\x1B" : c === 32 ? " " : c === 34 ? '"' : c === 47 ? "/" : c === 92 ? "\\" : c === 78 ? "" : c === 95 ? " " : c === 76 ? "\u2028" : c === 80 ? "\u2029" : "";
}
function charFromCodepoint(c) {
  if (c <= 65535) {
    return String.fromCharCode(c);
  }
  return String.fromCharCode(
    (c - 65536 >> 10) + 55296,
    (c - 65536 & 1023) + 56320
  );
}
var simpleEscapeCheck = new Array(256);
var simpleEscapeMap = new Array(256);
for (i = 0; i < 256; i++) {
  simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
  simpleEscapeMap[i] = simpleEscapeSequence(i);
}
var i;
function State$1(input, options) {
  this.input = input;
  this.filename = options["filename"] || null;
  this.schema = options["schema"] || _default;
  this.onWarning = options["onWarning"] || null;
  this.legacy = options["legacy"] || false;
  this.json = options["json"] || false;
  this.listener = options["listener"] || null;
  this.implicitTypes = this.schema.compiledImplicit;
  this.typeMap = this.schema.compiledTypeMap;
  this.length = input.length;
  this.position = 0;
  this.line = 0;
  this.lineStart = 0;
  this.lineIndent = 0;
  this.firstTabInLine = -1;
  this.documents = [];
}
function generateError(state, message) {
  var mark = {
    name: state.filename,
    buffer: state.input.slice(0, -1),
    // omit trailing \0
    position: state.position,
    line: state.line,
    column: state.position - state.lineStart
  };
  mark.snippet = snippet(mark);
  return new exception(message, mark);
}
function throwError(state, message) {
  throw generateError(state, message);
}
function throwWarning(state, message) {
  if (state.onWarning) {
    state.onWarning.call(null, generateError(state, message));
  }
}
var directiveHandlers = {
  YAML: function handleYamlDirective(state, name2, args) {
    var match2, major, minor;
    if (state.version !== null) {
      throwError(state, "duplication of %YAML directive");
    }
    if (args.length !== 1) {
      throwError(state, "YAML directive accepts exactly one argument");
    }
    match2 = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);
    if (match2 === null) {
      throwError(state, "ill-formed argument of the YAML directive");
    }
    major = parseInt(match2[1], 10);
    minor = parseInt(match2[2], 10);
    if (major !== 1) {
      throwError(state, "unacceptable YAML version of the document");
    }
    state.version = args[0];
    state.checkLineBreaks = minor < 2;
    if (minor !== 1 && minor !== 2) {
      throwWarning(state, "unsupported YAML version of the document");
    }
  },
  TAG: function handleTagDirective(state, name2, args) {
    var handle, prefix;
    if (args.length !== 2) {
      throwError(state, "TAG directive accepts exactly two arguments");
    }
    handle = args[0];
    prefix = args[1];
    if (!PATTERN_TAG_HANDLE.test(handle)) {
      throwError(state, "ill-formed tag handle (first argument) of the TAG directive");
    }
    if (_hasOwnProperty$1.call(state.tagMap, handle)) {
      throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
    }
    if (!PATTERN_TAG_URI.test(prefix)) {
      throwError(state, "ill-formed tag prefix (second argument) of the TAG directive");
    }
    try {
      prefix = decodeURIComponent(prefix);
    } catch (err) {
      throwError(state, "tag prefix is malformed: " + prefix);
    }
    state.tagMap[handle] = prefix;
  }
};
function captureSegment(state, start, end2, checkJson) {
  var _position, _length, _character, _result;
  if (start < end2) {
    _result = state.input.slice(start, end2);
    if (checkJson) {
      for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
        _character = _result.charCodeAt(_position);
        if (!(_character === 9 || 32 <= _character && _character <= 1114111)) {
          throwError(state, "expected valid JSON character");
        }
      }
    } else if (PATTERN_NON_PRINTABLE.test(_result)) {
      throwError(state, "the stream contains non-printable characters");
    }
    state.result += _result;
  }
}
function mergeMappings(state, destination, source, overridableKeys) {
  var sourceKeys, key, index2, quantity;
  if (!common.isObject(source)) {
    throwError(state, "cannot merge mappings; the provided source object is unacceptable");
  }
  sourceKeys = Object.keys(source);
  for (index2 = 0, quantity = sourceKeys.length; index2 < quantity; index2 += 1) {
    key = sourceKeys[index2];
    if (!_hasOwnProperty$1.call(destination, key)) {
      destination[key] = source[key];
      overridableKeys[key] = true;
    }
  }
}
function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startLineStart, startPos) {
  var index2, quantity;
  if (Array.isArray(keyNode)) {
    keyNode = Array.prototype.slice.call(keyNode);
    for (index2 = 0, quantity = keyNode.length; index2 < quantity; index2 += 1) {
      if (Array.isArray(keyNode[index2])) {
        throwError(state, "nested arrays are not supported inside keys");
      }
      if (typeof keyNode === "object" && _class3(keyNode[index2]) === "[object Object]") {
        keyNode[index2] = "[object Object]";
      }
    }
  }
  if (typeof keyNode === "object" && _class3(keyNode) === "[object Object]") {
    keyNode = "[object Object]";
  }
  keyNode = String(keyNode);
  if (_result === null) {
    _result = {};
  }
  if (keyTag === "tag:yaml.org,2002:merge") {
    if (Array.isArray(valueNode)) {
      for (index2 = 0, quantity = valueNode.length; index2 < quantity; index2 += 1) {
        mergeMappings(state, _result, valueNode[index2], overridableKeys);
      }
    } else {
      mergeMappings(state, _result, valueNode, overridableKeys);
    }
  } else {
    if (!state.json && !_hasOwnProperty$1.call(overridableKeys, keyNode) && _hasOwnProperty$1.call(_result, keyNode)) {
      state.line = startLine || state.line;
      state.lineStart = startLineStart || state.lineStart;
      state.position = startPos || state.position;
      throwError(state, "duplicated mapping key");
    }
    if (keyNode === "__proto__") {
      Object.defineProperty(_result, keyNode, {
        configurable: true,
        enumerable: true,
        writable: true,
        value: valueNode
      });
    } else {
      _result[keyNode] = valueNode;
    }
    delete overridableKeys[keyNode];
  }
  return _result;
}
function readLineBreak(state) {
  var ch;
  ch = state.input.charCodeAt(state.position);
  if (ch === 10) {
    state.position++;
  } else if (ch === 13) {
    state.position++;
    if (state.input.charCodeAt(state.position) === 10) {
      state.position++;
    }
  } else {
    throwError(state, "a line break is expected");
  }
  state.line += 1;
  state.lineStart = state.position;
  state.firstTabInLine = -1;
}
function skipSeparationSpace(state, allowComments, checkIndent) {
  var lineBreaks = 0, ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    while (is_WHITE_SPACE(ch)) {
      if (ch === 9 && state.firstTabInLine === -1) {
        state.firstTabInLine = state.position;
      }
      ch = state.input.charCodeAt(++state.position);
    }
    if (allowComments && ch === 35) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (ch !== 10 && ch !== 13 && ch !== 0);
    }
    if (is_EOL(ch)) {
      readLineBreak(state);
      ch = state.input.charCodeAt(state.position);
      lineBreaks++;
      state.lineIndent = 0;
      while (ch === 32) {
        state.lineIndent++;
        ch = state.input.charCodeAt(++state.position);
      }
    } else {
      break;
    }
  }
  if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
    throwWarning(state, "deficient indentation");
  }
  return lineBreaks;
}
function testDocumentSeparator(state) {
  var _position = state.position, ch;
  ch = state.input.charCodeAt(_position);
  if ((ch === 45 || ch === 46) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2)) {
    _position += 3;
    ch = state.input.charCodeAt(_position);
    if (ch === 0 || is_WS_OR_EOL(ch)) {
      return true;
    }
  }
  return false;
}
function writeFoldedLines(state, count) {
  if (count === 1) {
    state.result += " ";
  } else if (count > 1) {
    state.result += common.repeat("\n", count - 1);
  }
}
function readPlainScalar(state, nodeIndent, withinFlowCollection) {
  var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state.kind, _result = state.result, ch;
  ch = state.input.charCodeAt(state.position);
  if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 35 || ch === 38 || ch === 42 || ch === 33 || ch === 124 || ch === 62 || ch === 39 || ch === 34 || ch === 37 || ch === 64 || ch === 96) {
    return false;
  }
  if (ch === 63 || ch === 45) {
    following = state.input.charCodeAt(state.position + 1);
    if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
      return false;
    }
  }
  state.kind = "scalar";
  state.result = "";
  captureStart = captureEnd = state.position;
  hasPendingContent = false;
  while (ch !== 0) {
    if (ch === 58) {
      following = state.input.charCodeAt(state.position + 1);
      if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
        break;
      }
    } else if (ch === 35) {
      preceding = state.input.charCodeAt(state.position - 1);
      if (is_WS_OR_EOL(preceding)) {
        break;
      }
    } else if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch)) {
      break;
    } else if (is_EOL(ch)) {
      _line = state.line;
      _lineStart = state.lineStart;
      _lineIndent = state.lineIndent;
      skipSeparationSpace(state, false, -1);
      if (state.lineIndent >= nodeIndent) {
        hasPendingContent = true;
        ch = state.input.charCodeAt(state.position);
        continue;
      } else {
        state.position = captureEnd;
        state.line = _line;
        state.lineStart = _lineStart;
        state.lineIndent = _lineIndent;
        break;
      }
    }
    if (hasPendingContent) {
      captureSegment(state, captureStart, captureEnd, false);
      writeFoldedLines(state, state.line - _line);
      captureStart = captureEnd = state.position;
      hasPendingContent = false;
    }
    if (!is_WHITE_SPACE(ch)) {
      captureEnd = state.position + 1;
    }
    ch = state.input.charCodeAt(++state.position);
  }
  captureSegment(state, captureStart, captureEnd, false);
  if (state.result) {
    return true;
  }
  state.kind = _kind;
  state.result = _result;
  return false;
}
function readSingleQuotedScalar(state, nodeIndent) {
  var ch, captureStart, captureEnd;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 39) {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  state.position++;
  captureStart = captureEnd = state.position;
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 39) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);
      if (ch === 39) {
        captureStart = state.position;
        state.position++;
        captureEnd = state.position;
      } else {
        return true;
      }
    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;
    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, "unexpected end of the document within a single quoted scalar");
    } else {
      state.position++;
      captureEnd = state.position;
    }
  }
  throwError(state, "unexpected end of the stream within a single quoted scalar");
}
function readDoubleQuotedScalar(state, nodeIndent) {
  var captureStart, captureEnd, hexLength, hexResult, tmp, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 34) {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  state.position++;
  captureStart = captureEnd = state.position;
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 34) {
      captureSegment(state, captureStart, state.position, true);
      state.position++;
      return true;
    } else if (ch === 92) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);
      if (is_EOL(ch)) {
        skipSeparationSpace(state, false, nodeIndent);
      } else if (ch < 256 && simpleEscapeCheck[ch]) {
        state.result += simpleEscapeMap[ch];
        state.position++;
      } else if ((tmp = escapedHexLen(ch)) > 0) {
        hexLength = tmp;
        hexResult = 0;
        for (; hexLength > 0; hexLength--) {
          ch = state.input.charCodeAt(++state.position);
          if ((tmp = fromHexCode(ch)) >= 0) {
            hexResult = (hexResult << 4) + tmp;
          } else {
            throwError(state, "expected hexadecimal character");
          }
        }
        state.result += charFromCodepoint(hexResult);
        state.position++;
      } else {
        throwError(state, "unknown escape sequence");
      }
      captureStart = captureEnd = state.position;
    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;
    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, "unexpected end of the document within a double quoted scalar");
    } else {
      state.position++;
      captureEnd = state.position;
    }
  }
  throwError(state, "unexpected end of the stream within a double quoted scalar");
}
function readFlowCollection(state, nodeIndent) {
  var readNext = true, _line, _lineStart, _pos, _tag = state.tag, _result, _anchor = state.anchor, following, terminator, isPair, isExplicitPair, isMapping, overridableKeys = /* @__PURE__ */ Object.create(null), keyNode, keyTag, valueNode, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch === 91) {
    terminator = 93;
    isMapping = false;
    _result = [];
  } else if (ch === 123) {
    terminator = 125;
    isMapping = true;
    _result = {};
  } else {
    return false;
  }
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch = state.input.charCodeAt(++state.position);
  while (ch !== 0) {
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if (ch === terminator) {
      state.position++;
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = isMapping ? "mapping" : "sequence";
      state.result = _result;
      return true;
    } else if (!readNext) {
      throwError(state, "missed comma between flow collection entries");
    } else if (ch === 44) {
      throwError(state, "expected the node content, but found ','");
    }
    keyTag = keyNode = valueNode = null;
    isPair = isExplicitPair = false;
    if (ch === 63) {
      following = state.input.charCodeAt(state.position + 1);
      if (is_WS_OR_EOL(following)) {
        isPair = isExplicitPair = true;
        state.position++;
        skipSeparationSpace(state, true, nodeIndent);
      }
    }
    _line = state.line;
    _lineStart = state.lineStart;
    _pos = state.position;
    composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
    keyTag = state.tag;
    keyNode = state.result;
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if ((isExplicitPair || state.line === _line) && ch === 58) {
      isPair = true;
      ch = state.input.charCodeAt(++state.position);
      skipSeparationSpace(state, true, nodeIndent);
      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
      valueNode = state.result;
    }
    if (isMapping) {
      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos);
    } else if (isPair) {
      _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos));
    } else {
      _result.push(keyNode);
    }
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if (ch === 44) {
      readNext = true;
      ch = state.input.charCodeAt(++state.position);
    } else {
      readNext = false;
    }
  }
  throwError(state, "unexpected end of the stream within a flow collection");
}
function readBlockScalar(state, nodeIndent) {
  var captureStart, folding, chomping = CHOMPING_CLIP, didReadContent = false, detectedIndent = false, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = false, tmp, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch === 124) {
    folding = false;
  } else if (ch === 62) {
    folding = true;
  } else {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  while (ch !== 0) {
    ch = state.input.charCodeAt(++state.position);
    if (ch === 43 || ch === 45) {
      if (CHOMPING_CLIP === chomping) {
        chomping = ch === 43 ? CHOMPING_KEEP : CHOMPING_STRIP;
      } else {
        throwError(state, "repeat of a chomping mode identifier");
      }
    } else if ((tmp = fromDecimalCode(ch)) >= 0) {
      if (tmp === 0) {
        throwError(state, "bad explicit indentation width of a block scalar; it cannot be less than one");
      } else if (!detectedIndent) {
        textIndent = nodeIndent + tmp - 1;
        detectedIndent = true;
      } else {
        throwError(state, "repeat of an indentation width identifier");
      }
    } else {
      break;
    }
  }
  if (is_WHITE_SPACE(ch)) {
    do {
      ch = state.input.charCodeAt(++state.position);
    } while (is_WHITE_SPACE(ch));
    if (ch === 35) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (!is_EOL(ch) && ch !== 0);
    }
  }
  while (ch !== 0) {
    readLineBreak(state);
    state.lineIndent = 0;
    ch = state.input.charCodeAt(state.position);
    while ((!detectedIndent || state.lineIndent < textIndent) && ch === 32) {
      state.lineIndent++;
      ch = state.input.charCodeAt(++state.position);
    }
    if (!detectedIndent && state.lineIndent > textIndent) {
      textIndent = state.lineIndent;
    }
    if (is_EOL(ch)) {
      emptyLines++;
      continue;
    }
    if (state.lineIndent < textIndent) {
      if (chomping === CHOMPING_KEEP) {
        state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
      } else if (chomping === CHOMPING_CLIP) {
        if (didReadContent) {
          state.result += "\n";
        }
      }
      break;
    }
    if (folding) {
      if (is_WHITE_SPACE(ch)) {
        atMoreIndented = true;
        state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
      } else if (atMoreIndented) {
        atMoreIndented = false;
        state.result += common.repeat("\n", emptyLines + 1);
      } else if (emptyLines === 0) {
        if (didReadContent) {
          state.result += " ";
        }
      } else {
        state.result += common.repeat("\n", emptyLines);
      }
    } else {
      state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
    }
    didReadContent = true;
    detectedIndent = true;
    emptyLines = 0;
    captureStart = state.position;
    while (!is_EOL(ch) && ch !== 0) {
      ch = state.input.charCodeAt(++state.position);
    }
    captureSegment(state, captureStart, state.position, false);
  }
  return true;
}
function readBlockSequence(state, nodeIndent) {
  var _line, _tag = state.tag, _anchor = state.anchor, _result = [], following, detected = false, ch;
  if (state.firstTabInLine !== -1)
    return false;
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    if (state.firstTabInLine !== -1) {
      state.position = state.firstTabInLine;
      throwError(state, "tab characters must not be used in indentation");
    }
    if (ch !== 45) {
      break;
    }
    following = state.input.charCodeAt(state.position + 1);
    if (!is_WS_OR_EOL(following)) {
      break;
    }
    detected = true;
    state.position++;
    if (skipSeparationSpace(state, true, -1)) {
      if (state.lineIndent <= nodeIndent) {
        _result.push(null);
        ch = state.input.charCodeAt(state.position);
        continue;
      }
    }
    _line = state.line;
    composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
    _result.push(state.result);
    skipSeparationSpace(state, true, -1);
    ch = state.input.charCodeAt(state.position);
    if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
      throwError(state, "bad indentation of a sequence entry");
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }
  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = "sequence";
    state.result = _result;
    return true;
  }
  return false;
}
function readBlockMapping(state, nodeIndent, flowIndent) {
  var following, allowCompact, _line, _keyLine, _keyLineStart, _keyPos, _tag = state.tag, _anchor = state.anchor, _result = {}, overridableKeys = /* @__PURE__ */ Object.create(null), keyTag = null, keyNode = null, valueNode = null, atExplicitKey = false, detected = false, ch;
  if (state.firstTabInLine !== -1)
    return false;
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    if (!atExplicitKey && state.firstTabInLine !== -1) {
      state.position = state.firstTabInLine;
      throwError(state, "tab characters must not be used in indentation");
    }
    following = state.input.charCodeAt(state.position + 1);
    _line = state.line;
    if ((ch === 63 || ch === 58) && is_WS_OR_EOL(following)) {
      if (ch === 63) {
        if (atExplicitKey) {
          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
          keyTag = keyNode = valueNode = null;
        }
        detected = true;
        atExplicitKey = true;
        allowCompact = true;
      } else if (atExplicitKey) {
        atExplicitKey = false;
        allowCompact = true;
      } else {
        throwError(state, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line");
      }
      state.position += 1;
      ch = following;
    } else {
      _keyLine = state.line;
      _keyLineStart = state.lineStart;
      _keyPos = state.position;
      if (!composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
        break;
      }
      if (state.line === _line) {
        ch = state.input.charCodeAt(state.position);
        while (is_WHITE_SPACE(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }
        if (ch === 58) {
          ch = state.input.charCodeAt(++state.position);
          if (!is_WS_OR_EOL(ch)) {
            throwError(state, "a whitespace character is expected after the key-value separator within a block mapping");
          }
          if (atExplicitKey) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
            keyTag = keyNode = valueNode = null;
          }
          detected = true;
          atExplicitKey = false;
          allowCompact = false;
          keyTag = state.tag;
          keyNode = state.result;
        } else if (detected) {
          throwError(state, "can not read an implicit mapping pair; a colon is missed");
        } else {
          state.tag = _tag;
          state.anchor = _anchor;
          return true;
        }
      } else if (detected) {
        throwError(state, "can not read a block mapping entry; a multiline key may not be an implicit key");
      } else {
        state.tag = _tag;
        state.anchor = _anchor;
        return true;
      }
    }
    if (state.line === _line || state.lineIndent > nodeIndent) {
      if (atExplicitKey) {
        _keyLine = state.line;
        _keyLineStart = state.lineStart;
        _keyPos = state.position;
      }
      if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
        if (atExplicitKey) {
          keyNode = state.result;
        } else {
          valueNode = state.result;
        }
      }
      if (!atExplicitKey) {
        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _keyLine, _keyLineStart, _keyPos);
        keyTag = keyNode = valueNode = null;
      }
      skipSeparationSpace(state, true, -1);
      ch = state.input.charCodeAt(state.position);
    }
    if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
      throwError(state, "bad indentation of a mapping entry");
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }
  if (atExplicitKey) {
    storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
  }
  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = "mapping";
    state.result = _result;
  }
  return detected;
}
function readTagProperty(state) {
  var _position, isVerbatim = false, isNamed = false, tagHandle, tagName, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 33)
    return false;
  if (state.tag !== null) {
    throwError(state, "duplication of a tag property");
  }
  ch = state.input.charCodeAt(++state.position);
  if (ch === 60) {
    isVerbatim = true;
    ch = state.input.charCodeAt(++state.position);
  } else if (ch === 33) {
    isNamed = true;
    tagHandle = "!!";
    ch = state.input.charCodeAt(++state.position);
  } else {
    tagHandle = "!";
  }
  _position = state.position;
  if (isVerbatim) {
    do {
      ch = state.input.charCodeAt(++state.position);
    } while (ch !== 0 && ch !== 62);
    if (state.position < state.length) {
      tagName = state.input.slice(_position, state.position);
      ch = state.input.charCodeAt(++state.position);
    } else {
      throwError(state, "unexpected end of the stream within a verbatim tag");
    }
  } else {
    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
      if (ch === 33) {
        if (!isNamed) {
          tagHandle = state.input.slice(_position - 1, state.position + 1);
          if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
            throwError(state, "named tag handle cannot contain such characters");
          }
          isNamed = true;
          _position = state.position + 1;
        } else {
          throwError(state, "tag suffix cannot contain exclamation marks");
        }
      }
      ch = state.input.charCodeAt(++state.position);
    }
    tagName = state.input.slice(_position, state.position);
    if (PATTERN_FLOW_INDICATORS.test(tagName)) {
      throwError(state, "tag suffix cannot contain flow indicator characters");
    }
  }
  if (tagName && !PATTERN_TAG_URI.test(tagName)) {
    throwError(state, "tag name cannot contain such characters: " + tagName);
  }
  try {
    tagName = decodeURIComponent(tagName);
  } catch (err) {
    throwError(state, "tag name is malformed: " + tagName);
  }
  if (isVerbatim) {
    state.tag = tagName;
  } else if (_hasOwnProperty$1.call(state.tagMap, tagHandle)) {
    state.tag = state.tagMap[tagHandle] + tagName;
  } else if (tagHandle === "!") {
    state.tag = "!" + tagName;
  } else if (tagHandle === "!!") {
    state.tag = "tag:yaml.org,2002:" + tagName;
  } else {
    throwError(state, 'undeclared tag handle "' + tagHandle + '"');
  }
  return true;
}
function readAnchorProperty(state) {
  var _position, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 38)
    return false;
  if (state.anchor !== null) {
    throwError(state, "duplication of an anchor property");
  }
  ch = state.input.charCodeAt(++state.position);
  _position = state.position;
  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }
  if (state.position === _position) {
    throwError(state, "name of an anchor node must contain at least one character");
  }
  state.anchor = state.input.slice(_position, state.position);
  return true;
}
function readAlias(state) {
  var _position, alias, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 42)
    return false;
  ch = state.input.charCodeAt(++state.position);
  _position = state.position;
  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }
  if (state.position === _position) {
    throwError(state, "name of an alias node must contain at least one character");
  }
  alias = state.input.slice(_position, state.position);
  if (!_hasOwnProperty$1.call(state.anchorMap, alias)) {
    throwError(state, 'unidentified alias "' + alias + '"');
  }
  state.result = state.anchorMap[alias];
  skipSeparationSpace(state, true, -1);
  return true;
}
function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
  var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = false, hasContent = false, typeIndex, typeQuantity, typeList, type2, flowIndent, blockIndent;
  if (state.listener !== null) {
    state.listener("open", state);
  }
  state.tag = null;
  state.anchor = null;
  state.kind = null;
  state.result = null;
  allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;
  if (allowToSeek) {
    if (skipSeparationSpace(state, true, -1)) {
      atNewLine = true;
      if (state.lineIndent > parentIndent) {
        indentStatus = 1;
      } else if (state.lineIndent === parentIndent) {
        indentStatus = 0;
      } else if (state.lineIndent < parentIndent) {
        indentStatus = -1;
      }
    }
  }
  if (indentStatus === 1) {
    while (readTagProperty(state) || readAnchorProperty(state)) {
      if (skipSeparationSpace(state, true, -1)) {
        atNewLine = true;
        allowBlockCollections = allowBlockStyles;
        if (state.lineIndent > parentIndent) {
          indentStatus = 1;
        } else if (state.lineIndent === parentIndent) {
          indentStatus = 0;
        } else if (state.lineIndent < parentIndent) {
          indentStatus = -1;
        }
      } else {
        allowBlockCollections = false;
      }
    }
  }
  if (allowBlockCollections) {
    allowBlockCollections = atNewLine || allowCompact;
  }
  if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
    if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
      flowIndent = parentIndent;
    } else {
      flowIndent = parentIndent + 1;
    }
    blockIndent = state.position - state.lineStart;
    if (indentStatus === 1) {
      if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) {
        hasContent = true;
      } else {
        if (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) {
          hasContent = true;
        } else if (readAlias(state)) {
          hasContent = true;
          if (state.tag !== null || state.anchor !== null) {
            throwError(state, "alias node should not have any properties");
          }
        } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
          hasContent = true;
          if (state.tag === null) {
            state.tag = "?";
          }
        }
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    } else if (indentStatus === 0) {
      hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
    }
  }
  if (state.tag === null) {
    if (state.anchor !== null) {
      state.anchorMap[state.anchor] = state.result;
    }
  } else if (state.tag === "?") {
    if (state.result !== null && state.kind !== "scalar") {
      throwError(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"');
    }
    for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
      type2 = state.implicitTypes[typeIndex];
      if (type2.resolve(state.result)) {
        state.result = type2.construct(state.result);
        state.tag = type2.tag;
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
        break;
      }
    }
  } else if (state.tag !== "!") {
    if (_hasOwnProperty$1.call(state.typeMap[state.kind || "fallback"], state.tag)) {
      type2 = state.typeMap[state.kind || "fallback"][state.tag];
    } else {
      type2 = null;
      typeList = state.typeMap.multi[state.kind || "fallback"];
      for (typeIndex = 0, typeQuantity = typeList.length; typeIndex < typeQuantity; typeIndex += 1) {
        if (state.tag.slice(0, typeList[typeIndex].tag.length) === typeList[typeIndex].tag) {
          type2 = typeList[typeIndex];
          break;
        }
      }
    }
    if (!type2) {
      throwError(state, "unknown tag !<" + state.tag + ">");
    }
    if (state.result !== null && type2.kind !== state.kind) {
      throwError(state, "unacceptable node kind for !<" + state.tag + '> tag; it should be "' + type2.kind + '", not "' + state.kind + '"');
    }
    if (!type2.resolve(state.result, state.tag)) {
      throwError(state, "cannot resolve a node with !<" + state.tag + "> explicit tag");
    } else {
      state.result = type2.construct(state.result, state.tag);
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = state.result;
      }
    }
  }
  if (state.listener !== null) {
    state.listener("close", state);
  }
  return state.tag !== null || state.anchor !== null || hasContent;
}
function readDocument(state) {
  var documentStart = state.position, _position, directiveName, directiveArgs, hasDirectives = false, ch;
  state.version = null;
  state.checkLineBreaks = state.legacy;
  state.tagMap = /* @__PURE__ */ Object.create(null);
  state.anchorMap = /* @__PURE__ */ Object.create(null);
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    skipSeparationSpace(state, true, -1);
    ch = state.input.charCodeAt(state.position);
    if (state.lineIndent > 0 || ch !== 37) {
      break;
    }
    hasDirectives = true;
    ch = state.input.charCodeAt(++state.position);
    _position = state.position;
    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }
    directiveName = state.input.slice(_position, state.position);
    directiveArgs = [];
    if (directiveName.length < 1) {
      throwError(state, "directive name must not be less than one character in length");
    }
    while (ch !== 0) {
      while (is_WHITE_SPACE(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      if (ch === 35) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (ch !== 0 && !is_EOL(ch));
        break;
      }
      if (is_EOL(ch))
        break;
      _position = state.position;
      while (ch !== 0 && !is_WS_OR_EOL(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      directiveArgs.push(state.input.slice(_position, state.position));
    }
    if (ch !== 0)
      readLineBreak(state);
    if (_hasOwnProperty$1.call(directiveHandlers, directiveName)) {
      directiveHandlers[directiveName](state, directiveName, directiveArgs);
    } else {
      throwWarning(state, 'unknown document directive "' + directiveName + '"');
    }
  }
  skipSeparationSpace(state, true, -1);
  if (state.lineIndent === 0 && state.input.charCodeAt(state.position) === 45 && state.input.charCodeAt(state.position + 1) === 45 && state.input.charCodeAt(state.position + 2) === 45) {
    state.position += 3;
    skipSeparationSpace(state, true, -1);
  } else if (hasDirectives) {
    throwError(state, "directives end mark is expected");
  }
  composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
  skipSeparationSpace(state, true, -1);
  if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
    throwWarning(state, "non-ASCII line breaks are interpreted as content");
  }
  state.documents.push(state.result);
  if (state.position === state.lineStart && testDocumentSeparator(state)) {
    if (state.input.charCodeAt(state.position) === 46) {
      state.position += 3;
      skipSeparationSpace(state, true, -1);
    }
    return;
  }
  if (state.position < state.length - 1) {
    throwError(state, "end of the stream or a document separator is expected");
  } else {
    return;
  }
}
function loadDocuments(input, options) {
  input = String(input);
  options = options || {};
  if (input.length !== 0) {
    if (input.charCodeAt(input.length - 1) !== 10 && input.charCodeAt(input.length - 1) !== 13) {
      input += "\n";
    }
    if (input.charCodeAt(0) === 65279) {
      input = input.slice(1);
    }
  }
  var state = new State$1(input, options);
  var nullpos = input.indexOf("\0");
  if (nullpos !== -1) {
    state.position = nullpos;
    throwError(state, "null byte is not allowed in input");
  }
  state.input += "\0";
  while (state.input.charCodeAt(state.position) === 32) {
    state.lineIndent += 1;
    state.position += 1;
  }
  while (state.position < state.length - 1) {
    readDocument(state);
  }
  return state.documents;
}
function loadAll$1(input, iterator, options) {
  if (iterator !== null && typeof iterator === "object" && typeof options === "undefined") {
    options = iterator;
    iterator = null;
  }
  var documents = loadDocuments(input, options);
  if (typeof iterator !== "function") {
    return documents;
  }
  for (var index2 = 0, length = documents.length; index2 < length; index2 += 1) {
    iterator(documents[index2]);
  }
}
function load$1(input, options) {
  var documents = loadDocuments(input, options);
  if (documents.length === 0) {
    return void 0;
  } else if (documents.length === 1) {
    return documents[0];
  }
  throw new exception("expected a single document in the stream, but found more");
}
var loadAll_1 = loadAll$1;
var load_1 = load$1;
var loader = {
  loadAll: loadAll_1,
  load: load_1
};
var _toString = Object.prototype.toString;
var _hasOwnProperty2 = Object.prototype.hasOwnProperty;
var CHAR_BOM = 65279;
var CHAR_TAB = 9;
var CHAR_LINE_FEED = 10;
var CHAR_CARRIAGE_RETURN = 13;
var CHAR_SPACE = 32;
var CHAR_EXCLAMATION = 33;
var CHAR_DOUBLE_QUOTE = 34;
var CHAR_SHARP = 35;
var CHAR_PERCENT = 37;
var CHAR_AMPERSAND = 38;
var CHAR_SINGLE_QUOTE = 39;
var CHAR_ASTERISK = 42;
var CHAR_COMMA = 44;
var CHAR_MINUS = 45;
var CHAR_COLON = 58;
var CHAR_EQUALS = 61;
var CHAR_GREATER_THAN = 62;
var CHAR_QUESTION = 63;
var CHAR_COMMERCIAL_AT = 64;
var CHAR_LEFT_SQUARE_BRACKET = 91;
var CHAR_RIGHT_SQUARE_BRACKET = 93;
var CHAR_GRAVE_ACCENT = 96;
var CHAR_LEFT_CURLY_BRACKET = 123;
var CHAR_VERTICAL_LINE = 124;
var CHAR_RIGHT_CURLY_BRACKET = 125;
var ESCAPE_SEQUENCES = {};
ESCAPE_SEQUENCES[0] = "\\0";
ESCAPE_SEQUENCES[7] = "\\a";
ESCAPE_SEQUENCES[8] = "\\b";
ESCAPE_SEQUENCES[9] = "\\t";
ESCAPE_SEQUENCES[10] = "\\n";
ESCAPE_SEQUENCES[11] = "\\v";
ESCAPE_SEQUENCES[12] = "\\f";
ESCAPE_SEQUENCES[13] = "\\r";
ESCAPE_SEQUENCES[27] = "\\e";
ESCAPE_SEQUENCES[34] = '\\"';
ESCAPE_SEQUENCES[92] = "\\\\";
ESCAPE_SEQUENCES[133] = "\\N";
ESCAPE_SEQUENCES[160] = "\\_";
ESCAPE_SEQUENCES[8232] = "\\L";
ESCAPE_SEQUENCES[8233] = "\\P";
var DEPRECATED_BOOLEANS_SYNTAX = [
  "y",
  "Y",
  "yes",
  "Yes",
  "YES",
  "on",
  "On",
  "ON",
  "n",
  "N",
  "no",
  "No",
  "NO",
  "off",
  "Off",
  "OFF"
];
var DEPRECATED_BASE60_SYNTAX = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;
function compileStyleMap(schema2, map4) {
  var result, keys, index2, length, tag, style, type2;
  if (map4 === null)
    return {};
  result = {};
  keys = Object.keys(map4);
  for (index2 = 0, length = keys.length; index2 < length; index2 += 1) {
    tag = keys[index2];
    style = String(map4[tag]);
    if (tag.slice(0, 2) === "!!") {
      tag = "tag:yaml.org,2002:" + tag.slice(2);
    }
    type2 = schema2.compiledTypeMap["fallback"][tag];
    if (type2 && _hasOwnProperty2.call(type2.styleAliases, style)) {
      style = type2.styleAliases[style];
    }
    result[tag] = style;
  }
  return result;
}
function encodeHex(character) {
  var string, handle, length;
  string = character.toString(16).toUpperCase();
  if (character <= 255) {
    handle = "x";
    length = 2;
  } else if (character <= 65535) {
    handle = "u";
    length = 4;
  } else if (character <= 4294967295) {
    handle = "U";
    length = 8;
  } else {
    throw new exception("code point within a string may not be greater than 0xFFFFFFFF");
  }
  return "\\" + handle + common.repeat("0", length - string.length) + string;
}
var QUOTING_TYPE_SINGLE = 1;
var QUOTING_TYPE_DOUBLE = 2;
function State3(options) {
  this.schema = options["schema"] || _default;
  this.indent = Math.max(1, options["indent"] || 2);
  this.noArrayIndent = options["noArrayIndent"] || false;
  this.skipInvalid = options["skipInvalid"] || false;
  this.flowLevel = common.isNothing(options["flowLevel"]) ? -1 : options["flowLevel"];
  this.styleMap = compileStyleMap(this.schema, options["styles"] || null);
  this.sortKeys = options["sortKeys"] || false;
  this.lineWidth = options["lineWidth"] || 80;
  this.noRefs = options["noRefs"] || false;
  this.noCompatMode = options["noCompatMode"] || false;
  this.condenseFlow = options["condenseFlow"] || false;
  this.quotingType = options["quotingType"] === '"' ? QUOTING_TYPE_DOUBLE : QUOTING_TYPE_SINGLE;
  this.forceQuotes = options["forceQuotes"] || false;
  this.replacer = typeof options["replacer"] === "function" ? options["replacer"] : null;
  this.implicitTypes = this.schema.compiledImplicit;
  this.explicitTypes = this.schema.compiledExplicit;
  this.tag = null;
  this.result = "";
  this.duplicates = [];
  this.usedDuplicates = null;
}
function indentString(string, spaces) {
  var ind = common.repeat(" ", spaces), position = 0, next2 = -1, result = "", line, length = string.length;
  while (position < length) {
    next2 = string.indexOf("\n", position);
    if (next2 === -1) {
      line = string.slice(position);
      position = length;
    } else {
      line = string.slice(position, next2 + 1);
      position = next2 + 1;
    }
    if (line.length && line !== "\n")
      result += ind;
    result += line;
  }
  return result;
}
function generateNextLine(state, level) {
  return "\n" + common.repeat(" ", state.indent * level);
}
function testImplicitResolving(state, str2) {
  var index2, length, type2;
  for (index2 = 0, length = state.implicitTypes.length; index2 < length; index2 += 1) {
    type2 = state.implicitTypes[index2];
    if (type2.resolve(str2)) {
      return true;
    }
  }
  return false;
}
function isWhitespace4(c) {
  return c === CHAR_SPACE || c === CHAR_TAB;
}
function isPrintable(c) {
  return 32 <= c && c <= 126 || 161 <= c && c <= 55295 && c !== 8232 && c !== 8233 || 57344 <= c && c <= 65533 && c !== CHAR_BOM || 65536 <= c && c <= 1114111;
}
function isNsCharOrWhitespace(c) {
  return isPrintable(c) && c !== CHAR_BOM && c !== CHAR_CARRIAGE_RETURN && c !== CHAR_LINE_FEED;
}
function isPlainSafe(c, prev2, inblock) {
  var cIsNsCharOrWhitespace = isNsCharOrWhitespace(c);
  var cIsNsChar = cIsNsCharOrWhitespace && !isWhitespace4(c);
  return (
    // ns-plain-safe
    (inblock ? (
      // c = flow-in
      cIsNsCharOrWhitespace
    ) : cIsNsCharOrWhitespace && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET) && c !== CHAR_SHARP && !(prev2 === CHAR_COLON && !cIsNsChar) || isNsCharOrWhitespace(prev2) && !isWhitespace4(prev2) && c === CHAR_SHARP || prev2 === CHAR_COLON && cIsNsChar
  );
}
function isPlainSafeFirst(c) {
  return isPrintable(c) && c !== CHAR_BOM && !isWhitespace4(c) && c !== CHAR_MINUS && c !== CHAR_QUESTION && c !== CHAR_COLON && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET && c !== CHAR_SHARP && c !== CHAR_AMPERSAND && c !== CHAR_ASTERISK && c !== CHAR_EXCLAMATION && c !== CHAR_VERTICAL_LINE && c !== CHAR_EQUALS && c !== CHAR_GREATER_THAN && c !== CHAR_SINGLE_QUOTE && c !== CHAR_DOUBLE_QUOTE && c !== CHAR_PERCENT && c !== CHAR_COMMERCIAL_AT && c !== CHAR_GRAVE_ACCENT;
}
function isPlainSafeLast(c) {
  return !isWhitespace4(c) && c !== CHAR_COLON;
}
function codePointAt(string, pos) {
  var first2 = string.charCodeAt(pos), second;
  if (first2 >= 55296 && first2 <= 56319 && pos + 1 < string.length) {
    second = string.charCodeAt(pos + 1);
    if (second >= 56320 && second <= 57343) {
      return (first2 - 55296) * 1024 + second - 56320 + 65536;
    }
  }
  return first2;
}
function needIndentIndicator(string) {
  var leadingSpaceRe = /^\n* /;
  return leadingSpaceRe.test(string);
}
var STYLE_PLAIN = 1;
var STYLE_SINGLE = 2;
var STYLE_LITERAL = 3;
var STYLE_FOLDED = 4;
var STYLE_DOUBLE = 5;
function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType, quotingType, forceQuotes, inblock) {
  var i;
  var char = 0;
  var prevChar = null;
  var hasLineBreak = false;
  var hasFoldableLine = false;
  var shouldTrackWidth = lineWidth !== -1;
  var previousLineBreak = -1;
  var plain = isPlainSafeFirst(codePointAt(string, 0)) && isPlainSafeLast(codePointAt(string, string.length - 1));
  if (singleLineOnly || forceQuotes) {
    for (i = 0; i < string.length; char >= 65536 ? i += 2 : i++) {
      char = codePointAt(string, i);
      if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      plain = plain && isPlainSafe(char, prevChar, inblock);
      prevChar = char;
    }
  } else {
    for (i = 0; i < string.length; char >= 65536 ? i += 2 : i++) {
      char = codePointAt(string, i);
      if (char === CHAR_LINE_FEED) {
        hasLineBreak = true;
        if (shouldTrackWidth) {
          hasFoldableLine = hasFoldableLine || // Foldable line = too long, and not more-indented.
          i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ";
          previousLineBreak = i;
        }
      } else if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      plain = plain && isPlainSafe(char, prevChar, inblock);
      prevChar = char;
    }
    hasFoldableLine = hasFoldableLine || shouldTrackWidth && (i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ");
  }
  if (!hasLineBreak && !hasFoldableLine) {
    if (plain && !forceQuotes && !testAmbiguousType(string)) {
      return STYLE_PLAIN;
    }
    return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
  }
  if (indentPerLevel > 9 && needIndentIndicator(string)) {
    return STYLE_DOUBLE;
  }
  if (!forceQuotes) {
    return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
  }
  return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
}
function writeScalar(state, string, level, iskey, inblock) {
  state.dump = function() {
    if (string.length === 0) {
      return state.quotingType === QUOTING_TYPE_DOUBLE ? '""' : "''";
    }
    if (!state.noCompatMode) {
      if (DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1 || DEPRECATED_BASE60_SYNTAX.test(string)) {
        return state.quotingType === QUOTING_TYPE_DOUBLE ? '"' + string + '"' : "'" + string + "'";
      }
    }
    var indent = state.indent * Math.max(1, level);
    var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);
    var singleLineOnly = iskey || state.flowLevel > -1 && level >= state.flowLevel;
    function testAmbiguity(string2) {
      return testImplicitResolving(state, string2);
    }
    switch (chooseScalarStyle(
      string,
      singleLineOnly,
      state.indent,
      lineWidth,
      testAmbiguity,
      state.quotingType,
      state.forceQuotes && !iskey,
      inblock
    )) {
      case STYLE_PLAIN:
        return string;
      case STYLE_SINGLE:
        return "'" + string.replace(/'/g, "''") + "'";
      case STYLE_LITERAL:
        return "|" + blockHeader(string, state.indent) + dropEndingNewline(indentString(string, indent));
      case STYLE_FOLDED:
        return ">" + blockHeader(string, state.indent) + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
      case STYLE_DOUBLE:
        return '"' + escapeString(string) + '"';
      default:
        throw new exception("impossible error: invalid scalar style");
    }
  }();
}
function blockHeader(string, indentPerLevel) {
  var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : "";
  var clip = string[string.length - 1] === "\n";
  var keep = clip && (string[string.length - 2] === "\n" || string === "\n");
  var chomp = keep ? "+" : clip ? "" : "-";
  return indentIndicator + chomp + "\n";
}
function dropEndingNewline(string) {
  return string[string.length - 1] === "\n" ? string.slice(0, -1) : string;
}
function foldString(string, width) {
  var lineRe = /(\n+)([^\n]*)/g;
  var result = function() {
    var nextLF = string.indexOf("\n");
    nextLF = nextLF !== -1 ? nextLF : string.length;
    lineRe.lastIndex = nextLF;
    return foldLine(string.slice(0, nextLF), width);
  }();
  var prevMoreIndented = string[0] === "\n" || string[0] === " ";
  var moreIndented;
  var match2;
  while (match2 = lineRe.exec(string)) {
    var prefix = match2[1], line = match2[2];
    moreIndented = line[0] === " ";
    result += prefix + (!prevMoreIndented && !moreIndented && line !== "" ? "\n" : "") + foldLine(line, width);
    prevMoreIndented = moreIndented;
  }
  return result;
}
function foldLine(line, width) {
  if (line === "" || line[0] === " ")
    return line;
  var breakRe = / [^ ]/g;
  var match2;
  var start = 0, end2, curr = 0, next2 = 0;
  var result = "";
  while (match2 = breakRe.exec(line)) {
    next2 = match2.index;
    if (next2 - start > width) {
      end2 = curr > start ? curr : next2;
      result += "\n" + line.slice(start, end2);
      start = end2 + 1;
    }
    curr = next2;
  }
  result += "\n";
  if (line.length - start > width && curr > start) {
    result += line.slice(start, curr) + "\n" + line.slice(curr + 1);
  } else {
    result += line.slice(start);
  }
  return result.slice(1);
}
function escapeString(string) {
  var result = "";
  var char = 0;
  var escapeSeq;
  for (var i = 0; i < string.length; char >= 65536 ? i += 2 : i++) {
    char = codePointAt(string, i);
    escapeSeq = ESCAPE_SEQUENCES[char];
    if (!escapeSeq && isPrintable(char)) {
      result += string[i];
      if (char >= 65536)
        result += string[i + 1];
    } else {
      result += escapeSeq || encodeHex(char);
    }
  }
  return result;
}
function writeFlowSequence(state, level, object) {
  var _result = "", _tag = state.tag, index2, length, value;
  for (index2 = 0, length = object.length; index2 < length; index2 += 1) {
    value = object[index2];
    if (state.replacer) {
      value = state.replacer.call(object, String(index2), value);
    }
    if (writeNode(state, level, value, false, false) || typeof value === "undefined" && writeNode(state, level, null, false, false)) {
      if (_result !== "")
        _result += "," + (!state.condenseFlow ? " " : "");
      _result += state.dump;
    }
  }
  state.tag = _tag;
  state.dump = "[" + _result + "]";
}
function writeBlockSequence(state, level, object, compact) {
  var _result = "", _tag = state.tag, index2, length, value;
  for (index2 = 0, length = object.length; index2 < length; index2 += 1) {
    value = object[index2];
    if (state.replacer) {
      value = state.replacer.call(object, String(index2), value);
    }
    if (writeNode(state, level + 1, value, true, true, false, true) || typeof value === "undefined" && writeNode(state, level + 1, null, true, true, false, true)) {
      if (!compact || _result !== "") {
        _result += generateNextLine(state, level);
      }
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        _result += "-";
      } else {
        _result += "- ";
      }
      _result += state.dump;
    }
  }
  state.tag = _tag;
  state.dump = _result || "[]";
}
function writeFlowMapping(state, level, object) {
  var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index2, length, objectKey, objectValue, pairBuffer;
  for (index2 = 0, length = objectKeyList.length; index2 < length; index2 += 1) {
    pairBuffer = "";
    if (_result !== "")
      pairBuffer += ", ";
    if (state.condenseFlow)
      pairBuffer += '"';
    objectKey = objectKeyList[index2];
    objectValue = object[objectKey];
    if (state.replacer) {
      objectValue = state.replacer.call(object, objectKey, objectValue);
    }
    if (!writeNode(state, level, objectKey, false, false)) {
      continue;
    }
    if (state.dump.length > 1024)
      pairBuffer += "? ";
    pairBuffer += state.dump + (state.condenseFlow ? '"' : "") + ":" + (state.condenseFlow ? "" : " ");
    if (!writeNode(state, level, objectValue, false, false)) {
      continue;
    }
    pairBuffer += state.dump;
    _result += pairBuffer;
  }
  state.tag = _tag;
  state.dump = "{" + _result + "}";
}
function writeBlockMapping(state, level, object, compact) {
  var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index2, length, objectKey, objectValue, explicitPair, pairBuffer;
  if (state.sortKeys === true) {
    objectKeyList.sort();
  } else if (typeof state.sortKeys === "function") {
    objectKeyList.sort(state.sortKeys);
  } else if (state.sortKeys) {
    throw new exception("sortKeys must be a boolean or a function");
  }
  for (index2 = 0, length = objectKeyList.length; index2 < length; index2 += 1) {
    pairBuffer = "";
    if (!compact || _result !== "") {
      pairBuffer += generateNextLine(state, level);
    }
    objectKey = objectKeyList[index2];
    objectValue = object[objectKey];
    if (state.replacer) {
      objectValue = state.replacer.call(object, objectKey, objectValue);
    }
    if (!writeNode(state, level + 1, objectKey, true, true, true)) {
      continue;
    }
    explicitPair = state.tag !== null && state.tag !== "?" || state.dump && state.dump.length > 1024;
    if (explicitPair) {
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        pairBuffer += "?";
      } else {
        pairBuffer += "? ";
      }
    }
    pairBuffer += state.dump;
    if (explicitPair) {
      pairBuffer += generateNextLine(state, level);
    }
    if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
      continue;
    }
    if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
      pairBuffer += ":";
    } else {
      pairBuffer += ": ";
    }
    pairBuffer += state.dump;
    _result += pairBuffer;
  }
  state.tag = _tag;
  state.dump = _result || "{}";
}
function detectType(state, object, explicit) {
  var _result, typeList, index2, length, type2, style;
  typeList = explicit ? state.explicitTypes : state.implicitTypes;
  for (index2 = 0, length = typeList.length; index2 < length; index2 += 1) {
    type2 = typeList[index2];
    if ((type2.instanceOf || type2.predicate) && (!type2.instanceOf || typeof object === "object" && object instanceof type2.instanceOf) && (!type2.predicate || type2.predicate(object))) {
      if (explicit) {
        if (type2.multi && type2.representName) {
          state.tag = type2.representName(object);
        } else {
          state.tag = type2.tag;
        }
      } else {
        state.tag = "?";
      }
      if (type2.represent) {
        style = state.styleMap[type2.tag] || type2.defaultStyle;
        if (_toString.call(type2.represent) === "[object Function]") {
          _result = type2.represent(object, style);
        } else if (_hasOwnProperty2.call(type2.represent, style)) {
          _result = type2.represent[style](object, style);
        } else {
          throw new exception("!<" + type2.tag + '> tag resolver accepts not "' + style + '" style');
        }
        state.dump = _result;
      }
      return true;
    }
  }
  return false;
}
function writeNode(state, level, object, block2, compact, iskey, isblockseq) {
  state.tag = null;
  state.dump = object;
  if (!detectType(state, object, false)) {
    detectType(state, object, true);
  }
  var type2 = _toString.call(state.dump);
  var inblock = block2;
  var tagStr;
  if (block2) {
    block2 = state.flowLevel < 0 || state.flowLevel > level;
  }
  var objectOrArray = type2 === "[object Object]" || type2 === "[object Array]", duplicateIndex, duplicate;
  if (objectOrArray) {
    duplicateIndex = state.duplicates.indexOf(object);
    duplicate = duplicateIndex !== -1;
  }
  if (state.tag !== null && state.tag !== "?" || duplicate || state.indent !== 2 && level > 0) {
    compact = false;
  }
  if (duplicate && state.usedDuplicates[duplicateIndex]) {
    state.dump = "*ref_" + duplicateIndex;
  } else {
    if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
      state.usedDuplicates[duplicateIndex] = true;
    }
    if (type2 === "[object Object]") {
      if (block2 && Object.keys(state.dump).length !== 0) {
        writeBlockMapping(state, level, state.dump, compact);
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + state.dump;
        }
      } else {
        writeFlowMapping(state, level, state.dump);
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + " " + state.dump;
        }
      }
    } else if (type2 === "[object Array]") {
      if (block2 && state.dump.length !== 0) {
        if (state.noArrayIndent && !isblockseq && level > 0) {
          writeBlockSequence(state, level - 1, state.dump, compact);
        } else {
          writeBlockSequence(state, level, state.dump, compact);
        }
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + state.dump;
        }
      } else {
        writeFlowSequence(state, level, state.dump);
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + " " + state.dump;
        }
      }
    } else if (type2 === "[object String]") {
      if (state.tag !== "?") {
        writeScalar(state, state.dump, level, iskey, inblock);
      }
    } else if (type2 === "[object Undefined]") {
      return false;
    } else {
      if (state.skipInvalid)
        return false;
      throw new exception("unacceptable kind of an object to dump " + type2);
    }
    if (state.tag !== null && state.tag !== "?") {
      tagStr = encodeURI(
        state.tag[0] === "!" ? state.tag.slice(1) : state.tag
      ).replace(/!/g, "%21");
      if (state.tag[0] === "!") {
        tagStr = "!" + tagStr;
      } else if (tagStr.slice(0, 18) === "tag:yaml.org,2002:") {
        tagStr = "!!" + tagStr.slice(18);
      } else {
        tagStr = "!<" + tagStr + ">";
      }
      state.dump = tagStr + " " + state.dump;
    }
  }
  return true;
}
function getDuplicateReferences(object, state) {
  var objects = [], duplicatesIndexes = [], index2, length;
  inspectNode(object, objects, duplicatesIndexes);
  for (index2 = 0, length = duplicatesIndexes.length; index2 < length; index2 += 1) {
    state.duplicates.push(objects[duplicatesIndexes[index2]]);
  }
  state.usedDuplicates = new Array(length);
}
function inspectNode(object, objects, duplicatesIndexes) {
  var objectKeyList, index2, length;
  if (object !== null && typeof object === "object") {
    index2 = objects.indexOf(object);
    if (index2 !== -1) {
      if (duplicatesIndexes.indexOf(index2) === -1) {
        duplicatesIndexes.push(index2);
      }
    } else {
      objects.push(object);
      if (Array.isArray(object)) {
        for (index2 = 0, length = object.length; index2 < length; index2 += 1) {
          inspectNode(object[index2], objects, duplicatesIndexes);
        }
      } else {
        objectKeyList = Object.keys(object);
        for (index2 = 0, length = objectKeyList.length; index2 < length; index2 += 1) {
          inspectNode(object[objectKeyList[index2]], objects, duplicatesIndexes);
        }
      }
    }
  }
}
function dump$1(input, options) {
  options = options || {};
  var state = new State3(options);
  if (!state.noRefs)
    getDuplicateReferences(input, state);
  var value = input;
  if (state.replacer) {
    value = state.replacer.call({ "": value }, "", value);
  }
  if (writeNode(state, 0, value, true, true))
    return state.dump + "\n";
  return "";
}
var dump_1 = dump$1;
var dumper = {
  dump: dump_1
};
function renamed(from, to) {
  return function() {
    throw new Error("Function yaml." + from + " is removed in js-yaml 4. Use yaml." + to + " instead, which is now safe by default.");
  };
}
var Type = type;
var Schema = schema;
var FAILSAFE_SCHEMA = failsafe;
var JSON_SCHEMA = json;
var CORE_SCHEMA = core;
var DEFAULT_SCHEMA = _default;
var load2 = loader.load;
var loadAll = loader.loadAll;
var dump = dumper.dump;
var YAMLException = exception;
var types = {
  binary,
  float,
  map: map3,
  null: _null,
  pairs,
  set: set2,
  timestamp,
  bool,
  int,
  merge: merge3,
  omap,
  seq,
  str
};
var safeLoad = renamed("safeLoad", "load");
var safeLoadAll = renamed("safeLoadAll", "loadAll");
var safeDump = renamed("safeDump", "dump");
var jsYaml = {
  Type,
  Schema,
  FAILSAFE_SCHEMA,
  JSON_SCHEMA,
  CORE_SCHEMA,
  DEFAULT_SCHEMA,
  load: load2,
  loadAll,
  dump,
  YAMLException,
  types,
  safeLoad,
  safeLoadAll,
  safeDump
};
var js_yaml_default = jsYaml;

// node_modules/.pnpm/markmap-lib@0.17.0_markmap-common@0.17.0/node_modules/markmap-lib/dist/browser/index.mjs
var import_markdown_it_katex = __toESM(require_markdown_it_katex(), 1);
function initializeMarkdownIt() {
  const md = lib_default({
    html: true,
    breaks: true
  });
  md.use(ins_plugin).use(ins_plugin2).use(sub_plugin).use(sup_plugin);
  return md;
}
function createTransformHooks(transformer) {
  return {
    transformer,
    parser: new Hook(),
    beforeParse: new Hook(),
    afterParse: new Hook(),
    retransform: new Hook()
  };
}
function definePlugin(plugin2) {
  return plugin2;
}
var svgMarked = '<svg width="16" height="16" viewBox="0 -3 24 24"><path d="M19 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V5a2 2 0 0 0-2-2m-9 14-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8z"/></svg>\n';
var svgUnmarked = '<svg width="16" height="16" viewBox="0 -3 24 24"><path fill-rule="evenodd" d="M6 5a1 1 0 0 0-1 1v12a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1V6a1 1 0 0 0-1-1zM3 6a3 3 0 0 1 3-3h12a3 3 0 0 1 3 3v12a3 3 0 0 1-3 3H6a3 3 0 0 1-3-3v-5z" clip-rule="evenodd"/></svg>\n';
var name$5 = "checkbox";
var images = {
  " ": svgUnmarked.trim(),
  x: svgMarked.trim()
};
var plugin$3 = definePlugin({
  name: name$5,
  transform(transformHooks) {
    transformHooks.parser.tap((md) => {
      md.core.ruler.before("inline", "checkbox", (state) => {
        for (let i = 2; i < state.tokens.length; i += 1) {
          const token = state.tokens[i];
          if (token.type === "inline" && token.content) {
            const prevType = state.tokens[i - 1].type;
            const prevPrevType = state.tokens[i - 2].type;
            if (prevType === "heading_open" || prevType === "paragraph_open" && prevPrevType === "list_item_open") {
              token.content = token.content.replace(
                /^\[(.)\] /,
                (m, g) => images[g] ? `${images[g]} ` : m
              );
            }
          }
        }
        return false;
      });
    });
    return {};
  }
});
var pluginCheckbox = plugin$3;
var name$4 = "frontmatter";
var pluginFrontmatter = definePlugin({
  name: name$4,
  transform(transformHooks) {
    transformHooks.beforeParse.tap((md, context) => {
      const { content } = context;
      if (!/^---\r?\n/.test(content))
        return;
      const match2 = /\n---\r?\n/.exec(content);
      if (!match2)
        return;
      const raw = content.slice(4, match2.index);
      let frontmatter;
      try {
        frontmatter = js_yaml_default.load(raw);
        if (frontmatter == null ? void 0 : frontmatter.markmap) {
          frontmatter.markmap = normalizeMarkmapJsonOptions(
            frontmatter.markmap
          );
        }
      } catch {
        return;
      }
      context.frontmatter = frontmatter;
      context.content = content.slice(match2.index + match2[0].length);
      context.contentLineOffset = content.slice(0, match2.index).split("\n").length + 1;
    });
    return {};
  }
});
function normalizeMarkmapJsonOptions(options) {
  if (!options)
    return;
  ["color", "extraJs", "extraCss"].forEach((key) => {
    if (options[key] != null)
      options[key] = normalizeStringArray(options[key]);
  });
  ["duration", "maxWidth", "initialExpandLevel"].forEach((key) => {
    if (options[key] != null)
      options[key] = normalizeNumber(options[key]);
  });
  return options;
}
function normalizeStringArray(value) {
  let result;
  if (typeof value === "string")
    result = [value];
  else if (Array.isArray(value))
    result = value.filter((item) => item && typeof item === "string");
  return (result == null ? void 0 : result.length) ? result : void 0;
}
function normalizeNumber(value) {
  if (isNaN(+value))
    return;
  return +value;
}
function patchJSItem(urlBuilder, item) {
  if (item.type === "script" && item.data.src) {
    return {
      ...item,
      data: {
        ...item.data,
        src: urlBuilder.getFullUrl(item.data.src)
      }
    };
  }
  return item;
}
function patchCSSItem(urlBuilder, item) {
  if (item.type === "stylesheet" && item.data.href) {
    return {
      ...item,
      data: {
        ...item.data,
        href: urlBuilder.getFullUrl(item.data.href)
      }
    };
  }
  return item;
}
var name$3 = "hljs";
var preloadScripts$1 = [
  `@highlightjs/cdn-assets@${"11.8.0"}/highlight.min.js`
].map((path) => buildJSItem(path));
var styles$1 = [
  `@highlightjs/cdn-assets@${"11.8.0"}/styles/default.min.css`
].map((path) => buildCSSItem(path));
var config$1 = {
  versions: {
    hljs: "11.8.0"
  },
  preloadScripts: preloadScripts$1,
  styles: styles$1
};
var plugin$2 = definePlugin({
  name: name$3,
  config: config$1,
  transform(transformHooks) {
    var _a2, _b, _c;
    let loading;
    const preloadScripts2 = ((_b = (_a2 = plugin$2.config) == null ? void 0 : _a2.preloadScripts) == null ? void 0 : _b.map(
      (item) => patchJSItem(transformHooks.transformer.urlBuilder, item)
    )) || [];
    const autoload = () => {
      loading || (loading = loadJS(preloadScripts2));
      return loading;
    };
    let enableFeature = noop;
    transformHooks.parser.tap((md) => {
      md.set({
        highlight: (str2, language) => {
          enableFeature();
          const { hljs } = window;
          if (hljs) {
            return hljs.highlightAuto(str2, language ? [language] : void 0).value;
          }
          autoload().then(() => {
            transformHooks.retransform.call();
          });
          return str2;
        }
      });
    });
    transformHooks.beforeParse.tap((_, context) => {
      enableFeature = () => {
        context.features[name$3] = true;
      };
    });
    return {
      styles: (_c = plugin$2.config) == null ? void 0 : _c.styles
    };
  }
});
var pluginHljs = plugin$2;
function addDefaultVersions(paths, name2, version) {
  return paths.map((path) => {
    if (typeof path === "string" && !path.includes("://")) {
      if (!path.startsWith("npm:")) {
        path = `npm:${path}`;
      }
      const prefixLength = 4 + name2.length;
      if (path.startsWith(`npm:${name2}/`)) {
        path = `${path.slice(0, prefixLength)}@${version}${path.slice(
          prefixLength
        )}`;
      }
    }
    return path;
  });
}
var name$2 = "katex";
var preloadScripts = [
  `katex@${"0.16.8"}/dist/katex.min.js`
].map((path) => buildJSItem(path));
var webfontloader = buildJSItem(
  `webfontloader@${"1.6.28"}/webfontloader.js`
);
webfontloader.data.defer = true;
var styles = [`katex@${"0.16.8"}/dist/katex.min.css`].map(
  (path) => buildCSSItem(path)
);
var config2 = {
  versions: {
    katex: "0.16.8",
    webfontloader: "1.6.28"
  },
  preloadScripts,
  scripts: [
    {
      type: "iife",
      data: {
        fn: (getMarkmap) => {
          window.WebFontConfig = {
            custom: {
              families: [
                "KaTeX_AMS",
                "KaTeX_Caligraphic:n4,n7",
                "KaTeX_Fraktur:n4,n7",
                "KaTeX_Main:n4,n7,i4,i7",
                "KaTeX_Math:i4,i7",
                "KaTeX_Script",
                "KaTeX_SansSerif:n4,n7,i4",
                "KaTeX_Size1",
                "KaTeX_Size2",
                "KaTeX_Size3",
                "KaTeX_Size4",
                "KaTeX_Typewriter"
              ]
            },
            active: () => {
              getMarkmap().refreshHook.call();
            }
          };
        },
        getParams({ getMarkmap }) {
          return [getMarkmap];
        }
      }
    },
    webfontloader
  ],
  styles
};
var plugin$1 = definePlugin({
  name: name$2,
  config: config2,
  transform(transformHooks) {
    var _a2, _b, _c, _d;
    let loading;
    const preloadScripts2 = ((_b = (_a2 = plugin$1.config) == null ? void 0 : _a2.preloadScripts) == null ? void 0 : _b.map(
      (item) => patchJSItem(transformHooks.transformer.urlBuilder, item)
    )) || [];
    const autoload = () => {
      loading || (loading = loadJS(preloadScripts2));
      return loading;
    };
    const renderKatex = (source, displayMode) => {
      const { katex } = window;
      if (katex) {
        return katex.renderToString(source, {
          displayMode,
          throwOnError: false
        });
      }
      autoload().then(() => {
        transformHooks.retransform.call();
      });
      return source;
    };
    let enableFeature = noop;
    transformHooks.parser.tap((md) => {
      md.use(import_markdown_it_katex.default);
      ["math_block", "math_inline"].forEach((key) => {
        const fn = (tokens, idx) => {
          enableFeature();
          const result = renderKatex(tokens[idx].content, !!tokens[idx].block);
          return result;
        };
        md.renderer.rules[key] = fn;
      });
    });
    transformHooks.beforeParse.tap((_, context) => {
      enableFeature = () => {
        context.features[name$2] = true;
      };
    });
    transformHooks.afterParse.tap((_, context) => {
      var _a22;
      const markmap = (_a22 = context.frontmatter) == null ? void 0 : _a22.markmap;
      if (markmap) {
        ["extraJs", "extraCss"].forEach((key) => {
          var _a3, _b2;
          const value = markmap[key];
          if (value) {
            markmap[key] = addDefaultVersions(
              value,
              name$2,
              ((_b2 = (_a3 = plugin$1.config) == null ? void 0 : _a3.versions) == null ? void 0 : _b2.katex) || ""
            );
          }
        });
      }
    });
    return {
      styles: (_c = plugin$1.config) == null ? void 0 : _c.styles,
      scripts: (_d = plugin$1.config) == null ? void 0 : _d.scripts
    };
  }
});
var pluginKatex = plugin$1;
var name$1 = "npmUrl";
var pluginNpmUrl = definePlugin({
  name: name$1,
  transform(transformHooks) {
    transformHooks.afterParse.tap((_, context) => {
      const { frontmatter } = context;
      const markmap = frontmatter == null ? void 0 : frontmatter.markmap;
      if (markmap) {
        ["extraJs", "extraCss"].forEach((key) => {
          const value = markmap[key];
          if (value) {
            markmap[key] = value.map((path) => {
              if (path.startsWith("npm:")) {
                return transformHooks.transformer.urlBuilder.getFullUrl(
                  path.slice(4)
                );
              }
              return path;
            });
          }
        });
      }
    });
    return {};
  }
});
var name = "sourceLines";
var plugin = definePlugin({
  name,
  transform(transformHooks) {
    transformHooks.parser.tap((md) => {
      md.renderer.renderAttrs = wrapFunction(
        md.renderer.renderAttrs,
        (renderAttrs2, token) => {
          let attrs = renderAttrs2(token);
          if (token.block && token.map) {
            attrs += ` data-lines=${token.map.join(",")}`;
          }
          return attrs;
        }
      );
    });
    return {};
  }
});
var pluginSourceLines = plugin;
var plugins = [
  pluginFrontmatter,
  pluginKatex,
  pluginHljs,
  pluginNpmUrl,
  pluginCheckbox,
  pluginSourceLines
];
var builtInPlugins = plugins;
function cleanNode(node) {
  while (!node.content && node.children.length === 1) {
    node = node.children[0];
  }
  while (node.children.length === 1 && !node.children[0].content) {
    node = {
      ...node,
      children: node.children[0].children
    };
  }
  return {
    ...node,
    children: node.children.map(cleanNode)
  };
}
var Transformer = class {
  constructor(plugins2 = builtInPlugins) {
    this.assetsMap = {};
    this.urlBuilder = new UrlBuilder();
    this.hooks = createTransformHooks(this);
    this.plugins = plugins2.map(
      (plugin2) => typeof plugin2 === "function" ? plugin2() : plugin2
    );
    const assetsMap = {};
    for (const { name: name2, transform } of this.plugins) {
      assetsMap[name2] = transform(this.hooks);
    }
    this.assetsMap = assetsMap;
    const md = initializeMarkdownIt();
    this.md = md;
    this.hooks.parser.call(md);
  }
  transform(content, opts) {
    var _a2, _b, _c;
    const context = {
      content,
      features: {},
      contentLineOffset: 0
    };
    this.hooks.beforeParse.call(this.md, context);
    const html3 = this.md.render(context.content, {});
    this.hooks.afterParse.call(this.md, context);
    const root3 = cleanNode(
      buildTree(html3, {
        ...(_b = (_a2 = context.frontmatter) == null ? void 0 : _a2.markmap) == null ? void 0 : _b.htmlParser,
        ...opts
      })
    );
    root3.content || (root3.content = `${((_c = context.frontmatter) == null ? void 0 : _c.title) || ""}`);
    return { ...context, root: root3 };
  }
  /**
   * Get all assets from enabled plugins or filter them by plugin names as keys.
   */
  getAssets(keys) {
    const styles2 = [];
    const scripts = [];
    keys ?? (keys = this.plugins.map((plugin2) => plugin2.name));
    for (const assets of keys.map((key) => this.assetsMap[key])) {
      if (assets) {
        if (assets.styles)
          styles2.push(...assets.styles);
        if (assets.scripts)
          scripts.push(...assets.scripts);
      }
    }
    return {
      styles: styles2.map((item) => patchCSSItem(this.urlBuilder, item)),
      scripts: scripts.map((item) => patchJSItem(this.urlBuilder, item))
    };
  }
  /**
   * Get used assets by features object returned by `transform`.
   */
  getUsedAssets(features) {
    const keys = this.plugins.map((plugin2) => plugin2.name).filter((name2) => features[name2]);
    return this.getAssets(keys);
  }
};
var transformerVersions = {
  "markmap-lib": "0.17.0"
};
export {
  Transformer,
  builtInPlugins,
  transformerVersions
};
/*! Bundled license information:

js-yaml/dist/js-yaml.mjs:
  (*! js-yaml 4.1.0 https://github.com/nodeca/js-yaml @license MIT *)
*/
//# sourceMappingURL=markmap-lib.js.map
